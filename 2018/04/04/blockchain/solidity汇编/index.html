<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="本文是基于solidity官方文档v0.4.21. Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。 内联汇编为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由">
<meta name="keywords" content="solidity">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity汇编">
<meta property="og:url" content="http://cordate.github.io/2018/04/04/blockchain/solidity汇编/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="本文是基于solidity官方文档v0.4.21. Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。 内联汇编为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-04-08T03:30:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="solidity汇编">
<meta name="twitter:description" content="本文是基于solidity官方文档v0.4.21. Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。 内联汇编为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由">



  <link rel="alternate" href="https://www.gitbook.com/" title="柳絮纷飞" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="http://cordate.github.io/2018/04/04/blockchain/solidity汇编/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>solidity汇编 | 柳絮纷飞</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br/>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br/>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br/>公益 404</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/04/blockchain/solidity汇编/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">solidity汇编

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-04 17:58:04" itemprop="dateCreated datePublished" datetime="2018-04-04T17:58:04+08:00">2018-04-04</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-04-08 11:30:45" itemprop="dateModified" datetime="2018-04-08T11:30:45+08:00">2018-04-08</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<p>Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由于EVM是堆栈机，因此通常很难解决正确的堆栈插槽问题，并为堆栈上正确的操作码提供参数。Solidity的内联汇编试图通过以下功能来促进编写手动汇编时出现的问题和其他问题：</p>
<ul>
<li>方法样式的操作码：<code>mul(1, add(2, 3))</code>替换<code>push1 3 push1 2 add push1 1 mul</code>.</li>
<li>装配局部变量：<code>let x := add(2, 3)  let y := mload(0x40)  x := add(x, y)</code></li>
<li>访问外部变量： <code>function f(uint x) public { assembly { x := sub(x, 1) } }</code></li>
<li>标签： <code>let x := 10  repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li>
<li>循环： <code>for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }</code></li>
<li>if语句： <code>if slt(x, 0) { x := sub(0, x) }</code></li>
<li>switch语句： <code>switch x case 0 { y := mul(x, 2) } default { y := 0 }</code></li>
<li>函数调用： <code>function f(x) -&gt; y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) }   }</code></li>
</ul>
<p>我们现在要详细描述内联汇编语言。</p>
<p><b style="color:#6ab0de">警告: 内联汇编是一种在低级别访问以太坊虚拟机的方法。这丢弃了Solidity的几个重要的安全特征。</b></p>
<p><b style="color:#6ab0de">注意: TODO：写下内联汇编的作用域规则如何有点不同并且例如使用库的内部函数时出现的复杂情况。此外，编写有关编译器定义的符号。</b></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例提供了库代码以访问另一个合同的代码并将其加载到bytes变量中。这对于“普通的solidity”来说根本不可能，并且这个想法是用组装库的方式来增强语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">library GetCode &#123;</span><br><span class="line">    function at(address _addr) public view returns (bytes o_code) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // retrieve the size of the code, this needs assembly</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line">            // allocate output byte array - this could also be done without assembly</span><br><span class="line">            // by using o_code = new bytes(size)</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line">            // new &quot;memory end&quot; including padding</span><br><span class="line">            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            // store length in memory</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line">            // actually retrieve the code, this needs assembly</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在优化器无法生成高效代码的情况下，内联汇编也可能有所帮助。请注意，由于编译器不执行检查，所以汇编更难以编写，因此只有在您确实知道自己在做什么时才应该将它用于复杂的事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // This function is less efficient because the optimizer currently fails to</span><br><span class="line">    // remove the bounds checks in array access.</span><br><span class="line">    function sumSolidity(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i)</span><br><span class="line">            o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know that we only access the array in bounds, so we can avoid the check.</span><br><span class="line">    // 0x20 needs to be added to an array because the first slot contains the</span><br><span class="line">    // array length.</span><br><span class="line">    function sumAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Same as above, but accomplish the entire code within inline assembly.</span><br><span class="line">    function sumPureAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">           // Load the length (first 32 bytes)</span><br><span class="line">           let len := mload(_data)</span><br><span class="line"></span><br><span class="line">           // Skip over the length field.</span><br><span class="line">           //</span><br><span class="line">           // Keep temporary variable so it can be incremented in place.</span><br><span class="line">           //</span><br><span class="line">           // NOTE: incrementing _data would result in an unusable</span><br><span class="line">           //       _data variable after this assembly block</span><br><span class="line">           let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">           // Iterate until the bound is not met.</span><br><span class="line">           for</span><br><span class="line">               &#123; let end := add(data, len) &#125;</span><br><span class="line">               lt(data, end)</span><br><span class="line">               &#123; data := add(data, 0x20) &#125;</span><br><span class="line">           &#123;</span><br><span class="line">               o_sum := add(o_sum, mload(data))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h3><p>Assembly会像Solidity一样解析注释，文字和标识符，因此您可以使用常规的<code>//</code>和<code>/* */</code>进行注释。内联汇编集<code>assembly { ... }</code>在这些花括号内标记，并且可以使用以下内容（请参阅后面的章节以获取更多详细信息）。</p>
<ul>
<li>文字，例如<code>0x123</code>，<code>42</code>或<code>&quot;abc&quot;</code>（最多32个字符的字符串）</li>
<li>操作码（在“指令样式”中），例如<code>mload sload dup1 sstore</code>，列表见下文.</li>
<li>方法风格的操作码，例如 <code>add(1, mlod(0))</code></li>
<li>标签，例如 <code>name:</code></li>
<li>变量声明，例如<code>let x := 7</code>，<code>let x := add(y, 3)</code>或<code>let x</code>（被分配初始值空（0））</li>
<li>标识符（如果用作内联汇编，则为标签、汇编局部变量和外部），例如<code>jump(name)</code>，<code>3 x add</code></li>
<li>赋值（以“指令风格”），例如 <code>3 =: x</code></li>
<li>函数风格的赋值，例如 <code>x := add(y, 3)</code></li>
<li>局部变量作用域范围的块，例如 <code>{ let x := 3 { let y := add(x, 1) } }</code></li>
</ul>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>本文档不希望成为以太坊虚拟机的完整描述，但下面的列表可用作其操作码的指南。</p>
<p>如果一个操作码需要参数（总是从栈顶开始），它们会在括号中给出。请注意，参数的顺序可以被看作是在不是函数风格中被颠倒（下面会解释）。<code>-</code>标记的操作码不会向堆上压项目，标记<code>*</code>的操作码是特殊的，所有其他操作符都只能将一个项目压入到堆栈中。标有<code>F</code>，<code>H</code>，<code>B</code>或<code>C</code>的操作码表明自从Frontier，Homestead, Byzantium or Constantinople开始就有了。Constantinople仍处于规划之中，所有标记如此的指令都将导致无效的指令异常。</p>
<p>在下文中，<code>mem[a...b)</code>表示从位置<code>a</code>直到（不包括）位置<code>b</code>的内存字节，<code>storage[p]</code>表示<code>storage</code>在p处的内容。</p>
<p>该操作码<code>pushi</code>和<code>jumpdest</code>不能直接使用。</p>
<p>在语法中，操作码被表示为预定义的标识符。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th></th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop</td>
<td>-</td>
<td>F</td>
<td>停止执行，与<code>return(0,0)</code>相同</td>
</tr>
<tr>
<td>add(x, y)</td>
<td></td>
<td>F</td>
<td>x + y</td>
</tr>
<tr>
<td>sub(x, y)</td>
<td></td>
<td>F</td>
<td>x - y</td>
</tr>
<tr>
<td>mul(x, y)</td>
<td></td>
<td>F</td>
<td>x * y</td>
</tr>
<tr>
<td>div(x, y)</td>
<td></td>
<td>F</td>
<td>x / y</td>
</tr>
<tr>
<td>sdiv(x，y)</td>
<td></td>
<td>F</td>
<td>x / y，用于补码中的有符号数</td>
</tr>
<tr>
<td>mod(x，y)</td>
<td></td>
<td>F</td>
<td>x％y</td>
</tr>
<tr>
<td>smod(x，y)</td>
<td></td>
<td>F</td>
<td>x％y，用于补码中的有符号数</td>
</tr>
<tr>
<td>exp(x，y)</td>
<td></td>
<td>F</td>
<td>x对y的幂</td>
</tr>
<tr>
<td>not(x)</td>
<td></td>
<td>F</td>
<td>〜x，x的每一位都是取反的</td>
</tr>
<tr>
<td>lt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&lt;y,值为1，否则为0</td>
</tr>
<tr>
<td>gt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&gt;y,值为1，否则为0</td>
</tr>
<tr>
<td>slt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>sgt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&gt;y，值为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>eq(x, y)</td>
<td></td>
<td>F</td>
<td>如果x == y, 为1，否则为0</td>
</tr>
<tr>
<td>iszero(x)</td>
<td></td>
<td>F</td>
<td>如果x == 0，为1，否则为0</td>
</tr>
<tr>
<td>and(x, y)</td>
<td></td>
<td>F</td>
<td>x和y按位与</td>
</tr>
<tr>
<td>or(x, y)</td>
<td></td>
<td>F</td>
<td>x和y按位或</td>
</tr>
<tr>
<td>xor(x, y)</td>
<td></td>
<td>F</td>
<td>x和y的按位异或</td>
</tr>
<tr>
<td>byte(n, x)</td>
<td></td>
<td>F</td>
<td>x的第n个字节，其中最高有效字节是第0字节</td>
</tr>
<tr>
<td>shl(x, y)</td>
<td></td>
<td>C</td>
<td>y逻辑左移x位</td>
</tr>
<tr>
<td>shr(x, y)</td>
<td></td>
<td>C</td>
<td>y逻辑右移x位</td>
</tr>
<tr>
<td>sar(x, y)</td>
<td></td>
<td>C</td>
<td>y算术右移x位</td>
</tr>
<tr>
<td>addmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>（x + y）％ m以任意精确算术</td>
</tr>
<tr>
<td>mulmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>（x * y）％m以任意精确算术</td>
</tr>
<tr>
<td>signextend(i, x)</td>
<td></td>
<td>F</td>
<td>符号从最低有效位（i*8 + 7）位开始计数</td>
</tr>
<tr>
<td>keccak256(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>sha3(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>jump(label)</td>
<td>-</td>
<td>F</td>
<td>跳转到标签/代码位置</td>
</tr>
<tr>
<td>jumpi(label, cond)</td>
<td>-</td>
<td>F</td>
<td>如果cond不为零，则跳转到标签</td>
</tr>
<tr>
<td>pc</td>
<td></td>
<td>F</td>
<td>代码中的当前位置</td>
</tr>
<tr>
<td>pop(x)</td>
<td>-</td>
<td>F</td>
<td>弹出x个栈顶元素</td>
</tr>
<tr>
<td>dup1…dup16</td>
<td></td>
<td>F</td>
<td>将第i个堆栈槽复制到顶部（从顶部开始计数）</td>
</tr>
<tr>
<td>swap1…swap16</td>
<td>*</td>
<td>F</td>
<td>交换栈顶和在其下面的第i个栈槽</td>
</tr>
<tr>
<td>mload(p)</td>
<td></td>
<td>F</td>
<td><code>mem[p..(p+32))</code></td>
</tr>
<tr>
<td>mstore(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p..(p+32)) := v</code></td>
</tr>
<tr>
<td>mstore8(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p] := v &amp; 0xff</code>（仅修改单个字节）</td>
</tr>
<tr>
<td>sload(p)</td>
<td></td>
<td>F</td>
<td>storage[p]</td>
</tr>
<tr>
<td>sstore(p, v)</td>
<td>-</td>
<td>F</td>
<td>storage[p] := v</td>
</tr>
<tr>
<td>msize</td>
<td></td>
<td>F</td>
<td>内存大小，即最大的访问内存索引</td>
</tr>
<tr>
<td>gas</td>
<td></td>
<td>F</td>
<td>仍然可以用于执行的gas</td>
</tr>
<tr>
<td>address</td>
<td></td>
<td>F</td>
<td>当前合同/执行上下文的地址</td>
</tr>
<tr>
<td>balance(a)</td>
<td></td>
<td>F</td>
<td>地址a的账户余额（wei）</td>
</tr>
<tr>
<td>caller</td>
<td></td>
<td>F</td>
<td>调用者（不含delegatecall）</td>
</tr>
<tr>
<td>callvalue</td>
<td></td>
<td>F</td>
<td>目前的调用一起发送的以太币（wei）</td>
</tr>
<tr>
<td>calldataload(p)</td>
<td></td>
<td>F</td>
<td>从位置p开始的调用数据（32字节）</td>
</tr>
<tr>
<td>calldatasize</td>
<td></td>
<td>F</td>
<td>调用数据的大小，以字节为单位</td>
</tr>
<tr>
<td>calldatacopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从calldata数据位置f复制s个字节到mem的位置t开始的位置</td>
</tr>
<tr>
<td>codesize</td>
<td></td>
<td>F</td>
<td>当前合同/执行上下文的代码大小</td>
</tr>
<tr>
<td>codecopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从位置f的代码复制s字节到mem的位置t</td>
</tr>
<tr>
<td>extcodesize(a)</td>
<td></td>
<td>F</td>
<td>地址a处代码的大小</td>
</tr>
<tr>
<td>extcodecopy(a, t, f, s)</td>
<td>-</td>
<td>F</td>
<td>像<code>codecopy(t, f, s)</code>，但是从地址a处获取代码</td>
</tr>
<tr>
<td>returndatasize</td>
<td></td>
<td>B</td>
<td>最近一次返回数据的大小</td>
</tr>
<tr>
<td>returndatacopy(t, f, s)</td>
<td>-</td>
<td>B</td>
<td>将返回数据f位置的字节复制到t位置的mem</td>
</tr>
<tr>
<td>create(v, p, s)</td>
<td></td>
<td>F</td>
<td>用代码mem[p..(p + s))创建新的合约并发送v wei以太币并返回新的地址</td>
</tr>
<tr>
<td>create2(v, n, p, s)</td>
<td></td>
<td>C</td>
<td>在地址<code>keccak256(&lt;address&gt; . n . keccak256(mem[p..(p+s)))</code> 创建与代码mem[p..(p + s))的新合约并发送v wei并返回新地址</td>
</tr>
<tr>
<td>call(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>在输入mem[in..(in + insize))时提供g gas和v wei以及输出区mem[out..(out + oversize))，在地址a处调用合约，并在错误时返回0,1代表成功</td>
</tr>
<tr>
<td>callcode(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与<code>call</code>相同，但只能使用地址a的代码，否则保留在当前合约的上下文中</td>
</tr>
<tr>
<td>delegatecall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>H</td>
<td>与<code>callcode</code>相同，但也保持<code>caller</code> 和<code>callvalue</code></td>
</tr>
<tr>
<td>staticcall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>B</td>
<td>与<code>call(g, a, 0, in, insize, out, outsize)</code>相同, 但不允许状态修改</td>
</tr>
<tr>
<td>return(p, s)</td>
<td>-</td>
<td>F</td>
<td>结束执行，返回数据mem[p..(p + s))</td>
</tr>
<tr>
<td>revert(p, s)</td>
<td>-</td>
<td>B</td>
<td>结束执行，恢复状态更改，返回数据mem[p..(p + s))</td>
</tr>
<tr>
<td>selfdestruct(a)</td>
<td>-</td>
<td>F</td>
<td>终止执行，摧毁当前合同并将资金发送给地址a</td>
</tr>
<tr>
<td>invalid</td>
<td>-</td>
<td>F</td>
<td>用无效指令结束执行</td>
</tr>
<tr>
<td>log0(p, s)</td>
<td>-</td>
<td>F</td>
<td>没有主题和mem[p..(p + s))的数据的日志</td>
</tr>
<tr>
<td>log1(p, s, t1)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1和mem[p..(p + s))的数据</td>
</tr>
<tr>
<td>log2(p, s, t1, t2)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>log3(p, s, t1, t2, t3)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2，t3和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>log4(p, s, t1, t2, t3, t4)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2，t3，t4和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>origin</td>
<td></td>
<td>F</td>
<td>交易发送者</td>
</tr>
<tr>
<td>gasprice</td>
<td></td>
<td>F</td>
<td>交易的gas价格</td>
</tr>
<tr>
<td>blockhash(b)</td>
<td></td>
<td>F</td>
<td>块b的散列值 - 仅适用于不包括当前值的最后256个块</td>
</tr>
<tr>
<td>coinbase</td>
<td></td>
<td>F</td>
<td>目前的采矿受益者</td>
</tr>
<tr>
<td>timestamp</td>
<td></td>
<td>F</td>
<td>当前块的时间戳，以秒为单位</td>
</tr>
<tr>
<td>number</td>
<td></td>
<td>F</td>
<td>当前区块高度</td>
</tr>
<tr>
<td>difficulty</td>
<td></td>
<td>F</td>
<td>当前块的难度</td>
</tr>
<tr>
<td>gaslimit</td>
<td></td>
<td>F</td>
<td>当前块的区块gas限制</td>
</tr>
</tbody>
</table>
<h3 id="字面Literals"><a href="#字面Literals" class="headerlink" title="字面Literals"></a>字面Literals</h3><p>您可以使用十进制或十六进制符号键入整数常量，这会自动生成相应的<code>PUSHi</code>指令。下面创建代码，将2和3加起来得到5，然后与字符串“abc”进行按位与计算。字符串存储为左对齐，不能超过32个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; 2 3 add &quot;abc&quot; and &#125;</span><br></pre></td></tr></table></figure></p>
<p>译者注：这个看起来像比特币的脚本语言有木有。（基于堆栈的脚本语言，也就是说solidity的底层实现有点像比特币脚本，只是支持跳转语句而已）。</p>
<h3 id="函数风格"><a href="#函数风格" class="headerlink" title="函数风格"></a>函数风格</h3><p>您可以在操作码之后键入操作码，它们将以字节码结尾。例如将内存中在位置0x80处的数据加3，将是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0x80 mload add 0x80 mstore</span><br></pre></td></tr></table></figure></p>
<p>由于通常很难看到某些操作码的实际参数是什么，所以Solidity内联汇编还提供了一种“函数风格”表示法，其中相同的代码可如下编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(0x80, add(mload(0x80), 3))</span><br></pre></td></tr></table></figure></p>
<p>函数风格表达式不能在内部使用函数风格，例如<code>1 2 mstore(0x80, add)</code>不是有效的程序，它必须写成<code>mstore(0x80, add(2, 1))</code>。对于不带参数的操作码，括号可以省略。</p>
<p><b style="color:red">请注意，参数的顺序在函数风格中与指令风格完全相反</b>。如果使用函数风格，第一个参数将会在堆栈顶部结束。</p>
<h3 id="访问外部变量和函数"><a href="#访问外部变量和函数" class="headerlink" title="访问外部变量和函数"></a>访问外部变量和函数</h3><p><b style="color:red">通过简单地使用它们的名称就可以访问solidity变量和其他标识符。对于内存变量，这会将地址而不是值推入堆栈</b>。<b style="color:red">存储变量不同：存储中的值可能不占用完整的存储槽，因此它们的“地址”由该槽中的槽和字节偏移量组成</b>。要检索变量<code>x</code>指向的槽，你需要使用<code>x_slot</code>并检索您使用的字节偏移量<code>x_offset</code>。</p>
<p>在赋值中（见下文），我们甚至可以使用本地Solidity变量来赋值。</p>
<p>也可以访问内联汇编外部的函数：汇编将推入它们的入口标签（应用虚函数解析）。solidity中可靠的调用语义是：</p>
<ul>
<li>调用者将<code>return label, arg1, arg2, …, argn</code>压入栈中</li>
<li>调用连同<code>ret1, ret2, …, retm</code>返回。</li>
</ul>
<p>这个特性使用起来还是有点麻烦，因为在调用期间堆栈偏移量实际上会发生变化，因此对局部变量的引用将会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    function f(uint x) public returns (uint r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) // ignore the offset, we know it is zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>EVM组装中的另一个问题是，jump和jumpi使用可以轻易改变的绝对地址。Solidity内联汇编提供了标签，以便更容易地使用跳转。请注意，标签是低级特征，只需使用汇编函数，loops，if和switch指令（参见下文），就可以编写无标签的高效汇编。以下代码计算斐波那契数列中的一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let n := calldataload(4)</span><br><span class="line">    let a := 1</span><br><span class="line">    let b := a</span><br><span class="line">loop:</span><br><span class="line">    jumpi(loopend, eq(n, 0))</span><br><span class="line">    a add swap1</span><br><span class="line">    n := sub(n, 1)</span><br><span class="line">    jump(loop)</span><br><span class="line">loopend:</span><br><span class="line">    mstore(0, a)</span><br><span class="line">    return(0, 0x20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，只有汇编器知道当前堆栈高度时，才能自动访问堆栈变量。如果跳转源和目标具有不同的堆栈高度，这将失效。使用这种跳转仍然ok，但在这种情况下，您应该不会访问任何堆栈变量（即使是汇编中的变量）。</p>
<p>此外，堆栈高度分析器通过操作码（而不是根据控制流）执行代码操作码，因此在下列情况下，汇编器对在标签<code>two</code>处的堆栈高度会产生错误印象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 8</span><br><span class="line">    jump(two)</span><br><span class="line">    one:</span><br><span class="line">        // Here the stack height is 2 (because we pushed x and 7),</span><br><span class="line">        // but the assembler thinks it is 1 because it reads</span><br><span class="line">        // from top to bottom.</span><br><span class="line">        // Accessing the stack variable x here will lead to errors.</span><br><span class="line">        x := 9</span><br><span class="line">        jump(three)</span><br><span class="line">    two:</span><br><span class="line">        7 // push something onto the stack</span><br><span class="line">        jump(one)</span><br><span class="line">    three:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>译者注：看来这是堆栈式语言引入jump之后带来的一个大问题，不知道如何解决这个问题，这个问题既有编译器编译逻辑也有机器代码逻辑的表示。</p>
<h3 id="声明汇编本地变量"><a href="#声明汇编本地变量" class="headerlink" title="声明汇编本地变量"></a>声明汇编本地变量</h3><p>您可以使用let关键字来声明仅在内联程序中可见的变量，实际上仅在当前的<code>{...}</code>块中可见。<b style="color:red">该let指令将创建一个为变量保留的新堆栈槽，并在达到语句块末尾时再次自动删除</b>。您需要为变量提供一个初始值0，但它也可以是一个复杂的函数风格表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint x) public view returns (uint b) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let v := add(x, 1)</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line">            &#123;</span><br><span class="line">                let y := add(sload(v), 1)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; // y is &quot;deallocated&quot; here</span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; // v is &quot;deallocated&quot; here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以将汇编局部变量和局部变量赋值给函数。请注意，当您给指向内存或存储的变量赋值时，只会更改指针而不是数据。</p>
<p>有两种赋值方式：函数风格和指令风格。对于函数风格赋值（<code>variable := value</code>），您需要在函数风格表达式中提供一个值，该值可以导致恰好一个堆栈值，对于指令风格赋值（<code>=: variable</code>），该值仅从堆栈顶部获取。对于这两种方式，冒号<code>:</code>指向变量的名称。通过用新值替换堆栈上的变量值来执行赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0 // functional-style assignment as part of variable declaration</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    sload(10)</span><br><span class="line">    =: v // instruction style assignment, puts the result of sload(10) into v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句可以用于有条件地执行代码。没有“else”部分，如果您需要多种选择，请考虑使用“switch”（请参阅​​下文）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if eq(value, 0) &#123; revert(0, 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主体的花括号是必需的。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>你可以使用switch语句作为“if/else”的一个非常基本的版本（由于汇编中if没有else，我们可以使用switch的default代替）。它采用表达式的值并将其与几个常量进行比较，采用与匹配常数对应的分支。与某些编程语言的容易出错的行为相反，控制流不会从一种情况继续下去。可以有一个回退或默认情况称为<code>default</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    switch calldataload(4)</span><br><span class="line">    case 0 &#123;</span><br><span class="line">        x := calldataload(0x24)</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        x := calldataload(0x44)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(0, div(x, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>case可以不用大括号，但case的主体确实需要它们。</p>
<h3 id="循环Loops"><a href="#循环Loops" class="headerlink" title="循环Loops"></a>循环Loops</h3><p>汇编支持一个简单的for-style循环。For-style循环有一个包含初始化部分，条件和后迭代部分的头文件。条件必须是功能式的表达，而另外两个是语句块。如果初始化部分声明了任何变量，则这些变量的作用域被扩展到正文中（包括条件和后迭代部分）。</p>
<p>以下示例计算内存中区域的总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For循环也可以写成像while循环一样：只需将初始化和后迭代部分留空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    let i := 0</span><br><span class="line">    for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123;     // while(i &lt; 0x100)</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, 0x20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>内联汇编允许定义低级函数。这些从堆栈中取出它们的参数（并返回PC），并将结果放入堆栈。调用函数的方式与执行函数风格的操作码相同。</p>
<p>函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在该函数之外定义的局部变量。没有明确的<code>return</code>语句。</p>
<p>如果您调用返回多个值的函数，则必须使用<code>a, b := f(x)</code>或者<code>let a, b := f(x)</code> 将它们分配给元组。</p>
<p>以下示例通过平方和乘法实现幂函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base, exponent) -&gt; result &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0 &#123; result := 1 &#125;</span><br><span class="line">        case 1 &#123; result := base &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">            // 通过递归进行幂值计算。</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2))</span><br><span class="line">            switch mod(exponent, 2)</span><br><span class="line">                case 1 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="要避免的事情"><a href="#要避免的事情" class="headerlink" title="要避免的事情"></a>要避免的事情</h3><p>内联汇编可能具有相当高级的表象，但实际上它是非常低级的。函数调用，loops，ifs和switch通过简单的重写规则进行转换，之后，汇编程序为您做的唯一事情就是重新安排函数风格的操作码，管理跳转标签，计算变量访问的堆栈高度并在到达语句块的末尾时删除堆栈槽中分配的本地变量。特别是对于最后两种情况，<b style="color:red">重要的是要知道，汇编程序仅从上到下计数堆栈高度，而不一定遵循控制流程。而且，swap等操作只会交换堆栈的内容，而不会交换变量的位置。</b></p>
<h3 id="solidity约定"><a href="#solidity约定" class="headerlink" title="solidity约定"></a>solidity约定</h3><p><b style="color:blue">与EVM组装相反，Solidity知道窄于256位的类型，例如uint24。为了使它们更高效，大多数算术运算只将它们视为256位数字，而高位仅在必要时清除，即在它们被写入内存之前或执行比较之前。这意味着如果您从内联汇编中访问这样的变量，则可能必须首先手动清除更高位。</b>这个有助于我们理解solidity的工作机制。</p>
<p>Solidity以一种非常简单的方式管理内存：内存位置<code>0x40</code>处有一个“空闲内存指针”。如果你想分配内存，只需在那个位置使用内存，并相应地更新指针。</p>
<p>在solidity的内存数组元素始终占据32个字节（是的，对于<code>byte[]</code>，这是真实的，而对于<code>bytes</code>和<code>string</code>不是这样）。多维内存数组是指向内存数组的指针。动态数组的长度存储在数组的第一个插槽中，然后跟随数组元素。</p>
<p><b style="color:#6ab0de">警告:静态大小的内存数组没有长度字段，但它很快就会添加，以便在静态和动态大小的数组之间实现更好的可转换性，所以请不要依赖它。</b></p>
<h2 id="独立汇编"><a href="#独立汇编" class="headerlink" title="独立汇编"></a>独立汇编</h2><p>以上内联汇编语言描述的汇编语言也可以单独使用，实际上，计划是将其用作Solidity编译器的中间语言。在这种形式下，它试图实现几个目标：</p>
<ol>
<li>写在其中的程序应该是可读的，即使代码是由Solidity的编译器生成的。</li>
<li>从汇编到字节码的翻译应该包含尽可能少的“surprises”。</li>
<li>控制流应该易于检测，以帮助进行格式验证和优化。</li>
</ol>
<p>为了实现第一个和最后一个目标，汇编提供了高层次的结构，如<code>for</code>循环，<code>if</code>和<code>switch</code>语句和函数调用。它应该能够编写汇编程序不使用明确的<code>SWAP</code>，<code>DUP</code>， <code>JUMP</code>和<code>JUMPI</code>语句，因为前两个模糊的数据流和最后两个模糊处理的控制流。此外，函数语句<code>mul(add(x, y), 7)</code>优于纯操作码语句<code>7 y x add mul</code>， 因为在第一种形式中，更容易看出哪个操作数用于哪个操作码。</p>
<p>第二个目标是通过引入一个desugaring阶段来实现的，该阶段只能以非常规的方式移除较高级别的构造，并且仍然允许检查生成的低级汇编代码。汇编程序执行的唯一非本地操作是用户定义的标识符（函数，变量，…）的名称查找，它遵循非常简单和常规的范围规则以及从堆栈中清除局部变量。</p>
<p>作用域：声明的标识符（标签，变量，函数，汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。跨函数边界访问局部变量是不合法的，即使它们在范围内。阴影是不允许的。局部变量在声明之前不能被访问，但标签，函数和内联汇编可以。assembly是特殊的语句块，用于例如返回运行时代码或创建合约。子assembly中没有可见的外部assembly标识符。</p>
<p>如果控制流经过语句块的末尾，则会插入与该语句块中声明的局部变量数匹配的流行指令。无论何时引用局部变量，代码生成器都需要知道其当前在堆栈中的相对位置，因此需要跟踪当前所谓的堆栈高度。<b style="color:red">由于所有局部变量都在块的末尾被删除，块前后的堆栈高度应该相同。如果情况并非如此，则会发出警告。</b></p>
<p>为什么要使用更高级别的结构类似<code>switch</code>，<code>for</code>和函数：</p>
<p>使用switch，for和函数，它应该有可能编写复杂的代码，而无需手工使用jump或jumpi。这使得分析控制流程变得更加容易，从而可以改进格式验证和优化。</p>
<p>此外，如果允许手动跳转，计算堆栈高度相当复杂。需要知道堆栈中所有局部变量的位置，否则在块结束时既不会自动引用局部变量也不会从堆栈中自动删除局部变量。脱钩机构正确地将操作插入无法访问的语句块，以便在没有持续控制流的跳转情况下正确调整堆栈高度。</p>
<p>例：我们将按照Solidity的示例汇编去装配。我们考虑以下Solidity程序的运行时字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  function f(uint x) public pure returns (uint y) &#123;</span><br><span class="line">    y = 1;</span><br><span class="line">    for (uint i = 0; i &lt; x; i++)</span><br><span class="line">      y = 2 * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将生成以下汇编：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60) // store the &quot;free memory pointer&quot;</span><br><span class="line">  // function dispatcher</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // memory allocator</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // the contract function</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解除阶段后，它看起来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60)</span><br><span class="line">  &#123;</span><br><span class="line">    let $0 := div(calldataload(0), exp(2, 226))</span><br><span class="line">    jumpi($case1, eq($0, 0xb3de648b))</span><br><span class="line">    jump($caseDefault)</span><br><span class="line">    $case1:</span><br><span class="line">    &#123;</span><br><span class="line">      // the function call - we put return label and arguments on the stack</span><br><span class="line">      $ret1 calldataload(4) jump(f)</span><br><span class="line">      // This is unreachable code. Opcodes are added that mirror the</span><br><span class="line">      // effect of the function on the stack height: Arguments are</span><br><span class="line">      // removed and return values are introduced.</span><br><span class="line">      pop pop</span><br><span class="line">      let r := 0</span><br><span class="line">      $ret1: // the actual return point</span><br><span class="line">      $ret2 0x20 jump($allocate)</span><br><span class="line">      pop pop let ret := 0</span><br><span class="line">      $ret2:</span><br><span class="line">      mstore(ret, r)</span><br><span class="line">      return(ret, 0x20)</span><br><span class="line">      // although it is useless, the jump is automatically inserted,</span><br><span class="line">      // since the desugaring process is a purely syntactic operation that</span><br><span class="line">      // does not analyze control-flow</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $caseDefault:</span><br><span class="line">    &#123;</span><br><span class="line">      revert(0, 0)</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $endswitch:</span><br><span class="line">  &#125;</span><br><span class="line">  jump($afterFunction)</span><br><span class="line">  allocate:</span><br><span class="line">  &#123;</span><br><span class="line">    // we jump over the unreachable code that introduces the function arguments</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let size := 0</span><br><span class="line">    $start:</span><br><span class="line">    // output variables live in the same scope as the arguments and is</span><br><span class="line">    // actually allocated.</span><br><span class="line">    let pos := 0</span><br><span class="line">    &#123;</span><br><span class="line">      pos := mload(0x40)</span><br><span class="line">      mstore(0x40, add(pos, size))</span><br><span class="line">    &#125;</span><br><span class="line">    // This code replaces the arguments by the return values and jumps back.</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    // Again unreachable code that corrects stack height.</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  f:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let x := 0</span><br><span class="line">    $start:</span><br><span class="line">    let y := 0</span><br><span class="line">    &#123;</span><br><span class="line">      let i := 0</span><br><span class="line">      $for_begin:</span><br><span class="line">      jumpi($for_end, iszero(lt(i, x)))</span><br><span class="line">      &#123;</span><br><span class="line">        y := mul(2, y)</span><br><span class="line">      &#125;</span><br><span class="line">      $for_continue:</span><br><span class="line">      &#123; i := add(i, 1) &#125;</span><br><span class="line">      jump($for_begin)</span><br><span class="line">      $for_end:</span><br><span class="line">    &#125; // Here, a pop instruction will be inserted for i</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  $afterFunction:</span><br><span class="line">  stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇编发生在以下四个阶段：</p>
<ol>
<li>解析</li>
<li>Desugaring（移除switch，for和函数）</li>
<li>操作码流生成</li>
<li>字节码生成</li>
</ol>
<p>我们将以伪正式的方式指定第一步到第三步。更正式的规格将随之而来。</p>
<h3 id="解析-语法"><a href="#解析-语法" class="headerlink" title="解析/语法"></a>解析/语法</h3><p>解析器的任务如下：</p>
<ul>
<li>将字节流转换为标识符（就是每一个单词）流，丢弃C++风格的注释（对源引用存在特殊注释，但我们不在这里解释）。</li>
<li>根据下面的语法将标识符流转换为AST</li>
<li>使用它们在其定义的语句块中注册标识符（注释到AST节点）并注意从哪个点开始，可以访问变量。</li>
</ul>
<p>汇编词法分析器遵循由Solidity自己定义的那个。</p>
<p>空格用于分隔标识符，它由空格，制表符和换行符组成。评论是常规的JavaScript/C++评论，并且以与Whitespace相同的方式进行解释。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line">AssemblyItem =</span><br><span class="line">    Identifier |</span><br><span class="line">    AssemblyBlock |</span><br><span class="line">    AssemblyExpression |</span><br><span class="line">    AssemblyLocalDefinition |</span><br><span class="line">    AssemblyAssignment |</span><br><span class="line">    AssemblyStackAssignment |</span><br><span class="line">    LabelDefinition |</span><br><span class="line">    AssemblyIf |</span><br><span class="line">    AssemblySwitch |</span><br><span class="line">    AssemblyFunctionDefinition |</span><br><span class="line">    AssemblyFor |</span><br><span class="line">    &apos;break&apos; |</span><br><span class="line">    &apos;continue&apos; |</span><br><span class="line">    SubAssembly</span><br><span class="line">AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral</span><br><span class="line">AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">AssemblyCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;</span><br><span class="line">AssemblyLocalDefinition = &apos;let&apos; IdentifierOrList ( &apos;:=&apos; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = IdentifierOrList &apos;:=&apos; AssemblyExpression</span><br><span class="line">IdentifierOrList = Identifier | &apos;(&apos; IdentifierList &apos;)&apos;</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">AssemblyStackAssignment = &apos;=:&apos; Identifier</span><br><span class="line">LabelDefinition = Identifier &apos;:&apos;</span><br><span class="line">AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &apos;switch&apos; AssemblyExpression AssemblyCase*</span><br><span class="line">    ( &apos;default&apos; AssemblyBlock )?</span><br><span class="line">AssemblyCase = &apos;case&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblyFunctionDefinition = &apos;function&apos; Identifier &apos;(&apos; IdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; &apos;(&apos; IdentifierList &apos;)&apos; )? AssemblyBlock</span><br><span class="line">AssemblyFor = &apos;for&apos; ( AssemblyBlock | AssemblyExpression )</span><br><span class="line">    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock</span><br><span class="line">SubAssembly = &apos;assembly&apos; Identifier AssemblyBlock</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure></p>
<h3 id="Desugaring-去除语法糖"><a href="#Desugaring-去除语法糖" class="headerlink" title="Desugaring(去除语法糖)"></a>Desugaring(去除语法糖)</h3><p>AST转换删除<code>for</code>,<code>switch</code>和函数结构。结果仍然可以由同一个解析器解析，但它不会使用某些结构。如果jumpdests被添加，只跳转到不继续，将添加有关堆栈内容的信息，除非未访问外部作用域的局部变量或堆栈高度与前一条指令相同。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">desugar item: AST -&gt; AST =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyFunctionDefinition(&apos;function&apos; name &apos;(&apos; arg1, ..., argn &apos;)&apos; &apos;-&gt;&apos; ( &apos;(&apos; ret1, ..., retm &apos;)&apos; body) -&gt;</span><br><span class="line">  &lt;name&gt;:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($&lt;name&gt;_start)</span><br><span class="line">    let $retPC := 0 let argn := 0 ... let arg1 := 0</span><br><span class="line">    $&lt;name&gt;_start:</span><br><span class="line">    let ret1 := 0 ... let retm := 0</span><br><span class="line">    &#123; desugar(body) &#125;</span><br><span class="line">    swap and pop items so that only ret1, ... retm, $retPC are left on the stack</span><br><span class="line">    jump</span><br><span class="line">    0 (1 + n times) to compensate removal of arg1, ..., argn and $retPC</span><br><span class="line">  &#125;</span><br><span class="line">AssemblyFor(&apos;for&apos; &#123; init &#125; condition post body) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    init // cannot be its own block because we want variable scope to extend into the body</span><br><span class="line">    // find I such that there are no labels $forI_*</span><br><span class="line">    $forI_begin:</span><br><span class="line">    jumpi($forI_end, iszero(condition))</span><br><span class="line">    &#123; body &#125;</span><br><span class="line">    $forI_continue:</span><br><span class="line">    &#123; post &#125;</span><br><span class="line">    jump($forI_begin)</span><br><span class="line">    $forI_end:</span><br><span class="line">  &#125;</span><br><span class="line">&apos;break&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_end</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_end</span><br><span class="line">    jump($forI_end)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">&apos;continue&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_continue</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_continue</span><br><span class="line">    jump($forI_continue)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">AssemblySwitch(switch condition cases ( default: defaultBlock )? ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find I such that there is no $switchI* label or variable</span><br><span class="line">    let $switchI_value := condition</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: -&gt; jumpi($switchI_caseJ, eq($switchI_value, val))</span><br><span class="line">    &#125;</span><br><span class="line">    if default block present: -&gt;</span><br><span class="line">      &#123; defaultBlock jump($switchI_end) &#125;</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: &#123; body &#125; -&gt; $switchI_caseJ: &#123; body jump($switchI_end) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $switchI_end:</span><br><span class="line">  &#125;</span><br><span class="line">FunctionalAssemblyExpression( identifier(arg1, arg2, ..., argn) ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    if identifier is function &lt;name&gt; with n args and m ret values -&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        // find I such that $funcallI_* does not exist</span><br><span class="line">        $funcallI_return argn  ... arg2 arg1 jump(&lt;name&gt;)</span><br><span class="line">        pop (n + 1 times)</span><br><span class="line">        if the current context is `let (id1, ..., idm) := f(...)` -&gt;</span><br><span class="line">          let id1 := 0 ... let idm := 0</span><br><span class="line">          $funcallI_return:</span><br><span class="line">        else -&gt;</span><br><span class="line">          0 (m times)</span><br><span class="line">          $funcallI_return:</span><br><span class="line">          turn the functional expression that leads to the function call</span><br><span class="line">          into a statement stream</span><br><span class="line">      &#125;</span><br><span class="line">    else -&gt; desugar(children of node)</span><br><span class="line">  &#125;</span><br><span class="line">default node -&gt;</span><br><span class="line">  desugar(children of node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成操作码流"><a href="#生成操作码流" class="headerlink" title="生成操作码流"></a>生成操作码流</h3><p>在操作码流生成期间，我们会跟踪计数器中的当前堆栈高度，以便可以通过名称访问堆栈变量。每个修改堆栈的操作码以及每个用堆栈调整注释的标签都会修改堆栈高度。每次引入一个新的局部变量时，它都会与当前堆栈高度一起注册。如果访问变量（复制其值或赋值），则根据引入变量时当前堆栈高度和堆栈高度之间的差异选择适当的<code>DUP</code>或<code>SWAP</code>指令。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">codegen item: AST -&gt; opcode_stream =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyBlock(&#123; items &#125;) -&gt;</span><br><span class="line">  join(codegen(item) for item in items)</span><br><span class="line">  if last generated opcode has continuing control flow:</span><br><span class="line">    POP for all local variables registered at the block (including variables</span><br><span class="line">    introduced by labels)</span><br><span class="line">    warn if the stack height at this point is not the same as at the start of the block</span><br><span class="line">Identifier(id) -&gt;</span><br><span class="line">  lookup id in the syntactic stack of blocks</span><br><span class="line">  match type of id</span><br><span class="line">    Local Variable -&gt;</span><br><span class="line">      DUPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">    Label -&gt;</span><br><span class="line">      // reference to be resolved during bytecode generation</span><br><span class="line">      PUSH&lt;bytecode position of label&gt;</span><br><span class="line">    SubAssembly -&gt;</span><br><span class="line">      PUSH&lt;bytecode position of subassembly data&gt;</span><br><span class="line">FunctionalAssemblyExpression(id ( arguments ) ) -&gt;</span><br><span class="line">  join(codegen(arg) for arg in arguments.reversed())</span><br><span class="line">  id (which has to be an opcode, might be a function name later)</span><br><span class="line">AssemblyLocalDefinition(let (id1, ..., idn) := expr) -&gt;</span><br><span class="line">  register identifiers id1, ..., idn as locals in current block at current stack height</span><br><span class="line">  codegen(expr) - assert that expr returns n items to the stack</span><br><span class="line">FunctionalAssemblyAssignment((id1, ..., idn) := expr) -&gt;</span><br><span class="line">  lookup id1, ..., idn in the syntactic stack of blocks, assert that they are variables</span><br><span class="line">  codegen(expr)</span><br><span class="line">  for j = n, ..., i:</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(idj)</span><br><span class="line">  POP</span><br><span class="line">AssemblyAssignment(=: id) -&gt;</span><br><span class="line">  look up id in the syntactic stack of blocks, assert that it is a variable</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">  POP</span><br><span class="line">LabelDefinition(name:) -&gt;</span><br><span class="line">  JUMPDEST</span><br><span class="line">NumberLiteral(num) -&gt;</span><br><span class="line">  PUSH&lt;num interpreted as decimal and right-aligned&gt;</span><br><span class="line">HexLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit interpreted as hex and left-aligned&gt;</span><br><span class="line">StringLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit utf-8 encoded and left-aligned&gt;</span><br><span class="line">SubAssembly(assembly &lt;name&gt; block) -&gt;</span><br><span class="line">  append codegen(block) at the end of the code</span><br><span class="line">dataSize(&lt;name&gt;) -&gt;</span><br><span class="line">  assert that &lt;name&gt; is a subassembly -&gt;</span><br><span class="line">  PUSH32&lt;size of code generated from subassembly &lt;name&gt;&gt;</span><br><span class="line">linkerSymbol(&lt;lit&gt;) -&gt;</span><br><span class="line">  PUSH32&lt;zeros&gt; and append position to linker table</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/solidity/" rel="tag"># solidity</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
              <div>
                

<script src="//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.css">


  


<div class="likely">
  
    <div class="twitter">Tweet</div>
  
    <div class="facebook">Share</div>
  
    <div class="linkedin">Link</div>
  
    <div class="gplus">Plus</div>
  
    <div class="vkontakte">Share</div>
  
    <div class="odnoklassniki">Class</div>
  
    <div class="telegram">Send</div>
  
    <div class="whatsapp">Send</div>
  
    <div class="pinterest">Pin</div>
  
</div>

              </div>
            
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/04/blockchain/solidity合约/" rel="next" title="solidity合约">
                <i class="fa fa-chevron-left"></i> solidity合约
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/06/blockchain/solidity杂项/" rel="prev" title="solidity杂项">
                solidity杂项 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <!-- 左侧菜单--站点概览 -->
<div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image"
      src="/images/user-avatar"
      alt="Gavin Zhang"/>
  
  <p class="site-author-name" itemprop="name">Gavin Zhang</p>
  <div class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</div>
</div>

<!-- 下方的分类标签 -->

  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>


<!-- rss -->

  <div class="feed-link motion-element">
    <a href="https://www.gitbook.com/" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>











          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#内联汇编"><span class="nav-number">1.</span> <span class="nav-text">内联汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">1.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#句法"><span class="nav-number">1.2.</span> <span class="nav-text">句法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作码"><span class="nav-number">1.3.</span> <span class="nav-text">操作码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字面Literals"><span class="nav-number">1.4.</span> <span class="nav-text">字面Literals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数风格"><span class="nav-number">1.5.</span> <span class="nav-text">函数风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问外部变量和函数"><span class="nav-number">1.6.</span> <span class="nav-text">访问外部变量和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标签"><span class="nav-number">1.7.</span> <span class="nav-text">标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明汇编本地变量"><span class="nav-number">1.8.</span> <span class="nav-text">声明汇编本地变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值"><span class="nav-number">1.9.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if"><span class="nav-number">1.10.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">1.11.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环Loops"><span class="nav-number">1.12.</span> <span class="nav-text">循环Loops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">1.13.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要避免的事情"><span class="nav-number">1.14.</span> <span class="nav-text">要避免的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solidity约定"><span class="nav-number">1.15.</span> <span class="nav-text">solidity约定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#独立汇编"><span class="nav-number">2.</span> <span class="nav-text">独立汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析-语法"><span class="nav-number">2.1.</span> <span class="nav-text">解析/语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Desugaring-去除语法糖"><span class="nav-number">2.2.</span> <span class="nav-text">Desugaring(去除语法糖)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成操作码流"><span class="nav-number">2.3.</span> <span class="nav-text">生成操作码流</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>

  

  
</div>


  <div class="powered-by">由 Gavin 强力驱动 v3.5.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
      <div>
        <!-- add this第三方工具 -->
<div class="addthis_inline_share_toolbox">
  <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d2f5e89bbcb7cce" async="async"></script>
</div>

      </div>
    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  











  



  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '9ed54522a8818f2ebf63',
    clientSecret: '2977df7ea417b2b266949482dce578d39d7a2df6',
    repo: 'blog-comment',
    owner: 'cordate',
    admin: ['cordate'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  




  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
