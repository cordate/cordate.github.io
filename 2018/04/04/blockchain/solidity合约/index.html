<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="solidity," />


<meta name="description" content="本文是基于solidity官方文档v0.4.21. Solidity合约与面向对象语言中的类相似。它们包含可以修改这些变量的状态变量和函数中的持久数据。在不同的合约（实例）上调用函数将执行EVM函数调用，从而切换上下文以使状态变量不可访问。 创建合约合约可以通过以太坊交易或从Solidity合约中“从外部”创建。 诸如Remix之类的 IDE 使用UI元素使创建过程透明。 在Ethereum上以编">
<meta name="keywords" content="solidity">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity合约">
<meta property="og:url" content="http://cordate.github.io/2018/04/04/blockchain/solidity合约/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="本文是基于solidity官方文档v0.4.21. Solidity合约与面向对象语言中的类相似。它们包含可以修改这些变量的状态变量和函数中的持久数据。在不同的合约（实例）上调用函数将执行EVM函数调用，从而切换上下文以使状态变量不可访问。 创建合约合约可以通过以太坊交易或从Solidity合约中“从外部”创建。 诸如Remix之类的 IDE 使用UI元素使创建过程透明。 在Ethereum上以编">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-04-08T03:31:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="solidity合约">
<meta name="twitter:description" content="本文是基于solidity官方文档v0.4.21. Solidity合约与面向对象语言中的类相似。它们包含可以修改这些变量的状态变量和函数中的持久数据。在不同的合约（实例）上调用函数将执行EVM函数调用，从而切换上下文以使状态变量不可访问。 创建合约合约可以通过以太坊交易或从Solidity合约中“从外部”创建。 诸如Remix之类的 IDE 使用UI元素使创建过程透明。 在Ethereum上以编">






  <link rel="canonical" href="http://cordate.github.io/2018/04/04/blockchain/solidity合约/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>solidity合约 | 柳絮纷飞</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/04/blockchain/solidity合约/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">solidity合约</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T00:47:52+08:00">2018-04-04</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<p>Solidity合约与面向对象语言中的类相似。它们包含可以修改这些变量的状态变量和函数中的持久数据。在不同的合约（实例）上调用函数将执行EVM函数调用，从而切换上下文以使状态变量不可访问。</p>
<h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约</h2><p>合约可以通过以太坊交易或从Solidity合约中“从外部”创建。</p>
<p>诸如<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>之类的 IDE 使用UI元素使创建过程透明。</p>
<p>在Ethereum上以编程方式创建合约最好通过使用JavaScript API <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>完成。截至今天，它有一个名为<a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank" rel="noopener">web3.eth.Contract</a>的方法 来促进合约创建。</p>
<p><b style="color:red">创建合约时，其构造函数（与合约名称相同的函数）将执行一次。构造函数是可选的。只允许一个构造函数，这意味着不支持重载。</b></p>
<p><b style="color:blue">在内部，构造函数参数在合约本身的代码之后通过<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi" target="_blank" rel="noopener">ABI编码</a>传递，但如果使用<code>web3.js</code>，则不必关心这一点。</b></p>
<p><b style="color:blue">如果合约要创建另一个合约，则创建者必须知道所创建合约的源代码（和二进制文件）。这意味着循环创建依赖是不可能的。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    // TokenCreator is a contract type that is defined below.</span><br><span class="line">    // It is fine to reference it as long as it is not used</span><br><span class="line">    // to create a new contract.</span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    // This is the constructor which registers the</span><br><span class="line">    // creator and the assigned name.</span><br><span class="line">    function OwnedToken(bytes32 _name) public &#123;</span><br><span class="line">        // State variables are accessed via their name</span><br><span class="line">        // and not via e.g. this.owner. This also applies</span><br><span class="line">        // to functions and especially in the constructors,</span><br><span class="line">        // you can only call them like that (&quot;internally&quot;),</span><br><span class="line">        // because the contract itself does not exist yet.</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        // We do an explicit type conversion from `address`</span><br><span class="line">        // to `TokenCreator` and assume that the type of</span><br><span class="line">        // the calling contract is TokenCreator, there is</span><br><span class="line">        // no real way to check that.</span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(bytes32 newName) public &#123;</span><br><span class="line">        // Only the creator can alter the name --</span><br><span class="line">        // the comparison is possible since contracts</span><br><span class="line">        // are implicitly convertible to addresses.</span><br><span class="line">        if (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address newOwner) public &#123;</span><br><span class="line">        // Only the current owner can transfer the token.</span><br><span class="line">        if (msg.sender != owner) return;</span><br><span class="line">        // We also want to ask the creator if the transfer</span><br><span class="line">        // is fine. Note that this calls a function of the</span><br><span class="line">        // contract defined below. If the call fails (e.g.</span><br><span class="line">        // due to out-of-gas), the execution here stops</span><br><span class="line">        // immediately.</span><br><span class="line">        if (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    function createToken(bytes32 name)</span><br><span class="line">       public</span><br><span class="line">       returns (OwnedToken tokenAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        // Create a new Token contract and return its address.</span><br><span class="line">        // From the JavaScript side, the return type is simply</span><br><span class="line">        // `address`, as this is the closest type available in</span><br><span class="line">        // the ABI.</span><br><span class="line">        return new OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(OwnedToken tokenAddress, bytes32 name)  public &#123;</span><br><span class="line">        // Again, the external type of `tokenAddress` is</span><br><span class="line">        // simply `address`.</span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isTokenTransferOK(address currentOwner, address newOwner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bool ok)</span><br><span class="line">    &#123;</span><br><span class="line">        // Check some arbitrary condition.</span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可见性和Getters"><a href="#可见性和Getters" class="headerlink" title="可见性和Getters"></a>可见性和Getters</h2><p>由于Solidity知道两种函数调用（不产生实际EVM调用的内部函数（也称为“消息调用”）和外部函数调用），<b style="color:red">函数和状态变量有四种类型的可见性。</b></p>
<p><b style="color:blue">如存在函数可以指定external， public，internal或者private，其中默认为 public。对于状态变量，这external是不可能的，而且默认是internal。</b></p>
<ul>
<li>external：外部功能是合约界面的一部分，这意味着可以从其他合约和交易中调用它们。外部函数f不能在内部调用（即f()不起作用，但this.f()可以）。<b style="color:red">外部函数在接收大量数据时有时更高效。</b></li>
<li>public：<b style="color:blue">公共方法是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量，会生成一个自动获取器函数（见下文）。</b></li>
<li>internal：<b style="color:blue">这些方法和状态变量只能在内部进行访问（即从当前合约或从中衍生出的合约内），而不能使用this。</b></li>
<li>private：<b style="color:blue">私有函数和状态变量仅对它们定义的合约而不是衍生合约中可见。</b></li>
</ul>
<p><b style="color:#6ab0de">注意: 所有外部观察者都可以看到合约内的所有内容。设置成员为private只会阻止其他合约访问和修改信息，但在区块链之外，整个世界仍然可以看到它。</b></p>
<p>可见性说明符在状态变量的类型之后以及函数的参数列表和返回参数列表之间给出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a) private pure returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在以下示例中，<code>D</code>，可以调用c.getData()以检索data状态存储的值 ，但无法调用f。合约E来源于 C，因此可以调用compute方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//这将不会编译</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint private data;</span><br><span class="line"></span><br><span class="line">    function f(uint a) private returns(uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) public &#123; data = a; &#125;</span><br><span class="line">    function getData() public returns(uint) &#123; return data; &#125;</span><br><span class="line">    function compute(uint a, uint b) internal returns (uint) &#123; return a+b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    function readData() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint local = c.f(7); // error: member `f` is not visible</span><br><span class="line">        c.setData(3);</span><br><span class="line">        local = c.getData();</span><br><span class="line">        local = c.compute(3, 5); // error: member `compute` is not visible</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract E is C &#123;</span><br><span class="line">    function g() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint val = compute(3, 5); // access to internal member (from derived to parent contract)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Getter函数"><a href="#Getter函数" class="headerlink" title="Getter函数"></a>Getter函数</h3><p>编译器自动为所有公共状态变量创建getter函数。对于下面给出的合约，编译器将生成一个函数data，它不会接受任何参数并返回uint状态变量的值data。状态变量的初始化可以在声明中完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">getter方法具有外部可见性。如果符号在内部被访问（即没有<code>this.</code>），它被认为是一个状态变量。如果它是外部访问的（即with <code>this.</code>），它将作为函数进行访问。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data;</span><br><span class="line">    function x() public &#123;</span><br><span class="line">        data = 3; // internal access</span><br><span class="line">        uint val = this.data(); // external access</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个例子有点复杂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将生成以下形式的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，结构中的映射被省略，因为没有提供映射键的好方法。</p>
<h2 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h2><p><b style="color:red">修饰符可以用来轻松改变函数的行为。例如，他们可以在执行该方法之前自动检查一个条件。修饰符是合约的可继承属性，可能会被衍生合约覆盖。</b></p>
<p><b style="color:red">可修饰符，注意看代码的15行和52行，这个就是我们如何自定义自己的函数修饰符的例子，总的来说就是实现了钩子方法，超赞。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // This contract only defines a modifier but does not use</span><br><span class="line">    // it: it will be used in derived contracts.</span><br><span class="line">    // The function body is inserted where the special symbol</span><br><span class="line">    // `_;` in the definition of a modifier appears.</span><br><span class="line">    // This means that if the owner calls this function, the</span><br><span class="line">    // function is executed and otherwise, an exception is</span><br><span class="line">    // thrown.</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // This contract inherits the `onlyOwner` modifier from</span><br><span class="line">    // `owned` and applies it to the `close` function, which</span><br><span class="line">    // causes that calls to `close` only have an effect if</span><br><span class="line">    // they are made by the stored owner.</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // Modifiers can receive arguments:</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // It is important to also provide the</span><br><span class="line">    // `payable` keyword here, otherwise the function will</span><br><span class="line">    // automatically reject all Ether sent to it.</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// This function is protected by a mutex, which means that</span><br><span class="line">    /// reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br><span class="line">    /// The `return 7` statement assigns 7 to the return value but still</span><br><span class="line">    /// executes the statement `locked = false` in the modifier.</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:red">通过在一个空白分隔的列表中指定多个修饰符并按照所呈现的顺序对多个修饰符进行评估。</b></p>
<p><b style="color:#6ab0de">警告: 在早期版本的Solidity中，return具有修饰符的函数中的语句表现不同。</b></p>
<p><b style="color:red">来自修饰符或函数体的显式返回仅保留当前修饰符或函数体。返回变量被赋值并且控制流程在前一个修改器中的“_”之后继续。</b></p>
<p><b style="color:red">修饰符参数可使用允许任意表达式，在此上下文中，从该函数可见的所有符号在修饰符中都是可见的。在修饰符中引入的符号在函数中是不可见的（因为它们可能通过覆盖而改变）。(注意这里的修饰符是指修饰符函数)</b></p>
<h2 id="常量状态变量"><a href="#常量状态变量" class="headerlink" title="常量状态变量"></a>常量状态变量</h2><p><b style="color:red">状态变量可以声明为constant。在这种情况下，它们必须在编译时的常量表达式中分配。访问存储的任何表达式，blockchain数据（例如<code>now</code>，<code>this.balance</code>或 <code>block.number</code>），或者执行数据（<code>msg.value</code>或<code>gasleft()</code>）或调用外部合约是不允许的。对内存分配可能有副作用的表达式是允许的，但对其他内存对象可能有副作用的表达式则不允许。内置的功能<code>keccak256</code>，<code>sha256</code>，<code>ripemd160</code>，<code>ecrecover</code>，<code>addmod</code>和<code>mulmod</code>是允许的（即使他们这样做调用外部合约）。</b></p>
<p>在内存分配器上允许副作用的原因是应该可以构造复杂的对象，例如查找表。此功能尚未完全可用。</p>
<p>编译器不会为这些变量保留一个存储槽，并且每个出现都被各自的常量表达式替换（可能由优化器为单个值计算）。</p>
<p>并非所有类型的常量都在此时执行。唯一支持的类型是值类型和字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h3 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h3><p>可以用<code>view</code>声明函数，在这种情况下，它们保证不修改状态。</p>
<p>以下声明被视为修改状态：</p>
<ul>
<li>写入状态变量。</li>
<li><a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#events" target="_blank" rel="noopener">发射(触发)事件。</a></li>
<li><a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#creating-contracts" target="_blank" rel="noopener">创建其他合约</a>。</li>
<li>使用<code>selfdestruct</code>。</li>
<li>通过调用方法发送以太币。</li>
<li>调用任何未标记<code>view</code>或<code>pure</code>的方法。</li>
<li>使用低级别的调用。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public view returns (uint) &#123;</span><br><span class="line">        return a * (b + 42) + now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:#6ab0de">注意: 方法上的<code>constant</code>是<code>view</code>的别名，但这已被弃用，并计划在0.5.0版中删除。</b></p>
<p><b style="color:#6ab0de">注意: Getter方法被标记为<code>view</code>。</b></p>
<p><b style="color:#6ab0de">注意: 如果使用无效的显式类型转换，那么即使view调用了一个函数，状态修改也是可能的。您可以切换编译器在调用此类函数时使用<code>STATICCALL</code>，那么通过添加<code>pragma experimental &quot;v0.5.0&quot;;</code>来防止修改EVM级别的状态.</b></p>
<p><b style="color:#6ab0de">警告:编译器不强制<code>view</code>方法不去修改状态。但它会提出了一个警告。</b></p>
<h3 id="纯函数-pure-functions"><a href="#纯函数-pure-functions" class="headerlink" title="纯函数(pure functions)"></a>纯函数(<code>pure functions</code>)</h3><p>可以声明函数为<code>pure</code>，在这种情况下，它们承诺不读取或修改状态。</p>
<p>除了上面解释的状态修改语句列表之外，以下内容被认为是从状态中读取的：</p>
<ul>
<li>从状态变量读取。</li>
<li>访问<code>this.balance</code>或<code>&lt;address&gt;.balance</code>。</li>
<li>访问任何成员<code>block</code>，<code>tx</code>，<code>msg</code>（<code>msg.sig</code>和<code>msg.data</code>除外）。</li>
<li>调用任何未标记为<code>pure</code>的方法。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">        return a * (b + 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:#6ab0de">注意: 如果使用无效的显式类型转换，那么即使pure调用了一个函数，状态修改也是可能被访问的。您可以切换编译器在调用此类函数时使用<code>STATICCALL</code>，从而通过添加<code>pragma experimental &quot;v0.5.0&quot;;</code>来防止修改EVM级别的状态。</b></p>
<p><b style="color:#6ab0de">警告: 不可能阻止函数读取EVM级别的状态，只能防止它们写入状态（只有<code>view</code>能在EVM级别执行，<code>pure</code>不能）。</b></p>
<p><b style="color:#6ab0de">警告: 在版本0.4.17之前，编译器没有强制要求<code>pure</code>不读状态。</b></p>
<h3 id="fallback方法"><a href="#fallback方法" class="headerlink" title="fallback方法"></a>fallback方法</h3><p>我觉得应该在这里插入一个真实项目的示例，这样才能理解这篇的知识：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @dev fallback function ***DO NOT OVERRIDE***</span><br><span class="line">*/</span><br><span class="line">function () external payable &#123;</span><br><span class="line">    deposit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">合约可以有一个未命名的方法。这个方法不能有参数，也不能返回任何东西。如果没有其他函数与给定的函数标识符匹配（或者根本没有提供数据），它将在对合约的调用中执行。</b></p>
<p><b style="color:red">此外，只要合约收到普通以太网币（无数据），就会执行此方法。另外，为了接收以太币，必须标记回退功能payable。如果不存在此类功能，则合约无法通过正常交易接收以太币。</b></p>
<p>在最坏的情况下，fallback方法只能依靠2300gas（例如使用发送或传输以太币时使用），除了基本日志记录以外，没有太多空间来执行其他操作。以下操作将消耗比2300gas津贴更多的gas：</p>
<ul>
<li>写入存储（<code>storage</code>）</li>
<li>创建合约</li>
<li>调用消耗大量gas的外部方法</li>
<li>发送以太币</li>
</ul>
<p>像任何方法一样，只要给足够的gas，fallback方法就可以执行复杂的操作。</p>
<p><b style="color:#6ab0de">注意：即使fallback函数不能有参数，它仍然可以使用<code>msg.data</code>来检索随该调用提供的任何有效内容。</b></p>
<p><b style="color:#6ab0de">警告: 直接接收Ether的合约（没有函数调用，即使用send或transfer）但没有定义fallback函数会抛出异常，发回Ether（这在Solidity v0.4.0之前是不同的）。所以如果你想让你的合约接收Ether，你必须实现一个fallback方法。</b></p>
<p><b style="color:#6ab0de">警告：没有<code>payable</code>,<code>fallback</code>方法的合约可以作为coinbase交易（矿工挖矿奖励）的接收者或作为<code>selfdestruct</code>的目的地接收以太币。</b><br><b style="color:red">合约不能对这种以太币传输作出反应，因此也不能拒绝它们。这是EVM的设计选择，而且Solidity无法解决这个问题。</b><br><b style="color:#6ab0de">这也意味着<code>this.balance</code>可以高于合约中实施的一些账务计算的总和（即，具有在fallback函数中更新的计数器）。（这个就是在某些条件下转入的以太币，fallback函数不被执行，导致账户实际的值与你在合约中计算的值不一致的问题。）</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // This function is called for all messages sent to</span><br><span class="line">    // this contract (there is no other function).</span><br><span class="line">    // Sending Ether to this contract will cause an exception,</span><br><span class="line">    // because the fallback function does not have the `payable`</span><br><span class="line">    // modifier.</span><br><span class="line">    function() public &#123; x = 1; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// This contract keeps all Ether sent to it with no way</span><br><span class="line">// to get it back.</span><br><span class="line">contract Sink &#123;</span><br><span class="line">    function() public payable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    function callTest(Test test) public &#123;</span><br><span class="line">        test.call(0xabcdef01); // hash does not exist</span><br><span class="line">        // results in test.x becoming == 1.</span><br><span class="line"></span><br><span class="line">        // The following will not compile, but even</span><br><span class="line">        // if someone sends ether to that contract,</span><br><span class="line">        // the transaction will fail and reject the</span><br><span class="line">        // Ether.</span><br><span class="line">        //test.send(2 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>合约可以具有多个具有相同名称但具有不同参数的函数。这也适用于继承功能。以下示例显示了合约<code>A</code>范围内的函数重载<code>f</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint _in) public pure returns (uint out) &#123;</span><br><span class="line">        out = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint _in, bytes32 _key) public pure returns (uint out) &#123;</span><br><span class="line">        out = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数重载也存在于外部接口中。如果两个外部可见函数的Solidity类型不同而不是它们的外部类型不同，这是错误的(返回的类型一定要相同)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码不会被编译</span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(B _in) public pure returns (B out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(address _in) public pure returns (address out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个重载函数<code>f</code>最终都会接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p>
<h4 id="重载解析和参数匹配"><a href="#重载解析和参数匹配" class="headerlink" title="重载解析和参数匹配"></a>重载解析和参数匹配</h4><p><b style="color:blue">通过将当前作用域中的函数声明与函数调用中提供的参数进行匹配来选择重载函数。如果所有参数都可以隐式转换为预期类型，则函数被选为超载候选。如果没有确切的一个候选人，则解决失败。</b></p>
<p>注意: 重载解析不考虑返回参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">调用<code>f(50)</code>会创建一个类型错误，因为250可以隐式转换为<code>uint8</code> 和<code>uint256</code>类型。另一方面<code>f(256)</code>将解决<code>f(uint256)</code>重载，因为256不能隐式转换为uint8。</b></p>
<h2 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h2><p>事件允许方便地使用EVM日志记录工具，而后者又可用于在用于监听这些事件的dapp的用户界面中“调用”JavaScript回调。</p>
<p><b style="color:blue">Event是可继承的合约成员。当它们被调用时，它们会在交易日志中(区块链中的特殊数据结构)存储参数</b>。这些日志与合约的地址相关联，日志将被并入区块链并停留在区块链的可访问区块中（Frontier和Homestead这个永远是这样的，但这可能随着Serenity发布而改变）。<b style="color:red">日志和事件数据不能从合约内访问（甚至不能从创建它们的合约中访问）</b>。</p>
<p><b style="color:red">可以使用日志的SPV证明，因此如果外部实体提供有这种证明的合约，它可以检查日志是否确实存在于区块链中。但请注意，必须提供区块头，因为合约只能看到最后的256个区块的hash。</b></p>
<p><b style="color:blue">最多三个参数可以接收<code>indexed</code>属性，将导致搜索各个参数找到<code>indexed</code>：可以用户界面中筛选索引参数的特定值。</b> <b style="color:red">（其实就是说，参数是排序的，根据索引可以取得参数，然后指定该参数的过滤条件以达到筛选的功能,可以看一下下面我从别的地方拷贝来的代码，你就能明白一些，当然你如果能查看web3的源码，理解会更深入，其实以我的理解就是日志加查询索引而已！）。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);</span><br></pre></td></tr></table></figure>
<p>如果数组（包括string和bytes）用作索引参数，则其Keccak-256散列值将作为主题存储。</p>
<p><b style="color:red">除了用<code>anonymous</code>说明符声明事件之外，事件签名的散列是其中一个主题。这意味着无法通过名称筛选特定的匿名事件。</b></p>
<p><b style="color:red">所有非索引参数都将存储在日志的数据部分中。</b></p>
<p>注意: 索引参数不会自行存储。您只能搜索这些值，但不可能自行检索这些值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // Events are emitted using `emit`, followed by</span><br><span class="line">        // the name of the event and the arguments</span><br><span class="line">        // (if any) in parentheses. Any such invocation</span><br><span class="line">        // (even deeply nested) can be detected from</span><br><span class="line">        // the JavaScript API by filtering for `Deposit`.</span><br><span class="line">        emit Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript API中的用法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// watch for changes</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // result will contain various information</span><br><span class="line">    // including the argumets given to the `Deposit`</span><br><span class="line">    // call.</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Or pass a callback to start watching immediately</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="日志的低级接口"><a href="#日志的低级接口" class="headerlink" title="日志的低级接口"></a>日志的低级接口</h3><p>另外，也可以通过函数来访问低层接口的日志机制<code>log0</code>，<code>log1</code>，<code>log2</code>，<code>log3</code>和<code>log4</code>。<code>logi</code>接受<code>i+1</code>的bytes32类型参数，其中第一个参数将用于日志的数据部分，其他参数用作主题。上面的事件调用可以按照与上述相同的方式执行，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public payable &#123;</span><br><span class="line">        bytes32 _id = 0x420042;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>长十六进制数等于<code>keccak256(&quot;Deposit(address,hash256,uint256)&quot;)</code>, 事件的签名。</p>
<h3 id="了解事件的其他资源"><a href="#了解事件的其他资源" class="headerlink" title="了解事件的其他资源"></a>了解事件的其他资源</h3><p><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">Javascript文档</a><br><a href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol" target="_blank" rel="noopener">事件的示例用法</a><br><a href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js" target="_blank" rel="noopener">如何在js中访问它们</a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><b style="color:red">通过复制包括多态性的代码，Solidity支持多重继承。</b></p>
<p>所有的函数调用都是虚拟的，这意味着调用了大多数派生函数，除非明确给出了合约名称。</p>
<p>当合约从多个合约中继承时，只会在区块链上创建单个合约，并将所有基础合约中的代码复制到创建的合约中。</p>
<p>一般继承系统与Python非常相似 ，特别是多继承。</p>
<p>以下示例中给出了详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use `is` to derive from another contract. Derived</span><br><span class="line">// contracts can access all non-private members including</span><br><span class="line">// internal functions and state variables. These cannot be</span><br><span class="line">// accessed externally via `this`, though.</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// These abstract contracts are only provided to make the</span><br><span class="line">// interface known to the compiler. Note the function</span><br><span class="line">// without body. If a contract does not implement all</span><br><span class="line">// functions it can only be used as an interface.</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="line">// also a base class of `mortal`, yet there is only a single</span><br><span class="line">// instance of `owned` (as for virtual inheritance in C++).</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Functions can be overridden by another function with the same name and</span><br><span class="line">    // the same number/types of inputs.  If the overriding function has different</span><br><span class="line">    // types of output parameters, that causes an error.</span><br><span class="line">    // Both local and message-based function calls take these overrides</span><br><span class="line">    // into account.</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // It is still possible to call a specific</span><br><span class="line">            // overridden function.</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If a constructor takes an argument, it needs to be</span><br><span class="line">// provided in the header (or modifier-invocation-style at</span><br><span class="line">// the constructor of the derived contract (see below)).</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">请注意，上面我们调用<code>mortal.kill()</code>“转发”销毁请求。这样做的方式是有问题的，如以下示例所示</b>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Final.kill()</code>的调用将会调用<code>Base2.kill</code>称为最派生的覆盖，但这个函数将绕过<code>Base1.kill</code>，主要是因为它甚至不知道 <code>Base1</code>。解决这个问题的方法是使用super：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">如果<code>Base2</code>调用<code>super</code>的函数，它不会简单地在其一个基础合约上调用该函数。相反，它在最终的继承图中的下一个基础合约上调用该函数，因此它会调用<code>Base1.kill()</code>（请注意，最终的继承序列是 - 从派生最多的合约开始：<code>Final</code>，<code>Base2</code>，<code>Base1</code>，<code>mortal</code>，<code>owned</code>）。使用<code>super</code>时调用的实际函数在使用它的类的上下文中是未知的，尽管其类型是已知的。这对于普通的虚拟方法查找是相似的。</b></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一个可选函数，其名称与创建合约时执行的合约名称相同。<b style="color:red">构造函数可以是public或者internal</b>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint public a;</span><br><span class="line"></span><br><span class="line">    function A(uint _a) internal &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A(1) &#123;</span><br><span class="line">    function B() public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置构造函数为internal会导致合约被标记为<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#abstract-contract" target="_blank" rel="noopener">抽象</a>。</p>
<h3 id="基础构造函数的参数"><a href="#基础构造函数的参数" class="headerlink" title="基础构造函数的参数"></a>基础构造函数的参数</h3><p>派生合约需要提供基础构造函数所需的所有参数。这可以通过两种方式完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种方法直接在继承列表（<code>is Base(7)</code>）中。另一种方式是调用一个修饰符作为派生构造函数（<code>Base(_y * _y)</code>）的头部分的一部分。如果构造函数参数是一个常量来定义合约的行为或描述它，第一种实现方法更为方便。如果基础的构造函数参数取决于衍生合约的构造函数参数，则必须使用第二种方法。<b style="color:red">如果像在这个简单的例子中一样，这两处都用到了，那么修饰语风格的参数优先。</b></p>
<h3 id="多重继承和线性化"><a href="#多重继承和线性化" class="headerlink" title="多重继承和线性化"></a>多重继承和线性化</h3><p><b style="color:blue">允许多重继承的语言必须处理几个问题。一个是<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">钻石问题</a>。Solidity遵循Python的方式，并使用<a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="noopener">“C3线性化”</a>来强制基类的DAG中的特定顺序。这导致单调性的理想特性，但不允许某些继承图。特别是，在指令<code>is</code>中给出基类的顺序很重要。在下面的代码中，Solidity会给出错误<code>Linearization of inheritance graph impossible</code>。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这将不会编译</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其原因是<code>C</code>请求<code>X</code>覆盖<code>A</code> （通过<code>A,X</code>按此顺序），但<code>A</code>本身请求覆盖，这是无法解决的矛盾。</p>
<p><b style="color:red">要记住的一个简单规则是按照“most base-like”到“most derived”的顺序​​指定基类。</b></p>
<h3 id="继承不同类型的同名成员"><a href="#继承不同类型的同名成员" class="headerlink" title="继承不同类型的同名成员"></a>继承不同类型的同名成员</h3><p><b style="color:red">当继承导致具有相同名称的函数和修饰符的合约时，它被视为错误。这个错误也是由同名的事件和修饰符以及同名的函数和事件产生的。作为一个例外，状态变量getter可以覆盖公共函数。</b></p>
<h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p><b style="color:red">如果至少其中一个方法缺少如下例所示的实现（注意函数声明标头以<code>;</code>终止），则合约被标记为抽象</b>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些合约不能被编译（即使它们包含已实现的功能以及未实现的功能），但它们可以用作基本合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32) &#123; return &quot;miaow&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果合约继承自抽象合约，并且没有通过覆盖来实现所有未实现的功能，它本身就是抽象的。</p>
<p>请注意，没有实现的函数与<a href="https://solidity.readthedocs.io/en/v0.4.21/types.html#function-types" target="_blank" rel="noopener">函数类型</a>不同，即使它们的语法看起来非常相似。</p>
<p>没有实现的函数示​​例（函数声明）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(address) external returns (address);</span><br></pre></td></tr></table></figure></p>
<p>函数类型的示例（变量声明，其中变量是<code>function</code>类型的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(address) external returns (address) foo;</span><br></pre></td></tr></table></figure></p>
<p>抽象合约将合约的定义与其实现分离开来，从而提供更好的可扩展性和自我文档，并促进像Template方法和消除代码重复这样的模式。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><b style="color:red">接口类似于抽象合约，但它们不能实现任何方法。还有其他限制</b>：</p>
<ol>
<li>无法继承其他合约或接口。</li>
<li>无法定义构造函数。</li>
<li>无法定义变量。</li>
<li>无法定义struct。</li>
<li>无法定义枚举。</li>
</ol>
<p>这些限制中的一些可能会在未来取消。</p>
<p><b style="color:red">接口基本上仅限于合约ABI可以表示的内容，并且ABI和接口之间的转换应该是可能的，而不会丢失任何信息</b>。</p>
<p>接口由关键字<code>interface</code>表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    function transfer(address recipient, uint amount) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合约可以继承接口，因为它们会继承其他合约。</p>
<h2 id="库-Libraries"><a href="#库-Libraries" class="headerlink" title="库 Libraries"></a>库 Libraries</h2><p>库与合约类似，但其用途是它们只在特定地址部署一次，并使用EVM 的<code>DELEGATECALL</code> （<code>CALLCODE</code>直到Homestead）方法重用其代码。这意味着如果调用库函数，它们的代码将在调用合约的上下文中执行，即this指向调用合约，特别是可以访问来自调用合约的存储（storage）。由于库是一段独立的源代码，因此它只能访问调用协定的状态变量（如果它们被明确提供，否则无法命名它们）。如果库函数<code>DELEGATECALL</code>不修改状态（即，如果它们是<code>view</code>或<code>pure</code>方法），则只能直接调用库函数（即不使用<code>DELEGATECALL</code>），因为库被认为是无状态的。特别是，除非Solidity的类型系统被规避，否则不可能破坏库。</p>
<p>库可以被视为使用它们的合约的隐含基础合约。它们不会在继承层次结构中显式可见，但对库函数的调用看起来就像调用显式基础合约的函数（<code>L.f()</code>如果<code>L</code>是库的名称）。此外，<code>internal</code>库函数在所有合约中都是可见的，就像库是基础合约一样。当然，对内部函数的调用使用内部调用合约，这意味着可以传递所有内部类型，并且内存类型将通过引用传递并且不会被复制。为了在EVM中实现这一点，内部库函数和其中调用的所有函数的代码将在编译时拉入到调用合约中，并且JUMP将使用常规调用而不是<code>DELEGATECALL</code>。</p>
<p>以下示例说明了如何使用库（但请务必查看<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#using-for" target="_blank" rel="noopener">使用for</a>获取更高级的示例来实现Set）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // We define a new struct datatype that will be used to</span><br><span class="line">  // hold its data in the calling contract.</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // Note that the first parameter is of type &quot;storage</span><br><span class="line">  // reference&quot; and thus only its storage address and not</span><br><span class="line">  // its contents is passed as part of the call.  This is a</span><br><span class="line">  // special feature of library functions.  It is idiomatic</span><br><span class="line">  // to call the first parameter `self`, if the function can</span><br><span class="line">  // be seen as a method of that object.</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // The library functions can be called without a</span><br><span class="line">        // specific instance of the library, since the</span><br><span class="line">        // &quot;instance&quot; will be the current contract.</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // In this contract, we can also directly access knownValues.flags, if we want.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，您不必遵循这种方式来使用库：它们也可以在不定义结构数据类型的情况下使用。函数也可以在没有任何storage引用参数的情况下工作，并且它们可以具有多个storage引用参数并且在任何位置。</p>
<p><b style="color:blue">所有对<code>Set.contains</code>，<code>Set.insert</code>和<code>Set.remove</code>的调用都被编译为调用（<code>DELEGATECALL</code>）到外部合约/库</b>。<b style="color:blue">如果使用库，请注意执行实际的外部函数调用</b>。 <code>msg.sender</code>，<code>msg.value</code>和<code>this</code>在此调用中将保留它们的值，虽然（Homestead之前，因为使用的<code>CALLCODE</code>，<code>msg.sender</code>和<code>msg.value</code>改变了）。</p>
<p>下面的例子显示了如何在库中使用内存类型和内部函数，以实现自定义类型，而无需外部函数调用的开销：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // too bad, we have to add a limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于编译器无法知道库的部署位置，因此必须通过链接器将这些地址填充到最终的字节码中（请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/using-the-compiler.html#commandline-compiler" target="_blank" rel="noopener">使用命令行编译器</a>了解如何使用命令行编译器进行链接）。如果地址不作为编译器的参数给出，编译的十六进制代码将包含表单的占位符<code>__Set______</code>（其中 Set是库的名称）。地址可以通过用库合约地址的十六进制编码来手动填充替换所有这40个符号。</p>
<p>与合约相比，库的限制：</p>
<ul>
<li>没有状态变量</li>
<li>不能继承，也不能被继承</li>
<li>无法接收以太币</li>
</ul>
<p>（这些可能会在之后的版本解除。）</p>
<h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护</h3><p>正如介绍中提到，如果某个库的代码被执行应使用<code>CALL</code>，而不是一个<code>DELEGATECALL</code>或<code>CALLCODE</code>，它会恢复，除非<code>view</code>或<code>pure</code>函数被调用。</p>
<p><b style="color:red">EVM不提供直接的方式来检测合约是否被<code>CALL</code>调用，但合约可以使用<code>ADDRESS</code>操作码来找出当前正在运行的“哪里”。生成的代码将此地址与创建时使用的地址进行比较，以确定调用模式。</b></p>
<p><b style="color:red">更具体地说，库的运行时代码始终以一个推送指令开始，该指令在编译时为20个字节的零。部署代码运行时，该常量在内存中被当前地址替换，并且此修改的代码存储在合约中。在运行时，这会导致部署时间地址成为第一个被压入堆栈的常量，并且调度程序代码会将当前地址与此常量进行比较，以查看任何非<code>view</code>和非<code>pure</code>函数。</b></p>
<h2 id="using-for语句"><a href="#using-for语句" class="headerlink" title="using for语句"></a>using for语句</h2><p>该指令<code>using A for B;</code>可用于将库函数（从库<code>A</code>中）附加到任何类型（<code>B</code>）。<b style="color:red">这些函数将接收它们被调用的对象作为它们的第一个参数（如Python中的变量）</b>。</p>
<p><code>using A for *;</code>其效果是库<code>A</code>中的函数被附加到任何类型。</p>
<p>在这两种情况下，都会附加所有函数，即使是第一个参数的类型与对象类型不匹配的函数。在函数被调用的地方检查类型，并执行函数重载解析。</p>
<p><code>using A for B;</code>该指令对于当前作用域是有效的，现在仅限于一个合约，但稍后将被提升到全局作用域，这样通过包含一个模块，其数据类型（包括库函数）可用，而无需添加进一步的代码。</p>
<p>让我们以这种方式重写库中的设置示例 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// This is the same code as before, just without comments</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // this is the crucial change</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以这种方式扩展基本类型也是可能的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return uint(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint _old, uint _new) public &#123;</span><br><span class="line">        // This performs the library function call</span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        if (index == uint(-1))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        else</span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">请注意，所有库调用都是实际的EVM函数调用。这意味着如果您传递内存或值类型，将执行副本，甚至是<code>self</code>变量。唯一不执行复制的情况是使用storage引用变量。</b></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/solidity/" rel="tag"># solidity</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/03/blockchain/solidity表达式和控制结构/" rel="next" title="solidity表达式和控制结构">
                <i class="fa fa-chevron-left"></i> solidity表达式和控制结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/04/blockchain/solidity汇编/" rel="prev" title="solidity汇编">
                solidity汇编 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">80</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">82</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建合约"><span class="nav-number">1.</span> <span class="nav-text">创建合约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性和Getters"><span class="nav-number">2.</span> <span class="nav-text">可见性和Getters</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Getter函数"><span class="nav-number">2.1.</span> <span class="nav-text">Getter函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法修饰符"><span class="nav-number">3.</span> <span class="nav-text">方法修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常量状态变量"><span class="nav-number">4.</span> <span class="nav-text">常量状态变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法（函数）"><span class="nav-number">5.</span> <span class="nav-text">方法（函数）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看方法"><span class="nav-number">5.1.</span> <span class="nav-text">查看方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯函数-pure-functions"><span class="nav-number">5.2.</span> <span class="nav-text">纯函数(pure functions)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fallback方法"><span class="nav-number">5.3.</span> <span class="nav-text">fallback方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数重载"><span class="nav-number">5.4.</span> <span class="nav-text">函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载解析和参数匹配"><span class="nav-number">5.4.1.</span> <span class="nav-text">重载解析和参数匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件-Event"><span class="nav-number">6.</span> <span class="nav-text">事件 Event</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#日志的低级接口"><span class="nav-number">6.1.</span> <span class="nav-text">日志的低级接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#了解事件的其他资源"><span class="nav-number">6.2.</span> <span class="nav-text">了解事件的其他资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">7.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">7.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础构造函数的参数"><span class="nav-number">7.2.</span> <span class="nav-text">基础构造函数的参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承和线性化"><span class="nav-number">7.3.</span> <span class="nav-text">多重继承和线性化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承不同类型的同名成员"><span class="nav-number">7.4.</span> <span class="nav-text">继承不同类型的同名成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象合约"><span class="nav-number">8.</span> <span class="nav-text">抽象合约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">9.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#库-Libraries"><span class="nav-number">10.</span> <span class="nav-text">库 Libraries</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#库的调用保护"><span class="nav-number">10.1.</span> <span class="nav-text">库的调用保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#using-for语句"><span class="nav-number">11.</span> <span class="nav-text">using for语句</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
