<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="solidity," />


<meta name="description" content="本文是基于solidity官方文档v0.4.21. 输入参数和输出参数与Javascript一样，方法可能会将参数作为输入; 不像Javascript和C中，它们也可以返回任意数量的参数作为输出。 输入参数输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名称。例如，假设我们希望我们的合约接受一种具有两个整数的外部调用，我们会写如下所示的内容：1234567pragma solidi">
<meta name="keywords" content="solidity">
<meta property="og:type" content="article">
<meta property="og:title" content="solidity表达式和控制结构">
<meta property="og:url" content="http://cordate.github.io/2018/04/03/blockchain/solidity表达式和控制结构/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="本文是基于solidity官方文档v0.4.21. 输入参数和输出参数与Javascript一样，方法可能会将参数作为输入; 不像Javascript和C中，它们也可以返回任意数量的参数作为输出。 输入参数输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名称。例如，假设我们希望我们的合约接受一种具有两个整数的外部调用，我们会写如下所示的内容：1234567pragma solidi">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-04-08T03:30:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="solidity表达式和控制结构">
<meta name="twitter:description" content="本文是基于solidity官方文档v0.4.21. 输入参数和输出参数与Javascript一样，方法可能会将参数作为输入; 不像Javascript和C中，它们也可以返回任意数量的参数作为输出。 输入参数输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名称。例如，假设我们希望我们的合约接受一种具有两个整数的外部调用，我们会写如下所示的内容：1234567pragma solidi">






  <link rel="canonical" href="http://cordate.github.io/2018/04/03/blockchain/solidity表达式和控制结构/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>solidity表达式和控制结构 | 柳絮纷飞</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/03/blockchain/solidity表达式和控制结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">solidity表达式和控制结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T20:10:18+08:00">2018-04-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<h2 id="输入参数和输出参数"><a href="#输入参数和输出参数" class="headerlink" title="输入参数和输出参数"></a>输入参数和输出参数</h2><p>与Javascript一样，方法可能会将参数作为输入; 不像Javascript和C中，它们也可以返回任意数量的参数作为输出。</p>
<h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名称。例如，假设我们希望我们的合约接受一种具有两个整数的外部调用，我们会写如下所示的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function taker(uint _a, uint _b) public pure &#123;</span><br><span class="line">        // do something with _a and _b.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数可以在returns关键字后用相同的语法声明 。例如，假设我们希望返回两个结果：两个给定整数的和以及乘积，那么我们会写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function arithmetics(uint _a, uint _b)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint o_sum, uint o_product)</span><br><span class="line">    &#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出参数的名称可以省略。输出值也可以使用return语句指定。该return语句还能够返回多个值，请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#multi-return" target="_blank" rel="noopener">返回多个值</a>。返回参数被初始化为零; 如果他们没有明确设定，他们将保持为零。</p>
<p><b style="color:blue">输入参数和输出参数可以用作函数体中的表达式。在那里，它们也可以在赋值语句的左侧使用。</b></p>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>除了<code>switch</code>和<code>goto</code>之外，来自JavaScript的大部分控制结构都可以使用。所以有：<code>if</code>，<code>else</code>，<code>while</code>，<code>do</code>，<code>for</code>，<code>break</code>，<code>continue</code>，<code>return</code>，<code>?:</code>，这些与C或JavaScript已知的常规语义一样。</p>
<p>条件语句不能省略括号，但可以在单个语句的主体周围省略花括号。</p>
<p>请注意，solidity没有有从非布尔类型转换为Boolean类型的方式，因为<code>if (1) { ... }</code>在C和JavaScript中是可以转化，但是不是有效的solidity语句。</p>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>当函数有多个输出参数时，<code>return (v0, v1, ..., vn)</code>可以返回多个值。组件的数量必须与输出参数的数量相同。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>可以直接（“internally”）调用当前合约的方法，也可以递归地调用，如在这个无意义的示例中所见：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g(uint a) public pure returns (uint ret) &#123; return f(); &#125;</span><br><span class="line">    function f() internal pure returns (uint ret) &#123; return g(7) + f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">这些函数调用被转换为EVM内部的简单跳转。这样做的效果是当前内存不会被清除，即将内存引用传递给内部调用的函数非常有效。只有同一合约的方法可以在内部调用。</b></p>
<h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>表达式<code>this.g(8);</code>和<code>c.g(2);</code>（其中<code>c</code>是合约实例）也是有效的函数调用，但是这次函数将通过消息调用而不是直接通过跳转被称为“externally”。<b style="color:red">请注意函数调用this不能在构造函数中使用，因为实际合约尚未创建。</b></p>
<p><b style="color:red">其他合约的方法必须从外部调用。对于外部调用，所有方法参数都必须复制到内存中。</b></p>
<p>当调用其他合约的方法，调用发送wei的数量和gas可以用特殊的选项来指定<code>.value()</code>和<code>.gas()</code>分别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修饰符<code>payable</code>必须用于<code>info</code>，否则，<code>.value()</code> 选项将不可用。</p>
<p>请注意，该表达式<code>InfoFeed(addr)</code>执行显式类型转换，指出“我们知道给定地址处的合约类型是InfoFeed”，并且这不会执行构造函数。<b style="color:red">显式类型转换必须谨慎处理。不要在不确定其类型的合同上调用函数。</b></p>
<p>我们也可以直接使用<code>function setFeed(InfoFeed _feed) { feed = _feed; }</code>。要小心这样一个事实，即 <code>feed.info.value(10).gas(800)</code>只有（本地）设置函数调用发送的ether值和gas的数量，并且只有最后的括号才能执行实际的调用。</p>
<p>如果被调用合约不存在（在账户不包含代码的意义上），或者被调用合约本身抛出异常或缺少gas，函数调用会导致异常。</p>
<p><b style="color:#6ab0de">警告：与其他合约的任何交互都会产生潜在的危险，特别是如果合约的源代码未提前知晓。目前的合约将控制权移交给被调用合约，这可能会做任何事情。即使被调用合约继承自已知的父合约，继承合约也只需要具有正确的接口。然而，合约的执行可能是完全随意的，因此构成危险。另外，要做好准备，以防其在您的系统的在其他合约中调用，甚至在第一次调用返回之前回到被调用合约中。这意味着被调用合约可以通过其方法改变主动调用合约的状态变量。例如，以一种方式编写你的方法。</b></p>
<h3 id="命名调用和匿名方法参数"><a href="#命名调用和匿名方法参数" class="headerlink" title="命名调用和匿名方法参数"></a>命名调用和匿名方法参数</h3><p><b style="color:blue">函数调用参数也可以按名称的顺序给出，如果它们被包含在<code>{}</code>内，就可以在下面的例子中看到。参数列表必须按名称与函数声明中的参数列表重合，但可以按任意顺序排列。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint key, uint value) public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // named arguments</span><br><span class="line">        f(&#123;value: 2, key: 3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="省略方法参数名称"><a href="#省略方法参数名称" class="headerlink" title="省略方法参数名称"></a>省略方法参数名称</h3><p><b style="color:blue">未使用的参数名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问。</b><b style="color:red">注意：具名返回参数是可以通过名称直接访问的。这个也是solidity语言和其它语言的一个很大不同之处。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // omitted name for parameter</span><br><span class="line">    function func(uint k, uint) public pure returns(uint) &#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通过new创建合约"><a href="#通过new创建合约" class="headerlink" title="通过new创建合约"></a>通过new创建合约</h2><p>合约可以使用new关键字创建新合约。创建合约的完整代码必须事先知道，因此递归创建依赖关系是不可能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = new D(4); // will be executed as part of C&apos;s constructor</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">        // Send ether along with the creation</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">如示例中所示，可以在创建<code>D</code>使用该<code>.value()</code>选项的实例时转发Ether ，但不可能限制gas的数量</b>。如果创建失败（由于堆栈外，没有足够的余额或其他问题），会引发异常。</p>
<h2 id="表达式评估顺序"><a href="#表达式评估顺序" class="headerlink" title="表达式评估顺序"></a>表达式评估顺序</h2><p><b style="color:blue">表达式的评估顺序没有被指定（更正式地说，表达式树中一个节点的子节点的评估顺序没有被指定，但是它们当然是在节点本身之前被评估的）。只能保证语句按顺序执行，布尔表达式的短路完成。有关更多信息，请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html#order" target="_blank" rel="noopener">操作符的优先顺序</a>。</b></p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="解构赋值和返回多值"><a href="#解构赋值和返回多值" class="headerlink" title="解构赋值和返回多值"></a>解构赋值和返回多值</h3><p><b style="color:red">Solidity内部允许元组类型，即在编译时大小为常量的可能不同类型的对象列表。这些元组可以同时返回多个值，并同时将它们分配给多个变量（或一般的LValues）</b>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br><span class="line">        var (x, b, y) = f();</span><br><span class="line">        // Assigns to a pre-existing variable.</span><br><span class="line">        (x, y) = (2, 7);</span><br><span class="line">        // Common trick to swap values -- does not work for non-value storage types.</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        // Components can be left out (also for variable declarations).</span><br><span class="line">        // If the tuple ends in an empty component,</span><br><span class="line">        // the rest of the values are discarded.</span><br><span class="line">        (data.length,) = f(); // Sets the length to 7</span><br><span class="line">        // The same can be done on the left side.</span><br><span class="line">        // If the tuple begins in an empty component, the beginning values are discarded.</span><br><span class="line">        (,data[3]) = f(); // Sets data[3] to 2</span><br><span class="line">        // Components can only be left out at the left-hand-side of assignments, with</span><br><span class="line">        // one exception:</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        // (1,) is the only way to specify a 1-component tuple, because (1) is</span><br><span class="line">        // equivalent to 1.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Arrays和Structs的复杂度"><a href="#Arrays和Structs的复杂度" class="headerlink" title="Arrays和Structs的复杂度"></a>Arrays和Structs的复杂度</h3><p>赋值语义对于像数组和结构体这样的非值类型来说更复杂一些。<b style="color:red">赋值给状态变量总是创建一个独立的副本。另一方面，赋值给局部变量只为基本类型创建独立副本，即适合32个字节的静态类型。</b><b style="color:blue">如果结构或数组（包括bytes和string）从状态变量分配给局部变量，则局部变量保存对原始状态变量的引用。对局部变量的二次赋值不会修改状态，只会改变引用。</b><b style="color:red">赋值给局部变量的成员（或元素）会改变状态。(这个意思应该是指改变arrays和struct局部变量中的某一个属相，这个肯定是改变值的)</b></p>
<h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h2><p>被声明的变量将具有初始缺省值，其字节表示全部为零。变量的“默认值”是任何类型的典型“零状态”。例如，bool is 的默认值false。uint或int类型的默认值是0。对于静态大小的数组和bytes1对bytes32，每个单独的元件将被初始化为对应于其类型的默认值。最后，对于动态大小的数组，bytes和string，默认值是一个空数组或字符串。</p>
<p><b style="color:red">在方法中的任何位置声明的变量将在整个方法的范围内，而不管它在哪里声明（这将很快发生变化，请参见下文）</b>。发生这种情况是因为Solidity从JavaScript继承了它的范围规则。这与许多语言形成对比，在这些语言中变量只在声明块结束时才声明变量。因此，下面的代码是非法的并且会导致编译器抛出一个错误：<code>Identifier already declared</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 这个不会编译的</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract ScopingErrors &#123;</span><br><span class="line">    function scoping() public &#123;</span><br><span class="line">        uint i = 0;</span><br><span class="line"></span><br><span class="line">        while (i++ &lt; 1) &#123;</span><br><span class="line">            uint same1 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i++ &lt; 2) &#123;</span><br><span class="line">            uint same1 = 0;// Illegal, second declaration of same1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function minimalScoping() public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;// Illegal, second declaration of same2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function forLoopScoping() public &#123;</span><br><span class="line">        for (uint same3 = 0; same3 &lt; 1; same3++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (uint same3 = 0; same3 &lt; 1; same3++) &#123;// Illegal, second declaration of same3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">除此之外，如果声明了一个变量，它将在函数的开头初始化为其默认值。因此，尽管写得不好，但下面的代码是合法的：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function foo() public pure returns (uint) &#123;</span><br><span class="line">        // baz is implicitly initialized as 0</span><br><span class="line">        uint bar = 5;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">            bar += baz;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint baz = 10;// never executes</span><br><span class="line">        &#125;</span><br><span class="line">        return bar;// returns 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="0-5-0版开始的作用域"><a href="#0-5-0版开始的作用域" class="headerlink" title="0.5.0版开始的作用域"></a><b style="color:red">0.5.0版开始的作用域</b></h3><p>从版本0.5.0开始，Solidity将更改为更广泛的C99（以及许多其他语言）的范围规则：变量从声明后的正确位置直到块的结尾才可见。<b style="color:blue">作为这条规则的一个例外，在for循环的初始化部分声明的变量只有在for循环结束之前才可见。</b></p>
<p><b style="color:blue">在代码块之外声明的变量和其他项目，例如函数，合约，用户定义的类型等，不会更改其作用域行为。这意味着您可以在声明它们之前使用状态变量并递归调用函数。</b></p>
<p>这些规则现在已经作为实验性特性引入。</p>
<p>因此，下面的示例将在没有警告的情况下编译，因为这两个变量具有相同的名称，但是不相交的范围。<b style="color:red">在非0.5.0模式下，它们具有相同的作用域（函数minimalScoping），因此它不会在那里编译。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function minimalScoping() pure public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为C99范围规则的一个特殊示例，请注意，在下面的第一个赋值中，<code>x</code>实际上将分配外部变量而不是内部变量。在任何情况下，您都会收到有关外部变量被覆盖的警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() pure public returns (uint) &#123;</span><br><span class="line">        uint x = 1;</span><br><span class="line">        &#123;</span><br><span class="line">            x = 2; // this will assign to the outer variable</span><br><span class="line">            uint x;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; // x has value 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误处理：Assert-Require-Revert和Exceptions"><a href="#错误处理：Assert-Require-Revert和Exceptions" class="headerlink" title="错误处理：Assert, Require, Revert和Exceptions"></a>错误处理：Assert, Require, Revert和Exceptions</h2><p>Solidity使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。如果条件不满足，便利函数<code>assert</code>和<code>require</code>可以用来检查条件并抛出一个异常。<b style="color:red">该<code>assert</code>函数只能用于测试内部错误并检查不变量</b>。<b style="color:red">该require函数应用于确保有效条件（如输入或合同状态变量），或者验证从外部合约调用返回值</b>。如果使用得当，分析工具可以评估您的合约，以确定将失败的条件和方法调用，这个方法调用通过assert方法快速失败。正确运行的代码不应该达到失败的断言语句; 如果发生这种情况，您应该修复合同中的错误。</p>
<p>还有两种其他方式可以触发异常：<b style="color:red">该<code>revert</code>方法可用于标记错误并恢复当前的调用。将来还可能在revert调用中包含有关错误的详细信息。该throw关键字也可以用<code>revert()</code>替代。</b></p>
<p><b style="color:red">注意:从版本0.4.13开始，该throw关键字将被弃用，并将在未来逐步淘汰。</b></p>
<p><b style="color:blue">当子调用中发生异常时，它们会自动“冒泡”（即重新排除异常）。这个规则的例外是send和低级函数call，delegatecall以及callcode - false在发生异常而不是“冒泡”的情况下返回。</b></p>
<p><b style="color:#6ab0de">警告：作为EVM设计的一部分，如果被调用帐户不存在，低级别call，delegatecall和callcode调用将会返回成功。如果需要，必须在调用之前检查是否存在。</b></p>
<p><b style="color:red">捕捉异常尚不可能。</b></p>
<p>在以下示例中，您可以看到如何require轻松检查输入条件以及如何使用assert进行内部错误检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0); // Only allow even numbers</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);</span><br><span class="line">        // Since transfer throws an exception on failure and</span><br><span class="line">        // cannot call back here, there should be no way for us to</span><br><span class="line">        // still have half of the money.</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种<code>assert</code>风格的异常在下列情况下产生的：</p>
<ol>
<li>如果您访问数组的索引太大或是负数（即x[i] 当<code>i &gt;= x.length</code> 或<code>i &lt; 0</code>）。</li>
<li>如果您访问固定长度的bytesN索引太大或负数。</li>
<li>如果除以0或者对0取模。<code>5 / 0</code> 和<code>23 % 0</code></li>
<li>如果你数字移位的位数是负值。</li>
<li>如果你将一个太大或负值的值转换为一个枚举类型。</li>
<li>如果您调用内部函数类型的零初始化变量。</li>
<li>如果您assert使用评估为false的参数进行调用。</li>
</ol>
<p>require风格在以下情况下会生成异常：</p>
<ol>
<li>调用throw方法。</li>
<li>require使用评估为的参数进行调用false。</li>
<li>如果你调用通过消息调用方法，但它不能正常完成（即用完gas，没有匹配的方法，或抛出一个异常本身），当低层次的操作，除了call，send，delegatecall或callcode使用。低级操作不会抛出异常，但会通过返回false来指示失败。</li>
<li>如果您使用new关键字创建合约，但合约创建没有正确完成（请参阅上面有关“未正确完成”的定义）。（比如Contract构造方法中使用this）</li>
<li>如果您针对不包含代码的合约执行外部函数调用。</li>
<li><b style="color:red">如果您的合约通过一个没有payable修饰符的公共函数（包括构造函数和后备函数）接收Ether 。</b></li>
<li><b style="color:red">如果你的合同通过公共的getter函数接收Ether。</b></li>
<li>如果<code>.transfer()</code>调用失败。</li>
</ol>
<p><b style="color:blue">在内部，Solidity对一个require-style异常执行恢复操作（指令<code>0xfd</code>），并执行一个无效操作（指令<code>0xfe</code>）来抛出一个assert-style异常。在这两种情况下，这都会导致EVM恢复对该状态所做的所有更改。恢复的原因是没有安全的方法来继续执行，因为预期的效果没有发生。因为我们想保留交易的原子性，所以最安全的做法是恢复所有更改并使整个交易（或至少是调用）无效</b>。<b style="color:red">请注意，assert样式异常会消耗所有可用于调用的gas，而require风格异常不会消耗Metropolis版本中的任何气体。</b></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/solidity/" rel="tag"># solidity</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/03/blockchain/Solidity单位和全局可用变量/" rel="next" title="Solidity单位和全局可用变量">
                <i class="fa fa-chevron-left"></i> Solidity单位和全局可用变量
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/04/blockchain/solidity合约/" rel="prev" title="solidity合约">
                solidity合约 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">108</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">101</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#输入参数和输出参数"><span class="nav-number">1.</span> <span class="nav-text">输入参数和输出参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入参数"><span class="nav-number">1.1.</span> <span class="nav-text">输入参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出参数"><span class="nav-number">1.2.</span> <span class="nav-text">输出参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制结构"><span class="nav-number">2.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#返回多个值"><span class="nav-number">2.1.</span> <span class="nav-text">返回多个值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数调用"><span class="nav-number">3.</span> <span class="nav-text">函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部函数调用"><span class="nav-number">3.1.</span> <span class="nav-text">内部函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部函数调用"><span class="nav-number">3.2.</span> <span class="nav-text">外部函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名调用和匿名方法参数"><span class="nav-number">3.3.</span> <span class="nav-text">命名调用和匿名方法参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#省略方法参数名称"><span class="nav-number">3.4.</span> <span class="nav-text">省略方法参数名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过new创建合约"><span class="nav-number">4.</span> <span class="nav-text">通过new创建合约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式评估顺序"><span class="nav-number">5.</span> <span class="nav-text">表达式评估顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值"><span class="nav-number">6.</span> <span class="nav-text">赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解构赋值和返回多值"><span class="nav-number">6.1.</span> <span class="nav-text">解构赋值和返回多值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays和Structs的复杂度"><span class="nav-number">6.2.</span> <span class="nav-text">Arrays和Structs的复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域和声明"><span class="nav-number">7.</span> <span class="nav-text">作用域和声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-5-0版开始的作用域"><span class="nav-number">7.1.</span> <span class="nav-text">0.5.0版开始的作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理：Assert-Require-Revert和Exceptions"><span class="nav-number">8.</span> <span class="nav-text">错误处理：Assert, Require, Revert和Exceptions</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
