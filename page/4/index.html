<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/page/4/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/java/Spring循环依赖检查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/java/Spring循环依赖检查/" itemprop="url">Spring循环依赖检查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T15:34:46+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于循环依赖检查，一般地数据结构就是DAG（有向无环图图）。所以在Spring中也是这样去实现的。</p>
<p>在Spring中检查依赖是和注入的方式有很大关系的。</p>
<h2 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h2><p>Spring容器将每一个正在创建的Bean 标识符放在一个“<b style="color:red">当前创建Bean池</b>”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；<b style="color:red">而对于创建完毕的Bean将从“当前创建Bean池”中清除掉</b>。</p>
<h2 id="setter循环依赖"><a href="#setter循环依赖" class="headerlink" title="setter循环依赖"></a>setter循环依赖</h2><p>对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的Bean来完成的，而且<b style="color:red">只能解决单例作用域的Bean循环依赖</b>。我唯一有印象的就是这里的代码，之后如果再读Spring源码，我们再来进行详细地分析。</p>
<p>通过提前暴露一个<b style="color:red">单例工厂方法ObjectFactory</b>，从而使其他Bean能引用到该Bean。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决问题的方式是多种多样的，以后一定要想如何去解决一个问题，而不是关注问题本身的解决。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/java/Spring中创建bean的几种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/java/Spring中创建bean的几种方式/" itemprop="url">Spring中创建bean的几种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T14:36:40+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在忙于区块链知识的研究，却忘记了Spring的很多知识。其实我主打的知识还是应该是Spring、SpringMVC、Mybatis、Tomcat、SpringBoot、SpringCloud等等。但是实际上我现在对这方面的知识遗忘还是很厉害的。今天就来回顾一下Spring创建Bean的几种方式。</p>
<h2 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;hello&quot; name=&quot;helloImpl&quot; class=&quot;cn.javass.spring.chapter2.helloworld.HelloImpl&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="有参数的构造方法"><a href="#有参数的构造方法" class="headerlink" title="有参数的构造方法"></a>有参数的构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;bean2&quot; class=&quot;cn.javass.spring.chapter2.HelloImpl2&quot;&gt;</span><br><span class="line">    &lt;!-- 指定构造器参数 --&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a>静态工厂方式</h2><p>静态工厂的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloApiStaticFactory &#123;</span><br><span class="line">    //工厂方法</span><br><span class="line">    public static HelloApi newInstance(String message) &#123;</span><br><span class="line">        //返回需要的Bean实例</span><br><span class="line">        return new HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>xml的配置方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用静态工厂方法 --&gt;</span><br><span class="line">&lt;bean id=&quot;bean3&quot; class=&quot;cn.javass.spring.chapter2.HelloApiStaticFactory&quot; factory-method=&quot;newInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="实例工厂方法实例化Bean"><a href="#实例工厂方法实例化Bean" class="headerlink" title="实例工厂方法实例化Bean"></a>实例工厂方法实例化Bean</h2><p>实例工厂类代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.javass.spring.chapter2;</span><br><span class="line"></span><br><span class="line">public class HelloApiInstanceFactory &#123;</span><br><span class="line">    public HelloApi newInstance(String message) &#123;</span><br><span class="line">        return new HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>xml的定义方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—1、定义实例工厂Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;cn.javass.spring.chapter2.HelloApiInstanceFactory&quot;/&gt;</span><br><span class="line">&lt;!—2、使用实例工厂Bean创建Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;bean4&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><p>一个构造方法注入，一个是getter、Setter方法注入。除了注入bean，也可以注入常量、list、array、set、map等各种数据结构。</p>
<p>当然由于bean的创建方式有工厂的方式进行创建，所以注入的参数也可以通过factory-method进入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实不管是使用哪种方式的注入，都是生成FactoryBean，但其实我们可以使用多种方式对先有的Spring方式进行扩容。甚至是自己负责new一个对象，然后register到Spring容器里面。拥有这种思路对于我们后期对Springboot的学习很有帮助。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/blockchain/BIP-62处理延展性攻击/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/blockchain/BIP-62处理延展性攻击/" itemprop="url">BIP-62处理延展性攻击</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T10:23:54+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文档主要是解决比特币的延展性攻击。</p>
<p><b style="color:red">交易的延展性，也被称作为是可锻性，啥叫可锻，也即同样一个东西（如一坨金属），它的本质和质量都没有改变，但是它的形状改变了。而这个可锻性，会造成交易ID——TXID的不一致，从而导致用户找不到发送的交易。因为交易的ID就是指交易的hash值。但是由于隔离见证的使用，导致脚本不再是交易结构的一部分（但是逻辑上还是一样的），这样这个扩展性问题就不那么重要了。但是如果旧节点产生的交易，可能还是要使用这样的规则去杜绝扩展性。</b></p>
<p>注意：本文档是一项正在进行的工作，并未完成，实施或以其他方式适用于部署。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该文件规定了对比特币交易有效性规则的建议修改，以便不可能延展交易的可塑性（至少在交易发送者不选择避开它时）。</p>
<h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>此BIP根据2条款BSD许可证进行许可。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>截至2014年2月，比特币交易在多个方面具有延展性。这意味着（有效）交易可以在传送中被修改，而不会使其失效，但无法访问相关私钥。</p>
<p>这个问题有多种原因：（<b style="color:red">感觉这里讲的就是如果同一个输出，发送者发送多笔花费这个输出的交易会怎么样？</b>）</p>
<ul>
<li>交易被改后，交易发送者可能无法识别他自己的交易。（因为TXID可能被修改了，链上使用旧的txid是无法找到这笔交易的）</li>
<li>交易发送者可以花费由原始交易创建的更改的交易。如果修改后的交易被矿机开采，这将变为无效。</li>
<li>修改后的交易实际上是双重花费，可以在没有恶意的情况下（发送者）创建，但易于被用于其他攻击。</li>
</ul>
<p>已知几种延展性来源（<b style="color:red">主要是指哪些部分可以被修改，修改什么</b>）：</p>
<ol>
<li>现在的非DER编码的ECDSA签名. 比特币参考客户端使用OpenSSL来验证签名。由于OpenSSL接受的不仅仅是严格遵守DER标准的序列化，而且还是可延展性的来源。自v0.8.0以来，非DER签名不再被中继。（就是说DER签名可以解决问题，非DER签名的交易会有问题。）</li>
<li>scriptSig中没有推送操作。 <b style="color:red">在scriptSig中脚本操作的任何序列号都会导致预期的数据推送，但不仅仅是推送该数据，会产生具有相同有效性的替代事务。</b></li>
<li>scriptSig中非标准尺寸的推送操作。 比特币脚本语言具有多个推式运算符（OP_0，单字节推送，最多75字节的数据推送，OP_PUSHDATA1，OP_PUSHDATA2，OP_PUSHDATA4）。由于后者与前者具有相同的结果，它们会带来更多的可能性。(容易遭受DDOS攻击，推送大数据也会导致mempool内存爆满)</li>
<li>零填充数字推送。 在scriptPubKey操作码使用被解释为数字的输入的情况下，它们可以被填充为零。</li>
<li>内在的ECDSA签名延展性 ECDSA签名本身已经具有延展性：取数字S的负数（以曲线顺序为模）不会使其无效。（<b style="color:red">这个需要了解椭圆曲线的特性了，对称的点也在曲线上的</b>）</li>
<li>多余的scriptSig操作。 在脚本开始处添加额外的数据推送，这些数据不会被相应的scriptPubKey消耗，这也是可延展性的来源。(一开始压入一些数字，如果栈不被清空会有很多的问题)</li>
<li>输入被脚本忽略。 如果scriptPubKey以OP_DROP开头，例如，相应脚本的最后一次数据推送将始终被忽略。</li>
<li>基于Sighash标志的掩码。 Sighash标志可用于在签名时忽略脚本的某些部分。（修改sighash，这个可以查看DER的结构）。</li>
<li>交易发起者的新签名。 交易发起者（或任何可以访问相关私钥的人）总是能够创建新的签名，这些签名将相同的输入用于相同的输出。</li>
</ol>
<p><b style="color:red">前六个和第七个的一部分可以通过额外的共识规则来解决，但最后两个不能</b>。无法修复＃7意味着即使有了这些新的共识规则，也将始终有可能创建支出交易全都具有延展性的输出。然而，当限制使用一套安全的输出脚本时，<b style="color:red">额外的共识规则可以使支出交易选择性地不可延展（如果花费者选择;因为他自己总是可以绕过＃8和＃9）。</b></p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="新规则"><a href="#新规则" class="headerlink" title="新规则"></a>新规则</h3><p><b style="color:red">引入了七个额外的规则，以准确地与上面列出的七个可延展性来源进行对比：</b></p>
<ol>
<li>标准的ECDSA编码签名。 传递给OP_CHECKSIG，OP_CHECKSIGVERIFY，OP_CHECKMULTISIG或OP_CHECKMULTISIGVERIFY的ECDSA签名必须使用严格的DER编码进行编码。为了为OP_CHECKSIG和OP_CHECKMULTISIG故意创建无效签名提供一种紧凑的方式，还允许使用空字节数组（即OP_0的结果）。<b style="color:red">使用非DER签名进行验证会使整个脚本评估为False（而不仅仅是签名验证）</b>。请参阅参考资料：<a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#der-encoding" target="_blank" rel="noopener">DER编码</a>。</li>
<li>scriptSig中的非推送操作。 ScriptSig中只允许数据推送。评估任何其他操作会使脚本评估为false。请参阅参考：<a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#push-operators" target="_blank" rel="noopener">推送运算符</a>。</li>
<li>scriptSig中的推送操作是非标准大小类型。 尽可能使用尽可能最小的脚本操作。使用可以用较短方式编码的操作推送数据会使脚本评估为false。请参阅参考：推送运算符。</li>
<li>零填充数字推送。 任何时候脚本操作码都会消耗一个被解释为数字的堆栈值，它必须以尽可能最短的形式进行编码。’负零’是不允许的。请参阅参考：数字。</li>
<li>固有的ECDSA签名延展性。 我们要求ECDSA签名内的S值至多是曲线次序（就是n的值）除以2（实质上限制该值到其下半部分范围）。请参阅参考：<a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#low-s-values-in-signatures" target="_blank" rel="noopener">签名中的低S值</a>。</li>
<li>多余的scriptSig操作。 scriptPubKey评估将需要导致一个非零值。如果任何额外的数据元素保留在堆栈上，则脚本评估为false。</li>
<li>脚本忽略输入 OP_CHECKMULTISIG和OP_CHECKMULTISIGVERIFY消耗的（不必要的）额外堆栈元素必须是空字节数组（OP_0的结果）。其他任何事情都会使脚本评估为false。</li>
</ol>
<h3 id="区块有效性"><a href="#区块有效性" class="headerlink" title="区块有效性"></a>区块有效性</h3><p>为了在网络中引入这些新规则，我们添加了v3块和v3交易。交易跳过v2以使交易和​​区块规则之间的版本号保持同步。v2交易的处理与v1交易相同。使用与BIP 0034相同的机制来引入v3块。当过去1000个block中有75％是v3时，会激活一个新的共识规则：</p>
<ul>
<li>v3块中的所有交易都必须遵守规则＃1-＃2。</li>
<li>v3块中的v3（或更高）交易也需要遵循规则＃3-＃7。</li>
</ul>
<p>当过去1000个块中的95％为v3或更高时，v2块将完全失效。但请注意，v1（和v2）交易永远保持有效。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>以下是签名，编码和数据推送效果的总结。</p>
<h3 id="签名中的低位S值"><a href="#签名中的低位S值" class="headerlink" title="签名中的低位S值"></a>签名中的低位S值</h3><p>签名中的值S必须介于<code>0x1</code>和<code>0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0（含）</code>之间。如果S太高，只需将其替换为<code>S&#39;= 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S</code>.</p>
<p>不保证OpenSSL库生成的签名与此约束一致。参考客户端的0.9.3版本提供了检测和纠正的示例。</p>
<p>值R的约束与ECDSA不变，其值可以在<code>0x1</code>和<code>0xFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140（含）</code>之间。</p>
<h3 id="DER编码"><a href="#DER编码" class="headerlink" title="DER编码"></a>DER编码</h3><p>作为参考，这里是如何正确编码DER格式的签名。</p>
<p>格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x30 [总长度] 0x02 [R长度] [R] 0x02 [S长度] [S] [sighash型]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>总长度：后面所有内容的1字节长度描述符，<b tsyle="color:red">不包括sighash字节。</b></li>
<li>R长度：后面的R值的1字节长度描述符。</li>
<li>R：任意长度的大端编码的R值。它不能以任何0x00字节开始，除非接下来的第一个字节是0x80或更高，在这种情况下需要一个0x00。</li>
<li>S长度：接下来的S值的1字节长度描述符。</li>
<li>S：任意长度的大端编码的S值。与R相同的规则适用。</li>
<li>sighash类型：1字节散列类型标志（只允许0x01，0x02，0x03，0x81，0x82和0x83）。</li>
</ul>
<p>参考客户端自0.8.0版本开始实施（仅作为中继策略，而不是作为共识规则）。<br>该规则与上面的低S要求相结合导致S长度最多为32（并且R长度最多为33），并且总签名大小最多72字节（平均71.494字节）。</p>
<h3 id="推动操作"><a href="#推动操作" class="headerlink" title="推动操作"></a>推动操作</h3><ul>
<li>推空的字节序列必须使用OP_0。</li>
<li>通过0x10推送一个1字节的字节序列0x01必须使用OP_n。</li>
<li>推送字节0x81必须使用OP_1NEGATE。</li>
<li>推送任何其他高达75字节的字节序列时，必须使用正常的数据推送（操作码字节n，其中n是字节数，紧接着推送n字节的数据）。</li>
<li>推送76到255个字节必须使用OP_PUSHDATA1。</li>
<li>推送256到520字节必须使用OP_PUSHDATA2。</li>
<li>OP_PUSHDATA4永远不能使用，因为不允许超过520个字节，下面的操作可以使用其他操作符完成。</li>
<li>任何其他操作都不被认为是push。（<b style="color:red">意思就是不能使用数字这样直接做推送</b>）</li>
</ul>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>堆栈元素的本地数据类型是字节数组，但有些操作将参数解释为整数。使用的编码是带有明确的符号位（最后一个字节的最高位）的小端。数字的最短编码是（以（））之间的十六进制给出的范围边界编码。</p>
<ul>
<li>0：OP_0; （00）</li>
<li>1..16：OP_1..OP_16; （51）..（60）</li>
<li>-1：OP_1NEGATE; （79）</li>
<li>-127 ..- 2和17..127：正常的1字节数据推送; （01 FF）..（01 82）和（01 11）..（01 7F）</li>
<li>-32767 ..- 128和128..32767：正常的2字节数据推送; （02 FF FF）..（02 80 80）和（02 80 00）..（02 FF 7F）</li>
<li>-8388607 ..- 32768和32768..8388607：正常的3字节数据推送; （03 FF FF FF）..（03 00 80 80）和（03 00 80 00）..（03 FF FF 7F）</li>
<li>-2147483647 ..- 8388608和8388608..2147483647：正常的4字节数据推送; （04 FF FF FF FF）..（04 00 00 80 80）和（04 00 00 80 00）..（04 FF FF FF 7F）</li>
<li>任何其他数字都不能被编码。</li>
</ul>
<p>特别要注意的是，如果允许使用非最短格式，则零可以编码为（01 80）（负零）。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>交易中继发布了一个新的节点软件版本，它使v3交易标准化，并在scriptSigs满足上述规则时中继它们。v1交易的中继不受影响。支付v3交易创建的输出的v1交易也不受影响。</p>
<p>电子钱包更新由于v3交易目前是非标准的，因此无法立即开始创建它们。可以检查软件以确认新的规则，但只有当网络的重要部分已升级到兼容的代码时才能启动v3。它的意图是“我希望这个交易受到延展保护”，并且仍然是钱包软件的选择。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://www.zhihu.com/question/53863396" target="_blank" rel="noopener">比特币的交易延展性指的是什么？</a><br><a href="https://github.com/bitkevin/blog.biqu.io/blob/master/source/_posts/2013-10-27-bitcoin-transaction-02.markdown" target="_blank" rel="noopener">交易的构造、签名与广播</a><br><a href="https://blockchain.iethpay.com/transaction-malleability.html" target="_blank" rel="noopener">比特币中交易延展性问题</a><br><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/transaction_malleability.html" target="_blank" rel="noopener">交易延展性 | Transaction Malleability</a><br><a href="https://bitcoin.org/en/developer-guide#avoiding-key-reuse" target="_blank" rel="noopener">Transaction Malleability</a><br><a href="http://localhost:4000/2018/03/28/blockchain/BIP-62%E5%A4%84%E7%90%86%E5%BB%B6%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB/" target="_blank" rel="noopener">bips/bip-0062.mediawiki</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/27/blockchain/关于以太坊的签名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/blockchain/关于以太坊的签名/" itemprop="url">关于以太坊的签名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T14:54:18+08:00">2018-03-27</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前的博文当中我们已经提到过关于区块链技术的基础密码学之<a href="/2018/03/26/算法/关于椭圆曲线的理解/">椭圆曲线</a>的知识.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在正常的ecdsa算法中发现签名都是（r,s），但是以太坊中的签名返回好像还有一个v，而且在RFC6979中也没有提到这个v，我实在不知道这个v到底是一个什么的东西，今天特地来深入地研究一番。</p>
<p>这个v其实是用于椭圆曲线点恢复使用的，在椭圆曲线中（ecdsa）点的y轴是经过mod p的，这样你获得的点可能是经过转换的，你可以查看<a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v" target="_blank" rel="noopener">ECDSA: (v, r, s), what is v?</a>。另外比特币中是直接使用v=0|1，但是以太坊中v=27|28，这又是为啥呢？这主要是为了防止被攻击，可以查看<a href="https://ethereum.stackexchange.com/questions/15766/what-does-v-r-s-in-eth-gettransactionbyhash-mean" target="_blank" rel="noopener">What does v, r, s in eth_getTransactionByHash mean?</a>中的回答，主要的说明在<a href="https://github.com/ethereum/EIPs/issues/155" target="_blank" rel="noopener">EIP 155</a>当中。</p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>实施签名需要两个部分：待签名的数据+实施签名的账户。签名过程可以使用web3.eth.sign()来实现，具体代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; let msg = web3.sha3(&apos;today is 20171026&apos;)</span><br><span class="line">&gt; let signature = web3.eth.sign(address, msg)</span><br><span class="line">0x125a275046b65a96f11fdb7cd1072054e67526a76f54b1622fde4e4592d6fe2d5bf664ace77da52c6f94f08a56077e5d7a80048f70c38a92169205df3c9c43ea1b</span><br></pre></td></tr></table></figure></p>
<p>该返回值总共132字节（去掉前面的’0x’的话是130字节）。因为以太坊采用的ECDSA签名算法，根据ECDSA: (v, r, s), what is v?的介绍， 返回值可以分为三个部分：r, s, v。其中前0~66个字节为r， 66~130之间的字节为s， 130~132的字节为v。代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let r = signature.slice(0, 66)</span><br><span class="line">let s = &apos;0x&apos; + signature.slice(66, 130)</span><br><span class="line">let v = &apos;0x&apos; + signature.slice(130, 132)</span><br><span class="line">v = web3.toDecimal(v)</span><br></pre></td></tr></table></figure></p>
<p>接下来我们可以将它打印出来，在接下来验证签名的部分会用到。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><b style="color:red">签名完成了，我们如何验证某些签名后的数据是哪个账户签名的呢？在web3.js 发布1.0版本以前，验证签名只能通过智能合约的ecrecover函数来实现</b>。新版的web3.js提供了web3.eth.accounts.recover函数用于验证签名。这里我们仍然使用传统的智能合约ecrecover方式。</p>
<p>ecrecover接收数据的哈希值以及r/s/v等参数作为输入，返回实施该签名的账户地址。因此我们只需要通过合约拿到实施签名的地址，和我们真正的地址进行对比，如果地址一致，就说明验证通过了。</p>
<p><b style="color:red">智能合约代码如下：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.15;</span><br><span class="line">// 专门写了一个用于验证签名的合约呀</span><br><span class="line">contract Auth &#123;      </span><br><span class="line">    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(address retAddr) &#123;</span><br><span class="line">      bytes memory prefix = &quot;\x19Ethereum Signed Message:\n32&quot;;</span><br><span class="line">      bytes32 prefixedHash = sha3(prefix, hash);</span><br><span class="line">      // 验证过程(这里就可以看出，通过v返回address)</span><br><span class="line">      return ecrecover(prefixedHash, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们调用合约进行交互：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const contract=web3.eth.contract(abi).at(&apos;0x2e2A4cD2869862492C744307310847466c008257&apos;);</span><br><span class="line">console.log(contract.verify(msg, v, r, s));</span><br><span class="line">console.log(address)</span><br></pre></td></tr></table></figure></p>
<p>本地执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node sign.js</span><br><span class="line">0xe0803904cbfce8e07745e1b404de43ce6f1e43bc</span><br><span class="line">0xe0803904cbfce8e07745e1b404de43ce6f1e43bc</span><br></pre></td></tr></table></figure></p>
<p>可以看到实施签名的地址和验证后返回的地址一致，签名通过验证。在以太坊中完成对数据的签名和验证还是比较简单的。并且账户不仅可以对交易进行签名，还可以对任意数据进行签名并验证。</p>
<p><b style="color:red">还有就是我们可以通过发合约来利用solidity帮我们处理一些自己写代码比较复杂的事情，比如说这里的验证签名，这个是一个很好的思路，记下了！</b></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b style="color:blue">签名的算法比较奇特，这里我在网上搜索资料的时候发现了一篇<a href="http://www.5bite.com/post/862.html" target="_blank" rel="noopener">DFINITY区块链：密码学技术介绍</a>，我们先不理会这里面关于密码学深入的问题，里面的图其实和椭圆曲线大概是一致的，因为椭圆曲线中基点不停地加之后就是将所有的点联系起来，也就形成了这篇文章中的那些点线。感觉之前在看椭圆曲线的时候，还停留在代数基础上，其实去掉理论就会发现现在变成图了。然后思维就被打开了。</b></p>
<p>关于验签是如何成功返回公钥的，这个可能是去找所有的公钥进行匹配，哪个公钥成功了就是这个人前的吧！不过确实合约中好像没有公钥，那么这个公钥是如何生成的呢？这个需要进一步地学习，我想生成是可以的因为有私钥，基点等数据，关键就是k这个值。因为<code>P=k*G</code>，只要从公式中导出这个就可以了。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://zhuanlan.zhihu.com/p/30481292" target="_blank" rel="noopener">基于以太坊(Ethereum)完成对数据的签名及验证</a><br><a href="http://me.tryblockchain.org/web3js-sign-ecrecover-decode.html" target="_blank" rel="noopener">区块链语言Solidity校验椭圆曲线加密数字签名（附实例）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/27/blockchain/隔离见证、闪电网络理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/blockchain/隔离见证、闪电网络理解/" itemprop="url">隔离见证、闪电网络理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T14:07:26+08:00">2018-03-27</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我记得刚开始接触区块链的时候应该是2017年12月份左右，后来就投入到项目的开发中，但是对于区块链基础知识的学习，我想我还是差得很远，当时去理解隔离见证和雷电网络的时候有点捉襟见肘，大概的意思吧！现在也明白了这里面的意思，但是觉得还是需要写一篇博客记录一下，免得自己又忘记了，这可不是什么好现象。</p>
<h2 id="隔离见证"><a href="#隔离见证" class="headerlink" title="隔离见证"></a>隔离见证</h2><p>隔离见证已经于2017年8月在比特币上激活了。最近比特币正在朝着下一个扩容方案努力，闪电网络 Lightning Network。闪电网络的启动必须基于更多的用户使用隔离见证地址。</p>
<h3 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h3><p>现在的比特币网络交易量特别大，但是区块10分钟一个，一个区块限制1M大小，这就造成了比特币网络的拥堵。如果大家了解交易结构就一定知道加解密脚本，这些脚本都是放在区块里面的，于是大家就想如何能把脚本从区块中拿出来单独存储，这样一个区块不就可以容纳更多的交易了吗？于是下图的结构就出现了：</p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E5%8C%BA%E5%9D%97%E5%9B%BE%E8%A7%A3.jpg?raw=true" alt=""></p>
<p>隔离见证的其中一个好处是能缓解我们交易堵塞的问题。但是最重要的是为了闪电网络铺路。一种建立在比特币底层网络的智能合约。</p>
<p>隔离验证确实不是很好的解决之道，因为脚本还是需要存储的，没有脚本的交易，那么这个交易是不是可以随便花费。另外对于钱包节点都是要去检查脚本的准确性，这个还是需要有脚本数据的，所以这个也不是简单的事情吧！</p>
<h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p>隔离见证可以应用软分叉或者硬分叉，当然最终实施的是软分叉。新的节点是可以兼容后者的，但是旧节点是不是兼容新版本的区块这个是需要考虑的，如果不兼容那么就肯定出现软分叉。但是官方的说明是旧版本的节点不用升级，这句话的话外之音就是旧节点也是支持新版的区块（包含隔离见证）。看来这项技术很好。至于BCH应该是人为的硬分叉了。这部分知识可参考<a href="http://8btc.com/thread-45833-1-1.html" target="_blank" rel="noopener">隔离见证比任何硬分叉都高级</a></p>
<p>上篇的文章中提到了Core团队很多的问题，也许确实有问题，但是作为开发者，考虑前后版本兼容也是应该的，毕竟谁都不想出问题。另外还有一点就是一旦一个项目上线，可做的可能真的就不多了，一是改动复杂，程序员不想动，二是工作量比较大！对于这场战争我还是当个第三者吧，看惯了公司风风雨雨，拿刀开干的人还是很少的。一旦变革失败也不会有人同情，core团队可能有自己的考量。毕竟对于资本市场来说一切都是那么的浮躁。</p>
<h2 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h2><p>闪电网络提供了一个可扩展的微支付通道网络。交易双方若在区块链上预先设有支付通道，就可以多次、高频、双向地通过轧差方式实现瞬间确认的微支付；双方若无直接的点对点支付通道，只要网络中存在一条连通双方的、由多个支付通道构成的支付路径，闪电网络也可以利用这条支付路径实现资金在双方之间的可靠转移。</p>
<p>上面的这段话可能比较难于理解，总的来说就是通过多签名实现多重交易的划分，这里需要了解比<a href="/2018/03/16/blockchain/bitcoin智能合约的实现/">特币的智能合约</a>和<a href="/2018/03/17/blockchain/bitcoin脚本解析/">P2SH脚本</a>的相关知识。</p>
<p><b style="color:red">闪电网络并不试图解决单次支付的银货对付问题，其假设是单次支付的金额足够小，即使一方违约另一方的损失也非常小，风险可以承受。因此使用时必须注意“微支付”这个前提。多少资金算“微”，显然应该根据业务而定。</b></p>
<h3 id="技术本质"><a href="#技术本质" class="headerlink" title="技术本质"></a>技术本质</h3><p><b style="color:red">闪电网络的关键技术有三，后后依赖于前前，依次是：RSMC，HTLC和闪电网络。技术实现虽然复杂，但本质却很简单。</b></p>
<p><b style="color:blue">RSMC解决了通道中币单向流动问题，HTLC解决了币跨节点传递的问题。这两个类型的交易组合构成了闪电网络。这里面还会用到我们之前提到的<a href="/2018/03/26/blockchain/BIP-65%20OP-CHECKLOCKTIMEVERIFY/">BIP-65 OP_CHECKLOCKTIMEVERIFY</a>和<a href="/2018/03/26/blockchain/BIP-68使用共识序列号记录相对锁定时间/">BIP-68使用共识序列号记录相对锁定时间</a>，这两篇文档提到了交易锁定的问题，也提到了分叉的问题。</b></p>
<h3 id="RSMC"><a href="#RSMC" class="headerlink" title="RSMC"></a>RSMC</h3><p>我们先来创建一个序列到期可撤销合约（RSMC），Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入<b style="color:red">通道</b>中，便于业务往来。解释一下下方RSMC交易的结构（图X），左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p>
<h4 id="创建交易"><a href="#创建交易" class="headerlink" title="创建交易"></a>创建交易</h4><p><img src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/blockchain/RSMC%E4%BA%A4%E6%98%93%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt=""></p>
<p>来对上面的图进行一番解释：</p>
<ol>
<li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时，Funding Tx未签名，更不广播。</li>
<li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li>
<li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li>
<li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li>
<li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li>
<li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。</li>
</ol>
<p>上述过程以及结构图的描述，就是创建RSMC的全部过程。C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p>
<h4 id="交易更新"><a href="#交易更新" class="headerlink" title="交易更新"></a>交易更新</h4><p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%98%93%E6%9B%B4%E6%96%B0.jpg?raw=true" alt=""></p>
<p>此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？<br>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%98%93%E6%9B%B4%E6%96%B02.jpg?raw=true" alt=""></p>
<p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p>
<h4 id="交易关闭"><a href="#交易关闭" class="headerlink" title="交易关闭"></a>交易关闭</h4><p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p>
<h4 id="中转交易（真实的闪电网络，HTLC）"><a href="#中转交易（真实的闪电网络，HTLC）" class="headerlink" title="中转交易（真实的闪电网络，HTLC）"></a>中转交易（真实的闪电网络，HTLC）</h4><p>我们来看一下基本的流程图吧！<br><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BD%AC%E4%BA%A4%E6%98%93%E5%9B%BE.png?raw=true" alt=""><br>这里面的R就是支付的口令，其实就是交易节点之间没有直连的通道，需要其他人待转，这些人会收手续费。这里面需要解决几个问题（我的思考）：</p>
<ol>
<li>如何建立初始的支付通道</li>
<li>如果两个节点间无直接支付通道，如何找到最佳的支付通道。</li>
<li>如何保证第三方不作弊，防止现金丢失（前面的讲的都是这个问题）</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="RSMC-1"><a href="#RSMC-1" class="headerlink" title="RSMC"></a>RSMC</h4><p>闪电网络的基础是交易双方之间的双向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定义了该双向微支付通道的最基本工作方式。这是要求双方都拿出资金放到合约上，然后输出动态分配，最后确认输出后上链，这样的好处就是支付完全是在链下执行。</p>
<p><b style="color:red">为了鼓励双方尽可能久地利用通道进行交易，RSMC对主动终止通道方给予了一定的惩罚：主动提出方其资金到账将比对方晚，因此谁发起谁吃亏。这个设计虽然增加了技术复杂度，但应该说是合理的。</b> 这样许多交易就会在区块链下面执行，不会产生交易（只产生预备交易），最后交易才会上链。还有就是交易的凭证怎么保证？所以这个方式或许也有很多技术和现实的缺陷所在。</p>
<p><b style="color:red">通道余额分配方案的本质是结算准备金。在此安排下，因为要完全控制资金交收风险，每笔交易都不能突破当前结算准备金所施限制。</b></p>
<h4 id="HTLC"><a href="#HTLC" class="headerlink" title="HTLC"></a>HTLC</h4><p>RSMC只支持最简单的无条件资金支付，HTLC（Hashed Timelock Contract）进一步实现了有条件的资金支付，通道余额的分配方式也因此变得更为复杂。</p>
<p>通过HTLC，Alice和Bob可以达成这样一个协议：协议将锁定Alice的0.1 BTC，在时刻T到来之前（T以未来的某个区块链高度表述），如果Bob能够向Alice出示一个适当的R（称为秘密），使得R的哈希值等于事先约定的值H(R)，Bob就能获得这0.1 BTC；如果直到时刻T过去Bob仍然未能提供一个正确的R，这0.1 BTC将自动解冻并归还Alice。</p>
<h2 id="雷电网络"><a href="#雷电网络" class="headerlink" title="雷电网络"></a>雷电网络</h2><p>基于闪电网络的思路，以太坊社区也提出了自己的链下微支付通道解决方案：雷电网络（Raiden Network）。<br>延续了以太坊的风格，把本来较简单的问题复杂智能化。大致与闪电网络相同，但细节有些地方更复杂。例如：第一层面的那个旧版本作废，其实只要加上时间戳看哪个时间新就可以了。但是其额外增加了一个单增的Sequence Number字段来标明哪个有效。还有记录分配余额即可，但雷电网络记录的是增减变动量。在第二个层面上，雷电网络引入了较HTLC更通用和复杂的“Smart Condition”。就是说HTLC中采用的成熟简单地求HASH函数，在雷电网络中替代成了用户可自己设置的任意函数，就是说向外扩展了，更加智能，但同时面临的风险可能就越大。</p>
<h2 id="Corda"><a href="#Corda" class="headerlink" title="Corda"></a>Corda</h2><p>相近技术的低层思想是相通的，受到闪电网络思想的启发，知名的R3也宣布发布非区块链的分布式账本应用Corda，其本质思想应该是与闪电网络较相近似。<br>关于Corda的资料较少，如整个R3较闭源封闭一样，只是R3 CEV的首席技术官Richard Brown之前在博客中披露些Corda的主要特点：</p>
<ol>
<li>没有多余的全局数据共享：有合法需求的参与方才可按照协议获取数据；</li>
<li>Corda编写和配置在企业间流转，无中心控制者；</li>
<li>Corda在企业间单个交易水平达成共识，而不是在系统水平上；</li>
<li>系统设计直接支持监管观察员节点；</li>
<li>交易直接由交易双方验证，而不是由一大群不相干的验证者进行；</li>
<li>支持多种共识机制；</li>
<li>记录了智能合约代码和人类语言法律文件的清晰联系；</li>
<li>用行业标准工具创建；</li>
<li>没有原始加密货币。</li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>将交易和智能合约的执行放在链下快速地执行，仅在必要时才将其在链上公开结算执行，这就是闪电网络带给我们的绝佳思路。同时可增加对闪电结链上算时的手续费，减轻链上压力的同时有可能提升矿工收入，因理论上不可能所有交易都闪电。比特币主链上交易有其它任何形式链下交易或侧链交易所无法替代的优点。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://zhuanlan.zhihu.com/p/32613487" target="_blank" rel="noopener">三分钟让你了解什么是Segwit隔离见证</a><br><a href="http://8btc.com/thread-45833-1-1.html" target="_blank" rel="noopener">隔离见证比任何硬分叉都高级</a><br><a href="http://www.8btc.com/bitcoin-expansion-problem" target="_blank" rel="noopener">比特币扩容为什么选择2MB？</a><br><a href="https://www.zhihu.com/question/46515457" target="_blank" rel="noopener">什么是比特币的闪电网络？</a><br><a href="https://www.zhihu.com/question/58567061" target="_blank" rel="noopener">什么是隔离见证？</a><br><a href="http://www.8btc.com/ln-rn-corda" target="_blank" rel="noopener">详解最近大热的闪电网络、雷电网络和CORDA</a><br><a href="https://mp.weixin.qq.com/s/lM0p3ikVBdw1zE50IWtMZA" target="_blank" rel="noopener">6.9Bite酱一闪电网络⚡大白话零门槛讲解</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/26/blockchain/BIP-65 OP-CHECKLOCKTIMEVERIFY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/blockchain/BIP-65 OP-CHECKLOCKTIMEVERIFY/" itemprop="url">BIP-65 OP_CHECKLOCKTIMEVERIFY</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T20:55:20+08:00">2018-03-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该BIP为比特币脚本系统描述了一个新的操作码（OP_CHECKLOCKTIMEVERIFY），该操作码允许交易输出在未来的某个点之前变得不可花费。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><b style="color:blue">CHECKLOCKTIMEVERIFY重新定义了现有的NOP2操作码(其实就是OP_CHECKLOCKTIMEVERIFY命令替换了OP_NOP2命令)。执行时，如果以下任何一个条件成立，则脚本解释器将以错误终止：</b></p>
<ul>
<li>堆栈是空的; </li>
<li>堆栈中的顶层项目小于0;</li>
<li>顶层堆栈项的锁定时间类型（高度vs.时间戳）与nLockTime字段不同;</li>
<li>顶部堆栈项大于事务的nLockTime字段;</li>
<li>txin（交易输入）的nSequence字段是0xffffffff;</li>
</ul>
<p>否则，脚本执行将继续，如同NOP执行一样。</p>
<p>交易中的nLockTime字段可防止事务被挖掘，直到达到某个块高度或块时间为止。通过将传给CHECKLOCKTIMEVERIFY的参数与nLockTime字段进行比较，我们间接验证是否已达到所需的块高度或块时间; 直到该块高度或块时间已经达到，交易输出仍然不可花费。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>交易中的nLockTime字段可用于证明 将来可以花费这笔交易输出，方法是构造一个有效的交易开销，并对nLockTime字段进行设置。</p>
<p>然而，nLockTime字段不能证明在未来的某个时间内不可能花费交易输出，因为无法知道是否创建了支出该输出的其他交易的有效签名。</p>
<h2 id="第三方托管"><a href="#第三方托管" class="headerlink" title="第三方托管"></a>第三方托管</h2><p><b style="color:red">如果Alice和Bob联合经营一家企业，他们可能希望确保所有资金都保存在需要双方合作支出的二分之二的多重（多签名的交易）交易输出中。但是，他们认识到，在特殊情况下，例如任何一方受到“巴士撞击”，他们都需要备份计划来检索资金。因此，他们任命他们的律师Lenny担任第三方。</b></p>
<p>在任何时候，Lenny都可以与Alice或Bob合谋窃取资金，这是一个标准的2分之3 多签名。同样，Lenny可能宁愿不立即获得资金，以阻止居心不良的人试图暴力获取他的密钥。</p>
<p>但是，使用CHECKLOCKTIMEVERIFY可以将资金存储在以下格式的scriptPubKeys中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line">    &lt;now + 3 months&gt; CHECKLOCKTIMEVERIFY DROP</span><br><span class="line">    &lt;Lenny&apos;s pubkey&gt; CHECKSIGVERIFY</span><br><span class="line">    1</span><br><span class="line">ELSE</span><br><span class="line">    2</span><br><span class="line">ENDIF</span><br><span class="line">&lt;Alice&apos;s pubkey&gt; &lt;Bob&apos;s pubkey&gt; 2 CHECKMULTISIG</span><br></pre></td></tr></table></figure></p>
<p>在任何时候，资金都可以用下面的脚本来支付：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;Alice&apos;s signature&gt; &lt;Bob&apos;s signature&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>Lenny经过3个月后，Alice或Bob中的一个可以用以下脚本支付资金：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;Alice/Bob&apos;s signature&gt; &lt;Lenny&apos;s signature&gt; 1</span><br></pre></td></tr></table></figure></p>
<h2 id="非交互式时间锁定退款"><a href="#非交互式时间锁定退款" class="headerlink" title="非交互式时间锁定退款"></a>非交互式时间锁定退款</h2><p>存在许多协议，其中创建交易输出，这需要双方的合作来花费输出。为确保一方的失败不会导致资金损失，退款交易使用nLockTime提前设置。这些退款交易需要交互式创建，此外，目前易受交易延展性影响。CHECKLOCKTIMEVERIFY可用于这些协议，用非交互式设置取代交互式设置，另外，使交易延展性不成问题。</p>
<h3 id="双因素钱包"><a href="#双因素钱包" class="headerlink" title="双因素钱包"></a>双因素钱包</h3><p>诸如GreenAddress之类的服务将比特币存储为2比2的多签名脚本ScriptPubKey，使得一个密钥对由用户控制，另一个密钥对由服务控制。为了花费资金，用户使用本地安装的生成所需签名之一的钱包软件，然后使用第二因素身份验证方法来授权该服务创建第二个SIGHASH_NONE签名，该签名在将来的某个时间被锁定，并向用户发送该存储签名。如果用户需要花费资金并且服务不可用，他们会等到nLockTime过期。</p>
<p>问题是，在许多情况下，用户将不会拥有一些或全部交易输出的有效签名。使用CHECKLOCKTIMEVERIFY而不是按需创建退款签名而是使用以下形式的scriptPubKeys：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line">    &lt;service pubkey&gt; CHECKSIGVERIFY</span><br><span class="line">ELSE</span><br><span class="line">    &lt;expiry time&gt; CHECKLOCKTIMEVERIFY DROP</span><br><span class="line">ENDIF</span><br><span class="line">&lt;user pubkey&gt; CHECKSIG</span><br></pre></td></tr></table></figure></p>
<p>现在，用户总是能够在没有服务合作的情况下花费他们的资金，等待到期时间的到来。</p>
<h3 id="付款渠道"><a href="#付款渠道" class="headerlink" title="付款渠道"></a>付款渠道</h3><p>Jeremy Spilman风格的支付渠道首先设置一个存款，由2-of-2的多签名，tx1控制的存款，然后调整第二个交易tx2，将tx1的输出用于支付者和收款者。在发布tx1之前，创建一个退款交易tx3，以确保收款人是否可以清除付款人的存款。创建退款交易的过程目前易受交易延展性攻击的影响，此外还要求付款人存储退款。使用与双因子钱包示例中相同的scriptPubKey形式解决了这两个问题。</p>
<h2 id="用于发布数据的无信任支付"><a href="#用于发布数据的无信任支付" class="headerlink" title="用于发布数据的无信任支付"></a>用于发布数据的无信任支付</h2><p>PayPub协议可以通过首先证明加密文件包含所需数据，然后制作用于付款的scriptPubKeys来支付以无信任方式付款的信息，以便花费它们显示数据的加密密钥。然而，现有的实现有一个重大缺陷：发布者可以无限期地推迟密钥的发布。</p>
<p>这个问题可以用退款交易技术交互地解决; 使用CHECKLOCKTIMEVERIFY，可以使用以下形式的scriptPubKeys以非交互方式解决问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line">    HASH160 &lt;Hash160(encryption key)&gt; EQUALVERIFY</span><br><span class="line">    &lt;publisher pubkey&gt; CHECKSIG</span><br><span class="line">ELSE</span><br><span class="line">    &lt;expiry time&gt; CHECKLOCKTIMEVERIFY DROP</span><br><span class="line">    &lt;buyer pubkey&gt; CHECKSIG</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">数据的买家现在正在提供一个有效期限的安全报价。如果发行商在到期时间到期之前未能接受报价，买家可以通过消费输出来取消报价。</b></p>
<h2 id="证明牺牲矿工的收费"><a href="#证明牺牲矿工的收费" class="headerlink" title="证明牺牲矿工的收费"></a>证明牺牲矿工的收费</h2><p>证明牺牲一些有限的资源是各种密码协议中的常见技术。已经提出将硬币的牺牲证明为采矿费，作为牺牲可以指向的普遍公共物品，而不是简单地摧毁硬币。然而，这样做并非微不足道，即使是最好的现有技术 - 宣布 - 承诺 - 也会鼓励矿业集中。CHECKLOCKTIMEVERIFY可用于创建任何人都可以花费的产出（因此，假设矿工的行为是理想的和理性的，那么开采费），但只有在未来足够远的时间，大型矿工才能以折扣销售牺牲品。</p>
<h2 id="冻结资金"><a href="#冻结资金" class="headerlink" title="冻结资金"></a>冻结资金</h2><p>除了使用冷存储，硬件钱包和P2SH multisig输出来控制资金之外，现在资金可以直接在区块链中冻结在UTXO中。使用下面的scriptPubKey，在提供的失效时间之前，没有人能够使用安全输出。这种可靠地冻结资金的能力在需要减少胁迫或没收风险的情况下可能会有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expiry time&gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &lt;pubKeyHash&gt; EQUALVERIFY CHECKSIG</span><br></pre></td></tr></table></figure></p>
<h2 id="完全替换nLockTime字段"><a href="#完全替换nLockTime字段" class="headerlink" title="完全替换nLockTime字段"></a>完全替换nLockTime字段</h2><p>另外，请注意如果SignatureHash()算法可以选择覆盖脚本的一部分，那么签名可能会要求脚本Sig包含CHECKLOCKTIMEVERIFY操作码，并且还需要执行它们。（CODESEPARATOR操作码非常接近于在比特币的v0.1中实现这一点）。这种每签名功能可以完全取代每个交易的nLockTime字段，因为有效签名现在可以证明交易输出可以花费。</p>
<h2 id="详细规则"><a href="#详细规则" class="headerlink" title="详细规则"></a>详细规则</h2><p>参考下面转载的参考实现，了解这些语义的精确语义和详细基本原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">case OP_NOP2:</span><br><span class="line">&#123;</span><br><span class="line">    // CHECKLOCKTIMEVERIFY</span><br><span class="line">    //</span><br><span class="line">    // (nLockTime -- nLockTime )</span><br><span class="line"></span><br><span class="line">    if (!(flags &amp; SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))</span><br><span class="line">        break; // not enabled; treat as a NOP</span><br><span class="line"></span><br><span class="line">    if (stack.size() &lt; 1)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // Note that elsewhere numeric opcodes are limited to</span><br><span class="line">    // operands in the range -2**31+1 to 2**31-1, however it is</span><br><span class="line">    // legal for opcodes to produce results exceeding that</span><br><span class="line">    // range. This limitation is implemented by CScriptNum&apos;s</span><br><span class="line">    // default 4-byte limit.</span><br><span class="line">    //</span><br><span class="line">    // If we kept to that limit we&apos;d have a year 2038 problem,</span><br><span class="line">    // even though the nLockTime field in transactions</span><br><span class="line">    // themselves is uint32 which only becomes meaningless</span><br><span class="line">    // after the year 2106.</span><br><span class="line">    //</span><br><span class="line">    // Thus as a special case we tell CScriptNum to accept up</span><br><span class="line">    // to 5-byte bignums, which are good until 2**32-1, the</span><br><span class="line">    // same limit as the nLockTime field itself.</span><br><span class="line">    const CScriptNum nLockTime(stacktop(-1), 5);</span><br><span class="line"></span><br><span class="line">    // In the rare event that the argument may be &lt; 0 due to</span><br><span class="line">    // some arithmetic being done first, you can always use</span><br><span class="line">    // 0 MAX CHECKLOCKTIMEVERIFY.</span><br><span class="line">    if (nLockTime &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // There are two types of nLockTime: lock-by-blockheight</span><br><span class="line">    // and lock-by-blocktime, distinguished by whether</span><br><span class="line">    // nLockTime &lt; LOCKTIME_THRESHOLD.</span><br><span class="line">    //</span><br><span class="line">    // We want to compare apples to apples, so fail the script</span><br><span class="line">    // unless the type of nLockTime being tested is the same as</span><br><span class="line">    // the nLockTime in the transaction.</span><br><span class="line">    if (!(</span><br><span class="line">            (txTo.nLockTime &lt;  LOCKTIME_THRESHOLD &amp;&amp; nLockTime &lt;  LOCKTIME_THRESHOLD) ||</span><br><span class="line">            (txTo.nLockTime &gt;= LOCKTIME_THRESHOLD &amp;&amp; nLockTime &gt;= LOCKTIME_THRESHOLD)</span><br><span class="line">            ))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // Now that we know we&apos;re comparing apples-to-apples, the</span><br><span class="line">    // comparison is a simple numeric one.</span><br><span class="line">    if (nLockTime &gt; (int64_t)txTo.nLockTime)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // Finally the nLockTime feature can be disabled and thus</span><br><span class="line">    // CHECKLOCKTIMEVERIFY bypassed if every txin has been</span><br><span class="line">    // finalized by setting nSequence to maxint. The</span><br><span class="line">    // transaction would be allowed into the blockchain, making</span><br><span class="line">    // the opcode ineffective.</span><br><span class="line">    //</span><br><span class="line">    // Testing if this vin is not final is sufficient to</span><br><span class="line">    // prevent this condition. Alternatively we could test all</span><br><span class="line">    // inputs, but testing just this input minimizes the data</span><br><span class="line">    // required to prove correct CHECKLOCKTIMEVERIFY execution.</span><br><span class="line">    if (txTo.vin[nIn].IsFinal())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4" target="_blank" rel="noopener">https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>我们重用BIP66中使用的双阈值IsSuperMajority()切换机制，其阈值相同，但nVersion=4。新规则对于nVersion=4的每个块（高度为H）有效，并且至少有750之前的块（高度为H-1000..H-1）的nVersion&gt;=4。此外，当块之前的1000个块中的950个具有nVersion&gt;=4时，nVersion&lt;4块将变为无效，并且全部进一步的阻止执行新的规则。</p>
<p>应该注意的是，BIP9涉及永久性地将高位设置为1，这导致nVersion&gt;=所有先前的IsSuperMajority()软分叉，因此nVersion中的位不会永久丢失。</p>
<h2 id="SPV客户"><a href="#SPV客户" class="headerlink" title="SPV客户"></a>SPV客户</h2><p>尽管SPV客户端（目前）无法验证块，但相信矿工为他们进行验证，但他们能够验证块头并因此可以验证部署规则的子集。如果达到95％的阈值，如果1000个前面的块中的950个<code>nVersion&gt;=4</code>，则SPV客户端应拒绝<code>nVersion&lt;4</code>块，以防止未升级的矿工剩余的5％发生虚假确认。</p>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>感谢格雷戈里麦克斯韦提出将参数与每个交易的nLockTime进行比较，而不是当前块的高度和时间。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>PayPub</p>
<ul>
<li><a href="https://github.com/unsystem/paypub" target="_blank" rel="noopener">https://github.com/unsystem/paypub</a></li>
</ul>
<p>Jeremy Spilman付款渠道</p>
<ul>
<li><a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html" target="_blank" rel="noopener">https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html</a></li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Python / python-bitcoinlib</p>
<ul>
<li><a href="https://github.com/petertodd/checklocktimeverify-demos" target="_blank" rel="noopener">https://github.com/petertodd/checklocktimeverify-demos</a></li>
</ul>
<p>JavaScript / Node.js / bitcore</p>
<ul>
<li><a href="https://github.com/mruddy/bip65-demos" target="_blank" rel="noopener">https://github.com/mruddy/bip65-demos</a></li>
</ul>
<h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>该文件置于公共领域。</p>
<h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><a href="http://www.chidaolian.com/article-680-4" target="_blank" rel="noopener">BIP65：检查锁定时间验证</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki" target="_blank" rel="noopener">bips/bip-0065.mediawiki</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/26/blockchain/BIP-68使用共识序列号记录相对锁定时间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/blockchain/BIP-68使用共识序列号记录相对锁定时间/" itemprop="url">BIP-68使用共识序列号记录相对锁定时间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T19:03:48+08:00">2018-03-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该BIP介绍了的相对锁定时间（RLT），RLT使用序列号字段来实现强一致性语义，以使已签名的交易输入在确认其相应的输出后在限定的时间段内保持无效。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>比特币交易每个输入都有一个序列号字段。最初的想法似乎是mempool中的交易将被替换为具有更高序列值的相同输入。虽然这没有得到很好的实施，但假设即使较低的序列号利润更高，矿工会喜欢较高的序列号。然而，一个仅仅依靠利润动机的矿工会完全打破这个假设。此BIP所描述的更改将重新调整新用例的序列号，而不会破坏现有功能。这也为未来扩展和其他使用情况留下了空间。</p>
<p><b style="color:red">交易nLockTime用于防止在某个日期之前挖掘交易。nSequence将被重新用于防止交易的挖掘，直到花费在某个时间或时间段内的输出块高的确认</b>。除此之外，此功能还允许使用散列时间片合同（HTLC）和BIP112中使用的双向付款渠道。</p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><b style="color:red">本规范为nVersion大于或等于2的交易定义了序列号的含义，本规范的其余部分都是基于该规则的。</b></p>
<p>所有对过去的中位时间（MTP）的定义说明都是由BIP113定义的。</p>
<p>如果序列号的位（1 &lt;&lt; 31）被设置（最高位被设置），则没有共识含义被应用于序列号，并且可以被包括在当前所有可能情况下的任何块中。</p>
<p><b style="color:red">如果序列号的位（1 &lt;&lt; 31）未被设置，则序列号被解释为编码的相对锁定时间。</b></p>
<p>序列号编码解释如下：</p>
<ul>
<li><b style="color:red">位（1 &lt;&lt; 22）确定相对锁定时间是基于时间的还是基于块的：如果设置该位，则相对锁定时间以512秒为单位指定时间间隔。时间范围从输出的前一个块的中值时间开始，并在前一个块的MTP结束。如果该位未设置，则相对锁定时间将指定多个块。</b></li>
<li>标志（1 &lt;&lt; 22）是3字节有符号整数中的最高位，用于比特币脚本，作为带有OP_CHECKSEQUENCEVERIFY（BIP 112）的3字节PUSHDATA。</li>
</ul>
<p>本规范仅将序列号的16位解释为相对锁定时间，因此必须将0x0000ffff掩码应用于序列字段以提取相对锁定时间。16位规范允许一年的相对锁定时间，其余位允许将来扩展。</p>
<p><img src="https://github.com/bitcoin/bips/raw/master/bip-0068/encoding.png" alt=""></p>
<p>对于基于时间的相对锁定时间，选择512秒的粒度，因为比特币块每600秒产生一次。所以当使用基于块或基于时间的时候，可以用可用的位数来编码相同的时间量。从序列号转换为秒是通过乘以<code>512=2^9</code>，或等价地向上移位9位来执行的。</p>
<p>当相对锁定时间是基于时间的时候，它被解释为输入年龄的最小块时间约束。相对基于时间的零锁定时间表示可以包含在任何块中的输入。更一般地说，相对基于时间的锁定时间n可以被包括在任何在其消费的输出的挖矿开采日期之后512*n秒产生的块中，或者之后的任何块中。输出的开采日期等于先前开采的块的开采时间的中间值。</p>
<p>块产生时间等于其前一块过去的中值时间。</p>
<p>当相对锁定时间是基于块的时候，它被解释为输入年龄的最小块高度约束。相对基于块的锁定时间为零表示可以包含在任何块中的输入。更一般地说，一个相对块锁定时间n可以包含在它所花费的输出的开采日期之后的n个块中，或者之后的任何块中。</p>
<p>新规则不适用于coinbase交易输入的nSequence字段。</p>
<h2 id="履行"><a href="#履行" class="headerlink" title="履行"></a>履行</h2><p>参考实现由以下拉取请求提供 <a href="https://github.com/bitcoin/bitcoin/pull/7184" target="_blank" rel="noopener">https://github.com/bitcoin/bitcoin/pull/7184</a></p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>值得一提的是格雷戈里麦克斯韦提供了一个简洁明了的描述这种变化的行为，这成为这个BIP文本的基础。</p>
<p>BIP由BtcDrak，Nicolas Dorier和kinoshitajona编辑。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>该BIP将通过使用位0的“versionbits”BIP9进行部署。</p>
<p>对于比特币mainnet，该BIP9 开始时间将是午夜2016年5月1日UTC（大纪元时间戳1462060800）和BIP9 超时将是午夜2017年5月1日UTC（大纪元时间戳1493596800）。</p>
<p>对于比特币testnet，该BIP9 开始时间将是午夜2016年3月1日UTC（大纪元时间戳1456790400）和BIP9 超时将是午夜2017年5月1日UTC（大纪元时间戳1493596800）。</p>
<p>该BIP必须与BIP112和BIP113同时部署，使用相同的部署机制。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>比特币核心参考客户端软件唯一使用的序列号是禁用检查事务中的nLockTime约束。该BIP保留了该应用程序的语义。</p>
<p>从规范部分可以看出，该BIP未定义若干位，以便通过设置位（1 &lt;&lt; 31）来允许其他用例，因为其余31位在此BIP下无意义。另外，当位（1 &lt;&lt; 31）未设置时，位（1 &lt;&lt; 23）至（1 &lt;&lt; 30）根本无意义。</p>
<p>此外，该BIP仅指定16位来实际编码相对锁定时间，这意味着还有6个位未被使用（1 &lt;&lt; 16至1 &lt;&lt; 21）。这样就可以通过软叉提高粒度，或者增加将来最大可能的相对锁定时间。</p>
<p>从相对锁定时间计算序列号的最有效方法是使用位掩码和位移：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 0 &lt;= nHeight &lt; 65,535 blocks (1.25 years)</span><br><span class="line">nSequence = nHeight;</span><br><span class="line">nHeight = nSequence &amp; 0x0000ffff;</span><br><span class="line"></span><br><span class="line">// 0 &lt;= nTime &lt; 33,554,431 seconds (1.06 years)</span><br><span class="line">nSequence = (1 &lt;&lt; 22) | (nTime &gt;&gt; 9);</span><br><span class="line">nTime = (nSequence &amp; 0x0000ffff) &lt;&lt; 9;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>比特币邮件列表讨论：<a href="https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg07864.html" target="_blank" rel="noopener">https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg07864.html</a></p>
<p>BIP9：<a href="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki</a></p>
<p>BIP112：<a href="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki</a></p>
<p>BIP113：<a href="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki" target="_blank" rel="noopener">https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki</a></p>
<p>散列时间片契约（HTLCs）：<a href="https://github.com/ElementsProject/lightning/raw/master/doc/deployable-lightning.pdf" target="_blank" rel="noopener">https://github.com/ElementsProject/lightning/raw/master/doc/deployable-lightning.pdf</a></p>
<h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><a href="http://www.chidaolian.com/article-680-5" target="_blank" rel="noopener">BIP68：使用序列号的相对锁定时间</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/26/算法/关于椭圆曲线的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/算法/关于椭圆曲线的理解/" itemprop="url">关于椭圆曲线的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T11:30:55+08:00">2018-03-26</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一直觉得加密算法比较神奇，但是比特币中使用的椭圆双曲线算法一直让我感觉很神奇，之前看的时候没有看懂，这次认真看了两篇文档之后，终于理解了这种算法的奇妙之处，看来数学这个东西其实没有大家想像的那么难，也许就是很简单的东西堆砌成一个庞然大物，以至于你不再看得清楚了。</p>
<p>椭圆曲线的形状,并不是椭圆.是因为椭圆曲线的描述方程,类似于计算一个椭圆的周长的方程得名。</p>
<h2 id="从阿贝尔群开始"><a href="#从阿贝尔群开始" class="headerlink" title="从阿贝尔群开始"></a>从阿贝尔群开始</h2><p>群的定义是定义了二元操作“运算”并且用符号+表示的一个集合。假定我们要操作的群用 𝔾表示，那么我们在这个群上面要定义的“运算”必须符合以下几个属性：</p>
<ul>
<li>闭包。如果a和b都是𝔾的成员，那么a+b也是𝔾的成员。</li>
<li>组合性。(a+b)+c=a+(b+c)</li>
<li>单位元。存在确切的一个值，称之为单位元，0可以保证该等式成立 a+0=0+a=a</li>
<li>逆元。每个成员都有一个相反数：对于任意值a必定存在b使得a+b=0</li>
</ul>
<p>如果加上第五条这要求：</p>
<ul>
<li>交换性a+b=b+a</li>
</ul>
<p><b style="color:red">这样的群我们称之为 阿贝尔群。</b></p>
<h2 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h2><p>椭圆曲线是一个对数函数，<b style="color:red">曲线上的每个点都必须是非奇异的，所谓的”非奇异”或”光滑”的,在数学中是指曲线上任意一点都存在切线。</b>椭圆曲线对于X轴是对称的，记住这点很重要。关于这个函数的更多说明，还是参照引用的文章吧，里面提到的比我说的详细多了。</p>
<h2 id="椭圆曲线的阿贝尔群"><a href="#椭圆曲线的阿贝尔群" class="headerlink" title="椭圆曲线的阿贝尔群"></a>椭圆曲线的阿贝尔群</h2><p><b style="color:red">其实关于阿贝尔群，大家一定认为加法就是指数学中的那个加法，而对于椭圆曲线，这个加法还不一定非要是数学数字中的加法，这里的加法是指线相交，而加法中的元素也不是数字，而是一个点。举例来说，P+Q=R是指P与Q的连线与曲线相较于点Q，那么对于这个公式P-R=-Q又该如何解释呢？其实减号意味着点对于X轴对称的另一个点，另外公式变换一个P+(-R)=-Q，你再想想对称性，这个公式是不是成立的？这就是这个曲线的妙处所在。至于结合律就更好理解了，3点一线，不管你取那两个点，第三个点都能算出来不是么？至于0就是无穷远处的点就是0，这个适用于，直线平行于X轴或者y轴的时候使用。</b></p>
<h2 id="关于乘法"><a href="#关于乘法" class="headerlink" title="关于乘法"></a>关于乘法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mP = P + P + ...... + P = Q</span><br></pre></td></tr></table></figure>
<p>注意这里的乘法就是，一次一次加法算出来的，如果m越大，那么计算的量也就越大。<b style="color:blue">我们学的椭圆曲线密码体制就是利用以上的这个困难问题来设计的。</b></p>
<h2 id="素数域Fp"><a href="#素数域Fp" class="headerlink" title="素数域Fp"></a>素数域Fp</h2><p><b style="color:blue">如果椭圆曲线上一点P，存在最小的正整数n，使得数乘 nP=0∞，则将n称为P的阶，若n 不存在，我们说P是无限阶的。</b></p>
<p><b style="color:red">事实上，在有限域上定义的椭圆曲线上所有的点的阶n都是存在的。</b></p>
<h2 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h2><p><b style="color:red">终于到了学习，这个算法是如何进行加解密的过程的原理了，其实就是利用了上面提到的乘法和素数域的知识，另外也有了几个参数，这几个参数对应我们之前在bitcoin中使用的各种参数调节的问题，这里就应该是调节的本质了吧.</b>。好了下面我们来分析》》》</p>
<p>描述一条Fp上的椭圆曲线，常用到六个参量：T=(p,a,b,n,x,y)。</p>
<ul>
<li>（p 、a 、b） 用来确定一条椭圆曲线，p为素数域内点的个数，a和b是其内的两个大数；（这个p就是最后y mod p 的那个值，应该说p的取值决定了n的个数）</li>
<li>x,y为G基点的坐标，也是两个大数；</li>
<li>n为点G基点的阶；</li>
</ul>
<p>以上六个量就可以描述一条椭圆曲线，有时候我们还会用到h(椭圆曲线上所有点的个数p与n相除的整数部分)。</p>
<p><b style="color:red">现在我们描述一个利用椭圆曲线进行加密通信的过程</b>：</p>
<ol>
<li>A机器选定一条椭圆曲线 Ep(a,b) 并取椭圆曲线上一点，作为基点G。</li>
<li>A机器选择一个私有密钥k，并生成公开密钥 K=kG。</li>
<li>A机器将 Ep(a,b) 和点K，G传给用户B。</li>
<li>B机器接到信息后 ，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r。</li>
<li>B机器计算。<code>C1 = M + rK; C2=rG.</code></li>
<li>B机器将点C1、C2传给A机器。</li>
<li>A接到信息后，计算C1-kC2，结果就是点M。因为<code>C1-kC2=M+rK-k(rG)=M+rk-r(kG)=M</code>, 再对点M进行解码就可以得到明文。这样值就通过0运算神奇地还原了，注意这里的计算一是设计椭圆计算，椭圆计算是基于数学计算的过程的。</li>
</ol>
<p>在这个加密通信中，如果有一个偷窥者H ，他只能看到Ep(a,b)、K、G、C1、C2，而通过K、G 求k 或通过C2、G求r 都是相对困难的，因此，H无法得到A、B间传送的明文信息。</p>
<h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><p>是基于ECC（Elliptic Curve Cryptosystems，椭圆曲线密码体制，参看ECC）的DH（ Diffie-Hellman）密钥交换算法。其实就是双方互相传送公钥，然后通过双方的公钥计算出双方都知道的加密密钥S（注意这里面没有随机数传送，所以整个过程是安全的。）。</p>
<p>该算法可以用来解决如下问题：两端（Alice 和 Bob）想要安全的交换信息并且第三方不能获取到该信息。当然这是TLS协议中的目的之一，我们给出一个例子。<br>（其实下面的描述其实是ECDHE,而不是ECDH）</p>
<ol>
<li>Alice 和 Bob 生成他们自己的私钥和公钥，即Alice 有 da、Ha = da<em>G；Bob有db、Hb = db </em>G </li>
<li>Alice把Ha发给Bob，Bob把Hb发给Alice。这样Alice 有da,Ha,Hb，Bob有db,Ha,Hb。 </li>
<li>Alice计算S = da<em>Hb（即自己的私钥乘上Bob的公钥），同样的，Bob计算S = db</em>Ga（自己的私钥乘上Alice的公钥）。两边计算的S是相同的。</li>
</ol>
<h2 id="ECDSA签名算法"><a href="#ECDSA签名算法" class="headerlink" title="ECDSA签名算法"></a>ECDSA签名算法</h2><p><b style="color:red">现在有一个场景：Alice想要用私钥签名一个数据，Bob想要使用Alice的公钥验证这个签名；只有Alice能够进行计算签名然后得到签名，每个人都能验证签名值。</b></p>
<p>首先Alice和Bob拥有相同的椭圆曲线参数，算法被签名称之为ECDSA，是DSA算法的一个变体。</p>
<p><b style="color:red">ECDSA签名算法的输入 是 数据的哈希值</b>，而不是数据的本身，至于哈希算法选用哪一个就取决于自己了。为了使得ECDSA的输入值的比特数和子群的阶n的比特数一样，哈希值可能会被截断。我们把ECDSA输入称之为Z。<br>算法工作流程如下： </p>
<ol>
<li>取一个范围在[1, n - 1]的随机数k </li>
<li>计算点P=kG (就是计算出公钥)</li>
<li>计算r = x<sub>P</sub> mod n （算出r的值，n是基点的阶）</li>
<li>如果 r == 0，执行第一步 </li>
<li>计算s = k<sup>-1</sup> (z + r*d<sub>A</sub>) mod n （d<sub>A</sub>是Alice的公钥，k<sup>-1</sup> 是 k 对n的逆元, k是上面的随机数） </li>
<li>如果s==0，执行第一步 </li>
<li>二元组(r, s)就是签名值 </li>
</ol>
<p><img src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E7%AE%97%E6%B3%95/ecdsa%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p>上图中，Alice使用私钥da对z进行签名，生成二元组(r, s)。<br>Bob使用Alice的公钥对(r, s)和Z进行验证。</p>
<p>现在我们来看看Bob如何验证的： </p>
<ol>
<li>计算u<sub>1</sub> = s<sup>-1</sup> * z mod n </li>
<li>计算u<sub>2</sub> = s<sup>-1</sup> * r mod n </li>
<li>计算P = u<sub>1</sub>*G + u<sub>2</sub>*H<sub>A</sub></li>
<li>如果r == x<sub>P</sub> mod n，则验证正确</li>
</ol>
<p>过程证明请查看相应的引用。</p>
<h2 id="椭圆算法总结"><a href="#椭圆算法总结" class="headerlink" title="椭圆算法总结"></a>椭圆算法总结</h2><p>通过最后的示例我们可以看出，椭圆算法的公私钥其实是一样的，其实说白了就双方都不需要知晓别人给定的那个k和r的值，因为kr相乘之后，大家的值都是一致的，但是不能在网上随便传输k和r的值吧，这样还有什么安全性，这里很巧妙地利用了归的技术，隐藏了这种特性的原始值。这种特性就是椭圆曲线的对称性而衍生的阿贝尔群的特性。</p>
<p>鉴于np=0，所以一个私钥理论上是可以对应多个公钥的，一个公钥也可以对应多个私钥。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://www.jianshu.com/p/2e6031ac3d50" target="_blank" rel="noopener">椭圆曲线算法：入门（1）</a><br><a href="https://4hou.win/wordpress/?p=12084" target="_blank" rel="noopener">椭圆曲线算法（ECC）学习（一)</a><br><a href="http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch04.html" target="_blank" rel="noopener">钱包和地址</a><br><a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/" target="_blank" rel="noopener">Elliptic Curve Cryptography: a gentle introduction</a><br><a href="http://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/" target="_blank" rel="noopener">Elliptic Curve Cryptography: finite fields and discrete logarithms</a><br><a href="https://blog.csdn.net/mrpre/article/details/72850598" target="_blank" rel="noopener">有限域和离散对数问题(ECC椭圆曲线算法2)</a><br><a href="https://blog.csdn.net/mrpre/article/details/72850644" target="_blank" rel="noopener">ECDH and ECDSA(ECC椭圆曲线算法3)</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/23/blockchain/共识算法概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/blockchain/共识算法概述/" itemprop="url">共识算法概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T15:46:06+08:00">2018-03-23</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一开始就认为共识算法其实比较简单，但是一直没有认真地总结，导致这块知识一直都是短板。其实共识算法的本质是分布式一致性的问题，但是显然这和分布式一致性略有区别。有以下两个主要的区别：</p>
<ol>
<li>传统的分布式一致性算法认为，每个节点都不会欺诈，如果出现问题一般都是网络分区，请求顺序的问题。但是共识算法不能保证每一个节点都是正常节点，可能就是欺诈节点。</li>
<li>传统的一致性算法只要有值就行，不太关心哪个节点写入数据。<b style="color:red">但是共识算法，必须公平地对待每一个节点，选取这个节点必须是公平的，于是就有了POW和POS机制的出现。这个就好像是选择值本来一个很纯粹的事情绑定了特定的业务，所以要处理的事情就变得很复杂了。所以在分析共识算法的时候要将这个点剥离出来，拨出来之后这就是一个分布式一致性的问题。</b></li>
</ol>
<p>所以说共识算法，剥离了上面两个方面的因素就是一个纯粹的分布式一致性算法。<b style="color:red">其实说白了共识算法就是分布式一致性在P2P网络中的应用。</b></p>
<p>其他的分布式协议：<a href="/2018/03/22/算法/Paxos协议详解/">Paxos</a>、<a href="/2018/03/23/算法/Raft算法简介/">Raft</a>。</p>
<h2 id="从拜占庭将军问题谈起"><a href="#从拜占庭将军问题谈起" class="headerlink" title="从拜占庭将军问题谈起"></a>从拜占庭将军问题谈起</h2><p>这是一个很经典的分布式一致性问题的提出，这里我们就不做很多的说明。可以查看维基百科中关于这点的描述。</p>
<h2 id="拜占庭容错-BFT"><a href="#拜占庭容错-BFT" class="headerlink" title="拜占庭容错 BFT"></a>拜占庭容错 BFT</h2><p>这是拜占庭将军问题的早期的解决方案。在1982年的论文中提过几个解决方案。方案中把问题往下拆解，认为在“拜占庭将军”的问题可以在“军官与士官的问题”里解决，以降低将军问题的发生。而所谓的“军官与士官的问题”，就是探讨军官与他的士官是否能忠实实行命令。</p>
<p>其中一个解决方案认为即使出现了伪造或错误的消息。只要有问题的将军的数量不到三分之一，仍可以达到“拜占庭容错”。原因是把同样的标准下放到“军官与士官的问题”时，在背叛的军士官不足三分之一的情况下，有问题的军士官可以很容易的被纠出来。<b style="color:blue">比如有军官A，士官B与士官C。当A要求B进攻，却要求C撤退时</b>。<b style="color:red">只要B与C交换所收到的命令，就会立刻发现A有问题</b>。<b style="color:blue">以函数来表示，将军的总数为n，n里面背叛者的数量为t，则只要n &gt; 3t就可以容错。</b></p>
<p><b style="color:red">另一个解决方案需要有无法消去的签名。在现今许多高度信息安全要求的关键系统里，数字签名就经常被用来实现拜占庭容错，找出有问题的将军。然而，在生命攸关系统里，使用 错误侦测码就可以大幅降低问题的发生。无论系统是否存在拜占庭将军问题。所以需要做密码军算的数字签名也不一定适合这类系统。</b></p>
<p>假如上述两个解决方案里，将军们无法直接通信时，该论文亦有进一步的解决方案。<br>此外，1980年代还有其他用来达到拜占庭容错的架构被提出，如：FTMP、MMFCS 与 SIFT。</p>
<h2 id="使用拜占庭容错算法-PBFT"><a href="#使用拜占庭容错算法-PBFT" class="headerlink" title="使用拜占庭容错算法 PBFT"></a>使用拜占庭容错算法 PBFT</h2><p>1999年，卡斯托（Miguel Castro）与李斯克夫（Barbara Liskov）提出了实用拜占庭容错（PBFT）算法。该算法能提供高性能的运算，使得系统可以每秒处理成千的请求，比起旧式系统快了一些。<b style="color:red">后来也有针对BFT算法的各种优化版，但是优化的方向不同，有的是为了加强健壮性，有的是为了加强网络速度等。</b>下面来提一下这个PBFT算法的一些简要知识，具体请查看：<a href="https://www.jianshu.com/p/1e2acd3cbd9f" target="_blank" rel="noopener">实用拜占庭容错算法PBFT</a></p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/%E7%AE%97%E6%B3%95/PBFT%E6%B5%81%E7%A8%8B.png?raw=true" alt="PFBT流程图"><br>上面是PBFT的图示，下面我们讲个上面流程的故事。</p>
<ol>
<li>总司令给军长下命令向前行军500公里；</li>
<li>军长将消息（不只有命令）传递给所有师长；</li>
<li>1号2号师长又把消息传给其他师长，3号师长处于叛逃状态；</li>
<li>军长再次询问各位师长是否同意执行命令。</li>
<li>所有军官（包括军长和师长）向总司令汇报结果。</li>
</ol>
<p><b style="color:blue">这个算法的实用性为何高于BFT呢？因为在BFT的描述中，我们可以发现每个节点都不知道其他节点的情况，都会去询问所有的人他们所获得情况，进而做出自己的判断（只要大多数人同意的就是正确的）。这个过程达成一致性的时间比较长，而且耗费大量的P2P网络资源，不适合共识算法（规模不大是可以的）</b>。<b style="color:red">PBFT算法就是校验放给一个人去校验就可以了，而不需要全体所有的人来进行校验，你也不知道进行校验的人是谁，所以是安全的，分布式一致性也很容易达成。</b></p>
<h2 id="节点验证的机制"><a href="#节点验证的机制" class="headerlink" title="节点验证的机制"></a>节点验证的机制</h2><p>节点验证的方式其实是两方面的，一是节点未篡改通讯协议，二是节点的选举极具公平意义。现在区块链上的实现主要是POW和POS两种方式。</p>
<h2 id="工作量证明-POW"><a href="#工作量证明-POW" class="headerlink" title="工作量证明 POW"></a>工作量证明 POW</h2><p>这是比特币使用的共识机制，主要是通过不停地hash计算，算出nonce已满足难度系数。这样请求不易伪造，而且谁先解决难题谁就有记账权，我觉得这个是不可被攻击的。要想攻击必须具有51%以上的算力。</p>
<h2 id="权益证明-POS"><a href="#权益证明-POS" class="headerlink" title="权益证明 POS"></a>权益证明 POS</h2><p>这种安全的机制比较简单就是你持有币所获得的权限。</p>
<p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 </p>
<p>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p>
<h2 id="委任权益证明-DPOS"><a href="#委任权益证明-DPOS" class="headerlink" title="委任权益证明 DPOS"></a>委任权益证明 DPOS</h2><p>比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p>
<h2 id="Casper"><a href="#Casper" class="headerlink" title="Casper"></a>Casper</h2><p>这个协议也是POS，是以太坊正在开发的下一代以太坊共识协议。</p>
<p>以太坊社区提出的正在研发中的共识协议名为Casper。Casper的基本思路是，任何人抵押足够多的以太币到系统中就可以成为矿工参与到挖矿过程。共识算法要求所有的矿工诚实工作，如果一个矿工有意破坏，不遵守协议，系统就会对矿工做出惩罚：没收之前抵押的以太币。有人把Casper这样的挖矿机制称为“虚拟挖矿”，比特币的矿工要参与挖矿需要先购买矿机，Casper则要先抵押以太币到系统中；比特币的矿工如果不按规则挖矿，则会损失电费以及可能的挖矿收益，而Casper中，不守规则的惩罚更为严重，除了失去挖矿收益，还要销毁“矿机”：抵押的以太币会被系统没收！</p>
<h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图 DAG"></a>有向无环图 DAG</h2><p>DAG则采用异步机制替代链式检查点的同步策略，在优秀的软件实现中如果能够有效控制网络风暴带来的带宽需求指数增加，其不失为一种对最终一致性场景有较好应用前景的算法。但是DAG的局限性也极为明显，其体系无法被利用在需要进行同步操作或一致性要求较高的操作中（例如支付结算等）。</p>
<p>第一次提出DAG跟区块链结合是在Nxt社区，可以发现DAG最初出现就是为了解决区块链的效率问题。比特币的效率一直比较低，基于工作量证明共识下的出块机制是一个原因，由于链式的存储结构，整个网络中同时只能有一条链，导致出块无法并发执行。社区有人提出DAG的拓扑结构来存储区块，这个时候更多还是类似侧链的解决思路，不同的链条存储不同类型的交易，这样降低出现双花的可能，在之后某个节点需要合并的时候，几个分支再归并到一个区块。</p>
<h2 id="共识规则和软分叉"><a href="#共识规则和软分叉" class="headerlink" title="共识规则和软分叉"></a>共识规则和软分叉</h2><p>共识规则决定着每个交易或每个区块的有效性。比特币网络上的每个用户和矿工都遵守着同一套共识规则，代表着他们都愿意接受和同意一个账本。</p>
<p>当大多数用户和/或矿工决定采用更严格的共识规则时，软分叉就可能出现，这使一些以前有效的交易/区块将变为无效，而不是相反。如果大多数人执行新的规则的话，其他任何违规分叉（统计上）都不会在工作量证明方面赶上新的更严格的共识分叉。遵守旧规则的少数人将始终遵循更长，更严格的分叉，使得网络上的每个人都会最终接受和同意一个账本。</p>
<p>关于分叉的更多知识，我觉得<a href="http://me.tryblockchain.org/blockchain-dpos-bm-eos.html" target="_blank" rel="noopener">DPOS共识算法-by BM</a>这篇文档讲得挺好的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共识算法的知识很多这里就不做更多地说明了。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98#%E5%AF%A6%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%8C%AF" target="_blank" rel="noopener">拜占庭将军问题</a><br><a href="https://www.jianshu.com/p/1e2acd3cbd9f" target="_blank" rel="noopener">实用拜占庭容错算法PBFT</a><br><a href="https://www.jianshu.com/p/fb5edf031afd" target="_blank" rel="noopener">区块链核心技术：拜占庭共识算法之PBFT</a><br><a href="http://www.chidaolian.com/article-680-1" target="_blank" rel="noopener">案例分析软分叉的艺术——政策规则保护</a><br><a href="http://8btc.com/thread-40113-1-1.html" target="_blank" rel="noopener">以太坊紫皮书（中文版）</a><br><a href="https://blog.csdn.net/lsttoy/article/details/61624287" target="_blank" rel="noopener">[区块链]共识算法（POW,POS,DPOS,PBFT）介绍和心得</a><br><a href="http://8btc.com/thread-35475-1-1.html" target="_blank" rel="noopener">以太坊共识协议Casper原理是怎样的？</a><br><a href="http://chainx.org/news/index/detail/id/14.html" target="_blank" rel="noopener">拜占庭容错(BFT)算法介绍</a><br><a href="http://www.btc38.com/others/other_all/49.html" target="_blank" rel="noopener">加密的钱包如何获得POS利息</a><br><a href="http://www.btc38.com/altcoin/general/47.html" target="_blank" rel="noopener">深度教程：POS和POW全解析</a><br><a href="http://www.chidaolian.com/article-828-8" target="_blank" rel="noopener">盘点区块链共识机制——论PoW，PoS，DPos和DAG的优缺点对比分析</a><br><a href="https://www.7234.cn/dag/36392" target="_blank" rel="noopener">DAG也许是真正的区块链3.0</a><br><a href="http://me.tryblockchain.org/blockchain-dpos-bm-eos.html" target="_blank" rel="noopener">DPOS共识算法-by BM</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/23/算法/Raft算法简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/算法/Raft算法简介/" itemprop="url">Raft算法简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T11:24:29+08:00">2018-03-23</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分布式一致性算法中大家最熟悉还是Paxos，但是这个算法理解起来比较难，实现这个算法的难度也很高，最后都会对协议本身进行修改实现。</p>
<p>为了提高理解性，Raft 将一致性算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须需要考虑的状态。</p>
<h2 id="几个特性"><a href="#几个特性" class="headerlink" title="几个特性"></a>几个特性</h2><ul>
<li>强领导者（Strong Leader）：Raft 使用一种比其他算法更强的领导形式。例如，日志条目只从领导者发送向其他服务器。这样就简化了对日志复制的管理，使得 Raft 更易于理解。</li>
<li>领导选取（Leader Selection）：Raft 使用随机定时器来选取领导者。这种方式仅仅是在所有算法都需要实现的心跳机制上增加了一点变化，它使得在解决冲突时更简单和快速。</li>
<li>成员变化（Membership Change）：Raft 为了调整集群中成员关系使用了新的联合一致性（joint consensus）的方法，这种方法中大多数不同配置的机器在转换关系的时候会交迭（overlap）。这使得在配置改变的时候，集群能够继续操作。</li>
</ul>
<h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>分布式一致性的解决方案就是<b style="color:red">复制状态机</b>, 在一组服务器的状态机产生同样的状态的副本因此即使有一些服务器崩溃了这组服务器也还能继续执行。<b style="color:red">但是集群中有一个Leader节点，Leader选举是使用一个单独的复制状态机,并存储配置信息，防止leader崩溃。</b></p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/%E7%AE%97%E6%B3%95/%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA.jpg?raw=true" alt=""></p>
<p>从图上我们可以发现共识模块是处理分布式一致性的，Log模块记录操作的记录（这个操作很重要），最后是每台机器的状态机。<b style="color:red">复制状态机是通过复制日志实现的，每台服务器都保存一份日志，日志中包含一系列的命令，状态机会按照顺序执行这些命令。</b></p>
<p>应用于实际系统的一致性算法一般有以下特性：</p>
<ul>
<li>确保安全性（从来不会返回一个错误的结果），即使在所有的非拜占庭（Non-Byzantine）情况下，包括网络延迟、分区、丢包、冗余和乱序的情况下。</li>
<li>高可用性，只要集群中的大部分机器都能运行，可以互相通信并且可以和客户端通信，这个集群就可用。</li>
<li>不依赖时序保证一致性，时钟错误和极端情况下的消息延迟在最坏的情况下才会引起可用性问题。</li>
<li>通常情况下，一条命令能够尽可能快的在大多数节点对一轮远程调用作出相应时完成，一少部分慢的机器不会影响系统的整体性能。</li>
</ul>
<h2 id="易于理解的设计"><a href="#易于理解的设计" class="headerlink" title="易于理解的设计"></a>易于理解的设计</h2><p>设计 Raft 的目标有如下几个（我想任何算法都应该是这样的）：</p>
<ul>
<li>能提供一个完整的、实际的基础来进行系统构建，减少开发者的工作</li>
<li>在任何情况下都能保证安全可用。</li>
<li>对于常规的操作，必须是高效的。</li>
<li>易于理解（这样才能便于应用）</li>
<li>它必须能让开发者有一个直观的认识，这样才能使系统构建者们去对它进行扩展。（其实我觉得这点有点啰嗦）</li>
</ul>
<p>Raft使用了两种方式来简化算法的复杂度。</p>
<p><b style="color:blue">一是问题分解</b>：尽可能将问题分解成为若干个可解决的、可被理解的小问题。例如，在 Raft 中，我们把问题分解成为了<b style="color:blue">领导选取（leader election）</b>、<b style="color:blue">日志复制（log replication）</b>、<b style="color:blue">安全（safety）</b>和<b style="color:blue">成员变化（membership changes）</b>。</p>
<p><b style="color:blue">第二个方法是通过减少需要考虑的状态的数量将状态空间简化，这能够使得整个系统更加一致并且尽可能消除不确定性。</b>特别地，日志之间不允许出现空洞，并且 Raft 限制了限制了日志不一致的可能性。尽管在大多数情况下，我们都都在试图消除不确定性，但是有时候有些情况下，不确定性使得算法更易理解。尤其是，随机化方法使得不确定性增加，但是它减少了状态空间。我们使用随机化来简化了 Raft 中的领导选取算法。</p>
<h2 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>在所有服务器上持久存在的：（在响应远程过程调用 RPC 之前稳定存储的）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>currentTerm</td>
<td>服务器最后知道的任期号（从0开始递增）</td>
</tr>
<tr>
<td>votedFor</td>
<td>在当前任期内收到选票的候选人 id（如果没有就为 null）</td>
</tr>
<tr>
<td>log[]</td>
<td>日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号</td>
</tr>
</tbody>
</table>
<p>在所有服务器上不稳定存在的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>commitIndex</td>
<td>已知的被提交的最大日志条目的索引值（从0开始递增）</td>
</tr>
<tr>
<td>lastApplied</td>
<td>被状态机执行的最大日志条目的索引值（从0开始递增）</td>
</tr>
</tbody>
</table>
<p>在领导人服务器上不稳定存在的：（在选举之后初始化的）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nextIndex[]</td>
<td>对于每一个服务器，记录需要发给它的下一个日志条目的索引（初始化为领导人上一条日志的索引值+1）</td>
</tr>
<tr>
<td>matchIndex[]</td>
<td>对于每一个服务器，记录已经复制到该服务器的日志的最高索引值（从0开始递增）</td>
</tr>
</tbody>
</table>
<p><b style="color:red">这个是每台机器内部的状态量，根据这些信息我们可以查看相应的节点状态，每个节点也可以通过这些状态来检查网络中各节点的状态，最终需要leader节点进行同步。</b></p>
<h3 id="附加日志远程过程调用-（AppendEntries-RPC）"><a href="#附加日志远程过程调用-（AppendEntries-RPC）" class="headerlink" title="附加日志远程过程调用 （AppendEntries RPC）"></a>附加日志远程过程调用 （AppendEntries RPC）</h3><p>由领导人来调用复制日志（5.3节）；也会用作heartbeat</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>term</td>
<td>领导人的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>领导人的 id，为了其他服务器能重定向到客户端</td>
</tr>
<tr>
<td>prevLogIndex</td>
<td>最新日志之前的日志的索引值</td>
</tr>
<tr>
<td>prevLogTerm</td>
<td>最新日志之前的日志的领导人任期号</td>
</tr>
<tr>
<td>entries[]</td>
<td>将要存储的日志条目（表示 heartbeat 时为空，有时会为了效率发送超过一条）</td>
</tr>
<tr>
<td>leaderCommit</td>
<td>领导人提交的日志条目索引值</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>term</td>
<td>当前的任期号，用于领导人更新自己的任期号</td>
</tr>
<tr>
<td>success</td>
<td>如果其它服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td>
</tr>
</tbody>
</table>
<p>接受者需要实现：</p>
<ol>
<li>如果 term &lt; currentTerm返回 false（5.1节）(这个应该是发现了最新的leader)</li>
<li>如果在prevLogIndex处的日志的任期号与prevLogTerm不匹配时，返回 false（5.3节）（发现问题，3解决）</li>
<li>如果一条已经存在的日志与新的冲突（index 相同但是任期号 term 不同），则删除已经存在的日志和它之后所有的日志（5.3节）（解决2中存在的问题，回滚）</li>
<li>添加任何在已有的日志中不存在的条目（恢复数据）</li>
<li>如果leaderCommit &gt; commitIndex，将commitIndex设置为leaderCommit和最新日志条目索引号中较小的一个（获取新日志后更新）</li>
</ol>
<p><b style="color:red">这个心跳检测和同步日志消息其实就是检测当前节点与Leader节点异同，如果发现数据异常，根据Leader节点的数据进行回滚，拉取最新的日志，根据日志恢复状态机。如果发现漏了很多日志就同步日志恢复状态机。</b></p>
<h3 id="投票请求RPC（RequestVote-RPC）"><a href="#投票请求RPC（RequestVote-RPC）" class="headerlink" title="投票请求RPC（RequestVote RPC）"></a>投票请求RPC（RequestVote RPC）</h3><p>由候选人发起收集选票（5.2节）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>term</td>
<td>候选人的任期号</td>
</tr>
<tr>
<td>candidateId</td>
<td>请求投票的候选人 id</td>
</tr>
<tr>
<td>lastLogIndex</td>
<td>候选人最新日志条目的索引值</td>
</tr>
<tr>
<td>lastLogTerm</td>
<td>候选人最新日志条目对应的任期号</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>term</td>
<td>目前的任期号，用于候选人更新自己</td>
</tr>
<tr>
<td>voteGranted</td>
<td>如果候选人收到选票为 true</td>
</tr>
</tbody>
</table>
<p>接受者需要实现：</p>
<ol>
<li>如果term &lt; currentTerm返回 false（5.1节）(可能是旧的Leader，但现在有新的了，忽略)</li>
<li>如果votedFor为空或者与candidateId相同，并且候选人的日志和自己的日志一样新，则给该候选人投票（5.2节 和 5.4节）</li>
</ol>
<p><b style="color:blue">服务器需要遵守的规则：</b></p>
<p>所有服务器：</p>
<ul>
<li>如果commitIndex &gt; lastApplied，lastApplied自增，将log[lastApplied]应用到状态机（5.3节）</li>
<li>如果 RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则currentTerm赋值为 T，并切换状态为追随者（Follower）（5.1节）</li>
</ul>
<p>追随者（followers）: 5.2节</p>
<ul>
<li>响应来自候选人和领导人的 RPC</li>
<li><b style="color:red">如果在超过选取领导人时间之前没有收到来自当前领导人的AppendEntries RPC或者没有收到候选人的投票请求，则自己转换状态为候选人</b></li>
</ul>
<p>候选人：5.2节</p>
<ul>
<li>转变为选举人之后开始选举：<ul>
<li>currentTerm自增</li>
<li>给自己投票</li>
<li>重置选举计时器</li>
<li>向其他服务器发送RequestVote RPC</li>
</ul>
</li>
<li>如果收到了来自大多数服务器的投票：成为领导人</li>
<li><b style="color:red">如果收到了来自新领导人的AppendEntries RPC（heartbeat）：转换状态为追随者</b></li>
<li>如果选举超时：开始新一轮的选举</li>
</ul>
<p>领导人：</p>
<ul>
<li>一旦成为领导人：向其他所有服务器发送空的AppendEntries RPC（heartbeat）;在空闲时间重复发送以防止选举超时（5.2节）</li>
<li>如果收到来自客户端的请求：向本地日志增加条目，在该条目应用到状态机后响应客户端（5.3节）</li>
<li>对于一个追随者来说，如果上一次收到的日志索引大于将要收到的日志索引（nextIndex）：通过AppendEntries RPC将 nextIndex 之后的所有日志条目发送出去</li>
<li>如果发送成功：将该追随者的 nextIndex和matchIndex更新</li>
<li>如果由于日志不一致导致AppendEntries RPC失败：nextIndex递减并且重新发送（5.3节）</li>
<li>如果存在一个满足N &gt; commitIndex和matchIndex[i] &gt;= N并且log[N].term == currentTerm的 N，则将commitIndex赋值为 N</li>
</ul>
<h3 id="Raft-一致性算法的特性"><a href="#Raft-一致性算法的特性" class="headerlink" title="Raft 一致性算法的特性"></a>Raft 一致性算法的特性</h3><p>Raft 算法保证这些特性任何时刻都成立</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>选举安全原则（Election Safety）</td>
<td>一个任期（term）内最多允许有一个领导人被选上（5.2节）</td>
</tr>
<tr>
<td>领导人只增加原则（Leader Append-Only）</td>
<td>领导人永远不会覆盖或者删除自己的日志，它只会增加条目</td>
</tr>
<tr>
<td>日志匹配原则（Log Matching）</td>
<td>如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同（5.3 节）</td>
</tr>
<tr>
<td>领导人完全原则（Leader Completeness)</td>
<td>如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的领导人中</td>
</tr>
<tr>
<td>状态机安全原则（State Machine Safety）</td>
<td>如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目（5.4.3节）</td>
</tr>
</tbody>
</table>
<p><b style="color:red">Raft 通过首先选出一个领导人来实现一致性，然后给予领导人完全管理复制日志（replicated log）的责任。领导人接收来自客户端的日志条目，并把它们复制到其他的服务器上，领带人还要告诉服务器们什么时候将日志条目应用到它们的状态机是安全的。通过选出领导人能够简化复制日志的管理工作。例如，领导人能够决定将新的日志条目放到哪，而并不需要和其他的服务器商议，数据流被简化成从领导人流向其他服务器。如果领导人宕机或者和其他服务器失去连接，就可以选取下一个领导人。</b></p>
<p>通过选出领导人，Raft 将一致性问题分解成为三个相对独立的子问题：</p>
<ul>
<li>领导人选取（Leader election）： 在一个领导人宕机之后必须要选取一个新的领导人（5.2节）</li>
<li>日志复制（Log replication）： 领导人必须从客户端接收日志然后复制到集群中的其他服务器，并且强制要求其他服务器的日志保持和自己相同</li>
<li>安全性（Safety）： Raft 的关键的安全特性是 表-3 中提到的状态机安全原则（State Machine Safety）:如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目。5.4节阐述了 Raft 是如何保证这条原则的，解决方案涉及到一个对于选举机制另外的限制，这一部分会在 5.2节 中说明。</li>
</ul>
<p>在说明了一致性算法之后，本章会讨论有关可用性（availability）的问题和系统中时序（timing）的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>raft的Leader选举机制和策略总觉得和redis的集群模式很像，后来查看资料，果然redis内部使用的就是raft协议。也就大概明白raft协议的意思了。这里就不再过多地去说明了。</p>
<p>但是论文的后面还有大量的实现说明，我在讨论了，可以查看论文原文，里面提到了很多细节问题，都是我们不得不考虑的事情。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://www.infoq.com/cn/articles/raft-paper#" target="_blank" rel="noopener">Raft 一致性算法论文译文</a><br><a href="http://blog.csdn.net/gBbQRglVIr3dYi82/article/details/79386536" target="_blank" rel="noopener">图解分布式协议-RAFT</a><br><a href="https://blog.csdn.net/sanwenyublog/article/details/53385616" target="_blank" rel="noopener">redis集群实现(五) sentinel的架构与raft协议</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">97</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">92</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
