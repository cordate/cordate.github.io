<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/page/4/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/03/blockchain/Solidity单位和全局可用变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/blockchain/Solidity单位和全局可用变量/" itemprop="url">Solidity单位和全局可用变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T16:48:18+08:00">2018-04-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ether单位"><a href="#Ether单位" class="headerlink" title="Ether单位"></a>Ether单位</h2><p>字面上的Ether数量可以采取的后缀<code>wei</code>，<code>finney</code>，<code>szabo</code>或<code>ether</code>，没有Ether后缀，货币数字subdenominations之间的转换单位假定是<code>wei</code>，如<code>2 ether == 2000 finney</code>, 这个值为true</p>
<h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>像后缀<code>seconds</code>，<code>minutes</code>，<code>hours</code>，<code>days</code>，<code>weeks</code>和 <code>years</code>文字数字后可以用于时间单位，其中秒是基本单元和单位之间的转换如下：</p>
<ul>
<li>1 == 1 seconds</li>
<li>1 minutes == 60 seconds</li>
<li>1 hours == 60 minutes</li>
<li>1 days == 24 hours</li>
<li>1 weeks == 7 days</li>
<li><code>1 years == 365 days</code></li>
</ul>
<p><b style="color:blue">请注意，如果您使用这些单位执行日历计算，因为不是每年都等于365天，甚至因为闰秒而不是每天都有24小时。由于闰秒无法预测，因此必须通过外部oracle更新确切的日历库。</b></p>
<p>这些后缀不能应用于变量(<b style="color:red">因为这些是字面量，solidity引入的新的概念很重要</b>)。如果你想在例如几天内解释一些输入变量，你可以通过以下方式来完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) &#123;</span><br><span class="line">    if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="特殊变量和函数"><a href="#特殊变量和函数" class="headerlink" title="特殊变量和函数"></a>特殊变量和函数</h2><p><b style="color:red">全局命名空间中总是存在特殊的变量和方法，主要用于提供有关区块链的信息。</b></p>
<h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性</h3><ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的散列 - 仅适用于256个最新块，不包括当前块</li>
<li><code>block.coinbase(address)</code>：当前区块矿工的地址</li>
<li><code>block.difficulty(uint)</code>：当前区块困难</li>
<li><code>block.gaslimit(uint)</code>：当前区块的gaslimit</li>
<li><code>block.number(uint)</code>：当前区块的块高</li>
<li><code>block.timestamp(uint)</code>：当前区块时间戳记，因为unix时期以来的秒数</li>
<li><code>msg.data(bytes)</code>：完整的calldata</li>
<li><code>msg.gas(uint)</code>：剩余gas</li>
<li><code>msg.sender(address)</code>：消息的发送者（当前调用者）</li>
<li><code>msg.sig(bytes4)</code>：calldata的前四个字节（即函数标识符）</li>
<li><code>msg.value(uint)</code>：与消息一起发送的wei的数量</li>
<li><code>now(uint)</code>：当前区块时间戳（别名为block.timestamp）</li>
<li><code>tx.gasprice(uint)</code>：交易的gas价格</li>
<li><code>tx.origin(address)</code>：交易的发送者（完整的调用链）</li>
</ul>
<p><b style="color:#6ab0de">每个外部函数调用都可以修改msg所有成员的值，包括msg.sender和 msg.value也都可以更改。这包括调用库函数。</b></p>
<p><b style="color:#6ab0de">不要依赖<code>block.timestamp</code>，<code>now</code>和<code>block.blockhash</code>作为随机的来源，除非你知道自己在做什么。<br>在一定程度上，时间戳和区块哈希都会受到矿工的影响。例如，矿工社区中的不良者可以对选定的散列运行赌场支付功能，如果他们没有收到任何钱，只需重试一次不同的散列。<br>当前块时间戳必须严格大于最后一个块的时间戳，但唯一的保证是它将位于规范链中两个连续块的时间戳之间的某处。</b></p>
<p><b style="color:#6ab0de">如果要使用库函数实现访问限制 msg.sender，则必须手动提供值 msg.sender作为参数。</b></p>
<p><b style="color:#6ab0de">出于可伸缩性原因，块哈希不可用于所有块。您只能访问最近256个块的哈希，其他所有值都将为零。</b></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="assert-bool-condition-："><a href="#assert-bool-condition-：" class="headerlink" title="assert(bool condition)："></a><code>assert(bool condition)</code>：</h3><p>如果条件不满足则抛出 - 用于内部错误。</p>
<h3 id="require-bool-condition-："><a href="#require-bool-condition-：" class="headerlink" title="require(bool condition)："></a><code>require(bool condition)</code>：</h3><p>如果条件未满足则抛出 - 用于输入或外部组件中的错误。</p>
<h3 id="revert-："><a href="#revert-：" class="headerlink" title="revert()："></a><code>revert()</code>：</h3><p>中止执行并恢复状态更改</p>
<h2 id="数学和加密函数"><a href="#数学和加密函数" class="headerlink" title="数学和加密函数"></a>数学和加密函数</h2><h3 id="addmod-uint-x-uint-y-uint-k-returns-uint-："><a href="#addmod-uint-x-uint-y-uint-k-returns-uint-：" class="headerlink" title="addmod(uint x, uint y, uint k) returns (uint)："></a><code>addmod(uint x, uint y, uint k) returns (uint)</code>：</h3><p>添加以任意精度执行的时候，计算<code>(x + y) % k</code>，并且不会环绕在<code>2**256</code>。断言<code>k!=0</code>从0.5.0版开始。</p>
<h3 id="mulmod-uint-x-uint-y-uint-k-returns-uint-："><a href="#mulmod-uint-x-uint-y-uint-k-returns-uint-：" class="headerlink" title="mulmod(uint x, uint y, uint k) returns (uint)："></a><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：</h3><p>在以任意精度执行乘法的时候，计算<code>(x * y) % k</code>，并且不会绕回<code>2**256</code>。断言<code>k!=0</code>从0.5.0版开始。</p>
<h3 id="keccak256-returns-bytes32-："><a href="#keccak256-returns-bytes32-：" class="headerlink" title="keccak256(...) returns (bytes32)："></a><code>keccak256(...) returns (bytes32)</code>：</h3><p>计算（<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-packed-mode" target="_blank" rel="noopener">紧密排列的</a>）参数的Ethereum-SHA-3（Keccak-256）散列</p>
<h3 id="sha256-returns-bytes32-："><a href="#sha256-returns-bytes32-：" class="headerlink" title="sha256(...) returns (bytes32)："></a><code>sha256(...) returns (bytes32)</code>：</h3><p>计算（<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-packed-mode" target="_blank" rel="noopener">紧密排列</a>）参数的SHA-256哈希值</p>
<h3 id="sha3-…-returns-bytes32-："><a href="#sha3-…-returns-bytes32-：" class="headerlink" title="sha3(…) returns (bytes32)："></a>sha3(…) returns (bytes32)：</h3><p>别名 keccak256</p>
<h3 id="ripemd160-returns-bytes20-："><a href="#ripemd160-returns-bytes20-：" class="headerlink" title="ripemd160(...) returns (bytes20)："></a><code>ripemd160(...) returns (bytes20)</code>：</h3><p>计算（紧密排列）参数的 RIPEMD-160哈希值</p>
<h3 id="ecrecover-bytes32-hash-uint8-v-bytes32-r-bytes32-s-returns-address-："><a href="#ecrecover-bytes32-hash-uint8-v-bytes32-r-bytes32-s-returns-address-：" class="headerlink" title="ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)："></a><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：</h3><p>从椭圆曲线签名中恢复与公钥相关的地址，或在错误时返回零（<a href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio" target="_blank" rel="noopener">示例用法</a>）</p>
<p><b style="color:red">在上面，“紧密排列”意味着这些参数是连续的而没有填充。这意味着以下几点完全相同：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line">keccak256(0x616263)</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)</span><br></pre></td></tr></table></figure></p>
<p>如果需要填充，可以使用显式类型转换：<code>keccak256(&quot;\x00\x12&quot;)</code>与<code>keccak256(uint16(0x12))</code>相同。</p>
<p>请注意，常量将使用存储它们所需的最小字节数打包。这意味着，例如<code>keccak256(0x12345678) == keccak256(uint32(0x12345678))</code>和<code>keccak256(0) == keccak256(uint8(0))</code>。</p>
<p><b style="color:red">这可能是因为您在私人区块链上调用sha256，ripemd160或者ecrecover时遇到了Out-of-Gas这种情况。这样做的原因是，这些被作为所谓的预编译的合约执行，这些合约他们收到的第一条消息后（尽管他们的合约代码是硬编码）才真正存在。发送给不存在的合约的消息更加昂贵，因此执行会出现Out-of-Gas错误。解决这个问题的一个解决方法是，先在您的实际合同中使用它们，然后将例如1Wei发送给每个合同。这不是官方或测试网上的问题。</b></p>
<h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><h3 id="lt-address-gt-balance（uint256）："><a href="#lt-address-gt-balance（uint256）：" class="headerlink" title="&lt;address&gt;.balance（uint256）："></a><code>&lt;address&gt;.balance（uint256）</code>：</h3><p>以wei为单位的地址的余额</p>
<h3 id="lt-address-gt-transfer-uint256-amount-："><a href="#lt-address-gt-transfer-uint256-amount-：" class="headerlink" title="&lt;address&gt;.transfer(uint256 amount)："></a><code>&lt;address&gt;.transfer(uint256 amount)</code>：</h3><p>给相应地址发送一定数量的以太币（单位wei），<b style="color:red">失败时抛异常，转发2300gas的量，不可调整</b></p>
<h3 id="lt-address-gt-send-uint256-amount-returns-bool-："><a href="#lt-address-gt-send-uint256-amount-returns-bool-：" class="headerlink" title="&lt;address&gt;.send(uint256 amount) returns (bool)："></a><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：</h3><p>给相应地址发送一定数量的以太币（单位wei），<b style="color:red">失败返回false，转发2300gas的量，不可调整</b></p>
<h3 id="lt-address-gt-call-returns-bool-："><a href="#lt-address-gt-call-returns-bool-：" class="headerlink" title="&lt;address&gt;.call(...) returns (bool)："></a><code>&lt;address&gt;.call(...) returns (bool)</code>：</h3><p>发出低级别的CALL，<b style="color:red">失败返回false，转发所有可用的gas，可调节</b></p>
<h3 id="lt-address-gt-callcode-returns-bool-："><a href="#lt-address-gt-callcode-returns-bool-：" class="headerlink" title="&lt;address&gt;.callcode(...) returns (bool)："></a><code>&lt;address&gt;.callcode(...) returns (bool)</code>：</h3><p>发出低级别的CALLCODE，失败返回false，转发所有可用的gas，可调节</p>
<h3 id="lt-address-gt-delegatecall-returns-bool-："><a href="#lt-address-gt-delegatecall-returns-bool-：" class="headerlink" title="&lt;address&gt;.delegatecall(...) returns (bool)："></a><code>&lt;address&gt;.delegatecall(...) returns (bool)</code>：</h3><p>发出低级别的DELEGATECALL，失败返回false，转发所有可用的gas，可调节</p>
<p>欲了解更多信息，请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/types.html#address" target="_blank" rel="noopener">地址</a>部分。</p>
<p><b style="color:#6ab0de">使用中存在一些危险<code>send</code>：如果调用堆栈深度为1024（调用程序始终强制执行此操作），则传输将失败，如果发起人耗尽gas，则传输也会失败。因此，为了进行安全的ether传输，请务必检查<code>send</code>的返回值，使用<code>transfer</code>甚至更好：使用接收方提取资金的模式。</b></p>
<p><b style="color:#6ab0de">callcode不鼓励使用，将来会被删除。</b></p>
<h2 id="合同相关"><a href="#合同相关" class="headerlink" title="合同相关"></a>合同相关</h2><h3 id="this-（当前合同的类型）："><a href="#this-（当前合同的类型）：" class="headerlink" title="this （当前合同的类型）："></a>this （当前合同的类型）：</h3><p>目前的合同，明确转换为地址</p>
<h3 id="selfdestruct-address-recipient-："><a href="#selfdestruct-address-recipient-：" class="headerlink" title="selfdestruct(address recipient)："></a>selfdestruct(address recipient)：</h3><p>销毁当前的合同，将资金发送到给定的地址</p>
<h3 id="suicide-address-recipient-："><a href="#suicide-address-recipient-：" class="headerlink" title="suicide(address recipient)："></a>suicide(address recipient)：</h3><p>别名 selfdestruct</p>
<p>此外，当前合约的所有功能都可以直接包含当前方法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/03/blockchain/solidity数据类型说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/blockchain/solidity数据类型说明/" itemprop="url">solidity数据类型说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T08:43:48+08:00">2018-04-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在看区块链的英文文档，看起来很吃力，重点是特别容易遗忘，只能记一个大概比较痛苦，也许写文章是一个比较好的思路，可以强迫自己进行总结思考。但是最近发现写文章吧，很费时，一天也就只能看一篇（面试+项目上的事情很心烦），再加上区块链这样的技术比较新，有很大的概率会出现一些新的概念，导致一些单词不太好翻译（不像java的学习，现在资料满天飞），这给阅读带来极大的障碍。不管怎样还是坚持吧！</p>
<p>今天来聊聊solidity的类型，网上看过很多资料不是翻译不好就是版本太旧，根本没法看。今天就针对官方的文档总结一下。</p>
<p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>solidity是一种静态类型的语言，这意味着每个变量的类型（State和local）在编译时需要被指定。Solidity提供几个基本类型，这些类型可以组合为复杂的类型。</p>
<p>另外，类型可以在包含运算符的表达式中相互交互。</p>
<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>下面的都是值类型，这些类型的变量永远是采用值传递。在复制和传给方法时，他们都是采用拷贝的方式。</p>
<h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><p>bool：只有值true和false</p>
<h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><p><code>int</code>/<code>uint</code>: 可变长度的有符号和无符号整数。关键字<code>uint8</code>到<code>uint256</code>，步长为8。相对的<code>int8</code>到<code>int256</code>。<code>uint</code>和<code>int</code>是<code>uint256</code>和<code>int256</code>的别名。</p>
<p>除法总是截断（它只是编译为EVM的DIV操作码），但如果两个操作符都是Literals（或Literals表达式），它就不会截断。</p>
<p>移位操作的结果是左操作数的类型(意思是y一直在右边，x一直在左边)。表达式<code>x &lt;&lt; y</code>相当于<code>x * 2 ** y</code>，<code>x &gt;&gt; y</code>相当于<code>x / 2 ** y</code>。 这意味着将负数符号转移。按负数移动会引发运行时异常。</p>
<p><b style="color:red">由有符号整数类型负值的右移产生的结果与其他编程语言产生的结果不同。 在Solidity中，将右侧的地图向右移动，以便移位后的负值将舍入为零（截断）。 在其他编程语言中，负值的右移就像四舍五入的分割（朝向负无穷大）。</b></p>
<h3 id="固定小数的数字"><a href="#固定小数的数字" class="headerlink" title="固定小数的数字"></a>固定小数的数字</h3><p><b style="color:blue">固定点数字尚未完全支持。 它们可以被声明，但不能被赋值或被分配。</b></p>
<p><code>fixed / ufixed</code>：有符号和无符号的各种大小的定点数。 关键词<code>ufixedMxN</code>和<code>fixedMxN</code>，其中M表示类型所占的位数，N表示可用的小数点数。 M必须能被8整除，并从8到256位。 N必须介于0和80之间，包括0和80。 <code>ufixed</code>和<code>fixed</code>分别为<code>ufixed128x19</code>和<code>fixed128x19</code>的别名。</p>
<h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>保存20个字节的值（以太坊地址的大小）。 地址类型也有成员，并作为所有合同的基础。</p>
<p>操作： <code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> and <code>&gt;</code></p>
<p>地址的成员：</p>
<h4 id="balance-和-transfer"><a href="#balance-和-transfer" class="headerlink" title="balance 和 transfer"></a>balance 和 transfer</h4><p>可以使用balance属性来获取账户余额。通过transfer方法发送以太币。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#6ab0de">如果x是合同地址，则其代码（更具体而言：其fallback方法，如果存在）将与transfer调用一起执行（这是EVM的限制，无法阻止）。 如果执行耗尽gas或以任何方式失败，则以太网币转移将被还原，并且当前合同将以异常停止。</b></p>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>send是transfer低级别的副本。如果执行失败，当前合同的执行不会以异常的方式停止，但是会返回false；注意send调用深度是1024.</p>
<h4 id="call-callcode-delegatecall"><a href="#call-callcode-delegatecall" class="headerlink" title="call, callcode, delegatecall"></a>call, callcode, delegatecall</h4><p>此外，对于不符合ABI的合约接口，提供了函数call，它可以接受任意类型、任意数量的参数。 这些参数被填充到32个字节并连接。一个例外是第一个参数被编码为正好四个字节的情况。在这种情况下，它没有被填充以允许在这里使用方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class="line">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class="line">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure></p>
<p>call返回一个布尔值，指示调用的函数是否终止（true）或导致EVM异常（false）。 无法访问返回的实际数据（为此，我们需要事先知道编码和大小）。</p>
<p>我们可以通过<code>.gas()</code>来调整消耗的gas：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure></p>
<p>相似的，提供的以太币数量也可以被控制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure></p>
<p>最后，这些修饰可以组合使用，循序无所谓的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure></p>
<p>delegatecall可以以相同的方式使用，不同点在于只是使用了给定地址的代码，其他方面（storage、balance，……）都是从当前合约获取。delegatecall的目的是使用其他合约存储的library代码。用户必须确认storage的布局是适合双方合约delegatecall的。从Prior到homestead，只有名为<code>callcode</code>的有限变体可用，它不提供对原始合约<code>msg.sender</code>和<code>msg.value</code>值的访问。</p>
<p><b style="color:#6ab0de">这三个函数调用，delegatecall和callcode都是非常低级的函数，只能作为最后的手段，因为它们会破坏Solidity的类型安全性。</b></p>
<p><b style="color:#6ab0de"><code>.gas()</code>操作在这3个方法上都是可用的，<code>.value()方法不能在delegatecall上使用。</code></b></p>
<p><b style="color:red">所有的合约都继承了address的成员，所以我们可以通过<code>this.balance</code>来获取当前合约的账户余额。</b></p>
<p>callcode操作已被放弃，将来可能会被移除。</p>
<p>所有这些功能都是低级功能，应小心使用。具体来说，任何未知的合约都可能是恶意的，如果你要调用它，你将控制权移交给那个可以反过来又回到你的合约中的合约，所以当你的合约call调用返回时，做好改变你的状态变量的准备。</p>
<h3 id="固定大小的字节数组"><a href="#固定大小的字节数组" class="headerlink" title="固定大小的字节数组"></a>固定大小的字节数组</h3><p><code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code>. <code>byte</code> 是 <code>bytes1</code>的别名.</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li>比较： &lt;=, &lt;, ==, !=, &gt;=, &gt; (evaluate to bool)</li>
<li>位操作： &amp;, |, ^ (bitwise exclusive or), ~ (bitwise negation), &lt;&lt; (left shift), &gt;&gt; (right shift) </li>
<li>索引访问</li>
</ul>
<h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><ul>
<li>length：(只读）</li>
</ul>
<p><b style="color:#6ab0de"><code>byte[]</code>可能会浪费大量空间，31个字节；当向调用传递参数时，最好使用<code>bytes</code>.</b></p>
<h3 id="动态大小的byte数组"><a href="#动态大小的byte数组" class="headerlink" title="动态大小的byte数组"></a>动态大小的byte数组</h3><ul>
<li>bytes: 动态大小字节数据，查看<a href="http://solidity.readthedocs.io/zh/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>。不是值类型。</li>
<li>string: 动态大小的UTF-8编码字符串，查看<a href="http://solidity.readthedocs.io/zh/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>。不是值类型。</li>
</ul>
<p>根据经验，对任意长度的原始字节数据使用字节，对任意长度的字符串（UTF-8）数据使用字符串。如果您可以将长度限制为特定数量的字节，则始终使用<code>bytes1</code>到<code>bytes32</code>中的一个，因为它们便宜得多。</p>
<h3 id="地址文字"><a href="#地址文字" class="headerlink" title="地址文字"></a>地址文字</h3><p>通过地址校验测试的十六进制文字是地址类型，例如<code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>。 长度在39到41位之间且未通过校验和测试的十六进制文字会产生警告，并被视为常规有理数字文字。</p>
<h3 id="有理数和整数文字"><a href="#有理数和整数文字" class="headerlink" title="有理数和整数文字"></a>有理数和整数文字</h3><p>整数的是0-9的序列组成的，这被解读为数字。例如69. 八进制在solidity中是不存在的，所以前导的0是无效的。</p>
<p>分数是通过<code>.</code>表示的，左或右至少有一个数字。例如<code>1.</code>,<code>.1</code>,<code>1.3</code>。</p>
<p>科学记数法也支持，其中基数可以有分数，而指数则不可以。 例子包括<code>2e10</code>，<code>-2e10</code>，<code>2e-10</code>，<code>2.5e1</code>。</p>
<p>数字文字表达式保持任意精度，直到它们被转换为非文字类型（即通过将它们与非文字表达式一起使用）。 这意味着计算不会溢出，并且不会在数字文字表达式中截断。例如<code>(2**800 + 1) - 2**800</code>导致常量1（类型uint8），尽管中间结果甚至不适合机器字大小。 此外，<code>.5 * 8</code>会导致整数<code>4</code>（<b style="color:red">尽管在它们之间使用了非整数</b>）。</p>
<p>只要操作数是整数，任何可以应用于整数的运算符也可以应用于数字文字表达式。 如果两者中的任何一个都是小数，则位操作是不允许的，并且如果指数是分数（因为这可能导致非有理数），指数是不允许的。</p>
<p><b style="color:red">对于每个有理数，Solidity都有一个数字字面类型。</b>整数文字和有理数字文字属于数字文字类型。 此外，所有数字文字表达式（即仅包含数字文字和运算符的表达式）属于数字文字类型。 所以数字文字表达式1 + 2和2 + 1对于有理数3都属于相同的数字文字类型。</p>
<p><b style="color:#6ab0de">整数除法表达式在早前的版本中是截断的，但是现在将转化为一个有理数，比如<code>5/2</code>不再等于2，二是等于2.5.</b></p>
<p><b style="color:blue">数字文字表达式只要与非文字表达式一起使用，就会转换为非文字类型。 尽管我们知道在以下示例中赋值给b的表达式的值计算为整数，但部分表达式2.5 + a没有类型检查，因此代码不会编译.</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串文字"><a href="#字符串文字" class="headerlink" title="字符串文字"></a>字符串文字</h3><p>单引号或者双引号（”foo”或者’bar’）。它不需要像C中尾部放一个0.与整数文字一样，它们的类型可以变化，但如果它们适合字节和字符串，它们可以隐式转换为<code>bytes1</code>，…，<code>bytes32</code>。</p>
<p>字符串文字也支持转义字符，例如<code>\n</code>, <code>\xNN</code>和<code>\uNNNN</code>。<code>\xNN</code>使用十六进制并插入适当类型。<code>\uNNNN</code>使用Unicode编码，插入以UTF-8序列。</p>
<h3 id="十六进制文字"><a href="#十六进制文字" class="headerlink" title="十六进制文字"></a>十六进制文字</h3><p>以<code>hex</code>开头并且用单引号或者双引号包裹。它们的内容必须是十六进制字符串，它们的值将是这些值的二进制表示。</p>
<p>十六进制文字的行为与字符串文字相似，并具有相同的可转换性限制。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是在Solidity中创建用户定义类型的一种方法。 它们可以显式转换为所有整数类型，但是不允许隐式转换。 显式转换检查运行时的值范围，失败会导致异常。 枚举需要至少一个成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法类型（函数类型）"><a href="#方法类型（函数类型）" class="headerlink" title="方法类型（函数类型）"></a>方法类型（函数类型）</h2><p>函数类型是函数的类型。 函数类型的变量可以从函数中分配，而函数类型的函数参数可以用于将函数传递给函数调用并从函数调用返回函数。 函数类型有两种 - 内部和外部方法：</p>
<p><b style="color:red">内部函数</b>只能在当前合约内（更具体地说，在当前代码单元内部，它还包含内部库函数和继承函数）内部调用，因为它们不能在当前合约的上下文之外执行。 调用内部函数是通过跳转到其入口标签来实现的，就像在内部调用当前合同的函数一样。</p>
<p><b style="color:red">外部函数</b>由一个地址和一个函数签名组成，它们可以通过外部函数调用传递并返回。</p>
<p>函数类型的标注如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure></p>
<p>与参数类型不同，返回类型不能为空 - 如果函数类型不应返回任何内容，则必须省略整个<code>returns (&lt;return types&gt;)</code>部分。</p>
<p>默认情况下，函数类型是内部的，所以内部关键字可以省略。相比之下，合约函数本身在默认情况下是公共的，只有当用作类型的名称时，默认是内部的。</p>
<p><b style="color:red">有两种方法可以访问当前合约中的函数：直接使用其名称f或使用this.f.前者将产生内部功能，后者则具有外部功能。</b></p>
<p>如果函数类型变量未初始化，调用它将导致异常。如果您在使用delete之后调用某个函数，则会发生同样的情况。</p>
<p>如果外部函数类型在Solidity上下文之外使用，则它们被视为函数类型，它将函数标识符后跟的地址一起编码为单个字节24类型。</p>
<p>请注意，当前合约的公共方法既可以用作内部函数，也可以用作外部函数。要将f用作内部函数，只需使用f，如果要使用其外部窗体，请使用this.f.</p>
<p>显示如何使用内部函数类型的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.5;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个使用外部方法类型的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Lambda和内联函数计划加入，但是现在还不支持。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>复杂类型（即不总是适合256位的类型）必须比我们已经看到的值类型更仔细地处理。 由于复制它们可能相当昂贵，我们必须考虑是否要将它们存储在内存中（不是持久的）或存储器（存储状态变量的地方）。</p>
<h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h3><p>每种复杂类型（即数组和结构）都有一个额外的注释，即“数据位置”，关于它是存储在内存还是storage中。根据上下文，总是有一个默认值，但可以通过将<code>storage</code>或<code>memory</code>添加到该类型来覆盖它。函数参数（包括返回参数）的默认值是<code>memory</code>，局部变量的默认值是<code>storage</code>，并且对该状态变量（显然）被强制为<code>storage</code>。</p>
<p>还有第三个数据位置<code>calldata</code>，它是存储函数参数的不可修改的非持久性区域。外部函数的函数参数（不返回参数）被强制为calldata并且行为主要与内存相似。</p>
<p>数据位置很重要，因为它们会改变分配的行为方式：<code>storage</code>和<code>memory</code>之间的分配以及状态变量（甚至来自其他状态变量）的分配始终会创建独立副本。虽然本地存储变量的赋值只能指定一个引用，并且该引用始终指向状态变量，即使后者在此期间发生更改。另一方面，从内存存储引用类型到另一个内存存储引用类型的分配不会创建副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; // the data location of x is storage</span><br><span class="line"></span><br><span class="line">    // the data location of memoryArray is memory</span><br><span class="line">    function f(uint[] memoryArray) &#123;</span><br><span class="line">        x = memoryArray; // works, copies the whole array to storage</span><br><span class="line">        var y = x; // works, assigns a pointer, data location of y is storage</span><br><span class="line">        y[7]; // fine, returns the 8th element</span><br><span class="line">        y.length = 2; // fine, modifies x through y</span><br><span class="line">        delete x; // fine, clears the array, also modifies y</span><br><span class="line">        // The following does not work; it would need to create a new temporary /</span><br><span class="line">        // unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br><span class="line">        // y = memoryArray;</span><br><span class="line">        // This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br><span class="line">        // is no sensible location it could point to.</span><br><span class="line">        // delete y;</span><br><span class="line">        g(x); // calls g, handing over a reference to x</span><br><span class="line">        h(x); // calls h and creates an independent, temporary copy in memory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>强制的数据位置：</p>
<ul>
<li>外部函数的参数（不返回）：calldata</li>
<li>状态变量： storage</li>
</ul>
<p>默认的数据位置：</p>
<ul>
<li>函数的参数（也返回）：memory</li>
<li>其他的本地变量： storage</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组可以有编译时固定的大小，也可以是动态的。对于<code>storage</code>数组，元素类型可以是任意的（即其他数组，映射或结构）。对于<code>memory</code>数组，它不能是一个<code>mapping</code>，如果它是一个公共可见函数的参数，则它必须是ABI类型。</p>
<p>一个固定大小的数组k和元素类型T被写为<code>T[k]</code>，一个动态大小为<code>T[]</code>的数组。举例来说，uint的5个动态数组的数组是<code>uint[][5]</code>（请注意，与其他一些语言相比，符号是反转的）。要访问第三个动态数组中的第二个uint，可以使用<code>x[2][1]</code>（索引是基于零的，<b style="color:red">并且访问以与声明相反的方式工作</b>，即<code>x[2]</code>从类型中删除一个级别正确的）。</p>
<p>bytes和string的变量是特殊数组。一个bytes与byte[]类似，但是它紧密地包含在<code>calldata</code>中。string等于bytes, 但不允许使用长度或索引访问（现在）。</p>
<p>所以bytes总是比byte[]更受欢迎，因为它比较便宜。</p>
<p><b style="color:#6ab0de">如果你想访问字符串<code>s</code>的字节表示，使用<code>bytes(s).length / bytes(s)[7] = &#39;x&#39;;</code>. 请记住，您正在访问UTF-8表示的低级字节，而不是单个字符！</b></p>
<p>有可能将公开的数组标记并让Solidity创建一个getter。 数字索引将成为getter的必需参数。</p>
<h4 id="分配内存数组"><a href="#分配内存数组" class="headerlink" title="分配内存数组"></a>分配内存数组</h4><p>在内存中创建具有可变长度的数组可以使用new关键字来完成。与<code>storage</code>数组相反，通过分配给<code>.length</code>成员来调整存储器阵列的大小是不可能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组文字-行内数组"><a href="#数组文字-行内数组" class="headerlink" title="数组文字/行内数组"></a>数组文字/行内数组</h4><p>数组文字是作为表达式写入的数组，并且不会立即分配给变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] _data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组文本的类型是固定大小的<code>memory</code>数组，其基数类型是给定元素的常见类型。<code>[1,2,3]</code>的类型是<code>uint8[3] memory</code>，因为这些常量中的每一个的类型都是<code>uint8</code>。 因此，有必要将上例中的第一个元素转换为uint。请注意，目前固定大小的<code>memory</code>数组不能分配给动态大小的<code>memory</code>，即以下情况是不可能的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile.</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() &#123;</span><br><span class="line">        // The next line creates a type error because uint[3] memory</span><br><span class="line">        // cannot be converted to uint[] memory.</span><br><span class="line">        uint[] x = [uint(1), 3, 4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计划在将来删除此限制，但由于数组在ABI中的传递方式，目前会产生一些复杂性。</p>
<h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><p>数组有一个<code>length</code>成员来保存元素的数量。 通过更改<code>.length</code>成员，动态数组可以在<code>storage</code>中（不在内存中）调整大小。 尝试访问当前长度以外的元素时，不会自动发生。<code>memory</code>数组的大小一旦被创建就是固定的（但是动态的，即它可以依赖于运行时参数）。</p>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>动态<code>storage</code>数组和bytes（不是字符串）具有一个名为push的成员函数，可用于在数组末尾追加一个元素。 该函数返回新的长度。</p>
<p><b style="color:#6ab0de">尚不可能在外部函数中使用数组的数组。</b></p>
<p><b style="color:#6ab0de">由于EVM的限制，无法从外部函数调用返回动态内容。 <code>contract C { function f() returns (uint[]) { ... } }</code>中的函数f将返回从web3.js调用的内容，但不会从Solidity调用。<br>现在唯一的解决方法是使用大型静态大小的数组。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[2**20] m_aLotOfIntegers;</span><br><span class="line">    // Note that the following is not a pair of dynamic arrays but a</span><br><span class="line">    // dynamic array of pairs (i.e. of fixed size arrays of length two).</span><br><span class="line">    bool[2][] m_pairsOfFlags;</span><br><span class="line">    // newPairs is stored in memory - the default for function arguments</span><br><span class="line"></span><br><span class="line">    function setAllFlagPairs(bool[2][] newPairs) &#123;</span><br><span class="line">        // assignment to a storage array replaces the complete array</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFlagPair(uint index, bool flagA, bool flagB) &#123;</span><br><span class="line">        // access to a non-existing index will throw an exception</span><br><span class="line">        m_pairsOfFlags[index][0] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][1] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeFlagArraySize(uint newSize) &#123;</span><br><span class="line">        // if the new size is smaller, removed array elements will be cleared</span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() &#123;</span><br><span class="line">        // these clear the arrays completely</span><br><span class="line">        delete m_pairsOfFlags;</span><br><span class="line">        delete m_aLotOfIntegers;</span><br><span class="line">        // identical effect here</span><br><span class="line">        m_pairsOfFlags.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    function byteArrays(bytes data) &#123;</span><br><span class="line">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class="line">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += 7;</span><br><span class="line">        m_byteData[3] = 8;</span><br><span class="line">        delete m_byteData[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addFlag(bool[2] flag) returns (uint) &#123;</span><br><span class="line">        return m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createMemoryArray(uint size) returns (bytes) &#123;</span><br><span class="line">        // Dynamic memory arrays are created using `new`:</span><br><span class="line">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class="line">        // Create a dynamic byte array:</span><br><span class="line">        bytes memory b = new bytes(200);</span><br><span class="line">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Solidity提供了一种以结构形式定义新类型的方法，如以下示例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    // Defines a new type with two fields.</span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (uint =&gt; Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    function newCampaign(address beneficiary, uint goal) returns (uint campaignID) &#123;</span><br><span class="line">        campaignID = numCampaigns++; // campaignID is return variable</span><br><span class="line">        // Creates new struct and saves in storage. We leave out the mapping type.</span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute(uint campaignID) payable &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        // Creates a new temporary memory struct, initialised with the given values</span><br><span class="line">        // and copies it over to storage.</span><br><span class="line">        // Note that you can also use Funder(msg.sender, msg.value) to initialise.</span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkGoalReached(uint campaignID) returns (bool reached) &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        if (c.amount &lt; c.fundingGoal)</span><br><span class="line">            return false;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = 0;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合约没有提供众筹合约的全部功能，但它包含了理解结构所必需的基本概念。 结构类型可以用在映射和数组中，它们本身可以包含映射和数组。</p>
<p>尽管结构本身可以是映射成员的值类型，但结构不可能包含它自己类型的成员。 这个限制是必要的，因为结构的大小必须是有限的。</p>
<p>请注意，在所有函数中，结构类型被分配给（缺省存储数据位置的）局部变量。 这不会复制该结构，而只会存储一个引用，以便分配给本地变量的成员实际写入该状态。</p>
<p>当然，您也可以直接访问结构体的成员，而无需将其分配给本地变量，比如<code>campaigns[campaignID].amount=0</code>。</p>
<h3 id="映射Mappings"><a href="#映射Mappings" class="headerlink" title="映射Mappings"></a>映射Mappings</h3><p>映射类型被声明为<code>mapping(_KeyType =&gt; _ValueType)</code>。这里<code>_KeyType</code>几乎可以是任何类型，除了映射，动态大小的数组，合约，枚举和结构。 <code>_ValueType</code>实际上可以是任何类型，包括映射。</p>
<p>映射可以看作散列表，它被虚拟初始化，这样每个可能的键都存在并映射到一个字节表示全为零的值：一个类型的<a href="http://solidity.readthedocs.io/zh/latest/control-structures.html#default-value" target="_blank" rel="noopener">默认值</a>。但是，相似性在此处结束：关键数据实际上并不存储在映射中，只有其<code>keccak256</code>哈希用于查找值。</p>
<p>因此，映射没有长度或“设置”键或值的概念。</p>
<p>映射只能用于状态变量（或作为内部函数中的存储引用类型）。</p>
<p>有可能将<code>public</code>标记映射并让Solidity创建一个getter。<code>_KeyType</code>将成为getter的必需参数，它将返回<code>_ValueType</code>。</p>
<p><code>_ValueType</code>也可以是一个映射。 getter将递归地为每个<code>_KeyType</code>使用一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint newBalance) &#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    function f() returns (uint) &#123;</span><br><span class="line">        MappingExample m = new MappingExample();</span><br><span class="line">        m.update(100);</span><br><span class="line">        return m.balances(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>映射不可迭代，但可以在其上实现数据结构。 有关示例，请参阅<a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="noopener">可迭代映射</a>。</p>
<h2 id="涉及LValues的操作符"><a href="#涉及LValues的操作符" class="headerlink" title="涉及LValues的操作符"></a>涉及LValues的操作符</h2><p>如果a是一个LValue（即一个变量或可以分配的东西），则以下运算符可用作简写：</p>
<p><code>a += e</code>相当于<code>a = a + e</code>。 相应地定义运算符 -=，*=，/=，％=，a |=，＆=和^=。 a++和a–相当于 a+= 1 / a -= 1，但表达式本身仍然具有a的前一个值。 相反，–a和++a对a有相同的效果，但在更改后返回值。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><b style="color:red"><code>delete a</code>将类型的初始值赋给a</b>。即 对于整数而言，它相当于<code>a = 0</code>，但它也可以用于数组，它指定一个长度为零的动态数组或一个长度相同且所有元素都重置的静态数组。 对于结构体，它分配一个所有成员重置的结构体。</p>
<p>删除对整个映射没有影响（因为映射的键可能是任意的并且通常是未知的）。 所以，如果你删除一个结构体，它将重置所有不是映射的成员，并且还会映射到成员中，除非它们是映射关系。 但是，可以删除个人密钥及其映射的内容。</p>
<p><b style="color:red">需要注意的是<code>delete a</code>的行为类似于对a的赋值，即它将一个新对象存储在a中。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() &#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        delete x; // sets x to 0, does not affect data</span><br><span class="line">        delete data; // sets data to 0, does not affect x which still holds a copy</span><br><span class="line">        uint[] y = dataArray;</span><br><span class="line">        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also</span><br><span class="line">        // y is affected which is an alias to the storage object</span><br><span class="line">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span><br><span class="line">        // referencing storage objects can only be made from existing storage objects.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h2><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>如果编译器不允许隐式转换，但您知道自己在做什么，则有时可以使用显式类型转换。请注意，这可能会给你一些意想不到的行为，所以一定要测试以确保结果是你想要的！以下面的例子为例，你将一个负数int8转换为uint：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int8 y = -3;</span><br><span class="line">uint x = uint(y);</span><br></pre></td></tr></table></figure></p>
<p>在此代码片段的末尾，x将具有值<code>0xfffff..fd</code>（64个十六进制字符），在256位的二进制补码表示中为<code>-3</code>。</p>
<p>如果某种类型明确转换为较小类型，则会切断较高位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // b will be 0x5678 now</span><br></pre></td></tr></table></figure></p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>为了方便起见，并不总是需要明确指定变量的类型，编译器会根据分配给变量的第一个表达式的类型自动推断它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint24 x = 0x123;</span><br><span class="line">var y = x;</span><br></pre></td></tr></table></figure></p>
<p>在这里，类型y将是uint24。var函数参数或返回参数不可用。</p>
<p><b style="color:#6ab0de">该类型仅从第一个赋值中推导出来，因此以下片段中的循环是无限的，因为i将具有该类型uint8并且该类型的 任何值都小于2000.</b><code>for (var i = 0; i &lt; 2000; i++) { ... }</code>.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/30/blockchain/如何保护你的智能合约：6个Solidity漏洞以及如何避开它们/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/30/blockchain/如何保护你的智能合约：6个Solidity漏洞以及如何避开它们/" itemprop="url">如何保护你的智能合约：6个Solidity漏洞以及如何避开它们</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T11:23:37+08:00">2018-03-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>智能合约是“不可变的”。一旦部署，它们的代码是不能更改的，导致无法修复任何发现的bug。</p>
<p>在潜在的未来里，整个组织都由智能合约代码管控，对于适当的安全性需求巨大。过去的黑客如TheDAO或去年的Parity黑客（7月、11月）提高了开发者们的警惕，可我们还有很长的路要走。</p>
<h2 id="范围溢出的问题"><a href="#范围溢出的问题" class="headerlink" title="范围溢出的问题"></a>范围溢出的问题</h2><ol>
<li>代币中记录用户的代币数量，一旦上溢，就会出现用户代币数归零的现象。</li>
<li>同样，减号会出现下溢的问题。</li>
<li>如果溢出出现在循环语句中，那么可能就会出现不进入循环、过早结束循环和无限循环的问题。</li>
</ol>
<p>缓解措施：现在使用OpenZeppelin的<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">SafeMath</a>库已经成为了一个标准。</p>
<h2 id="可视性-Visibility-和Delegatecall"><a href="#可视性-Visibility-和Delegatecall" class="headerlink" title="可视性(Visibility)和Delegatecall"></a>可视性(Visibility)和Delegatecall</h2><p>对去年7月发生的事有印象的人来说，这个bug就很眼熟，毕竟Parity钱包被黑导致用户损失了3千万美金。</p>
<p><b style="color:red">Solidity的可视性修改功能和它们的区别:</b></p>
<ul>
<li>公共(Public)函数可以被任何人调用（被合约里的函数、继承合约里的函数、或者外面的用户）。</li>
<li>外部(External)函数只能从外部访问，<b style="color:blue">意味着它们不能被合约里的其他函数调用</b>。下面的要点不能编译，cannotBeCalled的外部可视性不允许它被合约里的函数调用（但它可以被别的合约调用）。</li>
</ul>
<p><b style="color:red">外部函数用起来更便宜因为它使用calldata操作码，而公共函数需要把所有参数复制到内存中</b>，详情请看<a href="https://ethereum.stackexchange.com/questions/19380/external-vs-public-best-practices?answertab=active#tab-top" target="_blank" rel="noopener">这里</a>。</p>
<p><b style="color:blue">私有(Private)和内部(Internal)函数更简单：private是只能在该合约里使用，而internal提供了一个更宽松的限制，它允许从母合约处继承的子合约使用那个函数。那就是说，除了需要外部交互的时候，设置你的函数为private或者internal。</b></p>
<h3 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h3><p>引述<a href="http://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries" target="_blank" rel="noopener">solidity文件</a>：</p>
<p><quota>“Delegatecall和信息调用，除了目标地址的代码要在请求调用的合约的上下文中执行之外，是完全一样的。msg.sender和msg.value不改变他们的值。 这意味着合约可以在运行是动态加载来自不同地址的代码。存储、当前地址和余额仍都取决于请求调用的合约，只有代码来自被调用合约。”</quota><b style="color:red">意思就是说将别的合约加入到自己的代码空间执行，但是不会改变别人合约的状态。</b></p>
<p><b style="color:red">这个低级函数非常有用，因为它是实现库和模块化代码的中坚力量。 然而，它打开了漏洞的大门，因为你的合同基本上允许任何人以他们的状态做任何他们想做的。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">// Credits to OpenZeppelin for this contract taken from the Ethernaut CTF</span><br><span class="line">// https://ethernaut.zeppelin.solutions/level/0x68756ad5e1039e4f3b895cfaa16a3a79a5a73c59</span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function Delegate(address _owner) &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  function Delegation(address _delegateAddress) &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // an attacker can call Delegate.pwn() in the context of Delegation</span><br><span class="line">  // this means that pwn() will modify the state of **Delegation** and not Delegate</span><br><span class="line">  // the result is that the attacker takes unauthorized ownership of the contract</span><br><span class="line">  function() &#123;</span><br><span class="line">    if(delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Parity黑客涉及两个不安全的可见性修改功能组合，以及用任意数据滥用delegate调用。易受攻击的合约的函数实现了delegatecall，并且一个来自其他合约，能修改主权的函数被设成公共的。这使得攻击者可以设计msg.data字段来调用易受攻击的函数。</p>
<p>至于msg.data字段里会包含什么，那会是你想要调用函数的签名。这里的签名指的是函数原型的sha3（keccak256的别名）散列的前8个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In this case:</span><br><span class="line">web3.sha3(&quot;pwn()&quot;).slice(0,10) --&gt; 0xdd365b8b</span><br><span class="line">// If the function takes an argument, pwn(uint256 x):</span><br><span class="line">web3.sha3(&quot;pwn(uint256)&quot;).slice(0,10) --&gt; 0x35f4581b</span><br></pre></td></tr></table></figure></p>
<h2 id="可重入性（The-DAO黑客事件）"><a href="#可重入性（The-DAO黑客事件）" class="headerlink" title="可重入性（The DAO黑客事件）"></a>可重入性（The DAO黑客事件）</h2><p>Solidity的call函数当被带着value调用时，会发送所有它收到的gas。在下面的代码片段中，调用是在实际减少发件人的余额之前完成的。一个在TheDAO黑客事件发生时reddit上的评论很好地解释了这个漏洞：</p>
<p><b style="color:blue">简单来说，就好像银行出纳员在她把你所要求的钱全部给你之前，不会更改你的余额。“我能取出500美金吗？等一下，在那之前，我能取出500美金吗？” 等等等等。按照设计的智能合约只会在最开始检查你有500美金，一次，而且允许它们自己被打断。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) public &#123;</span><br><span class="line">  if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">    if(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">      _amount;</span><br><span class="line">    &#125;</span><br><span class="line">    balances[msg.sender] -= _amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如这里所详细描述的，修复方案就是先减少发送人的余额再进行价值转移。对于使用并行编程的人来说，另外一个解决方法就是用互斥锁，从而一起缓解各种竞争条件。</p>
<p>目前来说，使用require(msg.sender.transfer(_value))是处理这些情况的最好的方法。</p>
<p>详细的信息也可以查看<a href="http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/" target="_blank" rel="noopener">More Ethereum Attacks: Race-To-Empty is the Real Deal</a></p>
<p>也可以查看：<a href="http://www.bikeji.com/discussions/4027" target="_blank" rel="noopener">DAO攻击简单解释</a></p>
<h2 id="强行将以太币置入合约"><a href="#强行将以太币置入合约" class="headerlink" title="强行将以太币置入合约"></a>强行将以太币置入合约</h2><p>Solidity的selfdestruct做两件事。(其实就是指删除合约地址)</p>
<ol>
<li>它使合约变为不可用，有效地删除该地址的bytecode。</li>
<li>它把合约的所有资金发送到目标地址。</li>
</ol>
<p>这里的一个特殊情况是，如果接收地址是一个合约，那么它的<a href="https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether" target="_blank" rel="noopener">fallback函数不会被执行</a>。</p>
<p>这意味着，如果一个合约的函数有一个依赖于该合约的余额低于一定数额的条件语句，那个语句可能会被绕过:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.18;</span><br><span class="line"></span><br><span class="line">contract ForceEther &#123;</span><br><span class="line"></span><br><span class="line">  bool youWin = false;</span><br><span class="line"></span><br><span class="line">  function onlyNonZeroBalance() &#123;</span><br><span class="line">      require(this.balance &gt; 0); </span><br><span class="line">      youWin = true;</span><br><span class="line">  &#125;</span><br><span class="line">  // throw if any ether is received</span><br><span class="line">  function() payable &#123;</span><br><span class="line">    revert();</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于那个没有的fallback函数，通常该合约无法收到以太币。<b style="color:red">但是，如果一个合约以这个合约为目标自毁，后退函数则不会被调用</b>。结果this.balance变得大于0，所以攻击者就可以在onlyNonZeroBalance里绕过require语句。</p>
<p><b style="color:red">缓解措施：永远不要用一个合约的余额作守卫。</b></p>
<h2 id="调用未知（DoS意外还原）"><a href="#调用未知（DoS意外还原）" class="headerlink" title="调用未知（DoS意外还原）"></a>调用未知（DoS意外还原）</h2><p>这个漏洞出现了在<a href="https://www.kingoftheether.com/" target="_blank" rel="noopener">King of Ether</a>智能合约中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract CallToTheUnknown &#123;</span><br><span class="line">  // Highest bidder becomes the Leader. </span><br><span class="line">  // Vulnerable to DoS attack by an attacker contract which reverts all transactions to it.</span><br><span class="line"></span><br><span class="line">    address currentLeader;</span><br><span class="line">    uint highestBid;</span><br><span class="line"></span><br><span class="line">    function() payable &#123;</span><br><span class="line">        require(msg.value &gt; highestBid);</span><br><span class="line">        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert</span><br><span class="line">        currentLeader = msg.sender;</span><br><span class="line">        highestBid = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pwn &#123;</span><br><span class="line">  // call become leader </span><br><span class="line">  function becomeLeader(address _address, uint bidAmount) &#123;</span><br><span class="line">    _address.call.value(bidAmount);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // reverts anytime it receives ether, thus cancelling out the change of the leader</span><br><span class="line">  function() payable &#123;</span><br><span class="line">    revert();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，攻击者的合约可以先通过向不安全的合约发送足够的以太成为主导。然后，另一个试图成为主导的玩家的交易将由于上面片段中的第25行(revert();)被抛出。虽然是一次简单的攻击，但这会导致合约永久性地拒绝服务，导致合约无效。这可以在遵循相同模式的其他庞式骗局合约中找到。</p>
<h2 id="短地址攻击"><a href="#短地址攻击" class="headerlink" title="短地址攻击"></a>短地址攻击</h2><p>这种攻击是由Golem团队发现的，详情请看<a href="https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95" target="_blank" rel="noopener">这篇文章</a>。这个漏洞允许攻击者滥用transfer函数并取出比他被准许的更多的ERC20代币。</p>
<p>注意：为了简单起见，我们会用正常一半大小的文字。</p>
<p>为了解释这个bug，让我们假设一个钱包里有10000个代币的交易所，和一个在那个交易所钱包里有32个代币余额的用户。让我们再假设这个用户的地址是0x12345600（注意尾部的零）而且他们想要取出比自己余额大的数额。他们就会去交易所，点击代币的取出按钮，<b style="color:blue">然后输入他们的地址但去掉尾部的零（交易所不验证输入的信息然后允许交易通过，即使攻击者的地址长度是无效的）</b>。</p>
<p>接着，EVM通过连接函数的签名和参数来计算输入的数据以便交易被执行。</p>
<p>ERC20的转送函数写为transfer(address to, uint256 amount)。那3个字段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sig : a9059cbb = web3.sha3(&quot;transfer(address,uint256)&quot;).slice(0,10)</span><br><span class="line">arg1: 123456   = receiving address</span><br><span class="line">arg2: 00000020  = 32 in hexademical (0x20)</span><br><span class="line">----------------------------------------</span><br><span class="line">Concatenated: a9059cbb 123456 00000020</span><br><span class="line">Transaction input data: 0xa9059cbb12345600000020</span><br></pre></td></tr></table></figure></p>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>仔细观察，交易的长度是2个字节（在现实世界中全字4个字节）。<b style="color:red">在这种情况下，EVM将会为交易补上尾部的零</b>， 变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xa9059cbb1234560000002000</span><br><span class="line">// a9059cbb = web3.sha3(&quot;transfer(address,uint256)&quot;).slice(0,10)</span><br><span class="line">// 12345600   = receiving address</span><br><span class="line">// 00002000  = 8192 in hexademical (0x2000 == 0x20&lt;&lt;8)</span><br></pre></td></tr></table></figure></p>
<p>这样一来，即使攻击者在交易所中的余额是32个代币，他们也能执行一个数额大得多的、合法的转移。这当然是在发送账户（交易所的钱包）拥有足够的转账余额的基础上。</p>
<p><b style="color:red">缓解措施：</b></p>
<ol>
<li>如果msg.data的大小无效，抛出</li>
<li>交易所必须对输入信息进行验证</li>
</ol>
<h2 id="额外红利"><a href="#额外红利" class="headerlink" title="额外红利"></a>额外红利</h2><p>避免在你的商业逻辑中使用now和block.blockhash，因为他们的结果是可预测的，或者会被矿工操控。想了解更多，请看<a href="https://link.zhihu.com/?target=https%3A//www.reddit.com/r/ethereum/comments/483rr1/do_not_use_block_hash_as_source_of_randomness/" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="我能做些什么来保护我的智能合约呢"><a href="#我能做些什么来保护我的智能合约呢" class="headerlink" title="我能做些什么来保护我的智能合约呢"></a>我能做些什么来保护我的智能合约呢</h3><p>这在很多地方都有提到，我个人最喜欢的在<a href="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702" target="_blank" rel="noopener">这里</a>。</p>
<p>其中，我最重要的选择是：</p>
<ol>
<li>别写华丽的代码</li>
<li>使用审计和测试过的代码</li>
<li>写尽可能多的单元测试</li>
</ol>
<h3 id="我能用什么工具来审计和分析我的代码呢？"><a href="#我能用什么工具来审计和分析我的代码呢？" class="headerlink" title="我能用什么工具来审计和分析我的代码呢？"></a>我能用什么工具来审计和分析我的代码呢？</h3><p>首先，solc执行语义检查是走向安全性的一大步，因为编译时可能会发现潜在的错误。</p>
<ol>
<li><a href="http://securify.ch/" target="_blank" rel="noopener">Securify.ch</a>是一个为了智能合约的静态分析工具</li>
<li><a href="http://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>也对你的代码静态分析，并能够发现如未初始化的存储指针和重入的错误</li>
<li><a href="https://github.com/melonproject/oyente" target="_blank" rel="noopener">Oyente</a>是另一个最近发布的智能合约分析工具</li>
<li><a href="https://github.com/IC3Hydra/Hydra" target="_blank" rel="noopener">Hydra</a>是一个“为了加密经济合约安全性的框架，去中心化安全奖励”</li>
<li><a href="https://github.com/comaeio/porosity" target="_blank" rel="noopener">Porosity</a>是一个“基于区块链以太坊智能合约的反编译器”</li>
<li><a href="https://github.com/trailofbits/manticore/" target="_blank" rel="noopener">Manticore</a>是一款带EVM支持的动态二进制分析工具</li>
<li><a href="https://github.com/trailofbits/ethersplay" target="_blank" rel="noopener">Ethersplay</a>是一个EVM的<a href="https://binary.ninja/" target="_blank" rel="noopener">Binary Ninja</a>插件</li>
</ol>
<p>最后，通过使用如solgraph之类的工具来图像化你的代码，可以帮助你发现关于函数可见性的潜在bug。</p>
<p><a href="https://github.com/raineorshine/solgraph" target="_blank" rel="noopener">https://github.com/raineorshine/solgraph</a></p>
<p>要更深入地了解对智能合约的攻击，请参阅：</p>
<ul>
<li><a href="https://medium.com/@weka/announcing-the-winners-of-the-first-underhanded-solidity-coding-contest-282563a87079" target="_blank" rel="noopener">The Underhanded Solidity Contest</a> [<a href="http://u.solidity.cc/" target="_blank" rel="noopener">1</a>,<a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017" target="_blank" rel="noopener">2</a>,<a href="https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1" target="_blank" rel="noopener">3</a>]</li>
<li><a href="https://github.com/trailofbits/not-so-smart-contracts/issues" target="_blank" rel="noopener">Trailofbits/not-so-smart-contracts</a></li>
<li><a href="https://eprint.iacr.org/2016/1007.pdf" target="_blank" rel="noopener">A survey of attacks on Ethereum Smart Contracts</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/known_attacks" target="_blank" rel="noopener">Smart contract best practices — Known attacks</a></li>
<li><a href="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702" target="_blank" rel="noopener">Onward with Smart Contract Security</a></li>
</ul>
<p>你可以练习你的智能合约黑客技巧在：<br><a href="http://ethernaut.zeppelin.solutions/" target="_blank" rel="noopener">Ethernaut</a>（需要ropsten testnet帐户）<br><a href="http://hackthiscontract.io/" target="_blank" rel="noopener">HackThisContract</a>（需要rinkeby testnet帐户</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/loomnetwork" target="_blank" rel="noopener">以太坊区块链的可扩展性</a><br><a href="https://medium.com/@gakonst" target="_blank" rel="noopener">Georgios Konstantopoulos</a><br><a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d" target="_blank" rel="noopener">How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1)</a><br><a href="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834" target="_blank" rel="noopener">How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 2)</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/29/blockchain/BIP-141-隔离见证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/blockchain/BIP-141-隔离见证/" itemprop="url">BIP-141 隔离见证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T20:16:24+08:00">2018-03-29</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><b style="color:red">这个BIP定义了一个称为“见证”的新结构，它承诺与交易处理树分开的块</b>。该结构包含检查交易有效性所需的数据，但不需要确定交易影响。特别是，脚本和签名被移到这个新的结构中。</p>
<p><b style="color:red">目击者是通过coinbase交易嵌入到块的现有merkle根目录中的树，以使BIP软叉兼容</b>。未来的硬分叉可以将这棵树放在它自己的分支中。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>整个交易的效果由输出消费（花费）和新输出创造决定。<b style="color:red">其他交易数据，特别是签名仅用于验证区块链状态，而不是确定区块链状态。</b></p>
<p>通过从交易结构中删除这些数据，这些数据被提交给交易处理树，几个问题得到解决：</p>
<ul>
<li><b>无意的延展性变得不可能。</b>由于签名数据不再是交易散列的一部分，因此交易签名方式的变化不再与交易标识相关。<b style="color:blue">作为交易可延展性的解决方案，这比典型签名方法（BIP62）要优越：</b><ul>
<li>它可以防止任何类型脚本的非自愿交易可塑性，只要所有输入都被签名（至少使用一次CHECKSIG或CHECKMULTISIG操作）</li>
<li>如果是m-n CHECKMULTISIG脚本，只有经过m个私钥持有者的同意才能进行交易（相对于只有1个拥有BIP62的私钥持有者）（<b style="color:red">注：隔离见证是需要比特币协议的支持的</b>）</li>
<li>它防止由于未知的ECDSA签名延展性而导致的非自愿交易延展性(<b style="color:red">我觉得应该是指scriptSig不签名而导致的问题</b>)</li>
<li><b style="color:red"> 它允许创建未经证实的交易依赖链而没有交易对手风险，这是离线协议的重要特征，如Lightning Network.</b></li>
</ul>
</li>
<li><b>签名数据的传输变为可选</b>。仅当对等方试图验证事务而不是仅仅检查其存在时才需要它。这样可以减少SPV证明的大小，并有可能提高SPV客户端的隐私，因为他们可以使用相同的带宽下载更多的事务。</li>
<li>通过将一部分交易数据移动到当前协议未知的结构中，可以通过软分支绕过某些约束，例如：<ul>
<li>在计算块大小时，见证的大小可以忽略/打折，在一定程度上有效地增加块大小</li>
<li>可以重新评估或删除硬编码常量，例如最大数据推送大小（520字节）或信号限制</li>
<li>可以引入新的脚本系统，而不受现有脚本语义的任何限制。例如，在BIP143中描述了用于交易签名验证的新的交易摘要算法</li>
</ul>
</li>
</ul>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="交易ID"><a href="#交易ID" class="headerlink" title="交易ID"></a>交易ID</h3><p><b style="color:red">一个新的数据结构witness被定义。每笔交易将有2个ID。</b></p>
<p>定义txid保持不变：传统序列化格式的双SHA256：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[nVersion] [txins] [txouts] [nLockTime]</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">wtxid定义了一个新的：具有目击者数据的新序列化的双SHA256：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[nVersion] [marker] [flag] [txins] [txouts] [witness] [nLockTime]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>nVersion，txins，txouts和nLockTime的格式是像传统的序列化。</li>
<li>marker必须是一个1字节的零值：0x00。</li>
<li>flag必须是1个字节的非零值。目前，必须使用0x01。</li>
<li><b style="color:red">witness是交易的所有见证数据的序列化。每个txin都与witness字段相关联。witness字段以var_int开始，以指示txin的堆栈项目的数目。随后是堆栈项目，每个项目以var_int开头以指示长度。见证数据不是脚本。</b></li>
</ul>
<p>非见证人程序（定义于下文）txin必须与空的见证字段相关联，使用0x00表示。如果所有的txins都不是witness程序，交易wtxid就等于它的交易txid。</p>
<h3 id="承诺结构"><a href="#承诺结构" class="headerlink" title="承诺结构"></a>承诺结构</h3><p>添加了一个新的区块规则，它需要对wtxid做出承诺（翻译是这样意思不太懂，也许是指要有wtxid字段吧）。coinbase交易的wtxid被认为是0x0000….0000。</p>
<p><b style="color:red">witness根hash</b>的计算方法与所有wtxid叶子一样，以类似于hashMerkleRoot块头中的方式计算。（其实就是与交易的默克尔树是一样的。）</p>
<p><b style="color:red">该承诺记录在coinbase交易的scriptPubKey中。它必须至少有38个字节，其中前6个字节0x6a24aa21a9ed是：</b></p>
<ul>
<li>1个字节 -  OP_RETURN（0x6a）</li>
<li>1字节 - 推送以下36个字节（0x24）</li>
<li>4字节 - 承诺（Commitment）头（0xaa21a9ed）</li>
<li>32字节 - 承诺哈希：Double-SHA256（见证根哈希|见证保留值）</li>
<li><b style="color:blue">第39个字节向前：可选数据，没有共识意义</b></li>
</ul>
<p>并且coinbase的输入见证必须由一个32字节的数组组成<code>witness reserved value</code>。</p>
<p><b style="color:red">如果有多个scriptPubKey匹配的模式，那么具有最高输出的索引的scriptPubKey被假定为承诺（commitment）。</b></p>
<p><b style="color:blue">如果块中的所有交易都没有见证数据，则该承诺（commitment）是可选的。</b></p>
<h3 id="见证程序（就是脚本啦）"><a href="#见证程序（就是脚本啦）" class="headerlink" title="见证程序（就是脚本啦）"></a>见证程序（就是脚本啦）</h3><p>由1字节推送(push)操作码（0至16）组成的scriptPubKey（或redeemScript如BIP16/P2SH中定义的），然后是2至40字节之间的数据推送，具有新的特殊含义。第一次推送的值被称为“版本字节”。下面推送的字节向量称为“见证程序”。（这个意思就是指NVersion + Script序列化后的数据吧！）</p>
<p><b style="color:red">witness验证逻辑被触发有两种情况。每种情况都决定了witness版本字节和程序的位置，以及scriptSig的形式：</b></p>
<ol>
<li>触发scriptPubKey一个版本字节，再加上一个witness程序。scriptSig必须完全为空或验证失败。（“本地witness程序”）</li>
<li><b style="color:blue">当scriptPubKey是P2SH脚本时被触发，并且redeemScript推入的BIP16 scriptSig恰好是推送版本字节加推送见证程序</b>。在scriptSig必须是完全的BIP-16的redeemScript或验证失败。（“P2SH witness程序”）</li>
</ol>
<p><b style="color:blue">如果版本字节是0，见证程序是20字节：</b></p>
<ul>
<li>它被解释为<code>pay-to-witness-public-key-hash</code>（P2WPKH）程序。</li>
<li><b style="color:red">witness必须包含2个项目（每个≤520个字节）。第一个是签名，第二个是公钥。</b></li>
<li>公钥的HASH160必须与20字节的见证程序相匹配。(不知这条的作用是啥，但是感觉很有用的样子)</li>
<li>在正常的脚本评估之后，使用CHECKSIG操作对照公钥验证签名。验证必须在堆栈上导致一个TRUE。</li>
</ul>
<p><b style="color:blue">如果版本字节为0（版本为0代表什么意思呢），见证程序为32字节：</b></p>
<ul>
<li>它被解释为pay-to-witness-script-hash（P2WSH）程序。</li>
<li>witness必须包含一个输入堆栈以供给脚本，然后是序列化脚本（witnessScript）。</li>
<li>witnessScript（≤10,000字节）从初始witness堆栈弹出。witnessScript的SHA256加密必须与32字节的见证程序相匹配。</li>
<li>witnessScript是反序列化的，并且在对其余见证堆栈（对于每个堆栈项≤520字节）的正常脚本评估之后执行。</li>
<li>该脚本不能失败，并且在堆栈中导致完全一个TRUE。</li>
</ul>
<p><b style="color:Red">如果版本字节为0，但见证程序既不是20也不是32字节，则脚本必须失败。</b><br><b style="color:Red">如果版本字节为1到16，则不会再有对witness程序或witness堆栈的进一步解释，并且证人堆栈没有大小限制。这些版本保留给未来的扩展.</b></p>
<h3 id="其他共识关键限制"><a href="#其他共识关键限制" class="headerlink" title="其他共识关键限制"></a>其他共识关键限制</h3><h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>目前块的总大小限制为1,000,000字节（1MB）。我们改变这个限制如下：</p>
<p>块重量定义为基本大小 * 3 + 总尺寸。</p>
<p>基本大小是原始交易序列化时的块大小（以字节为单位），没有任何见证相关数据，如未升级的节点所示。</p>
<p>总大小是按BIP144所述序列化交易的块大小（以字节为单位），包括基本数据和见证数据。</p>
<p>新规则是块重 ≤4,000,000。</p>
<h4 id="SIGOPS"><a href="#SIGOPS" class="headerlink" title="SIGOPS"></a>SIGOPS</h4><p>每块的信息量目前仅限于20,000个。我们改变这个限制如下：</p>
<p>当前pubkey脚本，签名脚本和P2SH检查脚本中的Sigops的计数是其先前值的4倍。sigop限制同样翻两番，达到80,000。</p>
<p>每个P2WPKH输入都被计为1 sigop。另外，P2WSH内的操作码witnessScript与先前在P2SH内的操作码相同redeemScript。也就是说，CHECKSIG被认为只有1个sigop，根据参数CHECKMULTISIG被计为1到20个sigops。该规则适用于本地证人计划和P2SH证人计划。</p>
<h3 id="附加定义"><a href="#附加定义" class="headerlink" title="附加定义"></a>附加定义</h3><p>以下定义不用于达成共识限制，但建议提供符合上述术语的语言。</p>
<h4 id="事务大小计算"><a href="#事务大小计算" class="headerlink" title="事务大小计算"></a>事务大小计算</h4><p>交易权重定义为基本交易规模 * 3 + 总交易规模（即与从基本规模和总规模计算分块权重相同的方法）。</p>
<p>虚拟交易大小定义为交易权重/4（四舍五入到下一个整数）。</p>
<p>基本交易大小是剥离见证数据的序列化交易的大小。</p>
<p>总交易大小是按BIP144中所述序列化的交易大小（以字节为单位），包括基本数据和见证数据。</p>
<h4 id="新的脚本语义"><a href="#新的脚本语义" class="headerlink" title="新的脚本语义"></a>新的脚本语义</h4><p>尽管P2WPKH和P2WSH的脚本语言看起来与预先隔离的witness脚本非常相似，但有几处显着的差异。用户不得假定在预先隔离的witness系统中花费的脚本也可以用作P2WPKH或P2WSH脚本。在生产网络中进行大规模部署之前，开发人员应该在testnet上测试脚本，并启用默认的中继策略，并在主网络上激活BIP141之后用少量资金进行测试。</p>
<p>在BIP143中描述了共识级别的一个主要区别，即作为0版见证程序中用于签名验证的新的交易摘要算法。</p>
<p>在参考实施版本0.13.1的第​​一版隔离见证中还包括三项接力和采矿政策。基于这些政策的软分叉很可能会在不久的将来提出。为了避免无限期延迟交易确认和永久性资金损失，用户必须仔细观察新的语义：</p>
<ul>
<li>在P2WPKH和P2WSH中只接受压缩的公钥（见<a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" rel="noopener">BIP143</a>）</li>
<li>P2WSH中OP_IF/NOTIF的参数必须最小</li>
<li>如果OP_CHECKSIG或OP_CHECKMULTISIG失败（对于预先隔离的证人脚本和P2WSH，则签名必须为空矢量（参见<a href="https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki" target="_blank" rel="noopener">BIP146</a>）</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="P2WPKH"><a href="#P2WPKH" class="headerlink" title="P2WPKH"></a>P2WPKH</h3><p>以下示例是版本0的pay-to-witness-public-key-hash（P2WPKH）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">witness:      &lt;signature&gt; &lt;pubkey&gt;</span><br><span class="line">scriptSig:    (empty)</span><br><span class="line">scriptPubKey: 0 &lt;20-byte-key-hash&gt;</span><br><span class="line">                (0x0014&#123;20-byte-key-hash&#125;)</span><br></pre></td></tr></table></figure></p>
<p>scriptPubKey中的’0’表示以下推送是版本0见证程序。见证计划的长度表明它是一种P2WPKH类型。证人必须包含2件物品。witness中公钥的HASH160必须与witness程序相匹配。</p>
<p>签名被验证为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;signature&gt; &lt;pubkey&gt; CHECKSIG</span><br></pre></td></tr></table></figure></p>
<p>&lt;b style=””color:red&gt;与传统P2PKH输出相比，P2WPKH等价物在scriptPubKey中占用3个字节，并将签名和公钥从ScriptSig移动到见证。(找到数据应该是通过wtxid)</p>
<h3 id="P2WPKH嵌套在BIP16-P2SH中"><a href="#P2WPKH嵌套在BIP16-P2SH中" class="headerlink" title="P2WPKH嵌套在BIP16 P2SH中"></a>P2WPKH嵌套在BIP16 P2SH中</h3><p>以下示例与P2WPKH相同，但嵌套在BIP16 P2SH输出中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">witness:      &lt;signature&gt; &lt;pubkey&gt;</span><br><span class="line">scriptSig:    &lt;0 &lt;20-byte-key-hash&gt;&gt;</span><br><span class="line">                (0x160014&#123;20-byte-key-hash&#125;)</span><br><span class="line">scriptPubKey: HASH160 &lt;20-byte-script-hash&gt; EQUAL</span><br><span class="line">                (0xA914&#123;20-byte-script-hash&#125;87)</span><br></pre></td></tr></table></figure></p>
<p>scriptSig中的唯一项目与HASH160进行哈希处理，与scriptPubKey中的20字节脚本哈希进行比较，并解释为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;20-byte-key-hash&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后按照前面例子中的描述验证公钥和签名。</p>
<p>与前面的例子相比，scriptPubKey大1个字节，scriptSig大23个字节。尽管嵌套见证程序的效率较低，但对于自0.6.0版本以来的所有比特币参考客户端，其支付地址都是完全透明且向后兼容的。</p>
<h3 id="P2WSH"><a href="#P2WSH" class="headerlink" title="P2WSH"></a>P2WSH</h3><p>以下示例是1-of-2多重签名版本0付钱证人脚本哈希（P2WSH）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">witness:      0 &lt;signature1&gt; &lt;1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG&gt;</span><br><span class="line">scriptSig:    (empty)</span><br><span class="line">scriptPubKey: 0 &lt;32-byte-hash&gt;</span><br><span class="line">                (0x0020&#123;32-byte-hash&#125;)</span><br></pre></td></tr></table></figure></p>
<p>scriptPubKey中的’0’表示以下推送是版本0见证程序。见证程序的长度表明它是一个P2WSH类型。证人中的最后一项（“witnessScript”）被弹出，用SHA256散列，与scriptPubKey中的32字节散列相比较，并反序列化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG</span><br></pre></td></tr></table></figure></p>
<p>该脚本使用来自witness的其余数据执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;signature1&gt; 1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG</span><br></pre></td></tr></table></figure></p>
<p>P2WSH允许10,000字节的最大脚本大小，因为520字节的推动限制被绕过。</p>
<p>scriptPubKey占用34个字节，而不是23个字节的BIP16 P2SH。大小的增加提高了可能发生的碰撞攻击的安全性，因为2<sup>80</sup>工作不再可行（截至2015年底，自比特币创建以来，已有2<sup>84</sup>次哈希计算在比特币挖矿中）。<b style="color:red">支出脚本与等效的BIP16 P2SH输出相同，但被移至见证。</b></p>
<h3 id="P2WSH嵌套在BIP16-P2SH中"><a href="#P2WSH嵌套在BIP16-P2SH中" class="headerlink" title="P2WSH嵌套在BIP16 P2SH中"></a>P2WSH嵌套在BIP16 P2SH中</h3><p>以下示例是相同的1对2多重签名P2WSH脚本，但嵌套在BIP16 P2SH输出中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">witness:      0 &lt;signature1&gt; &lt;1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG&gt;</span><br><span class="line">scriptSig:    &lt;0 &lt;32-byte-hash&gt;&gt;</span><br><span class="line">                (0x220020&#123;32-byte-hash&#125;)</span><br><span class="line">scriptPubKey: HASH160 &lt;20-byte-hash&gt; EQUAL</span><br><span class="line">                (0xA914&#123;20-byte-hash&#125;87)</span><br></pre></td></tr></table></figure></p>
<p>scriptSig中的唯一项目与HASH160进行哈希处理，与scriptPubKey中的20字节哈希进行比较，并解释为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;32-byte-hash&gt;</span><br></pre></td></tr></table></figure></p>
<p>P2WSH witnessScript然后按照前面例子中的描述执行。</p>
<p>与前面的例子相比，scriptPubKey小11个字节（安全性降低），而证人是相同的。但是，它也需要scriptSig中的35个字节。</p>
<h3 id="可扩展的承诺结构"><a href="#可扩展的承诺结构" class="headerlink" title="可扩展的承诺结构"></a>可扩展的承诺结构</h3><p>在coinbase交易的新承诺是witness root hash和witness reserved value的hash。在witness reserved value目前还没有达成共识的意义，但是将来会为未来的softforks允许新的承诺值。例如，如果未来需要一项新的共识批评（consensus-critical）承诺，则基础承诺将变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double-SHA256(Witness root hash|Hash(new commitment|witness reserved value))</span><br></pre></td></tr></table></figure></p>
<p>为了向后兼容，Hash(new commitment|witness reserved value)将会转到coinbase见证，并且witness reserved value将被记录在将来的softfork指定的另一个位置。可以通过这种方式添加任何数量的新承诺。</p>
<p>对比特币没有共识至关重要性的任何承诺，例如合并挖掘，都不得使用该功能witness reserved value来保留升级比特币共识协议的能力。</p>
<p>承诺之后的可选数据空间也为将来软叉的元数据留有余地，并且不得用于其他目的。</p>
<h3 id="无信任的未确认交易依赖链"><a href="#无信任的未确认交易依赖链" class="headerlink" title="无信任的未确认交易依赖链"></a>无信任的未确认交易依赖链</h3><p>隔离见证从根本上解决了交易延展性问题，从而以无信任的方式构建未经证实的交易依赖链。</p>
<p>Alice和Bob两方可能会同意将一定比特币发送到2比2的多重输出（“资金交易”）。如果没有签署资金交易，他们可能会创建另一个交易，在未来时间锁定，将2比2的多重输出投入到第三个账户（“支出交易”）。Alice和Bob将签署消费交易并交换签名。在审查签名后，他们将签署资金交易并将其交易给区块链。如果没有采取进一步行动，支出交易将在锁定时间后确认，并根据原始合同发放资金。<b style="color:red">它还保留了在锁定时间之前撤销原始合同的灵活性，通过锁定时间更短的另一笔支出交易，但只有在双方达成共识的情况下。</b></p>
<p>BIP62不可能将此类设置作为延展性修复，因为如果双方首次签署资金交易，则无法创建支出交易。如果Alice在Bob之前披露资金交易签名，Bob可以无限期锁定资金，而无需签署支出交易。</p>
<p>未经证实的交易依赖链是更复杂的支付网络的基本组成部分，比如双工微支付渠道和闪电网络，它们有可能极大地提高比特币系统的可扩展性和效率。</p>
<h2 id="未来的扩展"><a href="#未来的扩展" class="headerlink" title="未来的扩展"></a>未来的扩展</h2><h3 id="适用于SPV节点的紧凑型欺诈证明"><a href="#适用于SPV节点的紧凑型欺诈证明" class="headerlink" title="适用于SPV节点的紧凑型欺诈证明"></a>适用于SPV节点的紧凑型欺诈证明</h3><p>比特币现在只有两种真正的安全模式。用户或者运行一个全节点来验证系统中所有规则的每个块，或者一个SPV（简单支付验证）客户端，它只验证头部作为一些交易发布的证明。比特币白皮书建议，当SPV节点检测到无效块时，可以接受来自完整节点的警报，提示SPV节点下​​载有问题的块和交易进行验证。但是，这种方法可能会成为DoS攻击媒介，因为几乎不会产生虚警。警报必须具有紧凑但确定性的欺诈证据。</p>
<p>在目前的比特币协议中，除了少数几个规则外，几乎所有规则都可以生成紧凑的欺诈证据：</p>
<ol>
<li>无法证明矿工在coinbase交易输出中引入了太多比特币，而没有显示整个块本身和所有输入交易。</li>
<li>不可能证明违反任何块特定的约束条件，例如大小和sigop限制，而不显示整个块（以及在sigop限制情况下的所有输入交易）</li>
<li>如果没有从区块链上回溯到创世区块的所有交易ID，则无法证明花费了一些不存在的输入。</li>
</ol>
<p>可以提交额外的见证数据，以允许SPV节点可以快速验证的块无效的简短证明：</p>
<ol>
<li>交易费的总和树可以用来构建简短的证明，证明矿工不会为coinbase交易增加额外的费用。类似于块大小和sigop计数限制。</li>
<li>可以提供交易输入所花费输出的反向链接。这些反向链接包含块散列和瘦客户端可轻松查询和检查以验证输出是否存在的偏移量。</li>
</ol>
<p>这些承诺可以通过软分叉包含在可扩展的承诺结构中，并且对不了解这些新规则的节点是透明的。</p>
<h3 id="新的脚本系统"><a href="#新的脚本系统" class="headerlink" title="新的脚本系统"></a>新的脚本系统</h3><p><b style="color:red">由于version字节在witness程序之前被推送，并且版本未知的程序总是被视为任何人可以花费的脚本，所以可以通过软分叉来引入任何新的脚本系统。作为结构的见证不受任何现有脚本语义和约束的限制，特别是520字节的推送限制，因此允许任意大的脚本和签名。</b></p>
<p>新的脚本系统的例子包括Schnorr签名，可以显着减少多重交易处理的大小，Lamport签名是量子计算阻力，Merklized抽象语法树允许非常复杂的条件脚本的非常紧凑的见证。</p>
<h3 id="每个输入锁定时间（Per-input-lock-time）和相对锁定时间（relative-lock-time）"><a href="#每个输入锁定时间（Per-input-lock-time）和相对锁定时间（relative-lock-time）" class="headerlink" title="每个输入锁定时间（Per-input lock-time）和相对锁定时间（relative-lock-time）"></a>每个输入锁定时间（Per-input lock-time）和相对锁定时间（relative-lock-time）</h3><p>目前交易中只有一个nLockTime字段，并且所有输入必须共享相同的值。BIP68使用nSequence字段启用每个输入的相对锁定时间，但锁定时间段和分辨率有限。</p>
<p><b style="color:red">通过软分叉，可以引入单独的见证结构以允许每个输入的锁定时间和相对锁定时间，以及可以签署和操作新数据的新脚本系统（如BIP65和BIP112）。</b></p>
<h2 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h2><p><b style="color:red">作为一个软分叉，较旧的软件将继续无需修改即可运行</b>。但是，未升级的节点将不会看到也不会验证证人数据，并将所有见证程序视为任何人可以花费的脚本（除了几个证据程序等于0的边缘情况，脚本必须失败）。钱包应该时刻警惕任何人可以花钱的脚本，并怀疑地对待它们。强烈建议未升级的节点升级以利用新功能。</p>
<h3 id="未升级的钱包可以做什么"><a href="#未升级的钱包可以做什么" class="headerlink" title="未升级的钱包可以做什么"></a>未升级的钱包可以做什么</h3><ol>
<li>从未升级和升级的钱包接收比特币</li>
<li>使用传统P2PKH地址将比特币发送给未升级和升级的钱包（没有任何隔离见证的好处）</li>
<li>使用P2SH地址将比特币发送到升级的钱包</li>
<li>通过<a href="https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki" target="_blank" rel="noopener">BIP70</a>支付协议使用本地见证程序将比特币发送至升级的钱包</li>
</ol>
<h3 id="非升级的钱包不能做什么"><a href="#非升级的钱包不能做什么" class="headerlink" title="非升级的钱包不能做什么"></a>非升级的钱包不能做什么</h3><ul>
<li>验证隔离的证人交易。它假定这样的交易总是有效的</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>该BIP将通过名称为“segwit”的“版本位”BIP9并使用位1进行部署。</p>
<p>对于比特币主网络，BIP9启动时间将为2016年11月15日午夜UTC（时代邮戳时间戳1479168000），并且BIP9超时时间将为2017年11月15日午夜UTC（时代邮戳时间戳1510704000）。</p>
<p>对于比特币测试网，BIP9开始时间将为UTC时间2016年5月1日午夜（时间戳1462060800）和BIP9超时时间为UTC时间2017年5月1日（时间戳1493596800）。</p>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>特别感谢Gregory Maxwell在本BIP和Luke-Jr中提出了许多想法，以便弄清楚如何将其作为软分叉来部署。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>^ 例如，带OP_0的scriptPubKey后跟40字节的非零数据推送将由于程序大小不正确而失败。但是，带OP_0后跟41字节非零数据推送的scriptPubKey将会通过，因为它不被视为见证程序<br>^ 为了向后兼容，对于从0到16的任何版本字节，如果证明程序的CastToBool值为零，则脚本必须失败。然而，像这样的哈希是一个成功的对哈希函数的原像攻击，风险可以忽略不计。<br>^ 使用单个复合约束的原理，而不是两个单独的限制，例如1MB基础数据和3MB见证数据：使用两个单独的限制将使挖掘和费用估计几乎不可能。矿工们需要解决一个复杂的非线性优化问题，以找到在给定两个约束条件的情况下使费用最大化的一组交易，并且钱包将不能知道该支付什么，因为它取决于两个条件中的哪一个最受到实时的矿工们试图用他们的交易来生产积木。这种方法的另一个问题是闲聊。一旦一组事务处理达到基本数据1MB约束条件，通过最低限度地增加费用就可以向证人添加高达3MB的额外数据。在这种情况下，额外见证空间的边际成本实际上变为零。<br>^ <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html" target="_blank" rel="noopener">https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html</a></p>
<h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p><a href="https://github.com/bitcoin/bitcoin/pull/8149" target="_blank" rel="noopener">https://github.com/bitcoin/bitcoin/pull/8149</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki" target="_blank" rel="noopener">BIP16支付脚本散列</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki" target="_blank" rel="noopener">BIP143版本0witness程序的交易签名验证</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki" target="_blank" rel="noopener">BIP144隔离见证（同伴节点服务）</a></p>
<h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>该文件置于公共领域。</p>
<h2 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h2><p><a href="https://zhuanlan.zhihu.com/p/27512347" target="_blank" rel="noopener">bitcoin 源码解析 - 交易 Transaction(三) - Script</a><br><a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki" target="_blank" rel="noopener">bips/bip-0141.mediawiki</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/blockchain/什么是Secp256k1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/blockchain/什么是Secp256k1/" itemprop="url">什么是Secp256k1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T20:53:47+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文的阅读需要理解椭圆曲线，了解相关知识请查看我之前的博客文档。</p>
<p><b style="color:red">secp256k1是指比特币中使用的ECDSA曲线的参数</b>，并且在高效密码学标准（SEC）（Certicom Research，<a href="http://www.secg.org/sec2-v2.pdf）中进行了定义。" target="_blank" rel="noopener">http://www.secg.org/sec2-v2.pdf）中进行了定义。</a></p>
<p>在比特币开始流行之前，secp256k1几乎从未使用过，但由于其几个不错的属性，它现在越来越受欢迎。大多数常用曲线具有随机结构，但secp256k1是以特殊的非随机方式构建的，可以实现特别高效的计算。<b style="color:red">因此，如果实施得到充分优化，它通常比其他曲线快30％以上</b>。<b style="color:blue">另外，与流行的NIST曲线不同，secp256k1的常量是以可预测的方式选择的，这大大降低了曲线创建者在曲线中插入任何后门的可能性。</b></p>
<p>下面看一下这里面的函数图：</p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/Secp256k1%E5%87%BD%E6%95%B0%E5%9B%BE.png?raw=true" alt=""></p>
<p><b style="color:blue">Secp256k1是secp256k1椭圆曲线y<sup>2</sup> = x<sup>3</sup> + 7在实数上的图形。请注意，因为secp256k1实际上是在字段Z<sub>p</sub>上定义的，所以它的图形实际上看起来像是随机分散的点，而不是像图中这样是连续的点。</b></p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>从标准摘录：</p>
<p>与Koblitz曲线secp256k1相关联的F<sub>p</sub>上的椭圆曲线域参数由单元T=（p，a，b，G，n，h）指定，其中有限域F<sub>p</sub>由下式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F</span><br><span class="line">= 2256 - 232 - 29 - 28 - 27 - 26 - 24 - 1</span><br></pre></td></tr></table></figure></p>
<p>F<sub>p</sub>上的曲线E：y<sup>2</sup> = x<sup>3</sup> + ax + b由下式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007</span><br></pre></td></tr></table></figure></p>
<p>压缩形式的基点G是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798</span><br></pre></td></tr></table></figure></p>
<p>而在未压缩的形式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</span><br></pre></td></tr></table></figure></p>
<p>最后，G的循环因子n(就是指nG=G)和辅因子h如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141</span><br><span class="line">h = 01</span><br></pre></td></tr></table></figure></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>secp256k1具有特征p，它的素数域定义为ℤ<sub>p</sub>。常用的一些其他曲线具有特征2，并且在二进制伽罗瓦(Galois)域GF(2<sup>n</sup>)上定义，但secp256k1不是其中之一。</li>
<li>因为一个常数为零，曲线方程中<code>ax</code>项始终为零，因此曲线方程变为y<sup>2</sup> = x<sup>3</sup> + 7。</li>
</ul>
<h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><p><a href="https://bitcoin.stackexchange.com/questions/21907/what-does-the-curve-used-in-bitcoin-secp256k1-look-like" target="_blank" rel="noopener">secp256k1是什么（Pieter Wuille的比特币堆栈交换答案）</a></p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://en.bitcoin.it/wiki/Secp256k1" target="_blank" rel="noopener">Secp256k1</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/blockchain/Bitcoin中Base58Check/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/blockchain/Bitcoin中Base58Check/" itemprop="url">Bitcoin中Base58Check编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T16:58:57+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Base58二进制到文本编码被称为Base58Check，用于编码比特币地址。</p>
<p>更一般地说，Base58Check编码用于将比特币中的字节数组编码为人类可分类的字符串。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最初的比特币客户端源代码解释了base58编码背后的原因：</p>
<p>base58.h：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为什么base-58而不是标准的base-64编码？</span><br><span class="line">//  - 不希望0OIl字符在某些字体和字体中看起来相同</span><br><span class="line">//可以用来创建视觉上相同的账号。</span><br><span class="line">//  - 具有非字母数字字符的字符串并不像帐号那么容易被接受。</span><br><span class="line">//  - 如果没有标点符号，电子邮件通常不会换行。</span><br><span class="line">//  - 如果全部是字母数字，Doubleclicking会将整个数字选为一个单词。</span><br></pre></td></tr></table></figure></p>
<h2 id="Base58Check的功能"><a href="#Base58Check的功能" class="headerlink" title="Base58Check的功能"></a>Base58Check的功能</h2><p>Base58Check具有以下功能：</p>
<ul>
<li>一个任意大小的payload（<b style="color:red">这个payload其实就是公钥的HASH160的双次hash值</b>）。</li>
<li>由容易区分的大写和小写字母组成的一组58个字母数字符号（0OIl不使用）(<b style="color:red">主要的原因还是因为可能会产生歧义</b>)</li>
<li>一个字节的version/application信息。对于这个字节比特币地址使用0x00（未来的可能使用0x05）。</li>
<li>四个字节（32位）基于SHA256的错误校验码。此校验码可用于自动检测并可能更正印刷错误。</li>
<li>保留数据中前导零的额外步骤。（这里应该更深入地进行分析才是，但是现在真不太明白这里面的意思。）</li>
</ul>
<h2 id="创建一个Base58Check字符串"><a href="#创建一个Base58Check字符串" class="headerlink" title="创建一个Base58Check字符串"></a>创建一个Base58Check字符串</h2><p>Base58Check字符串是从version/application字节和payload创建的，如下所示。</p>
<ol>
<li>获取version字节和payload字节，并将它们连接在一起（按字节）。</li>
<li>取SHA256的前四个字节（SHA256（步骤1的结果））（<b style="color:red">也应该是前面提到的那四个字节的事情</b>）</li>
<li>将步骤1的结果和步骤2的结果连在一起（按字节顺序）。</li>
<li>处理步骤3的结果 - 一系列字节 - <b style="color:red">作为单个大端序号</b>，使用正常的数学步骤（bignumber division）和下面描述的base-58字母表转换为base-58。结果应该被标准化为没有任何前导的base-58零（字符’1’）。(<b style="color:red">这里注意前导0对应的Base58Check是1</b>)</li>
<li>在base58中值为零的前导字符’1’被保留用于表示整个前导零字节，就像它处于前导位置时一样，没有值作为base-58符号。必要时可以有一个或多个前导’1’来表示一个或多个前导零字节。计算第3步结果的前导零字节数（对于旧的比特币地址，至少有一个用于版本/应用程序字节;对于新地址，将永远不会有）。每个前导零字节在最终结果中应由其自己的字符’1’表示。</li>
<li>将步骤5中的1与步骤4 的结果连接起来。这是Base58Check的结果。</li>
</ol>
<p>在描述比特币地址<a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address" target="_blank" rel="noopener">技术背景</a>的页面上提供了一个更详细的例子。</p>
<h2 id="编码比特币地址"><a href="#编码比特币地址" class="headerlink" title="编码比特币地址"></a>编码比特币地址</h2><p>比特币地址是使用以下任一项的散列的Base58Check编码实现的：</p>
<ul>
<li>Pay-to-script-hash（p2sh）：有效载荷是：其中redeemScript是钱包知道如何消费的脚本; 版本（这些地址以数字’3’开头）RIPEMD160(SHA256(redeemScript))0x05</li>
<li>支付到PUBKEY散列（p2pkh）：有效载荷是其中ECDSA_publicKey是钱包知道的私有密钥的公共密钥; 版本（这些地址以数字’1’开头）RIPEMD160(SHA256(ECDSA_publicKey))0x00</li>
</ul>
<p>在这两种情况下得到的散列总是恰好为20个字节。这些是大端（最重要的字节在前）。（注意那些限制前导0x00字节的数字编码实现，或者预先增加额外的0x00字节来表示符号 - 你的代码必须正确处理这些情况，否则你可能会生成可以发送到但看不到的有效地址 -导致硬币的永久损失。）</p>
<h2 id="编码一个私钥"><a href="#编码一个私钥" class="headerlink" title="编码一个私钥"></a>编码一个私钥</h2><p><b style="color:red">Base58Check编码也用于编码钱包导入格式中的<a href="https://en.bitcoin.it/wiki/Private_key" target="_blank" rel="noopener">ECDSA私钥</a></b>。除了0x80用于version/application字节，并且有效载荷是32字节而不是20（比特币中的私钥是单个32字节无符号的大端整数）之外，它与比特币地址完全相同。对于与未压缩的公钥相关的私钥，这种编码总是会产生一个以’5’开头的51个字符的字符串，或者更具体地说’5H’，’5J’或’5K’。</p>
<h2 id="Base58符号图表"><a href="#Base58符号图表" class="headerlink" title="Base58符号图表"></a>Base58符号图表</h2><p>比特币中使用的Base58符号图特定于比特币项目，并不打算与比特币之外使用的任何其他Base58实现（排除的字符为：0，O，I和l）相同。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>字符</th>
<th>值</th>
<th>字符</th>
<th>值</th>
<th>字符</th>
<th>值</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>8</td>
<td>9</td>
<td>9</td>
<td>A</td>
<td>10</td>
<td>B</td>
<td>11</td>
<td>C</td>
</tr>
<tr>
<td>12</td>
<td>D</td>
<td>13</td>
<td>E</td>
<td>14</td>
<td>F</td>
<td>15</td>
<td>G</td>
</tr>
<tr>
<td>16</td>
<td>H</td>
<td>17</td>
<td>J</td>
<td>18</td>
<td>K</td>
<td>19</td>
<td>L</td>
</tr>
<tr>
<td>20</td>
<td>M</td>
<td>21</td>
<td>N</td>
<td>22</td>
<td>P</td>
<td>23</td>
<td>Q</td>
</tr>
<tr>
<td>24</td>
<td>R</td>
<td>25</td>
<td>S</td>
<td>26</td>
<td>T</td>
<td>27</td>
<td>U</td>
</tr>
<tr>
<td>28</td>
<td>V</td>
<td>29</td>
<td>W</td>
<td>30</td>
<td>X</td>
<td>31</td>
<td>Y</td>
</tr>
<tr>
<td>32</td>
<td>Z</td>
<td>33</td>
<td>a</td>
<td>34</td>
<td>b</td>
<td>35</td>
<td>c</td>
</tr>
<tr>
<td>36</td>
<td>d</td>
<td>37</td>
<td>e</td>
<td>38</td>
<td>f</td>
<td>39</td>
<td>g</td>
</tr>
<tr>
<td>40</td>
<td>h</td>
<td>41</td>
<td>i</td>
<td>42</td>
<td>j</td>
<td>43</td>
<td>k</td>
</tr>
<tr>
<td>44</td>
<td>m</td>
<td>45</td>
<td>n</td>
<td>46</td>
<td>o</td>
<td>47</td>
<td>p</td>
</tr>
<tr>
<td>48</td>
<td>q</td>
<td>49</td>
<td>r</td>
<td>50</td>
<td>s</td>
<td>51</td>
<td>t</td>
</tr>
<tr>
<td>52</td>
<td>u</td>
<td>53</td>
<td>v</td>
<td>54</td>
<td>w</td>
<td>55</td>
<td>x</td>
</tr>
<tr>
<td>56</td>
<td>y</td>
<td>57</td>
<td>z</td>
</tr>
</tbody>
</table>
<p>编码address_byte_string的算法（由1-byte_version + hash_or_other_data + 4-byte_check_code组成）是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">code_string = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span><br><span class="line">x = convert_bytes_to_big_integer(hash_result)</span><br><span class="line"></span><br><span class="line">output_string = &quot;&quot;</span><br><span class="line"></span><br><span class="line">while(x &gt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        (x, remainder) = divide(x, 58)</span><br><span class="line">        output_string.append(code_string[remainder])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">repeat(number_of_leading_zero_bytes_in_hash)</span><br><span class="line">    &#123;</span><br><span class="line">    output_string.append(code_string[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">output_string.reverse();</span><br></pre></td></tr></table></figure></p>
<h2 id="版本字节"><a href="#版本字节" class="headerlink" title="版本字节"></a>版本字节</h2><p>以下是一些常见的版本字节：</p>
<table>
<thead>
<tr>
<th>小数版本</th>
<th>领导的象征</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>Bitcoin pubkey hash</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>Bitcoin script hash</td>
</tr>
<tr>
<td>21</td>
<td>4</td>
<td>Bitcoin (compact) public key (proposed)</td>
</tr>
<tr>
<td>52</td>
<td>M or N</td>
<td>Namecoin pubkey hash</td>
</tr>
<tr>
<td>128</td>
<td>5</td>
<td>Private key</td>
</tr>
<tr>
<td>111</td>
<td>m or n</td>
<td>Bitcoin testnet pubkey hash</td>
</tr>
<tr>
<td>196</td>
<td>2</td>
<td>Bitcoin testnet script hash</td>
</tr>
</tbody>
</table>
<p><a href="https://en.bitcoin.it/wiki/List_of_address_prefixes" target="_blank" rel="noopener">地址前缀列表</a>是一个完整的列表。</p>
<h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><p><a href="http://lenschulwitz.com/base58" target="_blank" rel="noopener">在线Base58解码器，编码器和验证器</a></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp" target="_blank" rel="noopener">“Satoshi”C ++ codebase（解码和编码，不需要外部库）</a><br><a href="https://github.com/luke-jr/libbase58" target="_blank" rel="noopener">libbase58 C代码（解码和编码，不需要外部库）</a><br><a href="http://lenschulwitz.com/b58/base58perl.txt" target="_blank" rel="noopener">Base58在Perl中解码，编码和验证</a></p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://en.bitcoin.it/wiki/Base58Check_encoding" target="_blank" rel="noopener">Base58Check encoding</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于比特币地址知识，在精通比特币中有详细地介绍，这里我们不做更多的介绍，这篇文章是我翻译的结果。</p>
<p>在之前我们分析过椭圆曲线的知识，对于确定性钱包的知识我们也做了相关地介绍，还有就是分层确定性钱包的知识。</p>
<p><b style="color:red">另外Base58Check还有一个极大的好处就是可以校验地址是不是正确的，因为Base58生成的时候是加入了校验码</b>。我觉得比特币团队做的真的是很棒不是吗？详情可以参考：<a href="http://8btc.com/thread-31201-1-1.html" target="_blank" rel="noopener">为什么以太坊地址中没有校验值？</a></p>
<p><b style="color:red">对于比特币地址也要特别注意一下，地址类型也就是version/appication字段其实是自己加入的，和ecdsa本身并没有任何关系。校验码也是自己加上去的而已。我们可以看一下下面的图片.</b></p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%9D%9E%E5%8E%8B%E7%BC%A9%E5%85%AC%E9%92%A5%E7%94%9F%E6%88%90%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B.png?raw=true" alt=""></p>
<p>有一段时间我在分析java的ECKey的代码发现java底层的椭圆曲线算法的实现，这里我就不做更多的说明了。<b style="color:red">关键是我们如何实现分层确定性钱包，这个很简单也很复杂，其实就是找私钥G，至于这个G怎么找，我们可以查看精通比特币里面的说明，这里面只是提到了HMAC-SHA512。看来这里面隐藏了很多的细节因素，我们有时间需要研究一下，HMAC-SHA512的知识了。</b></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/java/Spring循环依赖检查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/java/Spring循环依赖检查/" itemprop="url">Spring循环依赖检查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T15:34:46+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于循环依赖检查，一般地数据结构就是DAG（有向无环图图）。所以在Spring中也是这样去实现的。</p>
<p>在Spring中检查依赖是和注入的方式有很大关系的。</p>
<h2 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h2><p>Spring容器将每一个正在创建的Bean 标识符放在一个“<b style="color:red">当前创建Bean池</b>”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；<b style="color:red">而对于创建完毕的Bean将从“当前创建Bean池”中清除掉</b>。</p>
<h2 id="setter循环依赖"><a href="#setter循环依赖" class="headerlink" title="setter循环依赖"></a>setter循环依赖</h2><p>对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的Bean来完成的，而且<b style="color:red">只能解决单例作用域的Bean循环依赖</b>。我唯一有印象的就是这里的代码，之后如果再读Spring源码，我们再来进行详细地分析。</p>
<p>通过提前暴露一个<b style="color:red">单例工厂方法ObjectFactory</b>，从而使其他Bean能引用到该Bean。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决问题的方式是多种多样的，以后一定要想如何去解决一个问题，而不是关注问题本身的解决。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/java/Spring中创建bean的几种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/java/Spring中创建bean的几种方式/" itemprop="url">Spring中创建bean的几种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T14:36:40+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在忙于区块链知识的研究，却忘记了Spring的很多知识。其实我主打的知识还是应该是Spring、SpringMVC、Mybatis、Tomcat、SpringBoot、SpringCloud等等。但是实际上我现在对这方面的知识遗忘还是很厉害的。今天就来回顾一下Spring创建Bean的几种方式。</p>
<h2 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;hello&quot; name=&quot;helloImpl&quot; class=&quot;cn.javass.spring.chapter2.helloworld.HelloImpl&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="有参数的构造方法"><a href="#有参数的构造方法" class="headerlink" title="有参数的构造方法"></a>有参数的构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;bean2&quot; class=&quot;cn.javass.spring.chapter2.HelloImpl2&quot;&gt;</span><br><span class="line">    &lt;!-- 指定构造器参数 --&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a>静态工厂方式</h2><p>静态工厂的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloApiStaticFactory &#123;</span><br><span class="line">    //工厂方法</span><br><span class="line">    public static HelloApi newInstance(String message) &#123;</span><br><span class="line">        //返回需要的Bean实例</span><br><span class="line">        return new HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>xml的配置方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用静态工厂方法 --&gt;</span><br><span class="line">&lt;bean id=&quot;bean3&quot; class=&quot;cn.javass.spring.chapter2.HelloApiStaticFactory&quot; factory-method=&quot;newInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="实例工厂方法实例化Bean"><a href="#实例工厂方法实例化Bean" class="headerlink" title="实例工厂方法实例化Bean"></a>实例工厂方法实例化Bean</h2><p>实例工厂类代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.javass.spring.chapter2;</span><br><span class="line"></span><br><span class="line">public class HelloApiInstanceFactory &#123;</span><br><span class="line">    public HelloApi newInstance(String message) &#123;</span><br><span class="line">        return new HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>xml的定义方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—1、定义实例工厂Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;cn.javass.spring.chapter2.HelloApiInstanceFactory&quot;/&gt;</span><br><span class="line">&lt;!—2、使用实例工厂Bean创建Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;bean4&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><p>一个构造方法注入，一个是getter、Setter方法注入。除了注入bean，也可以注入常量、list、array、set、map等各种数据结构。</p>
<p>当然由于bean的创建方式有工厂的方式进行创建，所以注入的参数也可以通过factory-method进入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实不管是使用哪种方式的注入，都是生成FactoryBean，但其实我们可以使用多种方式对先有的Spring方式进行扩容。甚至是自己负责new一个对象，然后register到Spring容器里面。拥有这种思路对于我们后期对Springboot的学习很有帮助。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/28/blockchain/BIP-62处理延展性攻击/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/28/blockchain/BIP-62处理延展性攻击/" itemprop="url">BIP-62处理延展性攻击</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-28T10:23:54+08:00">2018-03-28</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/bitcoin/" itemprop="url" rel="index"><span itemprop="name">bitcoin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文档主要是解决比特币的延展性攻击。</p>
<p><b style="color:red">交易的延展性，也被称作为是可锻性，啥叫可锻，也即同样一个东西（如一坨金属），它的本质和质量都没有改变，但是它的形状改变了。而这个可锻性，会造成交易ID——TXID的不一致，从而导致用户找不到发送的交易。因为交易的ID就是指交易的hash值。但是由于隔离见证的使用，导致脚本不再是交易结构的一部分（但是逻辑上还是一样的），这样这个扩展性问题就不那么重要了。但是如果旧节点产生的交易，可能还是要使用这样的规则去杜绝扩展性。</b></p>
<p>注意：本文档是一项正在进行的工作，并未完成，实施或以其他方式适用于部署。</p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该文件规定了对比特币交易有效性规则的建议修改，以便不可能延展交易的可塑性（至少在交易发送者不选择避开它时）。</p>
<h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>此BIP根据2条款BSD许可证进行许可。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>截至2014年2月，比特币交易在多个方面具有延展性。这意味着（有效）交易可以在传送中被修改，而不会使其失效，但无法访问相关私钥。</p>
<p>这个问题有多种原因：（<b style="color:red">感觉这里讲的就是如果同一个输出，发送者发送多笔花费这个输出的交易会怎么样？</b>）</p>
<ul>
<li>交易被改后，交易发送者可能无法识别他自己的交易。（因为TXID可能被修改了，链上使用旧的txid是无法找到这笔交易的）</li>
<li>交易发送者可以花费由原始交易创建的更改的交易。如果修改后的交易被矿机开采，这将变为无效。</li>
<li>修改后的交易实际上是双重花费，可以在没有恶意的情况下（发送者）创建，但易于被用于其他攻击。</li>
</ul>
<p>已知几种延展性来源（<b style="color:red">主要是指哪些部分可以被修改，修改什么</b>）：</p>
<ol>
<li>现在的非DER编码的ECDSA签名. 比特币参考客户端使用OpenSSL来验证签名。由于OpenSSL接受的不仅仅是严格遵守DER标准的序列化，而且还是可延展性的来源。自v0.8.0以来，非DER签名不再被中继。（就是说DER签名可以解决问题，非DER签名的交易会有问题。）</li>
<li>scriptSig中没有推送操作。 <b style="color:red">在scriptSig中脚本操作的任何序列号都会导致预期的数据推送，但不仅仅是推送该数据，会产生具有相同有效性的替代事务。</b></li>
<li>scriptSig中非标准尺寸的推送操作。 比特币脚本语言具有多个推式运算符（OP_0，单字节推送，最多75字节的数据推送，OP_PUSHDATA1，OP_PUSHDATA2，OP_PUSHDATA4）。由于后者与前者具有相同的结果，它们会带来更多的可能性。(容易遭受DDOS攻击，推送大数据也会导致mempool内存爆满)</li>
<li>零填充数字推送。 在scriptPubKey操作码使用被解释为数字的输入的情况下，它们可以被填充为零。</li>
<li>内在的ECDSA签名延展性 ECDSA签名本身已经具有延展性：取数字S的负数（以曲线顺序为模）不会使其无效。（<b style="color:red">这个需要了解椭圆曲线的特性了，对称的点也在曲线上的</b>）</li>
<li>多余的scriptSig操作。 在脚本开始处添加额外的数据推送，这些数据不会被相应的scriptPubKey消耗，这也是可延展性的来源。(一开始压入一些数字，如果栈不被清空会有很多的问题)</li>
<li>输入被脚本忽略。 如果scriptPubKey以OP_DROP开头，例如，相应脚本的最后一次数据推送将始终被忽略。</li>
<li>基于Sighash标志的掩码。 Sighash标志可用于在签名时忽略脚本的某些部分。（修改sighash，这个可以查看DER的结构）。</li>
<li>交易发起者的新签名。 交易发起者（或任何可以访问相关私钥的人）总是能够创建新的签名，这些签名将相同的输入用于相同的输出。</li>
</ol>
<p><b style="color:red">前六个和第七个的一部分可以通过额外的共识规则来解决，但最后两个不能</b>。无法修复＃7意味着即使有了这些新的共识规则，也将始终有可能创建支出交易全都具有延展性的输出。然而，当限制使用一套安全的输出脚本时，<b style="color:red">额外的共识规则可以使支出交易选择性地不可延展（如果花费者选择;因为他自己总是可以绕过＃8和＃9）。</b></p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="新规则"><a href="#新规则" class="headerlink" title="新规则"></a>新规则</h3><p><b style="color:red">引入了七个额外的规则，以准确地与上面列出的七个可延展性来源进行对比：</b></p>
<ol>
<li>标准的ECDSA编码签名。 传递给OP_CHECKSIG，OP_CHECKSIGVERIFY，OP_CHECKMULTISIG或OP_CHECKMULTISIGVERIFY的ECDSA签名必须使用严格的DER编码进行编码。为了为OP_CHECKSIG和OP_CHECKMULTISIG故意创建无效签名提供一种紧凑的方式，还允许使用空字节数组（即OP_0的结果）。<b style="color:red">使用非DER签名进行验证会使整个脚本评估为False（而不仅仅是签名验证）</b>。请参阅参考资料：<a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#der-encoding" target="_blank" rel="noopener">DER编码</a>。</li>
<li>scriptSig中的非推送操作。 ScriptSig中只允许数据推送。评估任何其他操作会使脚本评估为false。请参阅参考：<a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#push-operators" target="_blank" rel="noopener">推送运算符</a>。</li>
<li>scriptSig中的推送操作是非标准大小类型。 尽可能使用尽可能最小的脚本操作。使用可以用较短方式编码的操作推送数据会使脚本评估为false。请参阅参考：推送运算符。</li>
<li>零填充数字推送。 任何时候脚本操作码都会消耗一个被解释为数字的堆栈值，它必须以尽可能最短的形式进行编码。’负零’是不允许的。请参阅参考：数字。</li>
<li>固有的ECDSA签名延展性。 我们要求ECDSA签名内的S值至多是曲线次序（就是n的值）除以2（实质上限制该值到其下半部分范围）。请参阅参考：<a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#low-s-values-in-signatures" target="_blank" rel="noopener">签名中的低S值</a>。</li>
<li>多余的scriptSig操作。 scriptPubKey评估将需要导致一个非零值。如果任何额外的数据元素保留在堆栈上，则脚本评估为false。</li>
<li>脚本忽略输入 OP_CHECKMULTISIG和OP_CHECKMULTISIGVERIFY消耗的（不必要的）额外堆栈元素必须是空字节数组（OP_0的结果）。其他任何事情都会使脚本评估为false。</li>
</ol>
<h3 id="区块有效性"><a href="#区块有效性" class="headerlink" title="区块有效性"></a>区块有效性</h3><p>为了在网络中引入这些新规则，我们添加了v3块和v3交易。交易跳过v2以使交易和​​区块规则之间的版本号保持同步。v2交易的处理与v1交易相同。使用与BIP 0034相同的机制来引入v3块。当过去1000个block中有75％是v3时，会激活一个新的共识规则：</p>
<ul>
<li>v3块中的所有交易都必须遵守规则＃1-＃2。</li>
<li>v3块中的v3（或更高）交易也需要遵循规则＃3-＃7。</li>
</ul>
<p>当过去1000个块中的95％为v3或更高时，v2块将完全失效。但请注意，v1（和v2）交易永远保持有效。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>以下是签名，编码和数据推送效果的总结。</p>
<h3 id="签名中的低位S值"><a href="#签名中的低位S值" class="headerlink" title="签名中的低位S值"></a>签名中的低位S值</h3><p>签名中的值S必须介于<code>0x1</code>和<code>0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0（含）</code>之间。如果S太高，只需将其替换为<code>S&#39;= 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S</code>.</p>
<p>不保证OpenSSL库生成的签名与此约束一致。参考客户端的0.9.3版本提供了检测和纠正的示例。</p>
<p>值R的约束与ECDSA不变，其值可以在<code>0x1</code>和<code>0xFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140（含）</code>之间。</p>
<h3 id="DER编码"><a href="#DER编码" class="headerlink" title="DER编码"></a>DER编码</h3><p>作为参考，这里是如何正确编码DER格式的签名。</p>
<p>格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x30 [总长度] 0x02 [R长度] [R] 0x02 [S长度] [S] [sighash型]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>总长度：后面所有内容的1字节长度描述符，<b tsyle="color:red">不包括sighash字节。</b></li>
<li>R长度：后面的R值的1字节长度描述符。</li>
<li>R：任意长度的大端编码的R值。它不能以任何0x00字节开始，除非接下来的第一个字节是0x80或更高，在这种情况下需要一个0x00。</li>
<li>S长度：接下来的S值的1字节长度描述符。</li>
<li>S：任意长度的大端编码的S值。与R相同的规则适用。</li>
<li>sighash类型：1字节散列类型标志（只允许0x01，0x02，0x03，0x81，0x82和0x83）。</li>
</ul>
<p>参考客户端自0.8.0版本开始实施（仅作为中继策略，而不是作为共识规则）。<br>该规则与上面的低S要求相结合导致S长度最多为32（并且R长度最多为33），并且总签名大小最多72字节（平均71.494字节）。</p>
<h3 id="推动操作"><a href="#推动操作" class="headerlink" title="推动操作"></a>推动操作</h3><ul>
<li>推空的字节序列必须使用OP_0。</li>
<li>通过0x10推送一个1字节的字节序列0x01必须使用OP_n。</li>
<li>推送字节0x81必须使用OP_1NEGATE。</li>
<li>推送任何其他高达75字节的字节序列时，必须使用正常的数据推送（操作码字节n，其中n是字节数，紧接着推送n字节的数据）。</li>
<li>推送76到255个字节必须使用OP_PUSHDATA1。</li>
<li>推送256到520字节必须使用OP_PUSHDATA2。</li>
<li>OP_PUSHDATA4永远不能使用，因为不允许超过520个字节，下面的操作可以使用其他操作符完成。</li>
<li>任何其他操作都不被认为是push。（<b style="color:red">意思就是不能使用数字这样直接做推送</b>）</li>
</ul>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>堆栈元素的本地数据类型是字节数组，但有些操作将参数解释为整数。使用的编码是带有明确的符号位（最后一个字节的最高位）的小端。数字的最短编码是（以（））之间的十六进制给出的范围边界编码。</p>
<ul>
<li>0：OP_0; （00）</li>
<li>1..16：OP_1..OP_16; （51）..（60）</li>
<li>-1：OP_1NEGATE; （79）</li>
<li>-127 ..- 2和17..127：正常的1字节数据推送; （01 FF）..（01 82）和（01 11）..（01 7F）</li>
<li>-32767 ..- 128和128..32767：正常的2字节数据推送; （02 FF FF）..（02 80 80）和（02 80 00）..（02 FF 7F）</li>
<li>-8388607 ..- 32768和32768..8388607：正常的3字节数据推送; （03 FF FF FF）..（03 00 80 80）和（03 00 80 00）..（03 FF FF 7F）</li>
<li>-2147483647 ..- 8388608和8388608..2147483647：正常的4字节数据推送; （04 FF FF FF FF）..（04 00 00 80 80）和（04 00 00 80 00）..（04 FF FF FF 7F）</li>
<li>任何其他数字都不能被编码。</li>
</ul>
<p>特别要注意的是，如果允许使用非最短格式，则零可以编码为（01 80）（负零）。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>交易中继发布了一个新的节点软件版本，它使v3交易标准化，并在scriptSigs满足上述规则时中继它们。v1交易的中继不受影响。支付v3交易创建的输出的v1交易也不受影响。</p>
<p>电子钱包更新由于v3交易目前是非标准的，因此无法立即开始创建它们。可以检查软件以确认新的规则，但只有当网络的重要部分已升级到兼容的代码时才能启动v3。它的意图是“我希望这个交易受到延展保护”，并且仍然是钱包软件的选择。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://www.zhihu.com/question/53863396" target="_blank" rel="noopener">比特币的交易延展性指的是什么？</a><br><a href="https://github.com/bitkevin/blog.biqu.io/blob/master/source/_posts/2013-10-27-bitcoin-transaction-02.markdown" target="_blank" rel="noopener">交易的构造、签名与广播</a><br><a href="https://blockchain.iethpay.com/transaction-malleability.html" target="_blank" rel="noopener">比特币中交易延展性问题</a><br><a href="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/transaction_malleability.html" target="_blank" rel="noopener">交易延展性 | Transaction Malleability</a><br><a href="https://bitcoin.org/en/developer-guide#avoiding-key-reuse" target="_blank" rel="noopener">Transaction Malleability</a><br><a href="http://localhost:4000/2018/03/28/blockchain/BIP-62%E5%A4%84%E7%90%86%E5%BB%B6%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB/" target="_blank" rel="noopener">bips/bip-0062.mediawiki</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/03/27/blockchain/关于以太坊的签名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/blockchain/关于以太坊的签名/" itemprop="url">关于以太坊的签名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T14:54:18+08:00">2018-03-27</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在之前的博文当中我们已经提到过关于区块链技术的基础密码学之<a href="/2018/03/26/算法/关于椭圆曲线的理解/">椭圆曲线</a>的知识.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在正常的ecdsa算法中发现签名都是（r,s），但是以太坊中的签名返回好像还有一个v，而且在RFC6979中也没有提到这个v，我实在不知道这个v到底是一个什么的东西，今天特地来深入地研究一番。</p>
<p>这个v其实是用于椭圆曲线点恢复使用的，在椭圆曲线中（ecdsa）点的y轴是经过mod p的，这样你获得的点可能是经过转换的，你可以查看<a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v" target="_blank" rel="noopener">ECDSA: (v, r, s), what is v?</a>。另外比特币中是直接使用v=0|1，但是以太坊中v=27|28，这又是为啥呢？这主要是为了防止被攻击，可以查看<a href="https://ethereum.stackexchange.com/questions/15766/what-does-v-r-s-in-eth-gettransactionbyhash-mean" target="_blank" rel="noopener">What does v, r, s in eth_getTransactionByHash mean?</a>中的回答，主要的说明在<a href="https://github.com/ethereum/EIPs/issues/155" target="_blank" rel="noopener">EIP 155</a>当中。</p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>实施签名需要两个部分：待签名的数据+实施签名的账户。签名过程可以使用web3.eth.sign()来实现，具体代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; let msg = web3.sha3(&apos;today is 20171026&apos;)</span><br><span class="line">&gt; let signature = web3.eth.sign(address, msg)</span><br><span class="line">0x125a275046b65a96f11fdb7cd1072054e67526a76f54b1622fde4e4592d6fe2d5bf664ace77da52c6f94f08a56077e5d7a80048f70c38a92169205df3c9c43ea1b</span><br></pre></td></tr></table></figure></p>
<p>该返回值总共132字节（去掉前面的’0x’的话是130字节）。因为以太坊采用的ECDSA签名算法，根据ECDSA: (v, r, s), what is v?的介绍， 返回值可以分为三个部分：r, s, v。其中前0~66个字节为r， 66~130之间的字节为s， 130~132的字节为v。代码实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let r = signature.slice(0, 66)</span><br><span class="line">let s = &apos;0x&apos; + signature.slice(66, 130)</span><br><span class="line">let v = &apos;0x&apos; + signature.slice(130, 132)</span><br><span class="line">v = web3.toDecimal(v)</span><br></pre></td></tr></table></figure></p>
<p>接下来我们可以将它打印出来，在接下来验证签名的部分会用到。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><b style="color:red">签名完成了，我们如何验证某些签名后的数据是哪个账户签名的呢？在web3.js 发布1.0版本以前，验证签名只能通过智能合约的ecrecover函数来实现</b>。新版的web3.js提供了web3.eth.accounts.recover函数用于验证签名。这里我们仍然使用传统的智能合约ecrecover方式。</p>
<p>ecrecover接收数据的哈希值以及r/s/v等参数作为输入，返回实施该签名的账户地址。因此我们只需要通过合约拿到实施签名的地址，和我们真正的地址进行对比，如果地址一致，就说明验证通过了。</p>
<p><b style="color:red">智能合约代码如下：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.15;</span><br><span class="line">// 专门写了一个用于验证签名的合约呀</span><br><span class="line">contract Auth &#123;      </span><br><span class="line">    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(address retAddr) &#123;</span><br><span class="line">      bytes memory prefix = &quot;\x19Ethereum Signed Message:\n32&quot;;</span><br><span class="line">      bytes32 prefixedHash = sha3(prefix, hash);</span><br><span class="line">      // 验证过程(这里就可以看出，通过v返回address)</span><br><span class="line">      return ecrecover(prefixedHash, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们调用合约进行交互：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const contract=web3.eth.contract(abi).at(&apos;0x2e2A4cD2869862492C744307310847466c008257&apos;);</span><br><span class="line">console.log(contract.verify(msg, v, r, s));</span><br><span class="line">console.log(address)</span><br></pre></td></tr></table></figure></p>
<p>本地执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node sign.js</span><br><span class="line">0xe0803904cbfce8e07745e1b404de43ce6f1e43bc</span><br><span class="line">0xe0803904cbfce8e07745e1b404de43ce6f1e43bc</span><br></pre></td></tr></table></figure></p>
<p>可以看到实施签名的地址和验证后返回的地址一致，签名通过验证。在以太坊中完成对数据的签名和验证还是比较简单的。并且账户不仅可以对交易进行签名，还可以对任意数据进行签名并验证。</p>
<p><b style="color:red">还有就是我们可以通过发合约来利用solidity帮我们处理一些自己写代码比较复杂的事情，比如说这里的验证签名，这个是一个很好的思路，记下了！</b></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b style="color:blue">签名的算法比较奇特，这里我在网上搜索资料的时候发现了一篇<a href="http://www.5bite.com/post/862.html" target="_blank" rel="noopener">DFINITY区块链：密码学技术介绍</a>，我们先不理会这里面关于密码学深入的问题，里面的图其实和椭圆曲线大概是一致的，因为椭圆曲线中基点不停地加之后就是将所有的点联系起来，也就形成了这篇文章中的那些点线。感觉之前在看椭圆曲线的时候，还停留在代数基础上，其实去掉理论就会发现现在变成图了。然后思维就被打开了。</b></p>
<p>关于验签是如何成功返回公钥的，这个可能是去找所有的公钥进行匹配，哪个公钥成功了就是这个人前的吧！不过确实合约中好像没有公钥，那么这个公钥是如何生成的呢？这个需要进一步地学习，我想生成是可以的因为有私钥，基点等数据，关键就是k这个值。因为<code>P=k*G</code>，只要从公式中导出这个就可以了。</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://zhuanlan.zhihu.com/p/30481292" target="_blank" rel="noopener">基于以太坊(Ethereum)完成对数据的签名及验证</a><br><a href="http://me.tryblockchain.org/web3js-sign-ecrecover-decode.html" target="_blank" rel="noopener">区块链语言Solidity校验椭圆曲线加密数字签名（附实例）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">103</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">97</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
