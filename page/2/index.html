<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/page/2/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">



  <link rel="alternate" href="https://www.gitbook.com/" title="柳絮纷飞" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="http://cordate.github.io/page/2/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>柳絮纷飞</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br/>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br/>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br/>公益 404</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/blockchain/corda/Corda教程-hello world/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/07/blockchain/corda/Corda教程-hello world/" class="post-title-link" itemprop="url">Corda教程 - hello world</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-07 17:20:35 / 修改时间：21:09:52" itemprop="dateCreated datePublished" datetime="2018-06-07T17:20:35+08:00">2018-06-07</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>CorDapps是安装在一个或多个Corda节点上的插件，并使节点的所有者能够使节点执行一些新的过程 - 从发行债券工具到做餐馆预订。</p>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>我们的CorDapp将对账单进行模拟。IOU–“IO（我们）（YO）U”的简称 - 记录了一个人欠给他人一笔钱的事实。很明显，这是我们只想在贷款人和借款人之间需要知道的基础上进行沟通的敏感信息。幸运的是，这是Corda擅长的领域之一。由于区块链平台的规范，Corda可以轻松地让一小组人员就共享事实达成一致，而无需与网络上的其他人分享这一事实。</p>
<p>为了提供任何有用的功能，我们的CorDapp至少需要两个东西：</p>
<ul>
<li>状态，Corda节点达成共识的共同事实，然后存储在分类账上</li>
<li>流程，封装了执行特定分类帐更新的过程</li>
</ul>
<p>我们的IOU CorDapp也不例外。它将定义一个状态和一个流程：</p>
<h3 id="IOUState"><a href="#IOUState" class="headerlink" title="IOUState"></a>IOUState</h3><p>我们的状态将是<code>IOUState</code>。它将存储借条的价值，以及贷款人和借款人的身份。我们可以想象<code>IOUState</code>如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/tutorial-state.png" alt=""></p>
<h3 id="IOUFlow"><a href="#IOUFlow" class="headerlink" title="IOUFlow"></a>IOUFlow</h3><p>我们的流程将是<code>IOUFlow</code>。此流程将完全自动化将新IOU发放到分类账的过程。它由以下步骤组成：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/simple-tutorial-flow.png" alt=""></p>
<p>在传统的分布式账本系统中，所有数据都被广播给每个网络参与者，您不需要考虑数据流 - 只需打包分类账更新并将其发送给网络上的其他人即可。但在Corda，隐私是核心焦点，流程使我们能够在同意分类账更新的过程中仔细控制谁看到了什么。</p>
<h3 id="CorDapp模板"><a href="#CorDapp模板" class="headerlink" title="CorDapp模板"></a>CorDapp模板</h3><p>编写新的CorDapp时，通常需要将其基于标准模板：</p>
<ul>
<li><a href="https://github.com/corda/cordapp-template-java" target="_blank" rel="noopener">Java的Cordapp模板</a></li>
<li><a href="https://github.com/corda/cordapp-template-kotlin" target="_blank" rel="noopener">kotlin的Cordapp模板</a></li>
</ul>
<p>Cordapp模板为开发CorDapp提供了必需的样板，并允许您将CorDapp快速部署到虚拟节点的本地测试网络上，以测试其功能。</p>
<p>CorDapps可以用Java和Kotlin编写，并且将在本教程中以两种语言提供代码。</p>
<p>请注意，不需要下载和安装Corda本身。Corda V1.0所需的库将从一个在线Maven仓库自动下载。</p>
<h4 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h4><p>要下载模板，请在要下载CorDapp模板的目录中打开终端窗口，然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/corda/cordapp-template-java.git ;  cd cordapp-template-java</span><br></pre></td></tr></table></figure></p>
<p><em>要么</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/corda/cordapp-template-kotlin.git ;  cd cordapp-template-kotlin</span><br></pre></td></tr></table></figure></p>
<h4 id="在IntelliJ中打开模板"><a href="#在IntelliJ中打开模板" class="headerlink" title="在IntelliJ中打开模板"></a>在IntelliJ中打开模板</h4><p>下载模板后，按照以下说明在IntelliJ中打开它：<a href="https://docs.corda.net/tutorial-cordapp.html#opening-the-example-cordapp-in-intellij。" target="_blank" rel="noopener">https://docs.corda.net/tutorial-cordapp.html#opening-the-example-cordapp-in-intellij。</a></p>
<h4 id="模板结构"><a href="#模板结构" class="headerlink" title="模板结构"></a>模板结构</h4><p>该模板有许多文件，但我们可以忽略其中的大部分。我们只会修改以下文件：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于kotlin</span></span><br><span class="line"><span class="comment">// 1. The state</span></span><br><span class="line">cordapp-contracts-states/src/main/kotlin/com/template/StatesAndContracts.kt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The flow</span></span><br><span class="line">cordapp/src/main/kotlin/com/template/App.kt</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于java</span></span><br><span class="line"><span class="comment">// 1. The state</span></span><br><span class="line">cordapp-contracts-states/src/main/java/com/template/TemplateState.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The flow</span></span><br><span class="line">cordapp/src/main/java/com/template/TemplateFlow.java</span><br></pre></td></tr></table></figure>
<h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>为了防止以后出现构建错误，我们应该在开始之前删除以下文件：</p>
<ul>
<li>Java的： <code>cordapp/src/main/java/com/template/TemplateClient.java</code></li>
<li>kotlin： <code>cordapp/src/main/kotlin/com/template/Client.kt</code><h4 id="迄今取得进展"><a href="#迄今取得进展" class="headerlink" title="迄今取得进展"></a>迄今取得进展</h4>我们现在有一个模板，可以用来定义我们的IOU CorDapp。我们先来定义一下<code>IOUState</code>。<h3 id="编写状态"><a href="#编写状态" class="headerlink" title="编写状态"></a>编写状态</h3>在Corda，分类帐上的共享事实以状态表示。我们的第一个任务是定义一个新的状态类型来表示IOU。<h4 id="ContractState接口"><a href="#ContractState接口" class="headerlink" title="ContractState接口"></a>ContractState接口</h4>Corda状态是实现ContractState接口的类的任何实例。<code>ContractState</code>接口被定义为如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The list of entities considered to have a stake in this state.</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们可以看到<code>ContractState</code>接口只有一个字段<code>participants</code>。<code>participants</code>是这个状态相关的实体列表。</p>
<p>除此之外，我们的状态可以自由定义它需要的任何字段，方法，帮助者或内部类，以准确地表示分类账上给定类型的共享事实。</p>
<h4 id="建模IOUs"><a href="#建模IOUs" class="headerlink" title="建模IOUs"></a>建模IOUs</h4><p>我们应该如何在账本上定义代表借据？除了实现ContractState 接口之外，我们<code>IOUState</code>还需要属性来跟踪IOU的相关特性：</p>
<ul>
<li>IOU的价值</li>
<li>借条的贷方</li>
<li>借条的借款人</li>
</ul>
<p>还有更多可以包含的领域，比如IOU的货币，但现在让我们忽略它们。稍后添加它们通常就像为您的类定义添加附加属性一样简单。</p>
<h4 id="定义IOUState"><a href="#定义IOUState" class="headerlink" title="定义IOUState"></a>定义IOUState</h4><p>让我们开始打开<code>TemplateState.java</code>（对于Java）或<code>StatesAndContracts.kt</code>（对于Kotlin）并更新 <code>TemplateState</code>以定义<code>IOUState</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace TemplateState's definition with:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUState</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>,</span><br><span class="line">               <span class="keyword">val</span> lender: Party,</span><br><span class="line">               <span class="keyword">val</span> borrower: Party) : ContractState &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> participants <span class="keyword">get</span>() = listOf(lender, borrower)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Java，你还需要重命名<code>TemplateState.java</code>为<code>IOUState.java</code>。</p>
<p>为了定义IOUState，我们做了以下更改：</p>
<ul>
<li>我们已将<code>TemplateState</code>类重新命名为<code>IOUState</code></li>
<li>我们已经为Java 添加了属性<code>value</code>，<code>lender</code>以及<code>borrower</code>, Java中所需的getter和setter。<ul>
<li><code>value</code>是类型的<code>int</code>（在Java中）/ <code>Int</code>（在Kotlin中）</li>
<li><code>lender</code>并且<code>borrower</code>是类型<code>Party</code><ul>
<li><code>Party</code>是一种内置的Corda类型，表示网络上的实体</li>
</ul>
</li>
</ul>
</li>
<li>我们已经覆盖<code>participants</code>返回<code>lender</code>和<code>borrower</code>的列表<ul>
<li><code>participants</code> 是应该被通知创建或消费这个状态的所有各方的名单</li>
</ul>
</li>
</ul>
<p>我们发放到分类账上的借条只是这个类的实例。</p>
<h4 id="合同怎么处理？"><a href="#合同怎么处理？" class="headerlink" title="合同怎么处理？"></a>合同怎么处理？</h4><p>如果您已阅读白皮书或重要概念部分，您会知道每个州都有一个关联合同，该合同会对状态随着时间的推移而产生不变量。包括合同对于我们的第一个CorDapp并不重要，所以我们现在只使用由模板定义的空白<code>TemplateContract</code>和<code>TemplateContract.Commands.Action</code>命令。在下一个教程中，我们将实施我们自己的合约和命令。</p>
<h3 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h3><p>流程会对节点可以执行的一系列步骤进行编码，以实现特定的分类帐更新。通过在节点上安装新的流程，我们允许节点处理新的业务流程。我们定义的流程将允许节点发放 IOUState到分类帐上。</p>
<h4 id="流程轮廓"><a href="#流程轮廓" class="headerlink" title="流程轮廓"></a>流程轮廓</h4><p>我们的流程目标是协调一项借条发行交易。Corda中的交易是更新分类账的变更的原子单位。每笔交易都是将零个或多个现有状态标记为历史（输入），同时创建零个或多个新状态（输出）的建议。</p>
<p>创建这个交易并将其应用于分类帐的过程将由IOU的贷方进行，并且需要执行以下步骤：</p>
<ol>
<li>将发行新IOU的交易提案建立在分类帐上</li>
<li>签署交易提案</li>
<li>记录交易</li>
<li>将交易发送给借条人，以便他们也可以记录</li>
</ol>
<p>在此阶段，我们不要求借款人批准和签署IOU发行交易。当我们在下一个教程中查看合约时，我们将能够施加这个要求。</p>
<h5 id="支流"><a href="#支流" class="headerlink" title="支流"></a>支流</h5><p>Corda中很常见诸如记录交易或向交易对手发送交易等任务。Corda不是强迫每个开发人员重新实现自己的逻辑来处理这些任务，而是提供了许多库流程来处理这些任务。我们将这些流程调用到较大流程的上下文中，以处理可重复的任务子流程 。</p>
<p>在我们的案例中，我们可以使用IOU发行流程的步骤3和步骤4自动化<code>FinalityFlow</code>。</p>
<h4 id="FlowLogic"><a href="#FlowLogic" class="headerlink" title="FlowLogic"></a>FlowLogic</h4><p>所有的流程都必须继承<code>FlowLogic</code>。然后通过重写<code>FlowLogic.call</code>来定义流程采取的步骤。</p>
<p>让我们在<code>TemplateFlow.java</code>或<code>App.kt</code>中定义我们的<code>IOUFlow</code>。删除模板（<code>Initiator</code>和<code>Responder</code>）中的两个现有流程，并将其替换为以下内容：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace TemplateFlow's definition with:</span></span><br><span class="line"><span class="meta">@InitiatingFlow</span></span><br><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUFlow</span></span>(<span class="keyword">val</span> iouValue: <span class="built_in">Int</span>,</span><br><span class="line">              <span class="keyword">val</span> otherParty: Party) : FlowLogic&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The progress tracker provides checkpoints indicating the progress of the flow to observers. */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> progressTracker = ProgressTracker()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The flow logic is encapsulated within the call() method. */</span></span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// We retrieve the notary identity from the network map.</span></span><br><span class="line">        <span class="keyword">val</span> notary = serviceHub.networkMapCache.notaryIdentities[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create the transaction components.</span></span><br><span class="line">        <span class="keyword">val</span> outputState = IOUState(iouValue, ourIdentity, otherParty)</span><br><span class="line">        <span class="keyword">val</span> cmd = Command(TemplateContract.Commands.Action(), ourIdentity.owningKey)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create a transaction builder and add the components.</span></span><br><span class="line">        <span class="keyword">val</span> txBuilder = TransactionBuilder(notary = notary)</span><br><span class="line">                .addOutputState(outputState, TEMPLATE_CONTRACT_ID)</span><br><span class="line">                .addCommand(cmd)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We sign the transaction.</span></span><br><span class="line">        <span class="keyword">val</span> signedTx = serviceHub.signInitialTransaction(txBuilder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We finalise the transaction.</span></span><br><span class="line">        subFlow(FinalityFlow(signedTx))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Java，你还需要重命名<code>TemplateFlow.java</code>为<code>IOUFlow.java</code>。我们一步一步浏览这段代码。</p>
<p>我们已经定义了自己的<code>FlowLogic</code>重写了<code>FlowLogic.call</code>。<code>FlowLogic.call</code>有一个返回类型，必须匹配传递给它的类型参数<code>FlowLogic</code>- 这是通过运行流程返回的类型。</p>
<p><code>FlowLogic</code>子类可以有选择地使用构造函数参数，这些参数可以用作<code>FlowLogic.call</code>的参数。在我们的案例中，我们有两个：</p>
<ul>
<li><code>iouValue</code>，这是发行借据的价值</li>
<li><code>otherParty</code>，借条的借款人（运行该流程的节点是贷方）</li>
</ul>
<p><code>FlowLogic.call</code>被注解<code>@Suspendable</code> - <b style="color:Red">这可以让流程在遇到长时间运行的操作时被检查并指向并序列化到磁盘，从而允许您的节点继续运行其他流程。忘记这个注解将导致一些非常奇怪的错误信息！</b></p>
<p>在<code>FlowLogic</code>子类本身上还有更多的注释：</p>
<ul>
<li><code>@InitiatingFlow</code> 意味着该流程可以由节点直接启动</li>
<li><code>@StartableByRPC</code> 允许节点所有者通过RPC调用启动此流程</li>
</ul>
<p>我们来看看<code>FlowLogic.call</code>它自己的步骤。这是我们实际描述发行<code>IOUState</code>到分类账的程序的地方。</p>
<h5 id="选择一个公证人"><a href="#选择一个公证人" class="headerlink" title="选择一个公证人"></a>选择一个公证人</h5><p>每笔交易都需要一名公证人来防止双重花费，并担任时间戳管理机构。我们在流程中做的第一件事是从节点的<code>ServiceHub</code>检索一个公证人。<code>ServiceHub.networkMapCache</code>提供有关网络上其他节点以及它们提供的服务的信息。</p>
<p>注意: 无论何时我们需要流程中的信息 - 无论是关于我们自己的节点的身份，节点的本地存储还是网络的其余部分，我们通常都会通过节点的<code>ServiceHub</code>获取它。</p>
<h5 id="建立交易"><a href="#建立交易" class="headerlink" title="建立交易"></a>建立交易</h5><p>我们将分两步建立交易提案：</p>
<ul>
<li>创建交易的组件</li>
<li>将这些组件添加到交易生成器</li>
</ul>
<h5 id="交易项目"><a href="#交易项目" class="headerlink" title="交易项目"></a>交易项目</h5><p>我们的交易将具有以下结构：<br><img src="https://docs.corda.net/head/_images/simple-tutorial-transaction.png" alt=""></p>
<ul>
<li>输出<code>IOUState</code>的右侧表示我们将添加到分类账的状态。如您所见，没有任何输入 - 我们在创建IOU时不会消耗任何现有账本状态</li>
<li><code>Action</code>是将借条人列为签署人的命令</li>
</ul>
<p>我们已经讨论过了<code>IOUState</code>，但我们还没有看过命令。命令有两个功能：</p>
<ul>
<li>它们表明交易的意图 - 发行，转让，赎回，撤销。当我们在下一个教程中讨论合同时，这将是至关重要的</li>
<li>它们允许我们为交易定义所需的签名者。例如，IOU的创建可能只需要贷方的签名，而IOU的转移可能需要IOU的借款人和贷方的签名</li>
</ul>
<p>每个<code>Command</code>包含一个命令类型和一个公钥列表。现在，我们使用预先定义的<code>TemplateContract.Action</code>作为命令类型，并将贷方列为唯一的公钥。这意味着为使交易有效，贷款人必须签署交易。</p>
<h5 id="创建一个事务生成器"><a href="#创建一个事务生成器" class="headerlink" title="创建一个事务生成器"></a>创建一个事务生成器</h5><p>要真正建立拟议的交易，我们需要一个<code>TransactionBuilder</code>。这是一个可变的交易类，我们可以在其中添加输入，输出，命令以及交易所需的任何其他项目。我们创建一个<code>TransactionBuilder</code>使用我们早先检索的公证人。</p>
<p>一旦我们有了<code>TransactionBuilder</code>，我们添加我们的组件：</p>
<ul>
<li>该命令直接使用<code>TransactionBuilder.addCommand</code>添加 </li>
<li>输出<code>IOUState</code>使用<code>TransactionBuilder.addOutputState</code>添加。除了输出状态本身外，这种方法还要参考管理状态演变随时间推移的合约。在这里，我们传递了一个对其没有限制的<code>TemplateContract</code>引用。我们将在下一个教程中定义一个强制约束的合约</li>
</ul>
<h5 id="签署交易"><a href="#签署交易" class="headerlink" title="签署交易"></a>签署交易</h5><p>现在我们有一个有效的交易提案，我们需要签署它。交易一旦签署，任何人都无法修改交易而不会使此签名无效。这有效地使交易不可变。</p>
<p>我们用<code>ServiceHub.toSignedTransaction</code>签名交易，它返回一个<code>SignedTransaction</code>。<code>SignedTransaction</code>是将交易与该交易上的签名列表配对的对象。</p>
<h5 id="完成交易"><a href="#完成交易" class="headerlink" title="完成交易"></a>完成交易</h5><p>我们现在有一个有效的签名交易。剩下要做的就是让所有相关方都记录下来。通过这样做，它将成为分类账的永久部分。如上所述，我们将使用一个内置的<code>FinalityFlow</code>流程自动处理这个过程。<code>FinalityFlow</code>完全自动化的过程：</p>
<ul>
<li>如果需要，公证交易（即如果交易包含输入 和/或 时间窗口）</li>
<li>将它记录在我们的Vault中</li>
<li>将它发送给其他参与者（即贷方）以供他们进行记录</li>
</ul>
<h3 id="运行我们的CorDapp"><a href="#运行我们的CorDapp" class="headerlink" title="运行我们的CorDapp"></a>运行我们的CorDapp</h3><p>现在我们已经编写了一个CorDapp，现在是通过在一些真正的Corda节点上运行它来测试它的时候了。</p>
<h4 id="部署我们的CorDapp"><a href="#部署我们的CorDapp" class="headerlink" title="部署我们的CorDapp"></a>部署我们的CorDapp</h4><p>我们来看看我们要部署的节点。打开项目的build.gradle文件并向下滚动到<code>task deployNodes</code>部分。本节定义了三个节点。有两个标准节点（<code>PartyA</code>和<code>PartyB</code> ），<b style="color:red">以及运行网络map服务并公布验证公证服务的特殊网络map/公证节点。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">task deployNodes(type: net.corda.plugins.Cordform, dependsOn: [&apos;jar&apos;]) &#123;</span><br><span class="line">    directory &quot;./build/nodes&quot;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=Notary,L=London,C=GB&quot;</span><br><span class="line">        notary = [validating : true]</span><br><span class="line">        p2pPort 10002</span><br><span class="line">        rpcPort 10003</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=PartyA,L=London,C=GB&quot;</span><br><span class="line">        p2pPort 10005</span><br><span class="line">        rpcPort 10006</span><br><span class="line">        webPort 10007</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">        rpcUsers = [[ user: &quot;user1&quot;, &quot;password&quot;: &quot;test&quot;, &quot;permissions&quot;: [&quot;ALL]]]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=PartyB,L=New York,C=US&quot;</span><br><span class="line">        p2pPort 10008</span><br><span class="line">        rpcPort 10009</span><br><span class="line">        webPort 10010</span><br><span class="line">        sshdPort 10024</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">        rpcUsers = [[ user: &quot;user1&quot;, &quot;password&quot;: &quot;test&quot;, &quot;permissions&quot;: [&quot;ALL&quot;]]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用Gradle 来运行<code>deployNodes</code>任务。对于每个节点定义，Gradle将：</p>
<ul>
<li>将项目的源文件打包到一个CorDapp jar中</li>
<li><code>build/nodes</code>使用我们已安装的CorDapp创建一个新节点</li>
</ul>
<p>我们现在可以通过从项目的根目录运行以下命令来完成此操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean deployNodes</span><br></pre></td></tr></table></figure></p>
<h4 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a>运行节点</h4><p>运行<code>deployNodes</code>将构建<code>build/nodes</code>下的节点。如果我们导航到其中一个文件夹，我们将看到三个节点文件夹。每个节点文件夹具有以下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|____corda.jar                     // The runnable node</span><br><span class="line">|____corda-webserver.jar           // The node&apos;s webserver</span><br><span class="line">|____node.conf                     // The node&apos;s configuration file</span><br><span class="line">|____cordapps</span><br><span class="line">|____java/kotlin-source-0.1.jar  // Our IOU CorDapp</span><br></pre></td></tr></table></figure></p>
<p>我们通过从项目的根目录运行以下命令来启动节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/nodes/runnodes</span><br></pre></td></tr></table></figure></p>
<h4 id="与节点交互"><a href="#与节点交互" class="headerlink" title="与节点交互"></a>与节点交互</h4><p>现在我们的节点正在运行，让我们命令其中一个通过开启我们的<code>IOUFlow</code>创建一个借条。在更大的应用程序中，我们通常会提供一个位于节点顶部的Web API。在这里，为了简单起见，我们将通过其内置的CRaSH shell与节点进行交互。</p>
<p>转到显示<code>PartyA</code>的CRaSH shell的终端窗口。键入<code>help</code>将显示可用命令的列表。</p>
<p>注意: 本地终端shell只能在开发模式下使用。在生产环境中，可以启用SSH服务器。有关SSH和如何连接的更多信息，请参阅<a href="https://docs.corda.net/head/shell.html" target="_blank" rel="noopener">Shell</a>页面。</p>
<p>我们想用PartyB创建一个99的欠条。我们开始<code>IOUFlow</code>输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin</span><br><span class="line">start IOUFlow iouValue: 99, otherParty: "O=PartyB,L=New York,C=US"</span><br><span class="line">// Java</span><br><span class="line">start IOUFlow arg0: 99, arg1: "O=PartyB,L=New York,C=US"</span><br></pre></td></tr></table></figure></p>
<p>这个单一命令将导致PartyA和PartyB自动同意一个借条。这是流程框架的一大优势 - 它允许您将复杂的协商和更新过程减少为单个函数调用。</p>
<p>如果这个流程奏效了，它应该在PartyA和PartyB的Vault里记录一条新的借条。让我们检查。</p>
<p>我们可以运行以下命令来检查每个节点的vault的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vaultQuery contractStateType: com.template.IOUState</span><br></pre></td></tr></table></figure></p>
<p>PartyA和PartyB的保险库都应显示以下输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">states:</span><br><span class="line">- state:</span><br><span class="line">    data:</span><br><span class="line">      value: 99</span><br><span class="line">      lender: "C=GB,L=London,O=PartyA"</span><br><span class="line">      borrower: "C=US,L=New York,O=PartyB"</span><br><span class="line">      participants:</span><br><span class="line">      - "C=GB,L=London,O=PartyA"</span><br><span class="line">      - "C=US,L=New York,O=PartyB"</span><br><span class="line">    contract: "com.template.contract.IOUContract"</span><br><span class="line">    notary: "C=GB,L=London,O=Notary"</span><br><span class="line">    encumbrance: null</span><br><span class="line">    constraint:</span><br><span class="line">      attachmentId: "F578320232CAB87BB1E919F3E5DB9D81B7346F9D7EA6D9155DC0F7BA8E472552"</span><br><span class="line">  ref:</span><br><span class="line">    txhash: "5CED068E790A347B0DD1C6BB5B2B463406807F95E080037208627565E6A2103B"</span><br><span class="line">    index: 0</span><br><span class="line">statesMetadata:</span><br><span class="line">- ref:</span><br><span class="line">    txhash: "5CED068E790A347B0DD1C6BB5B2B463406807F95E080037208627565E6A2103B"</span><br><span class="line">    index: 0</span><br><span class="line">  contractStateClassName: "com.template.state.IOUState"</span><br><span class="line">  recordedTime: 1506415268.875000000</span><br><span class="line">  consumedTime: null</span><br><span class="line">  status: "UNCONSUMED"</span><br><span class="line">  notary: "C=GB,L=London,O=Notary"</span><br><span class="line">  lockId: null</span><br><span class="line">  lockUpdateTime: 1506415269.548000000</span><br><span class="line">totalStatesAvailable: -1</span><br><span class="line">stateTypes: "UNCONSUMED"</span><br><span class="line">otherResults: []</span><br></pre></td></tr></table></figure></p>
<p>这是发放IOUState到分类帐上的交易。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>我们已经编写了一个简单的CorDapp，允许将欠款发放到账本上。我们的CorDapp由两个关键部分组成：</p>
<ul>
<li>IOUState在账本上代表欠条</li>
<li>IOUFlow，编排商定分类帐一张欠条的创作过程</li>
</ul>
<p>完成本教程后，您的CorDapp应该如下所示：</p>
<ul>
<li>Java：<a href="https://github.com/corda/corda-tut1-solution-java" target="_blank" rel="noopener">https://github.com/corda/corda-tut1-solution-java</a></li>
<li>Kotlin：<a href="https://github.com/corda/corda-tut1-solution-kotlin" target="_blank" rel="noopener">https://github.com/corda/corda-tut1-solution-kotlin</a></li>
</ul>
<h4 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h4><p>我们可以对这个CorDapp进行一些改进：</p>
<ul>
<li>我们应该使用合同测试和流程测试框架添加单元测试</li>
<li>我们应该IOUState.value从一个整数变为适当的一种货币</li>
<li>我们可以添加一个API，以便与CorDapp进行交互</li>
</ul>
<p>但现在，最大的优先事项是<code>IOUContract</code>在每个<code>IOUState</code>时间段的演变中增加强加的限制 。这将是我们下一篇教程的重点。</p>
<h2 id="Hello-World-V2-合约约束"><a href="#Hello-World-V2-合约约束" class="headerlink" title="Hello World V2 - 合约约束"></a>Hello World V2 - 合约约束</h2><p>注意： 本教程扩展了上一篇的Hello，World教程中构建的CorDapp 。</p>
<p>在Hello，World教程中，我们构建了一个CorDapp，允许我们在账本上对IOU进行建模。我们的CorDapp由两个元素组成：</p>
<ul>
<li><code>IOUState</code>在账本上代表欠条</li>
<li><code>IOUFlow</code>，编排商定分类帐一张欠条的创作过程</li>
</ul>
<p>然而，我们的CorDapp并未对随着时间的推移对账簿上的借条发展施加任何限制。任何人都可以自由地在任何一方之间创造任何价值的欠条。</p>
<p>在本教程中，我们将编写一份合约，对IOUState可能随时间变化的规则制定规则。反过来，这将需要对前一教程中定义的流程进行一些小的更改。</p>
<h3 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h3><p>很容易想象大多数CorDapps会想要对它们的状态随着时间的推移施加一些限制：</p>
<ul>
<li>现金类的CorDapp不会希望允许用户无限制地创建生成资金的交易（至少在没有中央银行或商业银行参与的情况下）</li>
<li>贷款类的CorDapp可能不希望允许创建负值贷款</li>
<li>资产交易的CorDapp不会允许用户在没有交易对手同意的情况下完成交易</li>
</ul>
<p>在Corda，我们对各状态如何使用合约进行限制。</p>
<p>注意：Corda的合约与其他分布式账本平台的智能合约有很大不同。它们不是表示当前世界状态的有状态对象。相反，像真实世界的合约一样，他们只是对允许的交易类型施加规则。</p>
<p>每个状态都有相关的合约。如果交易不符合交易中每个输入和输出状态的合约，则交易无效。</p>
<h3 id="合约接口"><a href="#合约接口" class="headerlink" title="合约接口"></a>合约接口</h3><p>就像每个Corda状态必须实现<code>ContractState</code>接口一样，每个合约都必须实现 <code>Contract</code>接口：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implements the contract constraints in code.</span></span><br><span class="line">    <span class="meta">@Throws(IllegalArgumentException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，Contract它通过一个verify将交易作为输入的函数来表达它的约束，并且：</p>
<ul>
<li>抛出一个，IllegalArgumentException如果它拒绝交易提议</li>
<li>如果它接受交易提议，则无提示返回</li>
</ul>
<h4 id="控制IOU演变"><a href="#控制IOU演变" class="headerlink" title="控制IOU演变"></a>控制IOU演变</h4><p><code>IOUState</code>一个好的合约会是什么样子？没有正确或错误的答案 - 这取决于你希望你的CorDapp如何表现。</p>
<p>对于我们的CorDapp，让我们强加一下我们只想允许创建IOU的限制。我们不希望节点转让它们或将它们兑换为现金。强制执行此行为的一种方法是强加以下限制：</p>
<ul>
<li>涉及IOU的交易必须消耗零输入，并创建一个类型<code>IOUState</code>的输出 </li>
<li>交易还应该包括一个<code>Create</code>命令，表明交易的意图（更多的命令很快）</li>
</ul>
<p>我们可能还想对发布<code>IOUState</code>的属性施加一些限制：</p>
<ul>
<li>其价值必须是非负的</li>
<li>贷款人和借款人不能是同一个实体</li>
</ul>
<p>最后，我们要强制限制谁需要签署交易：</p>
<ul>
<li>借条的放款人必须签字</li>
<li>借条的借款人必须签字</li>
</ul>
<p>我们可以将这一交易描述如下：<br><img src="https://docs.corda.net/head/_images/simple-tutorial-transaction-2.png" alt=""></p>
<h4 id="定义IOUContract"><a href="#定义IOUContract" class="headerlink" title="定义IOUContract"></a>定义IOUContract</h4><p>我们来写一个强制执行这些约束的合约。我们将通过修改<code>TemplateContract.java</code>或 <code>StatesAndContracts.kt</code>更新<code>TemplateContract</code>来定义一个<code>IOUContract</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace IOUContract's contract ID and definition with:</span></span><br><span class="line">const <span class="keyword">val</span> IOU_CONTRACT_ID = <span class="string">"com.template.IOUContract"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUContract</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    <span class="comment">// Our Create command.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Create</span> : <span class="type">CommandData</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> command = tx.commands.requireSingleCommand&lt;Create&gt;()</span><br><span class="line"></span><br><span class="line">        requireThat &#123;</span><br><span class="line">            <span class="comment">// Constraints on the shape of the transaction.</span></span><br><span class="line">            <span class="string">"No inputs should be consumed when issuing an IOU."</span> using (tx.inputs.isEmpty())</span><br><span class="line">            <span class="string">"There should be one output state of type IOUState."</span> using (tx.outputs.size == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IOU-specific constraints.</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">out</span> = tx.outputsOfType&lt;IOUState&gt;().single()</span><br><span class="line">            <span class="string">"The IOU's value must be non-negative."</span> using (<span class="keyword">out</span>.value &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="string">"The lender and the borrower cannot be the same entity."</span> using (<span class="keyword">out</span>.lender != <span class="keyword">out</span>.borrower)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Constraints on the signers.</span></span><br><span class="line">            <span class="string">"There must be two signers."</span> using (command.signers.toSet().size == <span class="number">2</span>)</span><br><span class="line">            <span class="string">"The borrower and lender must be signers."</span> using (command.signers.containsAll(listOf(</span><br><span class="line">                    <span class="keyword">out</span>.borrower.owningKey, <span class="keyword">out</span>.lender.owningKey)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Java，你还需要重命名<code>TemplateContract.java</code>为<code>IOUContract.java</code>。</p>
<h4 id="Create命令"><a href="#Create命令" class="headerlink" title="Create命令"></a>Create命令</h4><p>我们添加到合同中的第一件事是一个命令。命令有两个功能：</p>
<ul>
<li>它们表明交易的意图，使我们能够对不同类型的交易进行不同的验证。例如，建议设立借条的交易可能必须满足兑换欠条的不同约束</li>
<li>它们允许我们为交易定义所需的签名者。例如，IOU的创建可能只需要贷方的签名，而IOU的转移可能需要IOU的借款人和贷方的签名</li>
</ul>
<p>我们的合约有一个命令，一个<code>Create</code>命令。<b style="color:red">所有命令都必须实现该<code>CommandData</code>接口。</b></p>
<p>该<code>CommandData</code>接口是命令的简单标记接口。实际上，它的声明只有两个单词（Kotlin接口不需要body）：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CommandData</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="验证逻辑"><a href="#验证逻辑" class="headerlink" title="验证逻辑"></a>验证逻辑</h4><p>我们的合约还需要通过实现<code>verify</code>来定义实际的合同约束。我们写这个verify函数的目标 是编写一个函数，给定一个交易：</p>
<ul>
<li>如果交易被认为是无效的，则抛出异常<code>IllegalArgumentException</code></li>
<li>如果该交易被认为是有效就不要抛出一个异常</li>
</ul>
<p>在决定交易是否有效时，该<code>verify</code>方法只能访问交易的内容：</p>
<ul>
<li><code>tx.inputs</code>，其中列出了输入</li>
<li><code>tx.outputs</code>，其中列出了输出</li>
<li><code>tx.commands</code>，其中列出了命令及其相关的签名者</li>
</ul>
<p>以及交易的附件和时间窗口，我们不会在这里使用。</p>
<p>基于上面列举的约束条件，<code>verify</code>如果满足以下任一条件，我们需要编写一个拒绝交易的函数：</p>
<ul>
<li><b style="color:red">该交易不包含<code>Create</code>命令</b></li>
<li>交易有输入</li>
<li>交易没有确切的一个输出</li>
<li>借据本身是无效的</li>
<li>交易不需要贷方的签名</li>
</ul>
<h4 id="命令约束"><a href="#命令约束" class="headerlink" title="命令约束"></a>命令约束</h4><p>我们的第一个约束是围绕交易的命令。我们使用Corda的<code>requireSingleCommand</code>功能来测试单个<code>Create</code>命令的存在。</p>
<p>如果该<code>Create</code>命令不存在，或者该交易有多个<code>Create</code>命令，则将抛出异常并且合同验证将失败。</p>
<h4 id="交易限制"><a href="#交易限制" class="headerlink" title="交易限制"></a>交易限制</h4><p>我们还希望我们的交易没有输入，只有单一输出 - 发行交易。</p>
<p>为了施加这个以及随后的限制，我们使用了<code>Corda</code>的内置<code>requireThat</code>模块。<code>requireThat</code>提供了一种简洁的方式来编写以下内容：</p>
<ul>
<li>如果右侧的条件不计算为真…</li>
<li>… IllegalArgumentException在左侧抛出消息</li>
</ul>
<p>像以前一样，抛出此异常的行为会导致交易被视为无效。</p>
<h4 id="借条限制"><a href="#借条限制" class="headerlink" title="借条限制"></a>借条限制</h4><p>我们想要对其IOUState本身施加两个约束：</p>
<ul>
<li>其价值必须是非负的</li>
<li>贷款人和借款人不能是同一个实体</li>
</ul>
<p>我们将这些约束与以前一样强加在同一个<code>requireThat</code>块中。</p>
<p>你可以看到，我们不仅限于在<code>requireThat</code>块中编写约束。我们也可以编写其他语句 - 在这种情况下，提取交易的单个<code>IOUState</code>元素并将其分配给一个变量。</p>
<h4 id="签名者约束"><a href="#签名者约束" class="headerlink" title="签名者约束"></a>签名者约束</h4><p>最后，我们要求贷款人和借款人都是交易中必需的签名人。交易所需的签名者等于命令中列出的所有签名者的联合。因此，我们从<code>Create</code>早先检索的命令中提取签名者。</p>
<p>这是一个绝对必要的约束 - 它确保在没有<code>IOUState</code>贷方和借方节点的明确同意的情况下在账本上不能创建账户。</p>
<h4 id="目前取得进展"><a href="#目前取得进展" class="headerlink" title="目前取得进展"></a>目前取得进展</h4><p>我们现在已经写了一个<code>IOUContract</code>限制每个<code>IOUState</code>时间的演变：</p>
<ul>
<li>一个<code>IOUState</code>只能被创建，不转移或赎回</li>
<li>创建一个<code>IOUState</code>无需输入，一个<code>IOUState</code>输出和一个 <code>Create</code>命令的发布事务</li>
<li>将<code>IOUState</code>通过发行交易创建必须有一个非负值，贷款人与借款人必须是不同的实体</li>
</ul>
<p>接下来，我们将更新IOUFlow它，以便在发放IOUState到分类账时遵守这些合同约束。</p>
<h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>我们现在需要更新我们的流程来实现三件事情：</p>
<ul>
<li>验证我们构建的交易提案是否满足<code>IOUContract</code>约束条件</li>
<li>更新贷款方的流程以请求借款人的签名</li>
<li>为响应贷方签名请求的借款人创建一个响应流程</li>
</ul>
<p>我们将通过修改我们在前一教程中编写的流程来实现这一点。</p>
<h4 id="验证交易"><a href="#验证交易" class="headerlink" title="验证交易"></a>验证交易</h4><p>在<code>IOUFlow.java</code>或者<code>App.kt中</code>，将imports块更改为以下内容：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Suspendable</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.StateAndContract</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.CollectSignaturesFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.FinalityFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.FlowLogic</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.InitiatingFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.StartableByRPC</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker</span><br></pre></td></tr></table></figure></p>
<p>在从网络中检索公证人的身份之后，通过更改代码进行更新<code>IOUFlow.call</code>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We create a transaction builder.</span></span><br><span class="line"><span class="keyword">val</span> txBuilder = TransactionBuilder(notary = notary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We create the transaction components.</span></span><br><span class="line"><span class="keyword">val</span> outputState = IOUState(iouValue, ourIdentity, otherParty)</span><br><span class="line"><span class="keyword">val</span> outputContractAndState = StateAndContract(outputState, IOU_CONTRACT_ID)</span><br><span class="line"><span class="keyword">val</span> cmd = Command(IOUContract.Create(), listOf(ourIdentity.owningKey, otherParty.owningKey))</span><br><span class="line"></span><br><span class="line"><span class="comment">// We add the items to the builder.</span></span><br><span class="line">txBuilder.withItems(outputContractAndState, cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verifying the transaction.</span></span><br><span class="line">txBuilder.verify(serviceHub)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signing the transaction.</span></span><br><span class="line"><span class="keyword">val</span> signedTx = serviceHub.signInitialTransaction(txBuilder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a session with the other party.</span></span><br><span class="line"><span class="keyword">val</span> otherpartySession = initiateFlow(otherParty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtaining the counterparty's signature.</span></span><br><span class="line"><span class="keyword">val</span> fullySignedTx = subFlow(CollectSignaturesFlow(signedTx, listOf(otherpartySession), CollectSignaturesFlow.tracker()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finalising the transaction.</span></span><br><span class="line">subFlow(FinalityFlow(fullySignedTx))</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">在原始的CorDapp中，我们通过调用一个称为<code>FinalityFlow</code>子流程的内置流来自动化对交易进行公证处理并将其记录到每个参与者的库中</b>。我们将使用另一个预定义的流程<code>CollectSignaturesFlow</code>来收集借款人的签名。</p>
<p>首先，我们需要更新命令。我们现在正在使用<code>IOUContract.Create</code>，而不是 <code>TemplateContract.Commands.Action</code>。我们也希望根据合同约束将借款人变成必需的签名人。这与将借款人的公钥添加到交易的命令一样简单。</p>
<p>我们还需要使用对旧的<code>IOUContract</code>的引用将输出状态添加到交易中，而不是旧的<code>TemplateContract</code>。</p>
<p>现在我们的状态是由一个真实的合约来管理的，我们希望在开始签署过程之前检查我们的交易提案是否满足这些要求。我们通过调用<code>TransactionBuilder.verify</code>我们的交易建议来完成此工作，然后再添加我们的签名来完成。</p>
<h4 id="请求借款人的签名"><a href="#请求借款人的签名" class="headerlink" title="请求借款人的签名"></a>请求借款人的签名</h4><p>我们现在需要与借款人沟通，要求他们签署交易。无论何时您想在流程环境中与另一方进行交流，您首先需要与他们建立流程会话。如果交易对手已经注册<code>FlowLogic</code>以响应<code>FlowLogic</code>发起会话，则将建立会话。这两个<code>FlowLogic</code>实例之间的所有通信都将作为本次会话的一部分。</p>
<p>一旦我们与借款人建立会话，我们就会使用<code>CollectSignaturesFlow</code>收集借款人的签名，这需要：</p>
<ul>
<li>由流程发起人签署的交易</li>
<li>流程发起人与所需签署人之间的流程会话列表</li>
</ul>
<p>并返回由所有必填签名者签署的交易。</p>
<p>然后，我们可以将这个完全签署的交易传递给<code>FinalityFlow</code>。</p>
<h4 id="创建借款人的流程"><a href="#创建借款人的流程" class="headerlink" title="创建借款人的流程"></a>创建借款人的流程</h4><p>在出借方方面，我们使用的<code>CollectSignaturesFlow</code>自动收集签名。为了让贷款人作出回应，我们还需要编写一个回应流程。在Java中的<code>IOUFlowResponder.java</code>新文件或Kotlin中的<code>App.kt</code>文件中，添加以下类：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.requireThat</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.SignedTransaction</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define IOUFlowResponder:</span></span><br><span class="line"><span class="meta">@InitiatedBy(IOUFlow::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUFlowResponder</span></span>(<span class="keyword">val</span> otherPartySession: FlowSession) : FlowLogic&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> signTransactionFlow = <span class="keyword">object</span> : SignTransactionFlow(otherPartySession, SignTransactionFlow.tracker()) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkTransaction</span><span class="params">(stx: <span class="type">SignedTransaction</span>)</span></span> = requireThat &#123;</span><br><span class="line">                <span class="keyword">val</span> output = stx.tx.outputs.single().<span class="keyword">data</span></span><br><span class="line">                <span class="string">"This must be an IOU transaction."</span> using (output <span class="keyword">is</span> IOUState)</span><br><span class="line">                <span class="keyword">val</span> iou = output <span class="keyword">as</span> IOUState</span><br><span class="line">                <span class="string">"The IOU's value can't be too high."</span> using (iou.value &lt; <span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subFlow(signTransactionFlow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>IOUFlow</code>一样，我们的<code>IOUFlowResponder</code>流程是一个<code>FlowLogic</code>子类, 重写了<code>FlowLogic.call</code>。</p>
<p>该流程使用<code>InitiatedBy</code>(<code>IOUFlow.class</code>)注解，这意味着您的节点将在从<code>Initiator</code>另一个节点上运行的实例接收到消息时调用<code>IOUFlowResponder.call</code> 。<code>IOUFlow</code>的这条消息会是什么？如果我们看一下<code>CollectSignaturesFlow</code>定义，我们可以看到我们将被发送一个<code>SignedTransaction</code>，并且预计将通过该交易发回我们的签名。</p>
<p>我们可以编写自己的流程来处理这个过程。但是，也有一个预定义的流程<code>SignTransactionFlow</code>可以自动处理流程。唯一的问题是<code>SignTransactionFlow</code>是一个抽象类 - 我们必须继承它并重写<code>SignTransactionFlow.checkTransaction</code>。</p>
<h4 id="CheckTransactions"><a href="#CheckTransactions" class="headerlink" title="CheckTransactions"></a>CheckTransactions</h4><p><code>SignTransactionFlow</code>将在签署之前自动验证交易及其签名。但是，仅仅因为交易在合同中有效并不意味着我们一定要签名。如果我们不想处理有问题的交易对手，或者价值太高，或者我们对交易结构不满意，该怎么办？</p>
<p>重写<code>SignTransactionFlow.checkTransaction</code>允许我们定义这些额外的检查。在我们的案例中，我们正在检查：</p>
<ul>
<li>交易涉及的<code>IOUState</code> - 确保<code>IOUContract</code>将运行以验证交易</li>
<li>借条的价值低于一定数额（在这种情况下为100）</li>
</ul>
<p>如果这些条件中的任何一个都不符合，我们将不签署交易 - 即使交易及其签名在合同中有效。</p>
<p>一旦我们定义了<code>SignTransactionFlow</code>子类，我们就会调用<code>FlowLogic.subFlow</code>，并且与借方和贷方的流程自动进行通信。</p>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>我们现在已经更新了流程，以验证交易并收集贷方签名，符合中定义的<code>IOUContract</code>约束条件。我们现在可以使用与之前相同的说明重新运行我们更新的CorDapp 。</p>
<p>我们的CorDapp现在对发行IOU进行限制。最重要的是，借款发行现在需要借款人和借款人达成协议，然后才能在账本上创建借条。这样可以防止贷款人或借款人以一种只有利于自己的方式单方面更新分类账。</p>
<p>完成本教程后，您的CorDapp应该如下所示：</p>
<ul>
<li>Java：<a href="https://github.com/corda/corda-tut2-solution-java" target="_blank" rel="noopener">https://github.com/corda/corda-tut2-solution-java</a></li>
<li>Kotlin：<a href="https://github.com/corda/corda-tut2-solution-kotlin" target="_blank" rel="noopener">https://github.com/corda/corda-tut2-solution-kotlin</a></li>
</ul>
<p>你现在应该准备开发你自己的CorDapps。您也可以在这里找到样品CorDapps的列表 。在编写CorDapps时，您还需要了解有关Corda API的更多信息 。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://docs.corda.net/head/hello-world-introduction.html" target="_blank" rel="noopener">Hello, World!</a><br><a href="https://docs.corda.net/head/tut-two-party-introduction.html" target="_blank" rel="noopener">Hello, World! Pt.2 - Contract constraints</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/blockchain/corda/Corda-networks/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/07/blockchain/corda/Corda-networks/" class="post-title-link" itemprop="url">Corda networks</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-07 15:47:02 / 修改时间：17:16:49" itemprop="dateCreated datePublished" datetime="2018-06-07T15:47:02+08:00">2018-06-07</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="设置Corda网络"><a href="#设置Corda网络" class="headerlink" title="设置Corda网络"></a>设置Corda网络</h2><p>Corda网络由多台运行节点的机器组成。这些节点使用持久协议进行通信，以创建和验证交易。</p>
<p>这种节点可能具有三种更广泛的功能类别。这些功能块是作为服务提供的，一个节点可以运行其中几个。</p>
<ul>
<li>公证人：运行公证服务见证人状态的节点花费并最终决定交易是否是双重花费</li>
<li>Oracle：通过提供影响交易有效性的事实将账本与外部世界链接起来的网络服务</li>
<li>常规节点：所有节点都有一个Vault，并且可能开始与其他节点，公证人和神谕（Oracle）进行通信的协议，并发展他们的私人分类账</li>
</ul>
<h3 id="建立你自己的网络"><a href="#建立你自己的网络" class="headerlink" title="建立你自己的网络"></a>建立你自己的网络</h3><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>给定Corda网络中的每个节点都必须具有由网络根CA签署的身份证书。有关更多信息，请参阅<a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>节点可以通过在节点的目录中添加/编辑<code>node.conf</code>进行配置。有关详情请参阅<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>。</p>
<p>一个示例配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">dataSourceProperties : &#123;</span><br><span class="line">    dataSourceClassName : org.h2.jdbcx.JdbcDataSource</span><br><span class="line">    &quot;dataSource.url&quot; : &quot;jdbc:h2:file:&quot;$&#123;baseDirectory&#125;&quot;/persistence&quot;</span><br><span class="line">    &quot;dataSource.user&quot; : sa</span><br><span class="line">    &quot;dataSource.password&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:10004&quot;</span><br><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user1, password=letmein, permissions=[ StartFlow.net.corda.protocols.CashProtocol ] &#125;</span><br><span class="line">]</span><br><span class="line">devMode : true</span><br></pre></td></tr></table></figure></p>
<p>有关网络配置的最重要的配置是：</p>
<ul>
<li><code>p2pAddress</code>：这指定了Artemis将与其他节点进行消息传递绑定的主机和端口。需要注意的是绑定的地址将不是<code>my-corda-node</code>，而是<code>::</code>（所有网络接口上的所有地址）。指定的主机名是必须由网络中的其他节点在外部解析的主机名。在上述配置中，这是VPN中机器的可解析名称。</li>
<li><code>rpcAddress</code>：Artemis将为RPC调用绑定的地址。</li>
<li><code>webAddress</code>：网络服务器应该绑定的地址。需要注意的是端口必须是来自截然不同p2pAddress并且rpcAddress如果他们是在同一台机器上。</li>
</ul>
<h4 id="引导网络"><a href="#引导网络" class="headerlink" title="引导网络"></a>引导网络</h4><p>节点使用网络图互相看到。这是一个静态签名的节点信息文件的集合，每个节点在网络中都有一个文件。大多数生产部署将通过HTTP使用高度可用，安全的网络映射分布。</p>
<p>对于节点（至少最初）驻留在同一个文件系统中的测试部署，可以将这些节点信息文件直接放置在节点的<code>additional-node-infos</code>目录中，节点将从该目录中选择并将它们存储在本地网络映射缓存中。节点在启动时生成自己的节点信息文件。</p>
<p>除了网络映射之外，网络中的所有节点都必须使用相同的一组网络参数。这些是一组保证节点间互操作性的常量。HTTP网络图分发节点自动下载的网络参数。在没有这个的情况下，网络参数必须在本地生成。这可以通过网络引导程序完成。这是一个工具，用于扫描公共目录中的所有节点配置，以生成复制到节点目录的网络参数文件。它还将每个节点的节点信息文件复制到每个其他节点，以便它们可以互相交换。</p>
<p>引导程序工具可以从<a href="http://downloads.corda.net/network-bootstrapper-corda-X.Y.jar" target="_blank" rel="noopener">http://downloads.corda.net/network-bootstrapper-corda-X.Y.jar</a> 下载，其中<code>X</code>是主要的Corda版本，并且<code>Y</code>是次要的Corda版本。</p>
<p>要使用它，请为要创建的每个节点创建一个包含<code>node.conf</code>文件的目录。然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar network-bootstrapper.jar &lt;nodes-root-dir&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如，在包含这些文件的目录上运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├──notary.conf //公证人的node.conf文件</span><br><span class="line">├──partya.conf // Party A的node.conf文件</span><br><span class="line">└──partyb.conf //乙方的node.conf文件</span><br></pre></td></tr></table></figure></p>
<p>会生成包含三个节点的目录：公证人，partya和partyb。</p>
<p>该工具仅引导网络。如果新节点需要加入网络，或者现有节点已经改变节点信息中的某些内容，例如P2P地址，它就不能动态更新。为此，新的节点信息文件将需要放置在其他节点的<code>additional-node-infos</code>目录中。一个简单的方法是使用rsync。但是，如果事先知道节点集合，最终节点文件夹可以在引导程序中预生成并且只在需要时启动。</p>
<h4 id="白名单合同"><a href="#白名单合同" class="headerlink" title="白名单合同"></a>白名单合同</h4><p>如果您想创建区域白名单（请参阅<a href="https://docs.corda.net/releases/release-V3.1/setting-up-a-corda-network.html" target="_blank" rel="noopener">API：合同约束</a>），则可以传入CorDapp jar列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar network-bootstrapper.jar &lt;nodes-root-dir&gt; &lt;path-to-first-corDapp&gt; &lt;path-to-second-corDapp&gt; ..</span><br></pre></td></tr></table></figure></p>
<p>CorDapp jars将被散列并扫描Contract类。默认情况下，该工具将生成一个名为<code>whitelist.txt</code>包含每个包含该jar散列项的合约的条目的文件。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.corda.finance.contracts.asset.Obligation：decd098666b9657314870e192ced0c3519c2c9d395507a238338f8d003929de8</span><br><span class="line">net.corda.finance.contracts.asset.Cash:decd098666b9657314870e192ced0c3519c2c9d395507a238338f8d003929de9</span><br></pre></td></tr></table></figure></p>
<p>这些将被添加到<code>NetworkParameters.whitelistedContractImplementations</code>。请参阅<a href="https://docs.corda.net/releases/release-V3.1/network-map.html" target="_blank" rel="noopener">网络映射</a>。</p>
<p>这意味着默认情况下，网络引导程序工具会将所有通过的CorDapps中的所有合约列入白名单。</p>
<p>如果根目录中有一个文件<code>whitelist.txt</code>，工具会将新的jar散列或合约附加到它。</p>
<p>区域操作员将维护这个白名单文件，并使用该工具将新版本的CorDapps添加到它。</p>
<p>警告:</p>
<ul>
<li>区域操作员必须确保该文件仅被附加。</li>
<li>如果操作员从列表中删除哈希值，则指向该版本的所有交易将突然失败约束验证，并且整个链会受到影响。</li>
<li>如果合同从白名单中删除，那么从此时开始创建的所有状态将受到HashAttachmentConstraint约束。</li>
</ul>
<p>注意：在未来的版本中，我们将提供维护合约白名单的防篡改方式。</p>
<p>对于约束的细粒度控制，如果多个合约存在于同一个jar中，则该工具从另一个文件中读取： <code>exclude_whitelist.txt</code>，其中包含不应列入白名单的合约列表，因此默认为严格限制： <code>HashAttachmentConstraint</code></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.corda.finance.contracts.asset.Cash</span><br><span class="line">net.corda.finance.contracts.asset.CommercialPaper</span><br></pre></td></tr></table></figure></p>
<h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>您现在可以按任何顺序启动节点。您应该看到一条横幅，一些日志行，并最终显示该节点已完全启动。<code>Node started up and registered</code></p>
<p>在流程管理方面，没有规定的方法。您可以手动启动jars，也可以使用systemd。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>只有少数重要的线条打印在控制台上。有关详细信息/诊断问题，请检查日志。</p>
<p>日志记录是标准的log4j2，可以进行相应配置。日志默认被重定向到<code>NODE_DIRECTORY/logs/</code>中的文件。</p>
<h4 id="连接到节点"><a href="#连接到节点" class="headerlink" title="连接到节点"></a>连接到节点</h4><p>一旦节点启动成功，您可以连接到它作为客户端来启动协议/查询状态等。根据您的网络设置，您可能需要通过管道远程执行此操作。</p>
<p>请参阅<a href="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html" target="_blank" rel="noopener">使用客户端RPC API</a>了解如何建立RPC链接。</p>
<p>旁注：客户始终与具有单一身份的单个节点相关联，该身份只能看到其分类账的一部分。</p>
<h2 id="网络许可"><a href="#网络许可" class="headerlink" title="网络许可"></a>网络许可</h2><p>Corda网络获得许可。要连接到网络，节点需要在其<code>&lt;workspace&gt;/certificates/</code>文件夹中有三个密钥库 ：</p>
<ul>
<li><code>truststore.jks</code>，它存储可信的公钥和证书（在我们的例子中是网络根CA的证书）</li>
<li><code>nodekeystore.jks</code>，它存储节点的身份密钥对和证书</li>
<li><code>sslkeystore.jks</code>，它存储节点的TLS密钥对和证书</li>
</ul>
<p><b style="color:red">生产部署需要安全的证书颁发机构。大多数生产部署将使用现有的证书颁发机构或使用将在未来几个月内提供的软件构建一个。在此之前，以下文档可用于创建您自己的认证中心。</b></p>
<p>注意: 如果您正在查找有关如何连接到现有兼容区域的信息，请转至章节：<a href="https://docs.corda.net/releases/release-V3.1/permissioning.html#connecting-to-a-compatibility-zone" target="_blank" rel="noopener">连接到兼容区域</a></p>
<h3 id="证书层级"><a href="#证书层级" class="headerlink" title="证书层级"></a>证书层级</h3><p>Corda网络有四种类型的证书颁发机构（CA）：</p>
<ul>
<li>根CA网络</li>
<li><b style="color:red">门卫CA</b><ul>
<li><b style="color:red">使用门卫CA代替根网络CA进行日常密钥签名以降低根网络CA的私钥被泄露的风险</b></li>
</ul>
</li>
<li>节点自己的CA<ul>
<li>每个节点在发布用于签署其身份密钥和TLS证书的子证书时充当自己的CA.</li>
</ul>
</li>
<li>合法身份的CA<ul>
<li>除签署交易外，Node的着名合法身份也可以颁发机密合法身份证书</li>
</ul>
</li>
</ul>
<p>以下约束也是强制性的：</p>
<ul>
<li>门卫证书由网络根发出，证书不包含扩展名</li>
<li><b style="color:red">知名服务身份证书由具有门卫证书的实体颁发</b></li>
<li>节点CA证书由具有门卫证书的实体颁发</li>
<li>众所周知的合法身份/TLS证书由标记为节点CA的证书颁发</li>
<li>保密合法身份证书由标记为众所周知的合法身份的证书颁发</li>
<li>Party的证书被标记为知名身份或机密身份</li>
<li>高于门卫/网络map的证书结构有意保留，因为它们与身份服务无关，因此在这些证书上实施特定结构没有优势。证书层次结构一致性检查是必需的，因为节点可以颁发自己的证书，并可以在证书上设置自己的角色标志，验证这些证书是否与证书层次结构设计一致，这一点很重要。作为副作用，这也作为对颁发证书的二级深度限制.</li>
</ul>
<p>所有证书必须与自定义角色扩展一起发布（见下文）。</p>
<p>我们可以将权限结构可视化如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/certificate_structure.png" alt=""></p>
<h3 id="密钥对和证书格式"><a href="#密钥对和证书格式" class="headerlink" title="密钥对和证书格式"></a>密钥对和证书格式</h3><p>您可以使用任何标准关键工具或Corda<code>X509Utilities</code>（使用Bouncy Castle）来创建所需的公钥/私钥对和证书。密钥对和证书应遵守以下限制：</p>
<ul>
<li>证书必须遵循X.509标准<ul>
<li>我们推荐X.509 v3用于向前兼容</li>
</ul>
</li>
<li>TLS证书必须遵循TLS v1.2标准</li>
<li>根网络CA，门卫CA和节点CA密钥以及节点TLS密钥必须遵循以下方案之一：<ul>
<li>ECDSA使用NIST P-256曲线（secp256r1）</li>
<li>具有3072位密钥大小的RSA</li>
</ul>
</li>
</ul>
<h3 id="证书角色扩展"><a href="#证书角色扩展" class="headerlink" title="证书角色扩展"></a>证书角色扩展</h3><p>Corda证书具有自定义的X.509 v3扩展名，用于指定证书所涉及的角色。该扩展具有OID <code>1.3.6.1.4.1.50530.1.1</code>并且不重要，因此Corda节点之外的实现可以安全地忽略它。该扩展包含一个ASN.1整数，用于标识证书的身份类型：</p>
<ol>
<li>门卫 doorman</li>
<li>网络map （Network Map）</li>
<li>服务标识 Service identity（目前仅用作分布式公证中的共享标识）</li>
<li>节点证书颁发机构 Node certificate authority （从中发布TLS和知名身份证书）</li>
<li>传输层安全 Transport layer security</li>
<li>众所周知的合法身份 Well-known legal identity</li>
<li>保密的法律身份 Confidential legal identity</li>
</ol>
<p>在典型的安装中，节点管理员不需要知道这些。但是，当节点证书由外部工具（例如组织内部署的现有PKI解决方案）管理时，了解这些约束非常重要。</p>
<p>证书路径验证被扩展，以便证书必须包含扩展名（如果扩展名存在于发行者的证书中）。</p>
<h3 id="创建根和门卫CA"><a href="#创建根和门卫CA" class="headerlink" title="创建根和门卫CA"></a>创建根和门卫CA</h3><h4 id="创建根网络CA的密钥库（keyStore）和信任库（trustStore）"><a href="#创建根网络CA的密钥库（keyStore）和信任库（trustStore）" class="headerlink" title="创建根网络CA的密钥库（keyStore）和信任库（trustStore）"></a>创建根网络CA的密钥库（keyStore）和信任库（trustStore）</h4><ol>
<li>创建一个新的密钥对<ul>
<li>这将用作根网络CA的密钥对</li>
</ul>
</li>
<li>为密钥对创建一个自签名证书。基本约束扩展必须设置为true<ul>
<li>这将被用作根网络CA的证书</li>
</ul>
</li>
<li>创建一个新的密钥库，并将根网络CA的密钥对和证书存储在其中以供以后使用<ul>
<li>此根密钥库将被根网络CA用于签署门卫CA的证书</li>
</ul>
</li>
<li>使用别名<code>cordarootca</code>创建一个名为<code>truststore.jks</code>并存储根网络CA证书的新Java密钥库<ul>
<li>随后必须将该密钥库供应给各个节点，以便它们可以将其存储在其<code>certificates</code>文件夹中</li>
</ul>
</li>
</ol>
<p><b style="color:Red">警告: 根网络CA的私钥应该受到保护并保持安全。</b></p>
<h4 id="创建门卫CA的密钥库"><a href="#创建门卫CA的密钥库" class="headerlink" title="创建门卫CA的密钥库"></a>创建门卫CA的密钥库</h4><ol>
<li>创建一个新的密钥对<ul>
<li>这将被用作门卫CA的密钥对</li>
</ul>
</li>
<li>获取使用根网络CA密钥签名的密钥对的证书。基本约束扩展必须设置为true<ul>
<li>这将被用作门卫CA的证书</li>
</ul>
</li>
<li>创建一个新的密钥库，并将门卫CA的密钥对和证书链（即门卫CA证书和根网络CA证书）存储在其中以备后用<ul>
<li>这个密钥库将被门卫CA用来签署节点的身份证书</li>
</ul>
</li>
</ol>
<h3 id="创建节点CA密钥库和TLS密钥库"><a href="#创建节点CA密钥库和TLS密钥库" class="headerlink" title="创建节点CA密钥库和TLS密钥库"></a>创建节点CA密钥库和TLS密钥库</h3><h4 id="创建节点CA密钥库"><a href="#创建节点CA密钥库" class="headerlink" title="创建节点CA密钥库"></a>创建节点CA密钥库</h4><ol>
<li>对于每个节点，创建一个新的密钥对</li>
<li>获取使用门卫CA密钥签名的密钥对的证书。基本约束扩展必须设置为true</li>
<li>使用别名<code>cordaclientca</code>创建一个名为<code>nodekeystore.jks</code>并存储密钥对的新Java密钥库<ul>
<li>节点将在本地存储此密钥库以签署其身份密钥和匿名密钥</li>
</ul>
</li>
</ol>
<h4 id="创建节点TLS密钥库"><a href="#创建节点TLS密钥库" class="headerlink" title="创建节点TLS密钥库"></a>创建节点TLS密钥库</h4><ol>
<li>对于每个节点，创建一个新的密钥对</li>
<li>为使用节点CA密钥签名的密钥对创建证书。基本约束扩展必须设置为 false</li>
<li>使用别名<code>cordaclienttls</code>创建一个名为<code>sslkeystore.jks</code>并存储密钥和证书的新Java密钥库<ul>
<li>节点将在本地存储此密钥库以签署其TLS证书</li>
</ul>
</li>
</ol>
<h3 id="在节点上安装证书"><a href="#在节点上安装证书" class="headerlink" title="在节点上安装证书"></a>在节点上安装证书</h3><p>对于每个节点，将以下文件复制到节点的证书目录（<code>&lt;workspace&gt;/certificates/</code>）中：</p>
<ol>
<li>节点的nodekeystore.jks密钥库</li>
<li>节点的sslkeystore.jks密钥库</li>
<li>根网络CA的truststore.jks密钥库</li>
</ol>
<h3 id="连接到兼容区域"><a href="#连接到兼容区域" class="headerlink" title="连接到兼容区域"></a>连接到兼容区域</h3><p><b style="color:red">要连接到兼容区域，您需要提交证书签名请求（CSR）以获取该区域的有效标识，从而向其证书签名授权（门卫）注册。</b></p>
<p>在您注册之前，您必须首先收到包含来自区域操作员的根证书的信任存储文件。然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar --initial-registration --network-root-truststore-password &lt;trust store password&gt;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，它会期望信任存储文件位于该位置<code>certificates/network-root-truststore.jks</code>。这可以用附加<code>--network-root-truststore</code>标志覆盖。</p>
<p>将根据从节点配置中获取的节点信息创建证书签名请求。生成请求需要来自节点配置文件的以下信息。</p>
<ul>
<li>myLegalName：    您公司的法定名称为X.500字符串。X.500允许区分具有相同名称的实体，因为合法名称在网络上必须是唯一的。如果另一个节点已经被许可使用该名称，则许可服务器将自动拒绝该请求。如果违反合法名称规则，请求也将被拒绝，请参阅<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html#node-naming" target="_blank" rel="noopener">节点命名</a>以获取更多信息。</li>
<li>电子邮件地址：    例如“<a href="mailto:admin@company.com" target="_blank" rel="noopener">admin@company.com</a>“</li>
<li>DEVMODE：    必须设置为false</li>
<li>compatibilityZoneURL：<br>Corda兼容区域网络管理服务根URL。<br>由Corda节点生成的一对新的私钥和公钥将用于创建请求。<br>该实用程序将向门卫服务器提交请求并定期轮询结果以检索证书。一旦请求被批准并且从服务器下载证书，节点将使用证书和生成的私钥创建密钥库和信任库。</li>
</ul>
<p>注意: 如果批准过程花费的时间比预期的长，您可以随时退出。请求过程将在重新启动时恢复。</p>
<p>只有在节点首次连接到网络或证书过期时，才需要此过程。</p>
<h2 id="Network-Map"><a href="#Network-Map" class="headerlink" title="Network Map"></a>Network Map</h2><p>网络map是已签名的NodeInfo对象的集合。每个NodeInfo都由其节点签名代表，因此不能被篡改。它在兼容区域中形成一组可达节点。节点可以从两个来源接收这些对象：</p>
<ul>
<li>一个讲述简单的基于HTTP的协议的网络映射服务器。</li>
<li>节点的目录中的<code>additional-node-infos</code>目录。</li>
</ul>
<p>网络映射服务器还分配参数文件，该参数文件为所有节点需要同意保持同步的各种设置定义值。</p>
<p>注意:在Corda 3中没有提供HTTP网络映射服务器的实现。这是因为兼容性区域管理其成员资格（数据库，票务工作流程，HSM硬件等）的细节预计会因运营商而异，所以我们提供了一个简单的基于REST的协议，用于上载/下载NodeInfos并管理网络参数。未来版本的Corda可能会为运行测试区提供一个简单的“存根”实现。在Corda 3中，运行测试网络的正确方法是通过您自己的机制分发相关文件。我们提供了一个工具来自动完成这项任务的大部分（见下文）。</p>
<h3 id="HTTP网络map协议"><a href="#HTTP网络map协议" class="headerlink" title="HTTP网络map协议"></a>HTTP网络map协议</h3><p>如果节点配置了<code>compatibilityZoneURL</code>配置，那么它首先将其自己的签名上传<code>NodeInfo</code> 到服务器（<b style="color:Red">并且每次启动时都会更改</b>），然后继续下载整个网络map。网络map由一个<code>NodeInfo</code>哈希列表组成。节点定期轮询网络映射（基于HTTP缓存有效头），并且下载和缓存任何新条目。不再存在的条目将从节点的缓存中删除。</p>
<p>网络地图服务的一组REST端点如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">请求方法</th>
<th style="text-align:center">路径</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">/network-map/publish</td>
<td style="text-align:center">让节点将其签名NodeInfo对象上传到网络地图。</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">/network-map/ack-parameters</td>
<td style="text-align:center">为了节点操作员确认网络图，新参数被接受以供将来更新。</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">/network-map</td>
<td style="text-align:center">检索当前签名的网络地图对象。整个对象用附加的网络映射证书进行签名。</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">/network-map/node-info/{hash}</td>
<td style="text-align:center">检索NodeInfo网络地图对象中指定的签名。</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">/network-map/network-parameters/{hash}</td>
<td style="text-align:center">检索签名的网络参数（见下文）。整个对象用附加的网络映射证书进行签名。</td>
</tr>
</tbody>
</table>
<p>HTTP用于网络map服务，而不是Corda自己的基于AMQP的对等消息传递协议，以便将服务器置于缓存内容交付网络后面，如Cloudflare，Akamai，Amazon Cloudfront等。通过使用工业HTTP缓存网络，map服务器可以更有效地屏蔽DoS攻击。另外，对于分发很少变化的小文件的情况，HTTP是一个很好理解和优化的协议。Corda自己的协议设计用于使用签名的二进制消息分离为并行和嵌套流的身份验证身份之间的复杂多方会话，这对于网络映射分发不是必需的。</p>
<h3 id="additional-node-infos目录"><a href="#additional-node-infos目录" class="headerlink" title="additional-node-infos目录"></a><code>additional-node-infos</code>目录</h3><p>除了HTTP网络map服务外，或者如果节点没有连接到一个节点，节点将轮询位于其基本目录中的<code>additional-node-infos</code>目录的内容。预计每个文件都是网络地图服务发布的相同签名<code>NodeInfo</code>对象。这些会自动添加到节点的缓存中，并可用于补充或替换HTTP网络图。如果同一节点通过这两种机制进行广告，则采用最新的节点。</p>
<p>启动时，节点会生成自己的签名节点信息文件，格式的文件名nodeInfo-${hash}。它也可以使用–just-generate-node-info命令行标志生成而不需要启动节点。要创建一个没有HTTP网络映射服务的简单网络，只需将该文件放置在该网络中每个节点的<code>additional-node-infos</code>目录中即可。例如，一个简单的方法是使用rsync。</p>
<p>通常，测试网络具有提前知晓的结构。为了创建这样的网络，我们提供了一个 <code>network-bootstrapper</code>工具。如果给定网络中每台机器的IP地址/域名，此工具会预先生成节点配置目录。生成的节点目录包含网络中每个其他节点的NodeInfos以及网络参数文件和身份证书。生成的节点不需要一次全部在线 - 一个未与之交互的离线节点不会以任何方式影响网络。因此，像这样生成的测试集群可以按照您可能需要的最大大小来确定大小，然后根据需要进行放大和缩小。</p>
<p>更多信息可以在<a href="https://docs.corda.net/releases/release-V3.1/setting-up-a-corda-network.html" target="_blank" rel="noopener">设置Corda网络</a>中找到。</p>
<h3 id="网络参数"><a href="#网络参数" class="headerlink" title="网络参数"></a>网络参数</h3><p>网络参数是一组值，参与该区域的每个节点需要达成一致并用于正确互操作。它们可以被认为是Corda部署的各个方面的封装，理性人可能会不同意。虽然其他区块链/DLT系统通常需要源代码fork以改变各种常量（如加密货币中的硬币总数，使用的端口号等），但在Corda中，我们将这些决策重构为单独的文件，并允许“区域运营商”对其进行决策。操作员签署一个包含这些值的数据结构，并将它们与网络map一起分发。提供工具以获得用户选择同意新版本参数的权限，并确保每个人同时切换到它们。</p>
<p>如果节点正在使用HTTP网络map服务，那么在首次启动时，它将下载已签名的网络参数，将其缓存在<code>network-parameters</code>文件中并将其应用到节点上。</p>
<p>警告: 如果<code>network-parameters</code>文件发生更改并且不再与网络map服务所发布的内容相匹配，则该节点将自动关闭。解决方法是删除不正确的文件并重新启动节点，以便可以再次下载参数。</p>
<p>如果节点没有使用HTTP网络map服务，那么预计签名文件是通过其他方式提供的。对于这种情况，网络引导程序工具除了生成网络参数文件之外，还会将节点信息文件分发到节点目录。</p>
<p>当前的一组网络参数：</p>
<ul>
<li>minimumPlatformVersion：节点必须运行的最低平台版本。低于此值的任何节点都不会启动。</li>
<li>notaries：    在兼容区域中允许的公证人的身份和验证类型（验证或不验证）的列表。</li>
<li>maxMessageSize：    （目前这被忽略，但它将在未来的版本中发布。）</li>
<li>maxTransactionSize：交易的最大允许字节数。这是交易对象及其附件的大小。</li>
<li>modifiedTime：    网络参数上次由兼容性区域运算符修改的时间。</li>
<li>epoch：    网络参数的版本号。从1开始，只要有任何参数改变，它就会一直增加。</li>
<li>whitelistedContractImplementations：合同代码的白名单版本列表。对于每个合同类，都有包含该合同的已批准CorDapp jar版本的散列列表。点击此处了解更多关于区域限制的信息<a href="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html" target="_blank" rel="noopener">API：合同限制</a></li>
</ul>
<p>更多参数将在未来版本中添加，以管理诸如允许的端口号，节点在从区域被逐出之前可以离线多久，区域成员是否需要IPv6连接，所需的加密算法和部署时间表（例如用于后期量子密码学），与SGX有关的参数等等。</p>
<h3 id="网络参数更新过程"><a href="#网络参数更新过程" class="headerlink" title="网络参数更新过程"></a>网络参数更新过程</h3><p>如果需要更改网络参数，Corda区域操作员将开始更新过程。有很多原因可能导致这一决定：例如，添加公证人，设置添加的新字段以实现平滑的网络互操作性，或者需要更改现有的兼容性常量。</p>
<p>注意: 未来版本可能支持分阶段推出网络参数更改的概念。</p>
<p>要同步兼容区域中的所有节点以使用新的一组网络参数，将提供两种RPC方法。该流程需要人员交互和对变更的批准，因此节点操作员可以在同意之前查看差异。</p>
<p>当更新即将发生时，网络map服务开始用通常的网络map数据通告附加信息。它包括新的网络参数哈希，更改说明和更新截止日期。节点向网络映射服务器查询新的一组参数。</p>
<p>新的参数集被公布的事实显示在节点日志中，并带有“下载的新网络参数”消息，并且通过RPC连接的程序可以通过使用该<code>CordaRPCOps.networkParametersFeed</code>方法接收<code>ParametersUpdateInfo</code>。通常，区域操作员还会通过电子邮件向节点操作员发送电子邮件，让他们了解即将发生的更改的详细信息，以及理由，如何提交对象，截止日期等。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Data class containing information about the scheduled network parameters update. The info is emitted every time node</span></span><br><span class="line"><span class="comment"> * receives network map with [ParametersUpdate] which wasn't seen before. For more information see: [CordaRPCOps.networkParametersFeed] and [CordaRPCOps.acceptNewNetworkParameters].</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> hash new [NetworkParameters] hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> parameters new [NetworkParameters] data structure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> description description of the update</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> updateDeadline deadline for accepting this update using [CordaRPCOps.acceptNewNetworkParameters]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ParametersUpdateInfo</span></span>(</span><br><span class="line">        <span class="keyword">val</span> hash: SecureHash,</span><br><span class="line">        <span class="keyword">val</span> parameters: NetworkParameters,</span><br><span class="line">        <span class="keyword">val</span> description: String,</span><br><span class="line">        <span class="keyword">val</span> updateDeadline: Instant</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>节点管理员可以检查更改并决定是否要接受它。在更新截止日期之前应该进行批准。在截止日期前不批准的节点可能会被区域运营商从网络地图中删除，但这是由运营商决定的决定。例如，运营商也可能会选择更改截止日期。</p>
<p>如果网络运营商开始通告一组不同的新参数，那么该新的组将覆盖前一组。只有最新的更新才能被接受。</p>
<p>要将参数批准发送回区域操作员， 必须使用更新来调用RPC方法<code>fun acceptNewNetworkParameters(parametersHash: SecureHash)</code>。请注意，批准不能撤消。您可以通过Corda shell执行<code>parametersHash</code>操作（请参阅Shell）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run acceptNewNetworkParameters parametersHash: &quot;ba19fc1b9e9c1c7cbea712efda5f78b53ae4e5d123c89d02c9da44ec50e9c17d&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果管理员不接受更新，则下一次该节点在截止日期后轮询网络映射，则通告的网络参数将为更新后的网络参数。前一组参数将不再有效。此时节点将自动关闭，并要求节点操作员再次将其恢复。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>随着Corda平台的不断发展和新功能的增加，拥有版本控制系统变得非常重要，它允许用户轻松比较版本并了解可用功能。每个Corda发行版都使用标准的语义版本方案<code>major.minor.patch</code>。这在公开域中发布时非常有用，但对于在平台上工作的开发人员不友好。它首先必须被解析，然后他们有三个独立的部分来确定API差异。发布版本仍然有用，节点发送的每个MQ消息都将其附加到标题属性<code>release-version</code>以进行调试。</p>
<p>使用单个增量整数值来表示Corda平台的API版本（称为平台版本）要容易得多。它类似于Android的API级别。它从1开始，每增加一个版本，就会增加1，这会改变整个平台上任何公开暴露的API。这包括节点本身的公共API，RPC系统，消息传递，序列化等。API始终保持向后兼容性，并且使用弃用从旧API迁移。在极少数情况下，API可能不得不被删除，例如由于安全问题。平台版本和发布版本之间没有任何关系 - 主要，次要或补丁值的更改可能会或可能不会增加平台版本。</p>
<p>平台版本是节点<code>NodeInfo</code>对象的一部分，可以从中获得<code>ServiceHub</code>。这使得CorDapp能够找出正在运行的版本并确定是否有可用的功能。当一个节点向网络映射服务注册时，它将使用该节点的平台版本来强制执行网络的最低​​版本要求。</p>
<p>注意: 未来版本可能会引入目标平台版本的概念，这与Android的<code>targetSdkVersion</code>类似，并且会为平台行为发生变化的情况提供维护行为兼容性的手段。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/linux/Systemd添加自定义系统服务设置自定义开机启动/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/07/linux/Systemd添加自定义系统服务设置自定义开机启动/" class="post-title-link" itemprop="url">【转】Systemd添加自定义系统服务设置自定义开机启动</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-07 10:35:10 / 修改时间：11:05:45" itemprop="dateCreated datePublished" datetime="2018-06-07T10:35:10+08:00">2018-06-07</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务权限"><a href="#服务权限" class="headerlink" title="服务权限"></a>服务权限</h2><p>systemd有系统和用户区分；系统（<code>/user/lib/systemd/system/</code>）、用户（<code>/etc/lib/systemd/user/</code>）.一般系统管理员手工创建的单元文件建议存放在<code>/etc/systemd/system/</code>目录下面。</p>
<h2 id="创建服务文件"><a href="#创建服务文件" class="headerlink" title="创建服务文件"></a>创建服务文件</h2><p>一般是放在<code>/etc/systemd/system/</code>目录下面，命名都是<code>xxx.service</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=kibana</span><br><span class="line">Group=kibana</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">EnvironmentFile=-/etc/default/kibana</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kibana</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">Restart=always</span><br><span class="line">WorkingDirectory=/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>下面是具体字段的说明：</p>
<p><code>[Unit]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Description</td>
<td style="text-align:center">服务的简单描述</td>
</tr>
<tr>
<td style="text-align:center">Documentation</td>
<td style="text-align:center">服务文档</td>
</tr>
<tr>
<td style="text-align:center">Before、After</td>
<td style="text-align:center">定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。</td>
</tr>
<tr>
<td style="text-align:center">Requires</td>
<td style="text-align:center">这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。</td>
</tr>
<tr>
<td style="text-align:center">Wants</td>
<td style="text-align:center">推荐使用。这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</td>
</tr>
</tbody>
</table>
<p><code>[Service]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type=simple（默认值）</td>
<td style="text-align:center">systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。</td>
</tr>
<tr>
<td style="text-align:center">Type=forking</td>
<td style="text-align:center">systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。</td>
</tr>
<tr>
<td style="text-align:center">Type=oneshot</td>
<td style="text-align:center">这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。</td>
</tr>
<tr>
<td style="text-align:center">Type=notify</td>
<td style="text-align:center">与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。</td>
</tr>
<tr>
<td style="text-align:center">Type=dbus</td>
<td style="text-align:center">若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。</td>
</tr>
<tr>
<td style="text-align:center">Type=idle</td>
<td style="text-align:center">systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。</td>
</tr>
<tr>
<td style="text-align:center">PIDFile</td>
<td style="text-align:center">pid文件路径</td>
</tr>
<tr>
<td style="text-align:center">ExecStart</td>
<td style="text-align:center">指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。</td>
</tr>
<tr>
<td style="text-align:center">ExecReload</td>
<td style="text-align:center">指定单元停止时执行的命令或者脚本。</td>
</tr>
<tr>
<td style="text-align:center">ExecStop</td>
<td style="text-align:center">指定单元停止时执行的命令或者脚本。</td>
</tr>
<tr>
<td style="text-align:center">PrivateTmp</td>
<td style="text-align:center">True表示给服务分配独立的临时空间</td>
</tr>
<tr>
<td style="text-align:center">Restart</td>
<td style="text-align:center">这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。</td>
</tr>
<tr>
<td style="text-align:center">RemainAfterExit</td>
<td style="text-align:center">如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</td>
</tr>
</tbody>
</table>
<p><code>[Install]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Alias</td>
<td style="text-align:center">为单元提供一个空间分离的附加名字。</td>
</tr>
<tr>
<td style="text-align:center">RequiredBy</td>
<td style="text-align:center">单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。</td>
</tr>
<tr>
<td style="text-align:center">WantBy</td>
<td style="text-align:center">单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。</td>
</tr>
<tr>
<td style="text-align:center">Also</td>
<td style="text-align:center">指出和单元一起安装或者被协助的单元。</td>
</tr>
<tr>
<td style="text-align:center">DefaultInstance</td>
<td style="text-align:center">实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</td>
</tr>
</tbody>
</table>
<h2 id="重载服务"><a href="#重载服务" class="headerlink" title="重载服务"></a>重载服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure>
<p>就会在<code>/etc/systemd/system/multi-user.target.wants/</code>目录下新建一个<code>/usr/lib/systemd/system/nginx.service</code> 文件的链接。</p>
<h2 id="操作服务"><a href="#操作服务" class="headerlink" title="操作服务"></a>操作服务</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo journalctl -f -u nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure>
<h2 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h2><p><a href="http://blog.51cto.com/wjb10000/1788364" target="_blank" rel="noopener">systemd添加自定义系统服务设置自定义开机启动</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/06/blockchain/corda/Corda-Nodes/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/06/blockchain/corda/Corda-Nodes/" class="post-title-link" itemprop="url">Corda Nodes</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-06 17:39:49" itemprop="dateCreated datePublished" datetime="2018-06-06T17:39:49+08:00">2018-06-06</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-07 15:44:07" itemprop="dateModified" datetime="2018-06-07T15:44:07+08:00">2018-06-07</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建本地节点"><a href="#创建本地节点" class="headerlink" title="创建本地节点"></a>创建本地节点</h2><p>每个Corda节点都有以下的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── certificates            // The node&apos;s certificates</span><br><span class="line">├── corda-webserver.jar     // The built-in node webserver</span><br><span class="line">├── corda.jar               // The core Corda libraries</span><br><span class="line">├── logs                    // The node logs</span><br><span class="line">├── node.conf               // The node&apos;s configuration files</span><br><span class="line">├── persistence.mv.db       // The node&apos;s database</span><br><span class="line">└── cordapps                // The CorDapps jars installed on the node</span><br></pre></td></tr></table></figure></p>
<p>该节点通过编辑其<code>node.conf</code>文件进行配置。通过将CorDapp JAR放入该<code>cordapps</code>文件夹中来在节点上安装CorDapps 。</p>
<p>在开发模式下（即何时<code>devMode = true</code>，请参阅<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>以获取更多信息）， 如果所需的密钥库不存在，则<code>certificates</code>目录中将填充预先配置的密钥库。这可以确保开发人员能够尽快获得节点的工作。但是，这些预配置的密钥库不安全。要了解更多信息，请参阅<a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>。</p>
<h2 id="节点命名"><a href="#节点命名" class="headerlink" title="节点命名"></a>节点命名</h2><p>节点的名称必须是有效的X.500专有名称。为了与其他实现（特别是TLS实现）兼容，我们将允许的X.500名称属性类型约束为X.509证书（在RFC 3280中指定）的最小支持集的子集以及locality属性：</p>
<ul>
<li>组织（O）</li>
<li>州（ST）</li>
<li>地点（L）</li>
<li>国家（C）</li>
<li>组织单元（OU）</li>
<li>通用名称（CN）</li>
</ul>
<p>更多信息参考<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html#node-naming" target="_blank" rel="noopener">这个网址</a>！</p>
<h2 id="Cordform任务"><a href="#Cordform任务" class="headerlink" title="Cordform任务"></a>Cordform任务</h2><p>Corda提供了一个名为的gradle插件<code>Cordform</code>，允许您自动生成和配置一组用于测试和演示的节点。这是一个<code>Cordform</code>调用的示例任务<code>deployNodes</code>，它创建三个节点，在<a href="https://github.com/corda/cordapp-template-kotlin/blob/release-V3/build.gradle#L100" target="_blank" rel="noopener">Kotlin CorDapp模板</a>中定义：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> deployNodes(type: net.corda.plugins.Cordform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line">    directory <span class="string">"./build/nodes"</span></span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Notary,L=London,C=GB"</span></span><br><span class="line">        <span class="comment">// The notary will offer a validating notary service.</span></span><br><span class="line">        notary = [validating : <span class="keyword">true</span>]</span><br><span class="line">        p2pPort  <span class="number">10002</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10003</span></span><br><span class="line">            adminPort <span class="number">10023</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No webport property, so no webserver will be created.</span></span><br><span class="line">        h2Port   <span class="number">10004</span></span><br><span class="line">        <span class="comment">// Includes the corda-finance CorDapp on our node.</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyA,L=London,C=GB"</span></span><br><span class="line">        p2pPort  <span class="number">10005</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10006</span></span><br><span class="line">            adminPort <span class="number">10026</span></span><br><span class="line">        &#125;</span><br><span class="line">        webPort  <span class="number">10007</span></span><br><span class="line">        h2Port   <span class="number">10008</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">        <span class="comment">// Grants user1 all RPC permissions.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"ALL"</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyB,L=New York,C=US"</span></span><br><span class="line">        p2pPort  <span class="number">10009</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10010</span></span><br><span class="line">            adminPort <span class="number">10030</span></span><br><span class="line">        &#125;</span><br><span class="line">        webPort  <span class="number">10011</span></span><br><span class="line">        h2Port   <span class="number">10012</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">        <span class="comment">// Grants user1 the ability to start the MyFlow flow.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"StartFlow.net.corda.flows.MyFlow"</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要将节点配置扩展到<code>deployNodes</code>任务中定义的属性之外，请使用<code>configFile</code>路径（相对或绝对）设置为其他配置文件的属性。根据node.conf，该文件应该遵循标准的<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>格式。该文件的属性将被附加到生成的节点配置中。通过<code>-PconfigFile</code>命令行选项运行Gradle任务时，也可以添加文件的路径。但是，相同的文件将应用于所有节点。在前面的示例<code>PartyB</code>节点之后，将有一个从文件添加的额外配置选项<code>none-b.conf</code>：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> deployNodes(type: net.corda.plugins.Cordform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line">    [...]</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyB,L=New York,C=US"</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// Grants user1 the ability to start the MyFlow flow.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"StartFlow.net.corda.flows.MyFlow"</span>]]]</span><br><span class="line">        configFile = <span class="string">"samples/trader-demo/src/main/resources/none-b.conf"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行此任务将在<code>build/nodes</code>文件夹中创建三个节点：</p>
<ul>
<li>一个<code>Notary</code>节点：<ul>
<li>提供验证公证服务</li>
<li>没有网络服务器（因为<code>webPort</code>没有定义）</li>
<li>正在运行<code>corda-finance</code>CorDapp</li>
</ul>
</li>
<li><code>PartyA</code>和<code>PartyB</code>节点：<ul>
<li>不提供任何服务</li>
<li>将有一个网络服务器（因为<code>webPort</code>已定义）</li>
<li>正在运行<code>corda-finance</code> CorDapp</li>
<li>有一个RPC用户，<code>user1</code>可以用来通过RPC登录到节点</li>
</ul>
</li>
</ul>
<p>此外，所有三个节点都将包含项目源文件夹中定义的所有CorDapps，即使这些CorDapps未列入每个节点的<code>cordapps</code>条目中。这意味着<code>deployNodes</code>，例如从模板CorDapp，运行任务会自动构建模板CorDapp并将其添加到每个节点。</p>
<p><b style="color:red">您可以扩展<code>deployNodes</code>以生成其他节点。</b></p>
<p>这<code>Dockerform</code>是一个<code>Cordform</code>的姐姐任务。它具有几乎相同的语法，并产生非常相似的结果 - 通过使用<code>docker-compose</code>增加一个额外的文件来增强节点的易用性。您可以在下面<code>IRS Demo&lt;https://github.com/corda/corda/blob/release-V3.0/samples/irs-demo/cordapp/build.gradle#L111&gt;</code> 的主Corda GitHub存储库的samples目录中找到示例任务：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> rpcUsersList = [</span><br><span class="line">    [<span class="string">'username'</span> : <span class="string">"user"</span>,</span><br><span class="line">     <span class="string">'password'</span> : <span class="string">"password"</span>,</span><br><span class="line">     <span class="string">'permissions'</span> : [</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.flows.AutoOfferFlow\$Requester"</span>,</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.flows.UpdateBusinessDayFlow\$Broadcast"</span>,</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.api.NodeInterestRates\$UploadFixesFlow"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.vaultQueryBy"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.networkMapSnapshot"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.currentNodeTime"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.wellKnownPartyFromX500Name"</span></span><br><span class="line">     ]]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// (...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> prepareDockerNodes(type: net.corda.plugins.Dockerform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Notary Service,L=Zurich,C=CH"</span></span><br><span class="line">        notary = [validating : <span class="keyword">true</span>]</span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Bank A,L=London,C=GB"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Bank B,L=New York,C=US"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Regulator,L=Moscow,C=RU"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project.group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不需要指定端口，因为每个节点都是独立的容器，所以不会发生端口冲突。运行该任务将创建与“Cordform任务”中所述的相同的文件夹结构<code>Dockerfile</code>，并<code>docker-compose.yml</code>在每个节点目录中和<code>build/nodes</code>目录中添加一个附加文件夹结构。默认情况下，每个节点都公开端口<code>10003</code>，这是RPC连接的默认端口。</p>
<p>要创建我们<code>deployNodes</code>任务中定义的节点，请在定义任务的项目根目录的终端窗口中运行以下命令<code>deployNodes</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew deployNodes</span><br></pre></td></tr></table></figure></p>
<p>这将在<code>build/nodes</code>文件夹中创建节点。将为该deployNodes任务中定义的每个节点生成一个节点文件夹，以及runnodes用于同时运行所有节点以进行测试和开发的shell脚本（或Windows上的批处理文件）。如果您对CorDapp源代码或deployNodes任务进行了任何更改，则需要重新运行该任务以查看更改才能生效。</p>
<p>现在可以按照运行节点中的说明<a href="https://docs.corda.net/releases/release-V3.1/running-a-node.html" target="_blank" rel="noopener">运行节点</a>。</p>
<h2 id="本地运行节点"><a href="#本地运行节点" class="headerlink" title="本地运行节点"></a>本地运行节点</h2><p>出于测试目的，本地运行Corda节点有几种方法。</p>
<h3 id="一次启动所有节点"><a href="#一次启动所有节点" class="headerlink" title="一次启动所有节点"></a>一次启动所有节点</h3><p><code>runnodes</code>是一个shell脚本（或Windows上的批处理文件），<code>deployNodes</code>可以让您快速启动所有节点及其Web服务器。<code>runnodes</code>只能用于测试目的。</p>
<p><code>runnodes</code>通过从项目的根目录运行以下命令来启动节点：命令：<code>build/nodes/runnodes</code>.</p>
<p>如果<code>OutOfMemoryError</code>在与节点进行交互时收到异常，则需要增加可供其使用的Java堆内存量，这可以在单独运行时执行。</p>
<h3 id="启动单个Corda节点"><a href="#启动单个Corda节点" class="headerlink" title="启动单个Corda节点"></a>启动单个Corda节点</h3><p>通过打开节点文件夹中的终端窗口并运行以下命令来运行节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，节点将查找调用的配置文件<code>node.conf</code>和在当前工作目录中调用的CorDapps <code>cordapps</code>文件夹。您可以在命令行上覆盖配置文件和工作区路径（例如 <code>./corda.jar --config-file=test.conf --base-directory=/opt/corda/nodes/test</code>）。</p>
<p>您可以使用<code>-Xmx</code>命令行参数来增加节点可用的Java堆内存量。例如，以下内容将以2048MB的堆大小运行节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx2048m -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>也可以通过在节点的文件夹中打开终端窗口并运行以下命令来运行节点的Web服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda-webserver.jar</span><br></pre></td></tr></table></figure></p>
<h3 id="启动启用远程调试的节点"><a href="#启动启用远程调试的节点" class="headerlink" title="启动启用远程调试的节点"></a>启动启用远程调试的节点</h3><p><b style="color:red">要启用节点的远程调试，请从终端窗口运行以下命令：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dcapsule.jvm.args=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005&quot; -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>该命令行将在端口5005上启动调试器并暂停进程，等待调试器附件。</p>
<h2 id="部署节点"><a href="#部署节点" class="headerlink" title="部署节点"></a>部署节点</h2><p>这些说明适用于想要将Corda节点部署到服务器的人员，无论他们是按照<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">本地创建节点</a>中的指示信息开发并测试了CorDapp 还是正在部署第三方CorDapp。</p>
<h3 id="Linux：作为系统服务安装并运行Corda"><a href="#Linux：作为系统服务安装并运行Corda" class="headerlink" title="Linux：作为系统服务安装并运行Corda"></a>Linux：作为系统服务安装并运行Corda</h3><p>我们建议创建系统服务来运行节点和可选的Web服务器。这提供日志记录和服务处理，并确保Corda服务在启动时运行。</p>
<p>具体细节查看<a href="https://docs.corda.net/releases/release-V3.1/deploying-a-node.html" target="_blank" rel="noopener">这里</a>！</p>
<h3 id="测试安装是否正确"><a href="#测试安装是否正确" class="headerlink" title="测试安装是否正确"></a>测试安装是否正确</h3><p>运行节点后，然后通过rpc服务尝试连接节点，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet your-hostname.example.com 10002</span><br></pre></td></tr></table></figure></p>
<p>如果你收到这个信息<code>Escape character is ^]</code>，说明Corda已经启动并且可使用。</p>
<h2 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h2><h3 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h3><p>Corda all-in-one <code>corda.jar</code>文件由<code>gradle buildCordaJAR</code>任务生成，默认为从当前工作目录中的<code>node.conf</code>文件读取配置。可以使用<code>--config-file</code> 命令行选项以不同名称或不同文件位置（相对路径相对于当前工作目录）为目标来配置此行为。另外，命令行<code>--base-directory</code>选项会更改Corda节点工作空间的位置，如果指定<code>node.conf</code>，则工作空间的根目录中会出现配置文件。</p>
<p>用于该<code>gradle deployNodes</code>任务的配置文件模板将在该文件夹<code>/config/dev</code>中找到。还要注意，从<code>:node</code>gradle模块的内置资源文件<code>/node/src/main/resources/reference.conf</code>中加载了一组基本的默认值。此文件中的所有属性都可以在文件配置中进行过滤，对于很少更改的属性，此默认值允许将该属性从配置文件中排除。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Corda配置文件使用JSON超集的HOCON格式。它具有多种功能，使其成为配置格式非常有用。请访问他们的<a href="https://github.com/typesafehub/config/blob/master/HOCON.md" target="_blank" rel="noopener">页面</a>了解更多详情。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>用于托管IRS Demo服务的常规节点配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">dataSourceProperties : &#123;</span><br><span class="line">    dataSourceClassName : org.h2.jdbcx.JdbcDataSource</span><br><span class="line">    &quot;dataSource.url&quot; : &quot;jdbc:h2:file:&quot;$&#123;baseDirectory&#125;&quot;/persistence&quot;</span><br><span class="line">    &quot;dataSource.user&quot; : sa</span><br><span class="line">    &quot;dataSource.password&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:10004&quot;</span><br><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user1, password=letmein, permissions=[ StartFlow.net.corda.protocols.CashProtocol ] &#125;</span><br><span class="line">]</span><br><span class="line">devMode : true</span><br></pre></td></tr></table></figure></p>
<p>简单的Notary配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Notary Service,OU=corda,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">p2pAddress : &quot;localhost:12345&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:12347&quot;</span><br><span class="line">notary : &#123;</span><br><span class="line">    validating : false</span><br><span class="line">&#125;</span><br><span class="line">devMode : true</span><br><span class="line">compatibilityZoneURL : &quot;https://cz.corda.net&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>下面是字段的解释，请查看<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html#fields" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="客户端RPC"><a href="#客户端RPC" class="headerlink" title="客户端RPC"></a>客户端RPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Corda提供了一个客户端库，允许您使用JVM兼容语言轻松编写客户端以与正在运行的节点进行交互。库使用消息队列协议连接到节点，然后提供一个简单的RPC接口与节点进行交互。正常情况下，您会对Java对象进行调用，并且会为您处理来回编组。</p>
<p>客户端库的起点是<a href="https://docs.corda.net/releases/release-V3.1/api/javadoc/net/corda/client/rpc/CordaRPCClient.html" target="_blank" rel="noopener"><code>CordaRPCClient</code></a>类。<code>CordaRPCClient</code>提供了一个<code>start</code>返回<code>CordaRPCConnection</code>的方法。一个<code>CordaRPCConnection</code>允许您访问的实现 <code>CordaRPCOps</code>接口，这个接口有<code>proxy</code>方法（kotlin）或<code>getProxy()</code>（Java中）。可以订阅RPC操作返回的可观察数据，以便从节点接收正在进行的更新流。有关此功能的更多详细信息在该proxy方法的文档中提供。</p>
<p><b style="color:blue">警告: 返回的<code>CordaRPCConnection</code>创建并消耗少量服务器端资源的成本有点高。当你完成它时，请调用<code>close</code>方法。或者，您可以在传入的lambda结束后使用CordaRPCClient上的<code>use</code>方法自动清理。不要为每次调用创建新的代理 - 重复使用现有的代理。</b></p>
<p>有关使用RPC API的简要教程，请参阅<a href="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html" target="_blank" rel="noopener">使用客户端RPC API</a>。</p>
<h3 id="RPC权限"><a href="#RPC权限" class="headerlink" title="RPC权限"></a>RPC权限</h3><p>对于节点的所有者通过RPC与其节点进行交互，他们必须定义一个或多个RPC用户。每个用户都使用用户名和密码进行身份验证，并为其分配一组权限，以控制他们可以执行哪些RPC操作。</p>
<p>通过将RPC用户添加到rpcUsers节点node.conf文件的列表中来创建RPC用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，RPC用户没有权限执行任何RPC操作。</p>
<h4 id="授予流权限"><a href="#授予流权限" class="headerlink" title="授予流权限"></a>授予流权限</h4><p>您向RPC用户提供使用语法启动特定流程的权限 ：<code>StartFlow.&lt;fully qualified flow name&gt;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “StartFlow.net.corda.flows.ExampleFlow1” ，</span><br><span class="line">            “StartFlow.net.corda.flows.ExampleFlow2” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>您还可以向RPC用户提供使用语法启动任何流的权限 <code>InvokeRpc.startFlow</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “InvokeRpc.startFlow” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h4 id="授予其他RPC权限"><a href="#授予其他RPC权限" class="headerlink" title="授予其他RPC权限"></a>授予其他RPC权限</h4><p>您向RPC用户提供使用以下语法执行特定RPC操作的权限 ：<code>InvokeRpc.&lt;rpc method name&gt;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “InvokeRpc.nodeInfo” ，</span><br><span class="line">            “InvokeRpc.networkMapSnapshot” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h4 id="授予所有权限"><a href="#授予所有权限" class="headerlink" title="授予所有权限"></a>授予所有权限</h4><p>您可以使用权限为RPC用户提供执行任何RPC操作（包括启动任何流）的 ALL权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “ALL” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="RPC安全管理"><a href="#RPC安全管理" class="headerlink" title="RPC安全管理"></a>RPC安全管理</h3><p>设置<code>rpcUsers</code>提供了一种向固定用户授予RPC权限的简单方法，但有一些明显的缺点。为了支持旨在提高安全性和灵活性的用例，Corda提供了额外的安全功能，例如：</p>
<ul>
<li>从外部数据源（例如：远程RDBMS）获取用户凭证和权限，以及可选的内存中缓存。特别是，这允许外部更新凭证和权限，而不需要重新启动节点。</li>
<li>密码以散列加密的形式存储。这被认为是安全问题时必须考虑的问题。Corda目前支持符合Apache Shiro框架提供的模块化加密格式的灵活密码哈希格式</li>
</ul>
<p>这些功能由嵌套在<code>security</code>字段中的一组选项控制<code>node.conf</code>。以下示例显示如何使用哈希加密格式的密码配置从远程数据库中检索用户凭据和权限，并启用用户数据的内存中缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">security  =  &#123; </span><br><span class="line">    authService  =  &#123; </span><br><span class="line">        dataSource  =  &#123; </span><br><span class="line">            type  =  “DB” ，</span><br><span class="line">            passwordEncryption  =  “SHIRO_1_CRYPT” ，</span><br><span class="line">            connection  =  &#123; </span><br><span class="line">               jdbcUrl  =  “&lt;jdbc connection string&gt;” </span><br><span class="line">               username  =  “&lt;db username&gt;” </span><br><span class="line">               password  =  “&lt;db user password&gt;” </span><br><span class="line">               driverClassName  =  “&lt;JDBC驱动程序&gt;”</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        options  =  &#123; </span><br><span class="line">             cache  =  &#123; </span><br><span class="line">                expireAfterSecs  =  120 </span><br><span class="line">                maxEntries  = 10000 </span><br><span class="line">             &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，也可以具有嵌入在用户的静态列表<code>security</code>通过指定结构<code>dataSource</code>的<code>INMEMORY</code>类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">security  =  &#123; </span><br><span class="line">    authService  =  &#123; </span><br><span class="line">        dataSource  =  &#123; </span><br><span class="line">            type  =  “INMEMORY” ，</span><br><span class="line">            users  =  [ </span><br><span class="line">                &#123; </span><br><span class="line">                    username  =  “&lt;username&gt;” ，</span><br><span class="line">                    password  =  “&lt;password&gt;” ，</span><br><span class="line">                    permissions  =  [ “&lt;permission 1&gt;” ， “&lt;permission 2&gt; “ ， ...] </span><br><span class="line">                &#125;，</span><br><span class="line">                ... </span><br><span class="line">            ] </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>看<a href="https://docs.corda.net/releases/release-V3.1/clientrpc.html" target="_blank" rel="noopener">原文</a></p>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Corda Shell是嵌入式的命令行工具，允许管理员控制和监视节点。它基于CRaSH外壳，并支持许多相同的功能。这些功能包括：</p>
<ul>
<li>调用任何节点的RPC方法</li>
<li>查看线程显示板，堆使用情况，VM属性</li>
<li>上传和下载附件</li>
<li>向基础数据库发出SQL查询</li>
<li>查看JMX指标并监控导出</li>
<li>用于文本和对象的UNIX样式管道，<code>egrep</code>命令用于处理列式数据的命令</li>
</ul>
<h3 id="通过本地终端的shell"><a href="#通过本地终端的shell" class="headerlink" title="通过本地终端的shell"></a>通过本地终端的shell</h3><p>在开发模式下，shell将显示在节点的终端窗口中。<code>--no-local-shell</code>运行节点时可以通过传递标志来禁用它 。</p>
<h3 id="SSH链接的Shell"><a href="#SSH链接的Shell" class="headerlink" title="SSH链接的Shell"></a>SSH链接的Shell</h3><h4 id="启用S​​SH访问"><a href="#启用S​​SH访问" class="headerlink" title="启用S​​SH访问"></a>启用S​​SH访问</h4><p>默认情况下，SSH服务器被禁用。要启用它，必须在节点的<code>node.conf</code>文件中配置一个端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sshd &#123; </span><br><span class="line">    port = 2222 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>用户使用与RPC相同的凭据通过SSH登录到shell。这是因为shell实际上使用RPC调用与节点进行通信。不需要RPC权限来允许连接和登录。</p>
<p>主机密钥从文件<code>&lt;node root directory&gt;/sshkey/hostkey.pem</code>加载。如果这个文件不存在，它会自动生成。在开发模式下，可以指定种子在同一台计算机上提供相同的结果，以避免主机检查错误。</p>
<h4 id="链接到shell"><a href="#链接到shell" class="headerlink" title="链接到shell"></a>链接到shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p [portNumber] [host] -l [user]</span><br></pre></td></tr></table></figure>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>当通过SSH访问shell时，需要一些额外的RPC权限：</p>
<ul>
<li>观察流（<code>flow watch</code>）需要<code>InvokeRpc.stateMachinesFeed</code></li>
<li>启动流程需要<code>InvokeRpc.startTrackedFlowDynamic</code>以及启动流程<code>InvokeRpc.registeredFlows</code>的许可</li>
</ul>
<h3 id="通过shell与节点交互"><a href="#通过shell与节点交互" class="headerlink" title="通过shell与节点交互"></a>通过shell与节点交互</h3><p>shell通过发出RPC（远程过程调用）与节点交互。您可以通过输入<code>run</code>后跟所需RPC方法的名称从shell进行 RPC。例如，您可以运行以下命令，在节点上看到注册流程的列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run registeredFlows</span><br></pre></td></tr></table></figure></p>
<p>一些RPC返回将在屏幕上显示的事件流，直到您按Ctrl-C。</p>
<p>您可以在<a href="https://docs.corda.net/api/kotlin/corda/net.corda.core.messaging/-corda-r-p-c-ops/index.html" target="_blank" rel="noopener">这里</a>找到可用RPC方法的列表 。</p>
<h4 id="流程命令"><a href="#流程命令" class="headerlink" title="流程命令"></a>流程命令</h4><p>该shell还具有处理流程的特殊命令：</p>
<ul>
<li><code>flow list</code> 列出节点上可用的流</li>
<li><code>flow watch</code> 显示当前在节点上运行的所有流，并显示结果（或错误）信息</li>
<li><code>flow start</code> 开始一个流程。该命令<code>flow start</code>采用流类的名称或其任何明确的子字符串，以及要传递给流构造函数的数据。如果给定子字符串有多个匹配项，则可能的匹配项将被打印出来。如果流有多个构造函数，那么参数的名称和类型将用于尝试并自动确定使用哪一个。如果与可用构造函数的匹配不清楚，则每个可用构造函数未匹配的原因将被打印出来。在模糊匹配的情况下，将使用第一个适用的构造函数.</li>
</ul>
<h4 id="参数语法"><a href="#参数语法" class="headerlink" title="参数语法"></a>参数语法</h4><p>使用称为<code>Yaml</code>（又一种标记语言）的语法将参数传递给RPC或流命令，这是一种简单的JSON类语言。Yaml的主要特点是：</p>
<ul>
<li>参数用逗号分隔</li>
<li>每个参数都被指定为一对<code>key: value</code><ul>
<li>有MUST是冒号后面输入一个空格，否则你会得到一个语法错误</li>
</ul>
</li>
<li>除非包含逗号，冒号或嵌入引号，否则字符串不需要用引号括起来</li>
<li>类名必须是完全合格的（例如<code>java.lang.String</code>）</li>
</ul>
<p>注意: 如果您的CorDapp是用Java编写的，除非使用<code>-parameters</code>javac参数编译节点，否则命名参数将不起作用 。请参阅<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">本地创建节点</a>以了解如何通过Gradle指定<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">节点</a>。</p>
<h5 id="创建一个类的实例"><a href="#创建一个类的实例" class="headerlink" title="创建一个类的实例"></a>创建一个类的实例</h5><p>类实例使用花括号语法创建。例如，如果我们有一个<code>Campaign</code>具有以下构造函数的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Campaign(val name: String, val target: Int)</span><br></pre></td></tr></table></figure></p>
<p>然后我们可以创建这个类的一个实例作为参数传递，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCampaign: &#123; name: Roger, target: 1000 &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="从字符串到类型的映射"><a href="#从字符串到类型的映射" class="headerlink" title="从字符串到类型的映射"></a>从字符串到类型的映射</h5><p>几个参数类型可以自动从字符串映射。查看<a href="https://docs.corda.net/releases/release-V3.1/api/kotlin/corda/net.corda.client.jackson/-jackson-support/index.html" target="_blank" rel="noopener">定义的解析器</a>以获取更多信息。我们覆盖这里最常见的类型。</p>
<h5 id="Amount"><a href="#Amount" class="headerlink" title="Amount"></a>Amount</h5><p>类型的参数<code>Amount&lt;Currency&gt;</code>可以写为：</p>
<ul>
<li>美元（$），英镑（£）或欧元（€）符号，后面跟着小数点</li>
<li>以ISO货币代码（例如“100.12 CHF”）开头的小数<h5 id="OpaqueBytes"><a href="#OpaqueBytes" class="headerlink" title="OpaqueBytes"></a>OpaqueBytes</h5>类型的参数<code>OpaqueBytes</code>可以作为字符串提供，该字符串将自动转换为 <code>OpaqueBytes</code>。<h5 id="Party"><a href="#Party" class="headerlink" title="Party"></a>Party</h5>类型的参数<code>Party</code>可以用几种方式写入：</li>
<li>通过使用节点的全名： “O=Monogram Bank,L=Sao Paulo,C=GB”</li>
<li>通过仅指定组织名称： “Monogram Bank”</li>
<li>通过指定名称的任何其他非模糊部分:( 如果只有一个网络节点位于圣保罗）”Sao Paulo”<h5 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h5>类型的参数<code>Instant</code>可以写成如下：<code>&quot;2017-12-22T00:00:00Z&quot;</code>。<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5>开始一个流程：我们将开始<code>CashIssue</code>流程如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow start CashIssueFlow amount: $1000, issuerBankPartyRef: 1234, notary: &quot;O=Controller, L=London, C=GB&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个分解如下：</p>
<ul>
<li><code>flow start</code> 是用于启动流的shell命令</li>
<li><code>CashIssue</code> 是我们想要开始的流程</li>
<li>之后的每一对都是流构造函数的参数<code>name: value</code></li>
</ul>
<p>该命令调用以下<code>CashIssue</code>构造函数：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CashIssueFlow</span></span>(<span class="keyword">val</span> amount: Amount&lt;Currency&gt;,</span><br><span class="line">                    <span class="keyword">val</span> issueRef: OpaqueBytes,</span><br><span class="line">                    <span class="keyword">val</span> recipient: Party,</span><br><span class="line">                    <span class="keyword">val</span> notary: Party) : AbstractCashFlow(progressTracker)</span><br></pre></td></tr></table></figure></p>
<h5 id="查询Vault"><a href="#查询Vault" class="headerlink" title="查询Vault"></a>查询Vault</h5><p>我们将按<code>IOUState</code>如下方式查询Vault的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vaultQuery contractStateType: com.template.IOUState</span><br></pre></td></tr></table></figure></p>
<p>这个分解如下：</p>
<ul>
<li><code>run</code> 是进行RPC调用的shell命令</li>
<li><code>vaultQuery</code> 是我们想要做的RPC调用</li>
<li><code>contractStateType: com.template.IOUState</code> 是我们查询的状态类型的完全限定名称</li>
</ul>
<h4 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h4><p>该shell可用于从节点上载和下载附件。要了解更多信息，请参阅教程“<a href="https://docs.corda.net/releases/release-V3.1/tutorial-attachments.html" target="_blank" rel="noopener">使用附件</a> ”。</p>
<h4 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h4><p>您可以键入<code>help</code> shell以列出可用的命令，并<code>man</code>获得许多命令的交互式帮助。您还可以将该标志<code>--help</code>或<code>-h</code>标志传递给命令以获取有关它支持哪些开关的信息。</p>
<p>命令可能具有子命令，其格式与<code>git</code>。在这种情况下，自行运行命令将列出支持的子命令。</p>
<h3 id="扩展shell"><a href="#扩展shell" class="headerlink" title="扩展shell"></a>扩展shell</h3><p>可以使用以Java或Groovy（一种Java兼容的脚本语言）编写的命令来扩展shell 。这些命令可以完全访问节点的内部API，因此可以用来实现几乎所有的功能。</p>
<p>有关如何编写这些命令的完整教程不在本文档的范围之内。要了解更多信息，请参阅<a href="http://www.crashub.org/" target="_blank" rel="noopener">CRaSH</a>文档。新命令放置在<code>shell-commands</code>节点目录的子目录中。现有命令的编辑将自动使用，但当前在节点启动后添加的命令不会被自动检测到。命令必须全部以小写字母<code>.java</code>或<code>.groovy</code>扩展名命名。</p>
<p><b style="color:blue">警告:在Groovy中编写的命令会忽略Java安全检查，因此无论是否存在任何沙盒，都可以无限制地访问节点和JVM内部。不允许不受信任的用户编辑shell-commands目录中的文件！</b></p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>随着时间的推移，Shell将得到增强。目前已知的限制包括：</p>
<ul>
<li>流或RPC没有命令完成</li>
<li>命令历史不会在重新启动时保留</li>
<li><code>jdbc</code>命令要求您首先明确登录到数据库</li>
<li>放置在<code>shell-commands</code>目录中的命令只有在节点重新启动后才会被注意到</li>
<li><code>jul</code>命令通告对日志的访问，但它不适用于我们正在使用的日志框架</li>
</ul>
<h2 id="节点数据库"><a href="#节点数据库" class="headerlink" title="节点数据库"></a>节点数据库</h2><p>目前，节点将其数据存储在H2数据库中。今后，我们计划支持各种各样的数据库。</p>
<p>您可以直接连接到正在运行的节点的数据库，以查看其存储的状态，交易和附件，如下所示：</p>
<ul>
<li>下载独立于<a href="http://www.h2database.com/html/download.html" target="_blank" rel="noopener">h2平台的zip文件</a>，将zip解压缩，然后在终端窗口中导航到解压缩的文件夹</li>
<li>将目录更改为bin文件夹：<code>cd h2/bin</code></li>
<li>运行以下命令以在Web浏览器选项卡中打开h2 Web控制台：<code>sh h2.sh</code></li>
<li><p>找到节点的JDBC连接字符串。每个节点在启动时在终端窗口中输出其连接字符串。在运行节点的终端窗口中，查找以下字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Database connection URL is              : jdbc:h2:tcp://10.18.0.150:56736/node</span><br></pre></td></tr></table></figure>
</li>
<li><p>将此字符串粘贴到JDBC URL字段中，并使用默认用户名和密码单击<code>Connect</code>。</p>
</li>
<li>您将看到一个显示节点存储和Vault内容的Web界面，并提供一个界面供您使用SQL查询它们。</li>
</ul>
<h2 id="节点后台管理"><a href="#节点后台管理" class="headerlink" title="节点后台管理"></a>节点后台管理</h2><p>当一个节点正在运行时，它会暴露一个RPC接口，让您监视它，上传和下载附件等等。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>默认情况下，节点日志文件存储在工作目录的子目录<code>logs</code>中并随时进行旋转。您也可以通过传递<code>--log-to-console</code>命令行标志将日志打印到控制台。默认日志记录级别INFO可以通过<code>--logging-level</code>命令行参数进行调整。该配置选项将影响所有模块。</p>
<p>您可能需要修改特定子模块的日志级别（例如，如果您想仔细查看休眠活动）。因此，对于更多的定制日志配置，logger设置可以通过分配给<code>log4j.configurationFile</code>系统属性的Log4j 2配置文件完全覆盖。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>在当前工作目录中创建一个文件<code>sql.xml</code>。添加以下文本：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate"</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，添加了一个记录器，名为<code>org.hibernate</code>的记录器已将此特定记录器级别设置为<code>debug</code>。</p>
<p>现在像往常一样启动节点，但是如上所述将附加参数<code>log4j.configurationFile</code>设置为文件名，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java &lt;Your existing startup options here&gt; -Dlog4j.configurationFile=sql.xml -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>要确定记录器的名称，对于Corda对象，请使用完全限定名称（例如，查看更详细的节点输出，使用<code>net.corda.node.internal.Node</code>尽管请注意，由于我们标记了此类<code>internal</code>，因此我们保留移动和重命名它的权利，因为它是目前尚未成为公共API的一部分）。对于其他库，请参阅它们的日志名称构造。如果找不到需要参考的内容，请使用上述<code>--logging-level</code>选项，然后从控制台输出中确定记录模块名称。</p>
<h3 id="SSH访问"><a href="#SSH访问" class="headerlink" title="SSH访问"></a>SSH访问</h3><p>节点可以配置为运行SSH服务器。详情请参阅Shell。</p>
<h3 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h3><p>该节点通过套接字公开其内部数据库，该套接字可以使用任何可以使用JDBC驱动程序的工具来浏览。JDBC URL在节点启动期间打印到日志中，并且通常如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:h2:tcp://192.168.0.31:31339/node</span><br></pre></td></tr></table></figure></p>
<p>用户名和密码可以在节点配置中更改，但默认为用户名“sa”和空白密码。</p>
<p>任何支持JDBC的数据库浏览工具都可以使用，但是如果您有IntelliJ Ultimate版本，那么您的IDE中会集成一个工具。只需打开数据库窗口并添加一个H2数据源，并提供上述详细信息。您现在可以浏览其中的表格和行数据。</p>
<h3 id="监视你的节点"><a href="#监视你的节点" class="headerlink" title="监视你的节点"></a>监视你的节点</h3><p>与大多数Java服务器一样，节点通过行业标准的JMX基础架构导出各种有用的度量标准和管理操作 。JMX是注册所谓的MBeans …对象的标准API，其属性和方法用于服务器管理。它不需要任何特定的网络协议来输出。因此，这些数据可以通过各种方式从节点导出：一些监控系统提供了一个“Java代理”，它本质上是一个JVM插件，用于查找所有MBean并将它们发送到网络上的统计收集器。对于这些系统，请按照供应商提供的说明进行操作。</p>
<p>具体查看<a href="https://docs.corda.net/releases/release-V3.1/node-administration.html#monitoring-your-node" target="_blank" rel="noopener">这里</a>! </p>
<h3 id="内存使用和调整"><a href="#内存使用和调整" class="headerlink" title="内存使用和调整"></a>内存使用和调整</h3><p>所有垃圾收集程序可以运行得更快，如果你给他们更多的内存，因为他们需要收集更少的频率。作为默认的JVM，如果你愿意的话，它可以愉快地占用你系统上的所有内存，默认情况下，Corda配置了一个相对较小的200MB Java堆。当添加其他开销时，这会为一个节点产生大约500mb的总内存使用量（开销来自编译代码，元数据，堆外缓冲区，线程堆栈等）。</p>
<p>如果你想让你的节点变得更快，并且分析表明过多的GC开销是原因，或者如果你的节点内存不足，你可以通过运行节点来给它更多的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>上面的示例命令会给出1千兆字节的Java堆。</p>
<h2 id="Out-of-process验证"><a href="#Out-of-process验证" class="headerlink" title="Out-of-process验证"></a>Out-of-process验证</h2><p>Corda节点通过<code>ServiceHub.transactionVerifierService</code>进行交易验证。这是默认情况下， <code>InMemoryTransactionVerifierService</code>它只是验证进程中的交易。</p>
<p>Corda可能被配置为不使用进程验证。任何数量的验证器都可以通过节点的暴露artemis SSL端口开始连接到节点。消息传递层负责负载平衡。</p>
<p><b style="color:blue">注意: 我们计划在内核沙箱转义的情况下，将内核级沙箱引入进程验证程序外，作为额外的防线。</b></p>
<p>要配置节点以使用进程外验证，请在<code>node.conf</code>中指定该<code>verifierType</code>选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">webAddress : &quot;localhost:10003&quot;</span><br><span class="line">verifierType: &quot;OutOfProcess&quot;</span><br></pre></td></tr></table></figure></p>
<p>你可以使用构建一个验证器jar 。<code>./gradlew verifier:standaloneJar</code></p>
<p>并运行它。<code>java -jar verifier/build/libs/corda-verifier.jar &lt;PATH_TO_VERIFIER_BASE_DIR&gt;</code></p>
<p><code>PATH_TO_VERIFIER_BASE_DIR</code>应该包含一个类似于节点目录中的<code>certificates</code>文件夹，并且<code>verifier.conf</code>包含以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeHostAndPort: &quot;my-corda-node:10002&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/01/blockchain/corda/Cordapp基础知识/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/01/blockchain/corda/Cordapp基础知识/" class="post-title-link" itemprop="url">Cordapp基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-01 10:17:22" itemprop="dateCreated datePublished" datetime="2018-06-01T10:17:22+08:00">2018-06-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-06 17:36:52" itemprop="dateModified" datetime="2018-06-06T17:36:52+08:00">2018-06-06</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CorDapps（Corda分布式应用程序）是在Corda平台上运行的分布式应用程序。CorDapp的目标是允许节点就分类账更新达成一致。他们通过定义Corda节点所有者可以通过RPC调用调用的流程来实现此目标：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/node-diagram.png" alt=""></p>
<p>Cordapps由以下关键组件组成：</p>
<ul>
<li>状态： 达成协议的事实</li>
<li>合约： 定义构成有效分类账更新的内容</li>
<li>服务： 在节点内提供长寿命的工具</li>
<li>序列化白名单： 限制节点从网络线路接收的类型</li>
</ul>
<p>每个Cordapp安装在单节点级别，而不是网络本身。例如，节点所有者可以选择安装Bond Trading CorDapp，并具有以下组件：</p>
<ul>
<li><code>BondState</code>: 用来代表债券，作为账本上的事实</li>
<li><code>BondContract</code>: 用来管理账本有效更新包括<code>BondState</code>状态</li>
<li>三个流程：<ul>
<li><code>IssueBondFlow</code>: 允许新的<code>BondState</code>状态发布到账本上</li>
<li><code>TradeBondFlow</code>: 允许存在的<code>BondState</code>状态在账本上进行买进和卖出。</li>
<li><code>ExitBondFlow</code>: 允许存在的<code>BondState</code>状态从账本上退出</li>
</ul>
</li>
</ul>
<p>安装此CorDapp后，节点所有者将能够使用CorDapp定义的流程来允许与发行，出售，购买和退出债券有关的分类帐更新。</p>
<h2 id="编写一个CorDapp"><a href="#编写一个CorDapp" class="headerlink" title="编写一个CorDapp"></a>编写一个CorDapp</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>每个CorDapp组件都采用JVM类的形式，该JVM类子类或实现Corda库类型：</p>
<ul>
<li>流程子类<code>FlowLogic</code></li>
<li>状态实现 <code>ContractState</code></li>
<li>合约实现 <code>Contract</code></li>
<li>服务子类 <code>SingletonSerializationToken</code></li>
<li>序列化白名单实现：<code>SerializationWhitelist</code></li>
</ul>
<h3 id="Web内容和RPC客户端"><a href="#Web内容和RPC客户端" class="headerlink" title="Web内容和RPC客户端"></a>Web内容和RPC客户端</h3><p>出于测试目的，CorDapps还可能包括：</p>
<ul>
<li>API和静态网页内容：由Corda内置的网络服务器提供。这个网络服务器不是生产就绪的，只能用于测试目的</li>
<li>RPC客户端：这些程序可以自动执行通过RPC与节点进行交互的过程</li>
</ul>
<p>在生产环境中，应该使用生产就绪的网络服务器，这些文件应该移到不同的模块或项目中，以便在构建时不会膨胀CorDapp。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>您应该将项目的结构基于Java或Kotlin模板：</p>
<ul>
<li><a href="https://github.com/corda/cordapp-template-java" target="_blank" rel="noopener">Java模板CorDapp</a></li>
<li><a href="https://github.com/corda/cordapp-template-kotlin" target="_blank" rel="noopener">Kotlin模板CorDapp</a></li>
</ul>
<p>该项目应该分为两个模块：</p>
<ul>
<li><code>cordapp-contracts-states</code>包含合约和状态等类的模块，将作为流程的一部分通过线路发送</li>
<li><code>cordapp</code>含有剩余的类模块</li>
</ul>
<p>每个模块将被编译到它自己的CorDapp中。当节点同意分类帐更新时，这可以最小化必须通过网络发送的JAR的大小。</p>
<h3 id="模块1-cordapp-contracts-states"><a href="#模块1-cordapp-contracts-states" class="headerlink" title="模块1 - cordapp-contracts-states"></a>模块1 - cordapp-contracts-states</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── main</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                ├── TemplateContract.java</span><br><span class="line">                └── TemplateState.java</span><br></pre></td></tr></table></figure>
<h3 id="模块2-cordapp"><a href="#模块2-cordapp" class="headerlink" title="模块2 - cordapp"></a>模块2 - cordapp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── template</span><br><span class="line">│   │           ├── TemplateApi.java</span><br><span class="line">│   │           ├── TemplateClient.java</span><br><span class="line">│   │           ├── TemplateFlow.java</span><br><span class="line">│   │           ├── TemplateSerializationWhitelist.java</span><br><span class="line">│   │           └── TemplateWebPlugin.java</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── META-INF</span><br><span class="line">│       │   └── services</span><br><span class="line">│       │       ├── net.corda.core.serialization.SerializationWhitelist</span><br><span class="line">│       │       └── net.corda.webserver.services.WebServerPluginRegistry</span><br><span class="line">│       ├── certificates</span><br><span class="line">│       └── templateWeb</span><br><span class="line">├── test</span><br><span class="line">│   └── java</span><br><span class="line">│       └── com</span><br><span class="line">│           └── template</span><br><span class="line">│               ├── ContractTests.java</span><br><span class="line">│               ├── FlowTests.java</span><br><span class="line">│               └── NodeDriver.java</span><br><span class="line">└── integrationTest</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                └── DriverBasedTest.java</span><br></pre></td></tr></table></figure>
<p>这里面需要注意的是<code>test</code>是包含示例单元测试，以及用于从IntelliJ运行CorDapp的节点驱动程序. <code>integrationTest</code>是包含一个示例集成测试。这里需要注意两者的区别。</p>
<p>在<code>main</code>中，有以下的几个目录：</p>
<ul>
<li><code>resources/META-INF/services</code> 包含CorDapp的序列化白名单和网页插件的注册管理机构</li>
<li><code>resources/certificates</code> 包含用于测试目的的虚拟证书</li>
<li><code>resources/templateWeb</code> 包含一个虚拟的前端</li>
<li><code>java</code>（或<code>kotlin</code>在Kotlin模板中），其中包括我们的CorDapp的源代码</li>
</ul>
<p>我们的CorDapp的源代码分解如下：</p>
<ul>
<li><code>TemplateFlow.java</code>，其中包含一个虚拟<code>FlowLogic</code>子类</li>
<li><code>TemplateState.java</code>，其中包含一个虚拟<code>ContractState</code>实现</li>
<li><code>TemplateContract.java</code>，其中包含一个虚拟<code>Contract</code>实现</li>
<li><code>TemplateSerializationWhitelist.java</code>，其中包含一个虚拟<code>SerializationWhitelist</code>实现</li>
</ul>
<p>在开发你的CorDapp时，你应该首先修改这些类来定义你的CorDapp的组件。一个单一的CorDapp可以定义多个流程，状态和合同。</p>
<p><b style="color:red">该模板还包含一个Web API和RPC客户端：</b></p>
<ul>
<li><code>TemplateApi.java</code></li>
<li><code>TemplateClient.java</code></li>
<li><code>TemplateWebPlugin.java</code></li>
</ul>
<p>这些用于测试目的，并将在生产CorDapp中删除。</p>
<h3 id="学习的资源"><a href="#学习的资源" class="headerlink" title="学习的资源"></a>学习的资源</h3><p>在编写CorDapp时，您应该查阅以下资源：</p>
<ul>
<li><a href="https://docs.corda.net/releases/release-V3.1/getting-set-up.html" target="_blank" rel="noopener">快速设置</a>来设置你的开发环境</li>
<li>你好，世界！教程来编写你的第一个CorDapp</li>
<li><a href="https://docs.corda.net/releases/release-V3.1/cordapp-build-systems.html" target="_blank" rel="noopener">构建一个CorDapp</a>来构建和运行您的CorDapp</li>
<li>该API文档阅读有关开发CorDapps可用的API<ul>
<li>还有一个<a href="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html" target="_blank" rel="noopener">cheatsheet</a>重新说明关键类型</li>
</ul>
</li>
<li>该<a href="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html" target="_blank" rel="noopener">流程指南</a>看如何执行常见任务流的代码示例</li>
<li><a href="https://www.corda.net/samples/" target="_blank" rel="noopener">CorDapps实例程序</a>显示Corda功能的各个部分</li>
</ul>
<h2 id="构建一个Cordapp"><a href="#构建一个Cordapp" class="headerlink" title="构建一个Cordapp"></a>构建一个Cordapp</h2><h3 id="CorDapp格式"><a href="#CorDapp格式" class="headerlink" title="CorDapp格式"></a>CorDapp格式</h3><p>Cordapp是一个semi-fat的jar包，它包含除 Corda核心库和其它依赖的任何其他CorDapps 之外的所有CorDapp依赖项。</p>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>在下面的说明中，我们假设你正在使用<code>gradle</code>和<code>cordformation</code>插件来构建你的CorDapp。</p>
<h3 id="设置依赖关系"><a href="#设置依赖关系" class="headerlink" title="设置依赖关系"></a>设置依赖关系</h3><h4 id="选择你的Corda，Quasar和Kotlin版本"><a href="#选择你的Corda，Quasar和Kotlin版本" class="headerlink" title="选择你的Corda，Quasar和Kotlin版本"></a>选择你的Corda，Quasar和Kotlin版本</h4><p>CorDapp的build.gradle文件中使用了几个变量来定义用于构建您的CorDapp的版本：</p>
<ul>
<li><code>ext.corda_release_version</code> 定义了Corda的版本</li>
<li><code>ext.corda_gradle_plugins_version</code> 定义了Corda Gradle插件的版本</li>
<li><code>ext.quasar_version</code> 定义了Quasar的版本</li>
<li><code>ext.kotlin_version</code> 定义Kotlin的版本（如果使用Kotlin编写您的CorDapp）</li>
</ul>
<h4 id="Corda依赖"><a href="#Corda依赖" class="headerlink" title="Corda依赖"></a>Corda依赖</h4><p><code>cordformation</code>和<code>cordapp</code>插件添加了两个新的gradle这个配置：</p>
<ul>
<li><code>cordaCompile</code>，这扩展了 <code>compile</code></li>
<li><code>cordaRuntime</code>，这扩展了 <code>runtime</code></li>
</ul>
<p><code>cordaCompile</code>和<code>cordaRuntime</code>指出不应包含在CorDapp JAR中的依赖关系。这些配置应该用于任何Corda依赖（例如corda-core，corda-node），以防止依赖包含两次（一次在CorDapp JAR中，一次在Corda JAR中）。</p>
<p>要针对Corda构建，您必须将以下内容添加到您的build.gradle文件中：</p>
<p>Cordapp插件应该适用于任何将要构建cordapp的项目，并且cordformation插件应该适用于希望在本地创建小型测试网络的项目。</p>
<p>这样做后，确保： net.corda:corda:$corda_release_version被定义为cordaRuntime依赖项，并且所有其他net.corda编译依赖项（例如，net.corda：corda-core：$ corda_release_version）被设置为cordaCompile依赖项。</p>
<p>您可能还想添加：</p>
<ul>
<li><code>net.corda:corda-test-utils:$corda_release_version</code>作为<code>testCompile</code>依赖项，以便使用Corda的测试框架</li>
<li><code>net.corda:corda-webserver:$corda_release_version</code>作为<code>cordaRuntime</code>依赖项，以便使用Corda的内置开发Web服务器</li>
</ul>
<h4 id="依赖其他CorDapps"><a href="#依赖其他CorDapps" class="headerlink" title="依赖其他CorDapps"></a>依赖其他CorDapps</h4><p>您的CorDapp也可能依赖于另一个CorDapp中定义的类，例如状态，合约和流程。有两种方法可以在CorDapp的build.gradle文件中添加另一个CorDapp作为依赖项：</p>
<ul>
<li><code>cordapp project(&quot;:another-cordapp&quot;)</code>（如果在同一个项目中的模块中定义了另一个CorDapp，则使用此方法）</li>
<li><code>cordapp &quot;net.corda:another-cordapp:1.0&quot;</code> （否则使用这个）</li>
</ul>
<p>该cordappgradle这个配置有两个目的：</p>
<ul>
<li>当使用<code>cordformation</code> Gradle插件时，<code>cordapp</code>配置表明该JAR应该作为CorDapp包含在您的节点中</li>
<li>当使用<code>cordapp</code> Gradle插件时，<code>cordapp</code>配置可防止CorDapp JAR中包含依赖项</li>
</ul>
<p>请注意，<code>cordformation</code>和<code>cordapp</code> Gradle插件可以一起使用。</p>
<h4 id="其他依赖关系"><a href="#其他依赖关系" class="headerlink" title="其他依赖关系"></a>其他依赖关系</h4><p>如果您的CorDapps有任何额外的外部依赖关系，可以像Gradle中的正常Kotlin / Java依赖关系那样指定它们。看下面的例子，特别是<code>apache-commons</code>包含。</p>
<p>有关管理依赖关系的更多信息，请参阅<a href="https://docs.gradle.org/current/userguide/dependency_management.html" target="_blank" rel="noopener">Gradle文档</a>。</p>
<p>以下是CorDapp的Gradle依赖关系块的示例：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Corda integration dependencies</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-core:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-finance:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-jackson:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-rpc:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-node-api:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-webserver-impl:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda-webserver:$corda_release_version"</span></span><br><span class="line">    testCompile <span class="string">"net.corda:corda-test-utils:$corda_release_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corda Plugins: dependent flows and services</span></span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its module in the same project.</span></span><br><span class="line">    cordapp <span class="keyword">project</span>(<span class="string">":cordapp-contracts-states"</span>)</span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its fully-qualified name.</span></span><br><span class="line">    cordapp <span class="string">"net.corda:bank-of-corda-demo:1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some other dependencies</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"org.jetbrains.kotlin:kotlin-test:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"junit:junit:$junit_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.apache.commons:commons-lang3:3.6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建CorDapp-Jar"><a href="#创建CorDapp-Jar" class="headerlink" title="创建CorDapp Jar"></a>创建CorDapp Jar</h3><p>一旦您的依赖关系设置正确，您可以使用gradle <code>jar</code>任务来构建您的CorDapp JAR ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradlew jar</span><br></pre></td></tr></table></figure></p>
<p>CorDapp JAR将被输出到<code>build/libs</code>文件夹。</p>
<h3 id="安装CorDapp-JAR"><a href="#安装CorDapp-JAR" class="headerlink" title="安装CorDapp JAR"></a>安装CorDapp JAR</h3><p>在安装CorDapp之前，您必须创建一个或多个节点来安装它。有关说明，请参阅<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">本地创建节点</a>。</p>
<p>在运行时，节点将加载其<code>cordapps</code>文件夹中存在的任何CorDapps 。因此，为了在节点上安装CorDapp，必须将CorDapp JAR添加到该<code>&lt;node_dir&gt;/cordapps/</code>文件夹中，其中node_dir是存储节点的JAR和配置文件的文件夹。</p>
<h2 id="通过master分支编译"><a href="#通过master分支编译" class="headerlink" title="通过master分支编译"></a>通过master分支编译</h2><p>针对最新的Corda稳定版本开发CorDapps是明智的。但是，如果您使用的是最新功能，或者正在测试主代码库上的PR，则可能需要针对不稳定的Master分支进行构建。</p>
<h2 id="Corda-Api"><a href="#Corda-Api" class="headerlink" title="Corda Api"></a>Corda Api</h2><p>以下是用于开发CorDapps的核心API：</p>
<ul>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-states.html" target="_blank" rel="noopener">API：状态 States</a>  <a href="http://cncorda.com/doc/apis/api-states/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-persistence.html" target="_blank" rel="noopener">API：持久化 Persistence</a>  <a href="http://cncorda.com/doc/apis/api-persistence/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-contracts.html" target="_blank" rel="noopener">API：合约 Contracts</a>  <a href="http://cncorda.com/doc/apis/api-contracts/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html" target="_blank" rel="noopener">API：合约约束 Contract Constraints</a>  <a href="http://cncorda.com/doc/apis/api-contract-constrains/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-vault-query.html" target="_blank" rel="noopener">API：Vault查询</a>  <a href="https://docs.corda.net/releases/release-V3.1/api-vault-query.html" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-transactions.html" target="_blank" rel="noopener">API：交易 Transaction</a>  <a href="http://cncorda.com/doc/apis/api-transactions/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-flows.html" target="_blank" rel="noopener">API：流程 Flows</a>  <a href="http://cncorda.com/doc/apis/api-flows/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-identity.html" target="_blank" rel="noopener">API：身份 Identity</a>  <a href="http://cncorda.com/doc/apis/api-identity/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-service-hub.html" target="_blank" rel="noopener">API：ServiceHub</a> <a href="http://cncorda.com/doc/apis/api-servicehub/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">API：RPC操作 RPC operations</a> <a href="http://cncorda.com/doc/apis/api-rpc-operations/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-testing.html#flow-testing" target="_blank" rel="noopener">API：测试 Testing</a></li>
</ul>
<h3 id="内部API和稳定性保证"><a href="#内部API和稳定性保证" class="headerlink" title="内部API和稳定性保证"></a>内部API和稳定性保证</h3><p>Corda 3.0提供稳定的wire协议并支持数据库升级。因此，您应该能够将持久数据从3.0迁移到未来版本。但是，在我们开始提供ABI稳定性之前，有必要针对未来版本的API重新编译应用程序。</p>
<p>此外，请注意，Corda 3.0版本已经过基本级别的安全审核，为确保节点安全得到维护，应遵循以下最佳做法：</p>
<ul>
<li>应该使用安全密码生成器创建RPC用户、数据库连接和shell用户的凭证，最好从节点主机的命令行创建。</li>
<li>绝不应使用默认或开发模式凭证部署节点。</li>
<li>Corda节点应该使用其中一个受支持的数据库平台，而不是仅用于开发目的的默认H2数据库。Postgres是一个支持的平台。</li>
<li>应该在安全的网络（如DMZ）内操作节点，将入站和出站流量限制为仅需要的端口（就是限定端口做一些事）。具体而言，节点运营商应该致力于允许从互联网上访问点对点流量。RPC和数据库连接应该仅限于内部。</li>
<li>节点Web服务器模块已弃用，因此不应将其部署到生产环境中，因为它不是与Corda节点相同的安全标准。</li>
</ul>
<p>可以从Java 9 Jigsaw模块中获得Corda工件。从<code>module-info.java</code>中可以引用其中一个模块，例如<code>requires net.corda.core;</code>。</p>
<h3 id="Corda稳定的模块"><a href="#Corda稳定的模块" class="headerlink" title="Corda稳定的模块"></a>Corda稳定的模块</h3><p>以下模块具有稳定的API，我们承诺不会在以下版本中中断，除非出于安全原因需要进行不兼容的更改：</p>
<ul>
<li>核心（net.corda.core）：核心Corda函数库，如加密函数、Corda构建模块的类型：状态，合约，交易，附件等，以及用于节点和协议的一些接口</li>
<li>客户端RPC（net.corda.client.rpc）：客户端RPC</li>
<li>客户端Jackson（net.corda.client.jackson）：对客户端应用程序的JSON支持</li>
<li>测试实用程序（net.corda.testing.core）：通用测试实用程序</li>
<li>测试节点驱动程序（net.corda.testing.node，net.corda.testing.driver）：测试实用程序以编程方式运行节点</li>
<li>Http Test Utils（net.corda.testing.http）：一组用于制作HttpCalls的实用程序，旨在演示和测试。</li>
<li>DSL Test Utils（net.corda.testing.dsl）：用于测试目的的用于构建伪交易（与有线协议不同）的简单DSL。</li>
<li>虚拟合约 Dummy Contracts（net.corda.testing.contracts）：用于测试目的的虚拟状态和合约</li>
<li>模拟服务 Mock Services（net.corda.testing.services）：用于测试目的的模拟服务实现</li>
</ul>
<h3 id="Corda孵化模块"><a href="#Corda孵化模块" class="headerlink" title="Corda孵化模块"></a>Corda孵化模块</h3><p>以下模块还没有完全稳定的API，但我们会尽最大努力最大限度地减少开发人员使用它们的中断，直到我们能够将其应用到公共API中：</p>
<ul>
<li>net.corda.confidential.identities：实验性支持分类账上的机密身份</li>
<li>net.corda.finance：一系列基本合同（及相关模式）和协议，如抽象可替代资产，现金，义务和商业票据</li>
<li>net.corda.client.jfx：支持Java FX UI</li>
<li>net.corda.client.mock：客户端模拟实用程序</li>
<li>Cordformation：Gradle集成插件</li>
</ul>
<h3 id="Corda不稳定模块"><a href="#Corda不稳定模块" class="headerlink" title="Corda不稳定模块"></a>Corda不稳定模块</h3><p>以下模块可用，但我们不承诺任何意义上的稳定性或延续性：</p>
<ul>
<li>net.corda.buildSrc：必要的gradle插件来构建Corda</li>
<li>net.corda.node：Corda节点的核心代码（例如节点驱动程序，节点服务，消息传递，持久性）</li>
<li>net.corda.node.api：节点和客户端模块之间共享的数据结构，例如通过RPC发送的类型</li>
<li>net.corda.samples.network.visualiser：一个网络可视化工具，它使用仿真来显示Corda网络上节点之间的交互和消息</li>
<li>net.corda.samples.demos.attachment：演示如何使用附件从一个节点发送一个事务到另一个节点，并且接收节点访问附件</li>
<li>net.corda.samples.demos.bankofcorda：模拟资产发行机构的角色（例如中央银行的现金）</li>
<li>net.corda.samples.demos.irs：展示两家银行之间的利率互换协议</li>
<li>net.corda.samples.demos.notary：一个节点获得多个事务的简单演示，由分布式（Raft或BFT SMaRt）公证人公证</li>
<li>net.corda.samples.demos.simmvaluation：SIMM评估和分布式账本协议的演示</li>
<li>net.corda.samples.demos.trader：演示了四个节点：公证人，现金发行人（Corda银行）和两个彼此进行交易的人，用现金交换商业票据</li>
<li>net.corda.node.smoke.test.utils：测试烟雾测试实用程序</li>
<li>net.corda.node.test.common：通用测试功能</li>
<li>net.corda.tools.demobench：一个GUI工具，允许在本地运行Corda节点进行演示</li>
<li>net.corda.tools.explorer：Corda的GUI前端</li>
<li>net.corda.tools.graphs：用于推断项目依赖性的实用程序</li>
<li>net.corda.tools.loadtest：Corda负载测试</li>
<li>net.corda.verifier：允许节点外交易验证，允许验证水平扩展</li>
<li>net.corda.webserver：是一个用于导出HTTP端点的CorDapps的servlet容器。该服务器是节点的RPC客户端</li>
<li>net.corda.sandbox-creator：沙箱实用程序</li>
<li>net.corda.quasar.hook：代理钩入Quasar并提供类型排除列表</li>
</ul>
<p><b style="color:#6ab0de"><code>net.corda</code>名称空间中包含<code>.internal</code>或<code>net.corda.node</code>仅供内部使用的任何软件包内的代码。未来版本将拒绝任何CorDapps使用这些包中的类型。</b></p>
<h3 id="DoNotImplement-注解"><a href="#DoNotImplement-注解" class="headerlink" title="@DoNotImplement 注解"></a><code>@DoNotImplement</code> 注解</h3><p>Corda API中的某些接口和抽象类已被标注为@DoNotImplement。虽然我们承诺不删除或修改任何这些类的现有功能，但注释是我们可能需要在将来版本的Corda中扩展它们的警告。因此，Cordapp开发人员应该“按原样”使用这些类，而不是试图扩展或实现它们中的任何一个。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Corda普遍使用一种自定义形式的安全二进制序列化。这样做的目的是：</p>
<ul>
<li>希望有一个模式（schema）描述与实际数据一起被序列化的内容<ul>
<li>版本控制（以前的序列化数据也能被识别）</li>
<li>为了更容易编写泛型代码，例如可以导航序列化数据形式的用户接口。</li>
<li>支持跨平台（非JVM）交互，其中类文件的格式不容易解释。</li>
</ul>
</li>
<li>希望使用独立于平台并且不受第三方库升级等影响的文档化和静态线路格式。</li>
<li>希望支持开放式多态，其中超类的子类的数量可以随时间扩展并且子类不需要在模式中预先定义。这是很多Corda概念的关键，例如状态。</li>
<li>通过支持的构造函数构造反序列化对象来提高安全性，而不是直接将数据插入到其字段中，而没有机会验证一致性或拦截尝试操纵假定的不变量。</li>
<li>二进制格式比数字签名更适用于基于文本的格式，因为修改语法的范围要小得多，而不是语义。</li>
</ul>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>经典的Java序列化，JVM类路径上的任何类都可以反序列化。通过利用类路径上的大量第三方库作为JVM应用程序依赖关系和精心设计的反序列字节流的一部分，这已被证明是漏洞利用和漏洞的来源。在Corda中，我们通过坚持每个对象的类属于允许的类的白名单中，阻止任何类被反序列化（并在序列化过程中主动）。</p>
<p>类通过三种机制之一进入白名单：</p>
<ul>
<li>通过<code>@CordaSerializable</code>注解。这个注解可能存在接口和超类的注解上。</li>
<li>通过实现<code>SerializationWhitelist</code>接口并指定白名单类别的列表。</li>
<li>通过内置的Corda白名单（见<code>DefaultWhitelist</code>类）。虽然这不是用户可编辑的，但它列出了为方便您而列入白名单的常见JDK类。</li>
</ul>
<p>注解的方式是加入白名单的首选方式。<a href="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html" target="_blank" rel="noopener">Using the client RPC API</a>是一个实例。</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>目前，基于Kryo的格式仍然被客户端和服务器端的RPC框架所使用。但是，计划很快RPC框架将转向AMQP框架。</p>
<p>将序列化方案分离到不同的上下文中使我们能够为该上下文使用最合适的框架，而不是试图强制采取一刀切的方法。Kryo更适合于程序堆栈框架的序列化，因为它比我们的AMQP框架在构建和序列化方面更加灵活。但是，这种灵活性使得安全性变得异常困难。相反，我们的AMQP框架允许我们专注于可以推理的安全框架，从而使安全性更低，安全漏洞更少。</p>
<h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><p>本节介绍AMQP序列化格式支持的类和接口。</p>
<ul>
<li>集合类型</li>
<li>JVM原始类型</li>
<li>数组</li>
<li>JDK类型：支持的类型可以查阅原文</li>
<li>第三方的类型</li>
<li>Corda类型：<code>@CordaSerializable</code>注解的类和接口</li>
</ul>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>您自己的类型必须遵守以下支持的规则：</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h5><ol>
<li>该类必须使用包含在<code>.class</code>文件中的参数名称进行编译。这是Kotlin中的默认设置，但必须使用<code>javac</code>的<code>-parameters</code>命令行选项打开。</li>
<li>这个类必须要用<code>@CordaSerializable</code>注解</li>
<li>必须支持构造函数参数，getter和setter的声明类型，并且在使用泛型时，泛型参数必须是受支持的类型，开放式通配符（*）或有界通配符，该通配符目前被扩展为开放式通配符</li>
<li>任何超类都必须遵守相同的规则，但可以是抽象的</li>
<li>对象引用循环不受支持，因此对象无法直接或间接引用自身</li>
</ol>
<h4 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h4><p>Corda的AMQP序列化框架实例化对象的主要方式是通过指定的构造函数。这用于首先确定对象的哪些属性将被序列化，然后在反序列化时用于使用序列化值实例化对象。</p>
<p>建议Corda中的可序列化对象遵守以下规则，因为它们允许不可变状态对象被反序列化：</p>
<ol>
<li>一个Java Bean getter，用于构造函数中的每个属性，并具有表单的名称<code>getX</code>。</li>
<li>一个构造函数，它采用您希望以序列化形式记录的所有属性。这是序列化框架重建类的一个实例所必需的.</li>
<li>如果提供了多个构造函数，则序列化框架需要知道使用哪一个。<code>@ConstructorForDeserialization</code> 注释可以被用来指示哪一个。对于没有<code>@ConstructorForDeserialization</code>注解的Kotlin类，将选择主构造函数</li>
</ol>
<h4 id="Setter实例化"><a href="#Setter实例化" class="headerlink" title="Setter实例化"></a>Setter实例化</h4><p>作为基于构造函数初始化的替代，Corda还可以通过检查类中存在的getter和setter方法来确定对象的重要元素。如果一个类只有一个默认的构造函数和属性，那么可序列化的属性将由该属性的getter和setter的存在来确定，这些属性都是公开可见的（即该类遵守可变JavaBean 的经典成语）。</p>
<p>在反序列化中，首先会创建一个默认实例，然后调用该对象以使用正确的值填充它。</p>
<h4 id="无法访问的私有属性"><a href="#无法访问的私有属性" class="headerlink" title="无法访问的私有属性"></a>无法访问的私有属性</h4><p>虽然Corda AMQP序列化框架支持私有对象属性，但没有可公开访问的getter方法，但强烈建议不要使用此开发习惯用法。</p>
<h4 id="不匹配的类属性-构造函数参数"><a href="#不匹配的类属性-构造函数参数" class="headerlink" title="不匹配的类属性/构造函数参数"></a>不匹配的类属性/构造函数参数</h4><p>考虑一个例子，您希望确保类型为某种形式容器的类的属性总是按照某些特定条件进行排序，但您希望保持该类的不变性。</p>
<h4 id="可变容器"><a href="#可变容器" class="headerlink" title="可变容器"></a>可变容器</h4><p>因为Java从根本上不提供可以确定类的可变性的机制，所以这给序列化框架带来了问题。当用容器属性（列表，地图等）重新构建对象时，我们必须选择是创建可变对象还是不可变对象。考虑到这些限制，我们决定保留不可变对象的不变性更好，而不是强制推断不可变对象的可变性。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>所有的枚举都支持，只要它们被<code>@CordaSerializable</code>注解。Corda支持枚举类型版本的互操作性。这允许这样的类型随时间改变而不破坏反向（或向前）兼容性。<a href="https://docs.corda.net/releases/release-V3.1/serialization-enum-evolution.html" target="_blank" rel="noopener">Enum Evolution</a>讨论了这样做的规则和机制。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>以下规则适用于受支持的<code>Throwable</code>实现。</p>
<ol>
<li>如果你希望你的异常是可序列化和安全传输的，它应该继承自<code>CordaException</code>或者<code>CordaRuntimeException</code></li>
<li>如果不是，该<code>Throwable</code>遗嘱将反序列化为一个<code>CordaRuntimeException</code>包含其中的原件的详细信息 <code>Throwable</code>，包括原始的类名称<code>Throwable</code></li>
</ol>
<h4 id="Kotlin对象"><a href="#Kotlin对象" class="headerlink" title="Kotlin对象"></a>Kotlin对象</h4><p>略</p>
<h3 id="类合成"><a href="#类合成" class="headerlink" title="类合成"></a>类合成</h3><p>Corda序列化支持在反序列化时从提供的模式动态合成类，而不在类路径中存在支持类。在通用代码可能希望能够对反序列化的数据，在JVM上运行的脚本语言以及确保不在类路径上的类可以反序列化而不加载潜在的恶意代码的情况下，这可能是有用的。</p>
<p>未来可能的增强包括：</p>
<ol>
<li>Java单例支持。我们将添加支持以识别单身人士的类别，并确定负责返回单身人士实例的静态方法</li>
<li>实例内化支持。我们将添加对确定应根据实例映射解析的类的支持，以避免创建许多相同（类似于String.intern()）的重复实例，</li>
</ol>
<h3 id="类型演变"><a href="#类型演变" class="headerlink" title="类型演变"></a>类型演变</h3><p>类型演化是类可以随时间改变的机制，但仍然可以在所有类型的版本中保持序列化和反序列化。这确保了一个对象的序列化，它具有旧类型的“看起来像”类可以被反序列化的版本以及实例化类的当前状态的版本。</p>
<p>更多细节可以在<a href="https://docs.corda.net/releases/release-V3.1/serialization-default-evolution.html" target="_blank" rel="noopener">Default Class Evolution</a>中找到。</p>
<h2 id="安全的编码准则"><a href="#安全的编码准则" class="headerlink" title="安全的编码准则"></a>安全的编码准则</h2><p>该平台通过默认设计确保安全。不幸的是，该平台无法防止各种安全错误。本文档描述了在编写应用程序以阻止各种攻击时需要考虑的问题。尽管假设没有合理的交易对手试图用流程级别的攻击来颠覆您的交易可能会很诱人，但是依靠信任来提高软件安全性会使您很难在稍后想要快速添加对手方并且没有广泛审查的情况下扩展您的业务。</p>
<h3 id="流动"><a href="#流动" class="headerlink" title="流动"></a>流动</h3><p><a href="https://docs.corda.net/releases/release-V3.1/flow-state-machines.html" target="_blank" rel="noopener">编写流程</a>是您的应用程序与网络上的其他各方进行通信的方式。因此，它们是恶意数据进入您应用程序的典型切入点，必须小心处理。</p>
<p>这些<code>receive</code>方法返回包装在<code>UntrustworthyData&lt;T&gt;</code>标记类型中的数据。这种类型不会添加任何功能，它只是提醒您正确验证从网络获得的所有内容。请记住，另一方可能没有运行您提供的用于参与流程的代码：他们被允许执行任何操作！需要注意的事项：</p>
<ul>
<li>例如，如果您建议为资产交易价值100美元的现金状态，并且签署的交易从另一方返回，则该交易与流程中较早建立或建议的部分交易不匹配，您必须检查它指向您实际请求的状态。否则，攻击者可以让你签署一项交易，如果他们知道一个ID的话，那么这笔交易将花费更多的时间给你。</li>
<li>一个不正确类型的交易。有两种交易类型：普通和公证变更。如果您希望获得一种类型，但获得另一种类型，则可能会发现自己签署了一项交易，将您的资产转移到敌对公证人的控制之下。</li>
<li>交易中各状态的意外更改。如果您有权访问所有需要的数据，则可以重新运行构建器逻辑并对结果状态进行比较，以确保它符合您的预期。例如，如果构建下一个状态所需的数据对双方都可用，则计算您想要相互同意的交易的函数可以在实现流程的两端的两个类之间共享。</li>
</ul>
<p>主题应该清楚：签名是一项非常敏感的操作，因此您需要确保您知道您要签名的是什么，并且输出没有任何变化！一旦您通过交易向交易对手提供了您的签名，就不再有任何事情可以阻止他们将其交付给分类账。</p>
<h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><p>合同是JVM沙箱内的任意函数，因此它们有很大的自由度。需要注意的事项：</p>
<ul>
<li>当前状态转换不应允许的状态更改。你会想要检查没有领域正在改变，除了预期的领域！</li>
<li>意外捕获并丢弃可能由验证逻辑抛出的异常。</li>
<li>如果您不知道其他合约是做什么或可能做什么，则通过虚拟方法调用其他合约。</li>
</ul>
<h2 id="流程cookbook"><a href="#流程cookbook" class="headerlink" title="流程cookbook"></a>流程cookbook</h2><p><a href="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html" target="_blank" rel="noopener">该流程</a>展示了如何在Java和Kotlin中使用Corda的API。</p>
<h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><p><a href="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html" target="_blank" rel="noopener">这个网页</a>是Corda知识的备忘单。</p>
<h2 id="Cordapp示例"><a href="#Cordapp示例" class="headerlink" title="Cordapp示例"></a>Cordapp示例</h2><p><a href="https://docs.corda.net/releases/release-V3.1/building-a-cordapp-samples.html" target="_blank" rel="noopener">CorDapp samples</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/31/blockchain/corda/Corda基础学习/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/31/blockchain/corda/Corda基础学习/" class="post-title-link" itemprop="url">Corda基础学习</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-31 17:40:02" itemprop="dateCreated datePublished" datetime="2018-05-31T17:40:02+08:00">2018-05-31</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-16 23:47:32" itemprop="dateModified" datetime="2018-09-16T23:47:32+08:00">2018-09-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇的博客中，我提到了Corda的一些基础的知识，但是那个版本是比较旧的，这次针对新的版本，写一些笔记来完成相应的更新。</p>
<h2 id="Corda-Network"><a href="#Corda-Network" class="headerlink" title="Corda Network"></a>Corda Network</h2><p>关于Corda的网络，有以下几点：</p>
<ol>
<li>这个网络由运行Corda和CorDapps的节点组成。</li>
<li>网络是授权的，通过doorman控制权限</li>
<li>节点之间的通信是点对点的，不依赖全局广播。</li>
</ol>
<h3 id="Network结构"><a href="#Network结构" class="headerlink" title="Network结构"></a>Network结构</h3><p>Corda网络是一个认证的节点点对点网络，里面每一个节点都是有Corda服务并且执行CorDapps应用的JVM运行环境。</p>
<p><b style="color:red">节点之间的通信是直接的，通过AMQP/1.0发送TLS加密的信息。是点对点的，不采用广播的方式。</b></p>
<p><b style="color:blue">每个网络存在网络映射(map)服务，可以发布网络上每个节点都可以访问的IP地址，以及这些节点的身份证书和它们提供的服务。</b></p>
<h3 id="doorman"><a href="#doorman" class="headerlink" title="doorman"></a>doorman</h3><p>Corda网络是半私人的。每个网络都有一个门卫服务，用于执行关于节点必须提供的信息的规则以及他们在被允许进入网络之前必须完成的了解您的客户(KYC)流程。</p>
<p>要加入网络，节点必须联系门卫并提供所需的信息。如果门卫感到满意，该节点将从网络的许可服务接收根权威机构签署的TLS证书。此证书在与网络上的其他参与者通信时验证节点的身份。</p>
<p><b style="color:red">注：在源码中发现就是发送http请求，而且还要设置一个URL。详细的信息可以参阅源码部分。</b></p>
<p>我们可以将网络可视化如下：</p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda%E7%BD%91%E7%BB%9C.png?raw=true" alt=""></p>
<h3 id="Network中的服务"><a href="#Network中的服务" class="headerlink" title="Network中的服务"></a>Network中的服务</h3><p>节点可以提供几种类型的服务：</p>
<ul>
<li>一个或多个可插式公证服务。公证人保证分类账更新的唯一性和可能性。每个公证服务可以在单个节点上运行，也可以在一组节点上运行。</li>
<li>零个或更多的Oracle服务。Oracle是一个众所周知的服务，<b style="color:red">如果他们陈述事实并且事实被认为是真实的，那么它就会签署交易。</b></li>
</ul>
<h2 id="账本Ledger"><a href="#账本Ledger" class="headerlink" title="账本Ledger"></a>账本Ledger</h2><p>概要</p>
<ul>
<li>分类账从每个节点的角度来看都是透明的对象</li>
<li>两个节点总是保证看到他们分享的任何分类账事实完全相同的版本</li>
</ul>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在Corda，没有单一的中央数据存储。相反，每个节点都维护一个已知事实的单独数据库。因此，每个节点只能看到分类帐上的一小部分事实，并且没有节点完全知道分类账。</p>
<p>例如，想象一个具有五个节点的网络，其中每个彩色圆圈表示一个共享事实：</p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-venn.png?raw=true" alt=""></p>
<p>我们可以看到尽管Carl，Demi和Ed都感知了事实3，，但是Alice和Bob却不知道事实3的存在。</p>
<p>同样重要的是，Corda保证，无论何时这些事实中的一个在网络多个节点间共享，它在每个知道它的节点的数据库中以锁的方式发展。<br><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-table.png?raw=true" alt=""></p>
<p>例如，Alice和Bob都会看到共享事实1和7的相同版本。</p>
<h2 id="身份Identity"><a href="#身份Identity" class="headerlink" title="身份Identity"></a>身份Identity</h2><p>概要</p>
<ul>
<li>Corda中的身份可以代表合法身份或服务身份</li>
<li><b style="color:red">身份证明由门卫签署的X.509证书或公认的身份证明</b></li>
<li>众所周知的身份发布在网络地图(map)中（NetworkMapService，这个在源码中我们也可以看到）</li>
<li>机密身份仅在需要知道的基础上共享</li>
</ul>
<p>Corda中的身份可以表示：</p>
<ul>
<li>一个组织的法律身份</li>
<li>网络服务的服务标识（该节点只是提供服务而已）</li>
</ul>
<p><b style="color:red">法律身份用于交易中的各方，例如现金状态的所有者。服务标识用于提供与交易相关的服务的人员，例如公证人员或oracle。</b>服务身份与合法身份不同，因此分布式服务可以存在于不同组织所拥有的节点上。这种分布式服务身份是基于的<code>CompositeKeys</code>，它描述了服务签名的有效签名者集合。有关<code>CompositeKeys</code>的更多技术细节，请参阅<a href="https://docs.corda.net/releases/release-V3.1/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a>。</p>
<p><b style="color:red">身份是众所周知的还是保密的，取决于他们的X.509证书（和对应的证书路径是否可信的根证书）已发布：</b>.</p>
<ul>
<li>众所周知的身份是法律实体或服务的一般可识别的公钥，这使得它们不适用于需要参与者保密的交易。<b style="color:blue">此证书已发布在网络地图服务中供任何人访问。</b></li>
<li>机密身份只发布给参与交易的人员。公钥可能暴露给第三方（例如公证服务），但名称和X.509证书的分发是受限的。</li>
</ul>
<p>虽然Corda交易隐私模式有几个要素，包括确保交易只与需要查看它们的用户共享以及有计划地使用英特尔SGX，但重要的是要提供深入的防御隐私攻击。机密身份用于确保即使第三方访问未加密的交易，他们也无法在没有附加信息的情况下识别参与者。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>节点必须能够验证使用X.509证书实现的公钥所有者的身份。<b style="color:red">首次运行时，节点生成密钥对并向网络门卫服务提交证书签名请求</b>（请参阅 <a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>）。Doorman服务应用适当的身份检查，<b style="color:red">然后向用作节点认证中心（CA）的节点发放证书</b>。从该初始CA证书中，节点自动创建并签署两个其他证书，一个TLS证书(sslKeyStore)和一个用于该节点众所周知的身份的签名证书(nodeKeyStore)。最后，节点建立包含其地址和众所周知的身份的节点信息记录，并将其注册到网络地图服务。</p>
<p>组织可以从签署证书创建公开和机密身份。众所周知的身份的用例包括代表用于冗余目的的单个身份的节点集群，或者为组织单位创建身份。</p>
<p>组织需要决定他们希望在网络地图服务中发布哪些身份，使其广为人知，并且出于隐私原因（通常是为了避免暴露商业敏感的交易细节），他们希望将其保留为机密身份。<b style="color:red">在某些情况下，出于操作原因，除了主网络地图服务之外，节点还可能使用专用网络地图服务。</b>使用此类网络地图注册的身份必须被认为是众所周知的，并且将机密身份存储在中央目录中，而不在记录级别应用控制，以确保只有需要访问身份的人才能检索其证书。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>概要：</p>
<ul>
<li>状态代表了分类账事实</li>
<li>通过将当前状态标记为历史的并创建更新状态来进行状态演变</li>
<li>每个节点都有一个保管库（Vault，可以是放入数据库中，有相应接口，默认是放在内存中），它在其中存储任何相关的状态</li>
</ul>
<h3 id="概观-1"><a href="#概观-1" class="headerlink" title="概观"></a>概观</h3><p>状态可以包含任意数据，允许它们表示任何种类的事实（例如股票，债券，贷款，KYC数据，身份信息……）。例如，以下状态代表IOU - Alice欠Bob的协议金额X：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/state.png" alt=""></p>
<p>除了关于事实本身的任何信息外，状态还包含对管理状态演变随时间推移的合约（Contract）的引用。</p>
<h3 id="状态序列"><a href="#状态序列" class="headerlink" title="状态序列"></a>状态序列</h3><p>共享事实随时间的生命周期由状态序列表示。当一个状态需要更新时，我们创建代表新状态的新版本状态，并将现有状态标记为历史状态。</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/state-sequence.png" alt=""></p>
<h3 id="金库-Vault"><a href="#金库-Vault" class="headerlink" title="金库(Vault)"></a>金库(Vault)</h3><p>网络上的每个节点都有一个保管库（Vault） - 一个数据库，用于追踪所有当前和历史状态，以及它认为与自身相关的所有当前状态和历史状态.</p>
<h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>概要</p>
<ul>
<li>每个输入和输出状态的合约都必须接受有效的交易</li>
<li>合约是用JVM编程语言（如Java或Kotlin）编写的，</li>
<li>合约执行是确定性的，其对交易的接受仅基于交易的内容</li>
</ul>
<h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><p>回想一下，交易只有在所有必需的签名者都进行了数字签名的情况下才有效。但是，即使交易收集了所有必需的签名，它也仅在合约有效的情况下才有效。</p>
<p>合约有效性定义如下：</p>
<ul>
<li><b style="color:red">每个状态都指向一份合约</b></li>
<li>一个合约需要一个交易作为输入，并指出根据合约的规则的交易是否被认为是有效的</li>
<li>只有当每个输入状态和每个输出状态的合约认为其有效时，交易才有效</li>
</ul>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/tx-validation.png" alt=""></p>
<p>合约代码可以用任何JVM语言编写，并且可以使用该语言的全部功能，包括：</p>
<ul>
<li><b style="color:red">检查输入，输出，命令，时间戳和/或附件的数量</b></li>
<li>检查这些组件的内容</li>
<li>循环结构，变量赋值，函数调用，辅助方法等</li>
<li>将类似的状态分组以验证它们是否为一组（例如，对所有现金状态的总价值施加一个规则）</li>
</ul>
<p>非合约有效的交易不是更新分类帐的有效提案，因此不能提交给分类账。通过这种方式，合约对状态随时间推移的演变规定了独立于所需签名人签署给定交易的意愿的规则。</p>
<h3 id="合约沙箱"><a href="#合约沙箱" class="headerlink" title="合约沙箱"></a>合约沙箱</h3><p>交易验证必须是确定性的 - 合约应始终接受或始终拒绝给定的交易。例如，交易有效性不能取决于进行验证的时间，也不取决于合作伙伴运行合约的信息量。这是确保网络上的所有同行对特定分类帐更新的有效性达成共识的必要条件。</p>
<p><b style="color:red">为了达到这个目的，合约评估确定性沙箱中的交易。沙盒有一个白名单（这就是在源码看到的WhiteList的作用了吧，不过这个白名单是针对附件的），可以防止合约导入可能成为非确定性来源的库</b>。这包括提供当前时间的库，随机数生成器，提供文件系统访问的库或网络库等。最终，验证交易时可用于合约的唯一信息是交易本身中包含的信息。</p>
<h3 id="合约限制"><a href="#合约限制" class="headerlink" title="合约限制"></a>合约限制</h3><p>由于合约无法获得外部信息，它只能检查交易的内部有效性。例如，它不能检查交易是否与最初与交易对手达成一致。</p>
<p>因此，节点在签署交易之前应检查交易内容，即使交易合约有效，以查看他们是否同意提议的分类帐更新。节点没有义务签署一项交易，只是因为它在合约中有效。例如，他们可能不愿意承担过大的贷款，或可能不同意为资产提供的现金数额。</p>
<h3 id="神谕（Oracle）"><a href="#神谕（Oracle）" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h3><p>有时，交易有效性将取决于一些外部信息，例如汇率。在这些情况下，需要一个oracle。有关更多详细信息，请参阅<a href="https://docs.corda.net/releases/release-V3.2/key-concepts-oracles.html" target="_blank" rel="noopener">Oracles</a>。</p>
<h3 id="法律散文（legal-prose）"><a href="#法律散文（legal-prose）" class="headerlink" title="法律散文（legal prose）"></a>法律散文（legal prose）</h3><p>每份合约还涉及法律散文文件，其中规定了与传统法律体系兼容的随时间推移的状态演变规则。在法律纠纷的情况下，可以依靠这份文件。</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>概要</p>
<ul>
<li>交易是更新分类账的提案</li>
<li>交易提案承诺以下情况：<ul>
<li>它不包含双重花费</li>
<li>这是合约有效的</li>
<li>它由所需方签署</li>
</ul>
</li>
</ul>
<p>Corda使用UTXO（未使用的交易输出）模型。其中分类帐上的每个状态都是不可变的。分类账通过应用交易随着时间的推移而发展，交易通过将零个或多个现有分类账状态标记为历史（输入）并产生零个或多个新分类账状态（输出）来更新分类账。交易表示在状态中看到的状态序列中的单个链接。<br><img src="https://docs.corda.net/releases/release-V3.2/_images/basic-tx.png" alt=""></p>
<p>交易可以包含任何数量任何类型的输入和输出：</p>
<ul>
<li>可以包含很多不同的状态类型（比如，包含现金和股票）</li>
<li><b style="color:red">可以是发行的（没有任何输入）或者退出（没有任何输出）</b></li>
<li>他们可以合并或者分割可替代资产（就像付10元收2元找8元）</li>
</ul>
<p>交易是原子的：要么所有交易的提议变更都被接受，要么都没有。</p>
<p>这里有两种基础交易类型：</p>
<ul>
<li>公证改变交易（用来改变一个状态的公证人，参阅<a href="https://docs.corda.net/releases/release-V3.2/key-concepts-notaries.html" target="_blank" rel="noopener">Notaries</a>）</li>
<li>普通的交易（其它的交易）</li>
</ul>
<h3 id="交易链"><a href="#交易链" class="headerlink" title="交易链"></a>交易链</h3><p>在创建新交易时，交易将申明的输出状态尚不存在，因此必须由交易提议者创建。但是，输入状态已作为先前交易的输出存在。因此，我们将其纳入拟议的交易中。</p>
<p>这些输入状态引用是下面的组合：</p>
<ul>
<li>交易创建输入的hash</li>
<li>输入的在上一个交易中的输出的索引</li>
</ul>
<p>这个情况可以使用下图来说明：<br><img src="https://docs.corda.net/releases/release-V3.2/_images/tx-chain.png" alt=""></p>
<p>这些输入状态引用（StateRef）将交易连接在一起，形成所谓的交易链。</p>
<h3 id="提交交易"><a href="#提交交易" class="headerlink" title="提交交易"></a>提交交易</h3><p>最初，交易只是更新分类帐的建议.<br><img src="https://docs.corda.net/releases/release-V3.1/_images/uncommitted_tx.png" alt=""></p>
<p>要成为现实，交易必须接收所有必需的签名者的签名（参见下面的命令）。每位必需的签名者将其签名附加到交易中以表明他们批准该提案：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/tx_with_sigs.png" alt=""></p>
<p>如果所有必需的签名都被收集起来，交易将变为已提交：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/committed_tx.png" alt=""></p>
<p>这意味着：</p>
<ul>
<li>交易的输入被标记为历史性的，并且不能用于任何未来的交易</li>
<li>交易的产出成为分类账当前状态的一部分</li>
</ul>
<h3 id="交易有效性"><a href="#交易有效性" class="headerlink" title="交易有效性"></a>交易有效性</h3><p>如果以下两个条件成立，每个必需的签名者只应签署交易：</p>
<ul>
<li>交易有效性：对于提议的交易以及创建当前提议的交易输入的交易链中的每个交易：<ul>
<li>交易由所有必要方进行数字签名</li>
<li>合约验证交易有效（查看<a href="https://docs.corda.net/releases/release-V3.2/key-concepts-contracts.html" target="_blank" rel="noopener">Contracts</a>）</li>
</ul>
</li>
<li>交易唯一性：没有其他交易已经消耗了我们建议交易的任何投入</li>
</ul>
<h3 id="其他交易组件"><a href="#其他交易组件" class="headerlink" title="其他交易组件"></a>其他交易组件</h3><p>除输入状态和输出状态外，交易可能包含：</p>
<ul>
<li>命令Commands</li>
<li>附件Attachments</li>
<li>时间戳Timestamps</li>
</ul>
<p>例如，一项交易，其中Alice使用5英镑的现金支付与Bob支付5英镑的欠条，由两个附件和时间戳支持，可能如下所示：<br><img src="https://docs.corda.net/releases/release-V3.2/_images/full-tx.png" alt=""></p>
<p>我们将探讨下面剩余交易组件所扮演的角色。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>假设我们有一个以现金状态和债券状态作为输入的交易，以现金状态和债券状态作为输出。该交易可能代表两种不同的情况：</p>
<ul>
<li>债券购买</li>
<li>债券上的息票支付</li>
</ul>
<p>我们可以想象，我们希望对构成有效交易的内容施加不同的规则，具体取决于这是购买还是优惠券付款。例如，在购买的情况下，我们需要改变债券的当前所有者，而在支付息票的情况下，我们会要求债券的所有权不变。</p>
<p>为此，我们有命令。在交易中包含命令可以让我们指出交易的意图，从而影响我们如何检查交易的有效性。</p>
<p>每个命令还与一个或多个签名者列表关联。通过将命令中列出的所有公钥的联合，我们得到交易所需的签名者列表。在我们的例子中，我们可以想象：</p>
<ul>
<li>在债券的息票付款中，只有债券所有者需要签署</li>
<li>在现金支付中，只需要现金的所有者签字</li>
</ul>
<p>我们可以看到这种情况如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/commands.png" alt=""></p>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>有时，我们有大量的数据可以在许多不同的交易中重用。一些例子：</p>
<ul>
<li>公众假期日历</li>
<li>支持法律文件</li>
<li>货币代码表</li>
</ul>
<p>对于这个用例，我们有附件。每个交易可以通过哈希引用零个或多个附件。这些附件是包含任意内容的ZIP/JAR文件。这些文件中的信息可以在检查交易的有效性时使用。</p>
<h3 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h3><p>在某些情况下，我们希望建议的交易只能在特定时间段内批准。例如：</p>
<ul>
<li>期权只能在特定日期后执行</li>
<li>债券只能在到期日前赎回</li>
</ul>
<p>在这种情况下，我们可以为交易添加一个时间窗口。时间窗口指定了可以提交交易的时间窗口。我们讨论时间窗口部分的时间窗口。</p>
<h2 id="流程（Flow）"><a href="#流程（Flow）" class="headerlink" title="流程（Flow）"></a>流程（Flow）</h2><p>概要</p>
<ul>
<li>流程自动化了同意分类帐更新的过程</li>
<li>节点之间的通信只发生在这些流程的上下文中，并且是点对点的</li>
<li>提供了内置流程来自动化常见任务</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>Corda网络使用点对点消息而不是全局广播。这意味着协调分类帐更新需要网络参与者准确指定需要发送的信息，交易对手以及以何种顺序。</p>
<p>以下是在Alice和Bob之间就简单分类账更新达成一致的过程的可视化：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/flow.gif" alt=""></p>
<h3 id="流程框架"><a href="#流程框架" class="headerlink" title="流程框架"></a>流程框架</h3><p>Corda不需要手动指定这些步骤，而是使用流程自动化流程。流程是一系列步骤，告诉节点如何实现特定的分类帐更新，例如发放资产或结算交易。</p>
<p>以下是上述简单分类账更新中涉及的流程步骤顺序：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/flow-sequence.png" alt=""></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>一旦给定的业务流程被封装在流中并作为CorDapp的一部分安装在节点上，节点的所有者就可以指示节点随时使用RPC调用启动该业务流程。该流程将所有网络，I / O和并发问题从节点所有者中抽象出来。</p>
<p>节点上的所有活动都发生在这些流程的上下文中。与合约不同，流程不在沙箱中执行，这意味着节点可以执行诸如网络，I/O等操作，并在流程执行过程中使用随机源。</p>
<h4 id="节点间通信"><a href="#节点间通信" class="headerlink" title="节点间通信"></a>节点间通信</h4><p>节点通过在流之间传递消息进行通信。每个节点具有零个或多个流类，它们被注册为响应来自单个其他流的消息。</p>
<p>假设Alice是网络上的一个节点，并希望与另一个网络节点Bob同意分类帐更新。为了与Bob沟通，Alice必须：</p>
<ul>
<li>开始注册Bob回应的流程</li>
<li>在该流程的上下文中向Bob发送消息</li>
<li>鲍勃将开始注册的交易对手流程</li>
</ul>
<p>现在建立了一个连接，Alice和Bob可以通过传递一系列来回传递的消息来同意分类账更新，如流程步骤中所规定的那样。</p>
<h4 id="子流程"><a href="#子流程" class="headerlink" title="子流程"></a>子流程</h4><p>可以通过在另一个流程的上下文中将流程作为子流程启动来组成流程。作为子流程开始的流程称为子流程。父流程将一直等到子流程返回。</p>
<h4 id="流程库"><a href="#流程库" class="headerlink" title="流程库"></a>流程库</h4><p>Corda提供了一个处理常见任务的流程库，这意味着开发人员不必重新定义常见流程背后的逻辑，例如：</p>
<ul>
<li>公证和记录交易</li>
<li>从对手方节点收集签名</li>
<li>验证一系列交易</li>
</ul>
<p>有关可用内置流程的更多信息，请参见<a href="https://docs.corda.net/releases/release-V3.1/flow-library.html" target="_blank" rel="noopener">Flow库</a>。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>流程框架允许节点一次有多个活动流。这些流量可能持续数天，跨节点重启甚至升级。</p>
<p>这是通过将数据流序列化到磁盘来实现的，只要它们进入阻塞状态（例如，当它们正在等待I / O或网络呼叫时）。与其等待流程畅通无阻，节点立即开始处理任何其他计划流程，仅在以后返回到原始流程。</p>
<h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>概要</p>
<ul>
<li>承诺，交易必须达到有效性和唯一性共识</li>
<li>有效性共识需要交易及其所有依赖关系的合约有效性</li>
<li>唯一性共识可以防止双重花费</li>
</ul>
<h3 id="两种共识"><a href="#两种共识" class="headerlink" title="两种共识"></a>两种共识</h3><p>确定提议的交易是否是有效的分类帐更新涉及达成两种类型的共识：</p>
<ul>
<li>有效性共识 - 在签署交易前由每个必需签署者检查</li>
<li>唯一性共识 - 只有公证服务才能检查</li>
</ul>
<p>有效性共识是检查以下条件是否适用于拟议交易以及交易链中为交易提议交易产生输入的每个交易的过程：</p>
<ul>
<li>交易被每个输入和输出状态的合约所接受</li>
<li>交易拥有所有必需的签名</li>
</ul>
<p>验证提议的交易本身是不够的。我们还必须核实导致建立交易建议输入的交易链中的每一笔交易。</p>
<p>这就是所谓的走链。例如，假设网络上的一方提出将我们的国债转让给我们的交易。在下列情况下，我们只能确保债券转移有效：</p>
<ul>
<li>国债是由中央银行在有效的发行交易中发行的</li>
<li>债券交易后的每一次交易都是有效的</li>
</ul>
<h3 id="唯一性共识"><a href="#唯一性共识" class="headerlink" title="唯一性共识"></a>唯一性共识</h3><p>唯一性共识是要求所提议的交易的投入没有一个在另一笔交易中已经消耗。</p>
<p>如果一个或多个输入已经在另一个交易中被使用，这就是所谓的双重支出，并且交易提议被认为是无效的。</p>
<p>公证人提供了唯一性共识。请参阅公证人了解更多详情。</p>
<h2 id="公证人（Notary）"><a href="#公证人（Notary）" class="headerlink" title="公证人（Notary）"></a>公证人（Notary）</h2><p>概要</p>
<ul>
<li>公证人防止“双花”</li>
<li>公证员也可以选择验证交易</li>
<li>一个网络可以有几个公证人，每个公证人都运行不同的共识算法</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个公证是一种网络服务，它提供了独特的共识被证明的是，对于一个给定的交易，它尚未签署消耗任何拟议中的交易的输入状态的其他交易。</p>
<p>在被要求公证交易时，公证人可以：</p>
<ul>
<li>如果交易尚未签署其他消耗建议交易输入状态的交易，请签署交易</li>
<li>拒绝该交易并标记双重支出尝试已经发生</li>
</ul>
<p>这样做，公证人提供了系统中的终点。在获得公证人的签名之前，各方不能确定同等有效但冲突的交易不会被视为花费给定输入状态的“有效”尝试。但是，在获得公证人的签名后，我们可以确定提议的交易的输入状态尚未被先前的交易消耗。因此，公证是系统中的终点。</p>
<p>每个状态都有一个指定的公证人，如果公证人是所有交易输入状态的指定公证人，公证人只会公证一项交易。</p>
<h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>Corda具有“可插入”的共识，允许公证人根据隐私，可扩展性，法律系统兼容性和算法敏捷性的要求选择一致的算法。</p>
<p>特别是，公证人在以下方面可能会有所不同：</p>
<ul>
<li>结构 - 公证可能是单个网络节点，相互信任的节点群或相互不信任的节点群</li>
<li>共识算法 - 公证服务可以选择运行高速，高可信度算法，如RAFT，低速低信任算法（如BFT），或者其他任何其他共识算法</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>公证服务还必须在提交之前通过确认每笔交易来决定是否提供有效性共识。在作出这个决定时，他们面临以下的交易：</p>
<ul>
<li><b style="color:red">如果一个交易没有被检查有效性，它会产生“拒绝状态”攻击的风险，在这种情况下，一个节点明知地建立一个无效的事务，消耗一些现有状态并将其发送给公证人，导致这些状态被标记为已消耗。（这是攻击风险，需要验证交易合法性以抵制这种攻击）</b>.</li>
<li>如果交易被检查的有效性，公证员将需要看到交易及其依赖的全部内容。这泄露了可能的私人数据给公证人</li>
</ul>
<p>在评估这种折衷时，还有几点需要注意。在非验证模型的情况下，Corda的受控数据分布模型意味着关于未消费状态的信息并未广泛共享。此外，Corda的许可网络意味着公证人可以存储创建“拒绝状态”交易的一方的身份，从而使得攻击能够逐个解决。</p>
<p>在验证模型的情况下，使用匿名的，新近生成的公钥而不是法定身份来识别交易中的当事方会限制公证人看到的信息。</p>
<h3 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h3><p>每个Corda网络可以有多个公证员，每个公证员可能运行不同的共识算法。这提供了几个好处：</p>
<ul>
<li>隐私 - 我们可以在同一网络上同时具有验证和非验证公证服务，每个都运行不同的算法。这使得节点能够按照每个交易选择首选公证人</li>
<li>负载平衡 - 通过多个公证处理交易负载可以为整个平台提供更高的交易吞吐量</li>
<li>低等待时间 - 等待时间可以通过选择与交易双方身体接近的公证员来最小化</li>
</ul>
<h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>请记住，如果公证人是所有交易输入状态的指定公证人，则公证人只会签署交易。但是，有些情况下我们可能需要更换状态的指定公证人。这些包括：</p>
<ul>
<li>当单个交易需要消耗具有不同指定公证人的多个状态时</li>
<li>由于隐私或效率问题，节点宁愿为给定的交易使用不同的公证人</li>
</ul>
<p>在这些交易可以创建之前，必须首先将各状态重新命名为全部具有相同的公证人。这是通过使用特殊的公证人更改交易来实现的，该交易需要：</p>
<ul>
<li>单个输入状态</li>
<li><b style="color:red">与输入状态相同的输出状态，但指定的公证人已更改（将输入的公证人更改掉作为输入即可）</b></li>
</ul>
<p>输入状态的指定公证人将签署交易，如果它不构成双重花费，此时一个状态将进入具有旧状态所有财产的存在，但具有不同的指定公证人。</p>
<h2 id="时间窗口-1"><a href="#时间窗口-1" class="headerlink" title="时间窗口"></a>时间窗口</h2><p>概要</p>
<ul>
<li>如果交易包含时间窗口，则只能在该窗口期间提交</li>
<li>公证人是时间戳管理机构，拒绝在该窗口之外提交交易</li>
<li>时间窗口可以有开始和结束时间，也可以在任何一端打开</li>
</ul>
<h3 id="在分布式系统中的时间"><a href="#在分布式系统中的时间" class="headerlink" title="在分布式系统中的时间"></a>在分布式系统中的时间</h3><p>公证人还充当时间戳的权力，验证在公证之前在特定时间窗口发生的交易。</p>
<p>创建交易的一方和公证人之间永远不会有精确的时钟同步。这不仅仅是由于物理和网络延迟的问题，而且还因为在插入命令和获得公证签名之间可能有许多其他步骤（例如将交易发送给交易中涉及的其他方，请求人签字…）。因此交易发送给公证人的时间可能与交易创建时间大不相同。</p>
<p>假设公证人的时间馈送是由美国海军天文台的原子钟定义的GPS / NaviStar时间。这个是非常准确的，全球免费提供。</p>
<h2 id="神谕（Oracle）-1"><a href="#神谕（Oracle）-1" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h2><p>概要</p>
<ul>
<li>事实可以作为命令的一部分包含在交易中</li>
<li>如果包含的事实是真实的，则oracle是一种仅签署交易的服务</li>
</ul>
<h3 id="概观-2"><a href="#概观-2" class="headerlink" title="概观"></a>概观</h3><p>在很多情况下，交易的合约效力取决于一些外部数据，例如当前的汇率。但是，如果我们要让每个参与者根据他们自己对当前汇率的看法来评估交易的有效性，那么合同的执行将是非确定性的：一些签名者会认为交易是有效的，而另一些则认为它是无效的。因此，会在分类账的真实状态上产生分歧。</p>
<p>Corda使用oracles解决了这个问题。神谕（Oracle）是网络服务，根据请求提供封装特定事实（例如，时间x时的汇率）的命令，并将神谕列为必需的签名者。</p>
<p><b style="color:red">如果一个节点希望在交易中使用某个事实，他们会请求一个命令，从oracle中断言这个事实。如果oracle认为事实是真的，他们会发回所需的命令。然后节点将这个命令包含在他们的交易中，并且oracle将签署该交易来断言事实是真实的。</b></p>
<p>如果他们希望将他们的服务货币化，神谕可以选择只签署一笔交易，并证明其收取的费用是有效的。</p>
<h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p><a href="/2018/05/30/blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E4%BA%A4%E6%98%93%E6%8B%86%E5%88%86">交易拆分</a></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>概要</p>
<ul>
<li>节点是JVM运行时间，具有运行Corda软件的唯一网络标识</li>
<li>该节点有两个与外界的接口：<ul>
<li>网络层，用于与其他节点交互</li>
<li>RPC，用于与节点的所有者进行交互</li>
</ul>
</li>
<li>通过在插件注册表中安装CorDapps来扩展节点的功能</li>
</ul>
<h3 id="节点架构"><a href="#节点架构" class="headerlink" title="节点架构"></a>节点架构</h3><p>Corda节点是一个JVM运行时环境，在网络上具有唯一身份，用于承载Corda服务和CorDapps。</p>
<p>我们可以将节点的内部架构可视化如下：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/node-architecture.png" alt=""></p>
<p>该体系结构的核心要素是：</p>
<ul>
<li>用于存储数据的持久层</li>
<li>用于与其他节点交互的网络接口</li>
<li>用于与节点所有者进行交互的RPC接口</li>
<li>一个服务中心（ServiceHub），用于允许节点的流程调用节点的其他服务</li>
<li>通过安装CorDapps扩展节点的cordapp界面和提供程序</li>
</ul>
<h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p>持久层有两部分：</p>
<ul>
<li>Vault，其中节点存储任何相关的当前和历史状态</li>
<li>存储服务（StorageService），它存储数据，附件和流程检查点（checkpoints）</li>
</ul>
<p>节点的所有者可以使用RPC接口查询节点的存储（见下文）。</p>
<h3 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h3><p>作为运行流程的一部分，与网络中其他节点的所有通信都由节点本身处理。节点的所有者不直接与其他网络节点交互。</p>
<h3 id="RPC接口"><a href="#RPC接口" class="headerlink" title="RPC接口"></a>RPC接口</h3><p>节点的所有者通过远程过程调用（RPC）与节点交互。<a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">API：RPC操作</a>记录了节点公开的关键<a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">RPC操作</a>。</p>
<h3 id="服务中心（ServiceHub）"><a href="#服务中心（ServiceHub）" class="headerlink" title="服务中心（ServiceHub）"></a>服务中心（ServiceHub）</h3><p>在内部，节点可以访问在流程执行期间使用的一组丰富的服务，以协调分类帐更新。提供的主要服务是：</p>
<ul>
<li>有关网络上其他节点及其提供的服务的信息</li>
<li>访问保管库（Vault）内容和存储（Storage）服务</li>
<li>访问和生成节点的公钥 - 私钥对</li>
<li>关于节点本身的信息</li>
<li>当前时间，由节点跟踪</li>
</ul>
<h3 id="CorDapp提供商"><a href="#CorDapp提供商" class="headerlink" title="CorDapp提供商"></a>CorDapp提供商</h3><p>CorDapp提供程序是安装新的CorDapps以扩展节点行为的地方。</p>
<p>该节点还默认安装了几个CorDapps来处理常见任务，例如：</p>
<ul>
<li>检索交易对方的交易和附件</li>
<li>升级合同</li>
<li>广播商定的分类账更新以供对手方记录</li>
</ul>
<h4 id="排水模式（Draining-mode）"><a href="#排水模式（Draining-mode）" class="headerlink" title="排水模式（Draining mode）"></a>排水模式（Draining mode）</h4><p>为了使节点能够干净关闭，重要的是没有流程正在运行中，这意味着不应该坚持检查点。该节点能够处于流程排放模式，在此期间：</p>
<ul>
<li>需要通过RPC启动新流程的命令将被拒绝。</li>
<li>预计将要执行将被忽略。（那么这些流程应该如何进行处理呢？）</li>
<li>最初的P2P会话消息将不会被处理，这意味着对等方将无法发起涉及该节点的新流程。</li>
<li>所有其他活动将照常进行，确保机内流程的数量将严格减少。</li>
</ul>
<p>由于它们的数量（可以通过RPC进行监控）达到零，所以关闭节点是安全的。该属性是持久的，这意味着重新启动节点不会将其重置为默认值，并且需要RPC命令。</p>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>概要</p>
<ul>
<li>权限的网络更适合财务用例</li>
<li>点对点通信允许共享需要知道的信息</li>
<li>UTXO模型允许每秒更多的交易处理</li>
</ul>
<h3 id="Permissioned-vs-permissionless"><a href="#Permissioned-vs-permissionless" class="headerlink" title="Permissioned vs. permissionless"></a>Permissioned vs. permissionless</h3><p>传统blockchain网络是permissionless。网络上的各方都是匿名的，可以随意加入和离开。</p>
<p>相比之下，Corda网络获得许可。网络上的每一方都有一个已知的身份，他们在与交易对手进行交流时使用，网络访问由门卫控制。这有几个好处：</p>
<ul>
<li>对于涉及受监管金融机构的大多数情况，匿名方不适用</li>
<li>了解您的交易对手的身份可以使用现有的法律体系，以分类方式解决冲突</li>
<li>如果没有使用诸如工作证明等昂贵的机制，Sybil攻击就可以避免</li>
</ul>
<h3 id="点对点与全球广播"><a href="#点对点与全球广播" class="headerlink" title="点对点与全球广播"></a>点对点与全球广播</h3><p>传统的区块链网络向每个参与者传播每一条消息。其原因有两方面：</p>
<ul>
<li>交易对手身份未知，因此必须将消息发送给每位参与者以确保其到达其预期接收者</li>
<li>让每个参与者意识到每一笔交易都可以让网络防止双重花费</li>
</ul>
<p>缺点是所有参与者都能看到其他人的数据。这在许多使用情况下是不可接受的。</p>
<p>在Corda中，每条消息都会发送给特定的对方，并且不会被任何无关的第三方看到。开发人员可以完全控制发送什么消息，向谁发送消息，以及按照什么顺序。因此，数据仅在需要知道的基础上共享。为了防止这种制度出现双重花费，我们聘请公证人作为工作证明的替代方案。</p>
<p>Corda还使用其他几种技术来最大化网络上的隐私：</p>
<ul>
<li>交易拆分：交易的结构方式允许他们在不公开交易内容的情况下进行数字签名。这是通过使用名为Merkle树的数据结构实现的。你可以在merkle-trees中阅读关于这种技术的更多信息。</li>
<li>密钥随机化：交易双方仅通过其公钥识别，并为每个交易生成新密钥对。因此，旁观者无法确定哪一方参与了某个交易。（公钥大家都可以看到，但是不会公布私钥，但是如何保证通信的安全是个问题）</li>
</ul>
<h3 id="UTXO与账户模式"><a href="#UTXO与账户模式" class="headerlink" title="UTXO与账户模式"></a>UTXO与账户模式</h3><p>Corda使用UTXO（未使用的交易输出）模型。每个交易消耗一组现有状态来产生一组新状态。</p>
<p>替代方案将是一个账户模型。在账户模型中，有状态对象存储在分类账上，事务采取请求的形式来更新这些对象的当前状态。</p>
<p>UTXO模型的主要优点是可以并行应用具有不同输入的交易，极大地增加了网络每秒潜在的交易量。在账户模型中，每秒交易数量受限于对给定对象的更新必须按顺序应用的事实。</p>
<h3 id="Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）"><a href="#Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）" class="headerlink" title="Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）"></a>Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）</h3><p>金融机构需要有能力利用传统的法律制度解决冲突。Corda旨在通过以下方式使其成为可能：</p>
<ul>
<li>拥有许可的网络，意味着参与者知道他们在每次交易中处理的是谁</li>
<li>所有的代码合约都有一份法律文件的支持，这些文件描述了可以依靠解决冲突的合约的预期行为</li>
</ul>
<h3 id="构建与重用"><a href="#构建与重用" class="headerlink" title="构建与重用"></a>构建与重用</h3><p>只要有可能，Corda就会重新使用现有技术，使整个平台更加强健。例如，Corda重复使用：</p>
<ul>
<li>用于开发CorDapps的标准JVM编程语言</li>
<li>现有的SQL数据库</li>
<li>现有的消息队列实现</li>
</ul>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://docs.corda.net/releases/release-V3.1/key-concepts.html" target="_blank" rel="noopener">https://docs.corda.net/releases/release-V3.1/key-concepts.html</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/blockchain/corda/Corda基础知识/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/30/blockchain/corda/Corda基础知识/" class="post-title-link" itemprop="url">Corda基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-30 16:28:29" itemprop="dateCreated datePublished" datetime="2018-05-30T16:28:29+08:00">2018-05-30</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-16 21:58:40" itemprop="dateModified" datetime="2018-09-16T21:58:40+08:00">2018-09-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>corda是分布式账本技术的一种，另一种大家已经熟知的就是HyperLedger的Fabric。当然这种插件化的开发也有公共链上的石墨烯技术，这种技术也是插件化的挖矿节点的实现，但是石墨烯技术是C++语言的实现，这里我就不做更多的说明了，关于石墨烯更多的介绍可以点击<a href="https://github.com/cryptonomex/graphenes" target="_blank" rel="noopener">这里</a>。<a href="https://steemit.com/blockchain/@robinwen/bts-steem-eos" target="_blank" rel="noopener">这篇文章</a>也做了详细的介绍。</p>
<p>Corda与Fabric的区别，官网的说法是Corda专注于金融这块，而Fabric是基于组织联盟的，但是不管怎样分布式账本技术都是借鉴了区块链的设计思想的；Fabric是插件化的，而Corda是模块化的，我觉得这点在软件设计上有很大的区别。Corda是基于Kotlin开发的，而Fabric主力语言是Go，但是也可以使用其他语言，并不限制。</p>
<p>如果你想了解更多的Corda知识，可以参阅官网的<a href="https://docs.corda.net/releases/release-M7.0/_static/corda-introductory-whitepaper.pdf" target="_blank" rel="noopener">技术白皮书</a>。这个白皮书介绍了，这个系统最终的方案，现在还有很多未实现，正在实现中，当然在实现中可能会有与白皮书不一样的地方。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="包含的实现"><a href="#包含的实现" class="headerlink" title="包含的实现"></a>包含的实现</h3><p>Corda原型机目前包括：</p>
<ul>
<li>具有消息持久性和递送重试的对等网络。</li>
<li>用于定义合同和状态的关键数据结构。</li>
<li>智能合约，您可以在合约目录中找到。</li>
<li>与它们一起工作的算法，如序列化，散列，签名和签名验证。</li>
<li>API文档和教程（您正在阅读的内容）。</li>
<li>业务流程编排框架。</li>
<li>公证基础设施用于精确时间戳，并且在没有区块链的情况下消除双重花费。</li>
<li>一个简单的REST API和一个Web应用程序演示，用它来呈现IRS交易的前端。</li>
</ul>
<p>现在不包括，但是后面会进行实现的部分：</p>
<ul>
<li>沙盒，分销或发布智能合同代码</li>
<li>用于管理的用户界面</li>
</ul>
<p>现在的Corda版本仍然是创意的快速探索，所以为了提高开发的速度，会采取一些捷径，注意以下的一些事项：</p>
<ul>
<li>它使用一个对象映射序列化框架，而不是一个明确的，供应商中立的协议。</li>
<li>目前没有权限框架。（shiro或者Spring auth）</li>
<li>一些隐私技术尚未实施</li>
<li>它使用嵌入式SQL数据库，但尚未支持主流SQL供应商（Oracle，Postgres，MySQL，SQL Server等）的连接。</li>
</ul>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>在corda项目下定义了一些示例程序，这些程序在samples目录下，运行的命令如官网的命令，这里就不做更多说明了。</p>
<p><a href="https://docs.corda.net/releases/release-M7.0/running-the-demos.html" target="_blank" rel="noopener">运行演示</a></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>corda网络是由运行Corda和CorDapps的节点组成</li>
<li>网络是授权网络，通过doorman控制访问</li>
<li>节点之间是点对点的交互，而不是一个全局的广播网络<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4>Corda网络是一个认证的节点点对点网络，里面每一个节点都是有Corda服务并且执行CorDapps应用的JVM运行环境。</li>
</ul>
<p>节点之间的交流都是直接的，通过AMQP/1.0发送TLS-加密的信息。这意味着数据只在需要知道的节点间共享，并没有全局广播。</p>
<p><b style="color:red">每个网络都有一个网络映射（map）服务，这个服务发布可以访问的节点IP地址，还有这些节点的身份证书和节点提供的服务。</b></p>
<h4 id="门卫（doorman）"><a href="#门卫（doorman）" class="headerlink" title="门卫（doorman）"></a>门卫（doorman）</h4><p><b style="color:red">Corda网络是半私有化的。每个网络都有一个门卫服务，门卫强制实施关于节点必须提供信息和在被准入网络前必须完成的KYC进程的规则。</b></p>
<p><b style="color:red">为了加入网络，节点必须联系门卫并提供需必要的信息。如果门卫同意了，节点会从网络权限服务收到一个根授权签名的TLS证书。当与其他参与交互时，这个证书用于证明节点的身份。</b></p>
<p>我们可以想象如下一个网络：<br><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda%E7%BD%91%E7%BB%9C.png?raw=true" alt=""></p>
<h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><p>节点提供几种类型的服务：</p>
<ul>
<li>一个或更多可插拔公证（Notary）服务。公证者保证账本更新的唯一性、可能性的有效性。每一个公证服务可能是在单个节点上运行，或者跨越节点集群。</li>
<li>零个或更多的神谕（oracle）服务。神谕是一个知名服务，如果他们阐明一个事实并且这个事实是真的，那么就签署交易。</li>
</ul>
<h3 id="账本Ledger"><a href="#账本Ledger" class="headerlink" title="账本Ledger"></a>账本Ledger</h3><ul>
<li>账本是每个节点透明的对象</li>
<li>两个节点总是被保证可以看到账本上他们共享事实的完全相同版本。</li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在Corda中，没有一个单独的中心数据存储。替代的是，每个节点维护一个独立的已知事实的数据库。所以，每个节点只会看到账本上事实的子集，并且没有节点可以感知到整个账本。</p>
<p>例如，想象一个拥有5个节点的网络；在这个网络上，每个彩色的圆代表一个共享的事实：<br><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-venn.png?raw=true" alt=""></p>
<p>我们可以看到尽管Carl，Demi和Ed都感知了事实3，，但是Alice和Bob却不知道事实3的存在。</p>
<p>同样重要的是，Corda保证，无论何时这些事实中的一个在网络多个节点间共享，它在每个知道它的节点的数据库中以锁的方式发展。<br><img src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-table.png?raw=true" alt=""></p>
<p>例如，Alice和Bob都会看到共享事实1和7的相同版本。</p>
<h3 id="身份Identity"><a href="#身份Identity" class="headerlink" title="身份Identity"></a>身份Identity</h3><ul>
<li>Corda中的身份代表合法的身份或者服务识别。</li>
<li><b style="color:red">身份是通过Doorman签署的X.509证书签名或者一个已知证书。</b></li>
<li><b style="color:red">众所周知的身份发布在网络地图(map)中</b></li>
<li>机密身份仅在需要知道的基础上共享</li>
</ul>
<p>Corda中的身份代表：</p>
<ul>
<li>组织的合法身份</li>
<li>一个网络服务的服务身份</li>
</ul>
<p>合法身份是为交易的参与者使用，比如一个Cash状态的拥有者。服务身份是给这些提供交易相关服务使用，比如Notary，或者Oracle。服务身份与和合法身份是不同的，以至于一个节点上存在不同组织的服务。这些分散的服务身份是基于<code>CompositeKeys</code>;<code>CompositeKeys</code>为服务的签名描述有效的签名者集合。查看<a href="https://docs.corda.net/releases/release-V3.2/api-core-types.html" target="_blank" rel="noopener">API: Core types</a>，了解更多关于<code>CompositeKeys</code>的知识。</p>
<p><b style="color:red">身份是众所周知的还是保密的，取决于他们的X.509证书（和对应的证书路径是否可信的根证书）已发布：</b>.</p>
<ul>
<li>众所周知的身份是法律实体或服务的一般可识别的公钥，这使得它们不适用于需要参与者保密的交易。此证书已发布在网络地图服务中供任何人访问。</li>
<li>机密身份只发布给参与交易身份的人员。公钥可能暴露给第三方（例如公证服务），但名称和X.509证书的分发是有限的。</li>
</ul>
<p>虽然Corda交易隐私模式有几个要素，包括确保交易只与需要查看它们的用户共享以及有计划地使用英特尔SGX，但重要的是要提供深入的防御隐私攻击。机密身份用于确保即使第三方访问未加密的交易，他们也无法在没有附加信息的情况下识别参与者。</p>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>节点必须能够验证使用X.509证书实现的公钥所有者的身份。<b style="color:red">首次运行时，节点生成密钥对并向网络门卫服务提交证书签名请求</b>（请参阅 <a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>）。Doorman服务应用适当的身份检查，然后向用作节点认证中心（CA）的节点发放证书。从该初始CA证书中，节点自动创建并签署两个其他证书，一个TLS证书(sslKeyStore)和一个用于该节点众所周知的身份的签名证书(nodeKeyStore)。最后，节点建立包含其地址和众所周知的身份的节点信息记录，并将其注册到网络地图服务。</p>
<p>组织可以从签署证书创建公开和机密身份。众所周知的身份的用例包括代表用于冗余目的的单个身份的节点集群，或者为组织单位创建身份。</p>
<p>组织需要决定他们希望在网络地图服务中发布哪些身份，使其广为人知，并且出于隐私原因（通常是为了避免暴露商业敏感的交易细节），他们希望将其保留为机密身份。在某些情况下，出于操作原因，除了主网络地图服务之外，节点还可能使用专用网络地图服务。使用此类网络地图注册的身份必须被认为是众所周知的，并且将机密身份存储在中央目录中，而不在记录级别应用控制，以确保只有需要访问身份的人才能检索其证书。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>这里需要介绍状态（State）、交易（Transaction）和合约（Contract），以及它们之间的交互关系。</p>
<p>首先，交易消费的是状态（State），交易的作用就是将一个状态变换为一个新的状态。分类账被定义为一组不可变状态，由数字签名的交易创建和销毁。每个交易指向一组将要消耗/销毁的状态，这些状态称为<strong>输入</strong>，并且包含一组将会创建的新状态，这些状态称为<strong>输出</strong>。</p>
<p>其次，合约定义了一个验证函数，这是一个纯函数，以交易为输入。要被视为有效，交易必须被输入和输出状态所指向的每个合约的验证功能所接受。</p>
<p>除了输入和输出之外，交易还可能包括命令，小数据包，平台不会自行解释，但可以参数化执行合约。<b style="color:blue">它们可以被认为是验证函数的参数。每个命令都有一个与之关联的公钥列表。该平台确保交易在合约开始执行之前由命令中列出的每个密钥签署。该平台确保交易在合同开始执行之前由命令中列出的每个密钥签署。因此，验证功能可以相信所有列出的密钥都签名了交易，但是负责验证交易从验证功能角度看是否有效所需的任何密钥都包含在列表中.</b></p>
<p><b style="color:red">命令总是嵌入在交易中。有时候，有很多数据可以在许多不同的交易中重复使用。这种使用的例子就是我们的附件。每个交易可以通过哈希引用0个或多个附件。附件始终都是ZIP/JAR文件，可能包含任何内容。这里可以看出命令与附件相关。</b></p>
<p><b style="color:red">请注意交易中可以有输入、输出、命令（Command）和附件（Attachment）。但是这些东西可能有也可能没有。交易中的数据需要合约来进行解释，并确保它们正确地结合在一起。</b></p>
<p><b style="color:red">交易有时可能需要提供带有外界数据的合约。可能包括以下的列子：股票价格、关于事件的事实或者法律实体的状态（例如破产）等等。这些事实的提供者称为神谕（oracles），他们通过签署包含他们已知的命令的交易或通过创建签名附件来为账本提供事实。这些命令包含事实和签名来彰显对此事实的一致。</b></p>
<p>时间也被建模为一个事实，并且有一种称为公证的特殊服务的签名。公证人是一种很有可能的分散式服务，<b style="color:red">它履行在其他区块链系统中矿工的作用</b>：公证人确保只有一项交易可以消耗任何给定的输出。此外，他们可以验证放置在交易中的时间戳命令，该命令指定交易被认为对公证有效的时间窗口。时间窗口可以是开放式的（即开始但不结束或反之亦然）。通过这种方式，交易可以与公证人的时钟相关联。</p>
<p>一个Corda网络可能有多个竞争公证人。每个状态（State）都指向控制它的公证人。虽然单个交易只有在全部由同一公证人控制的情况下才会消耗状态，但是提供了将一个状态（或一组状态）从一个公证转移到另一个公证的特殊类型的交易。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Amount"><a href="#Amount" class="headerlink" title="Amount"></a>Amount</h4><p>Amount类是用来表示一些可替代的资产的量。它是一个通用类，它包装用于定义基础产品的类型，称为Token。它可以是JDK的Currency类型，或者Issued，或者是更复杂的类型（例如义务合同签发定义（其中包含用于解决义务的标记定义）。）</p>
<p>使用示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// A quantity of some specific currency like pounds, euros, dollars etc.</span><br><span class="line">Amount&lt;Currency&gt;</span><br><span class="line">// A quantity of currency that is issued by a specific issuer, for instance central bank vs other bank dollars</span><br><span class="line">Amount&lt;Issued&lt;Currency&gt;&gt;</span><br><span class="line">// A quantity of obligations to deliver currency of any issuer.</span><br><span class="line">Amount&lt;Obligation.State&lt;Currency&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>Corda合约由三部分组成; 代表特定交易或资产细节的可执行代码、法律散文（legal prose）和状态对象。<b style="color:red">在关系数据库术语中，状态就像数据库中的一行。</b>分类帐中的状态参考（无论是否已消费）用<code>StateRef</code>对象表示。如果状态引用（state ref）已经能从存储中找到，你将有一个<code>StateAndRef</code>，这是一个简单的<code>StateRef</code>加上数据。</p>
<p><code>ContractState</code>类是所有状态必须实现的接口。<code>TransactionState</code>是一个简单的<code>ContractState</code>容器（一个合约程序使用的自定义数据）和附加的平台级别的状态信息，比如notary指针。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A _participant_ is any party that is able to consume this state in a valid transaction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The list of participants is required for certain types of transactions. For example, when changing the notary</span></span><br><span class="line"><span class="comment">     * for this state, every participant has to be involved and approve the transaction</span></span><br><span class="line"><span class="comment">     * so that they receive the updated state, and don't end up in a situation where they can no longer use a state</span></span><br><span class="line"><span class="comment">     * they possess, since someone consumed that state during the notary change process.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The participants list should normally be derived from the contents of the state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些接口继承了<code>ContractState</code>，代表常见状态的标准化功能：</p>
<ul>
<li><p><code>OwnableState</code><br>拥有所有者的状态（表示为一个<code>PublicKey</code>，就是状态里面包含拥有者的<code>PublicKey</code>）。公开所有者和用于替换所有者的功能，例如当资产被出售时。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OwnableState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/** There must be a MoveCommand signed by this key to claim the amount. */</span></span><br><span class="line">    <span class="keyword">val</span> owner: AbstractParty</span><br><span class="line">    <span class="comment">/** Copies the underlying data structure, replacing the owner field with this new value and leaving the rest alone. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwner</span><span class="params">(newOwner: <span class="type">AbstractParty</span>)</span></span>: CommandAndState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearState</code><br>一种链接回到其先前状态的状态，随着时间的推移创建一个状态线程。对特定交易或不可拆分资产（如罕见艺术品）进行建模时，线性状态非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LinearState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unique id shared by all LinearState states throughout history within the vaults of all parties.</span></span><br><span class="line"><span class="comment">     * Verify methods should check that one input and one output share the id in a transaction,</span></span><br><span class="line"><span class="comment">     * except at issuance/termination.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> linearId: UniqueIdentifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DealState</code><br>一个<code>LinearState</code>(通过继承实现)表示两方或多方之间的协议。旨在简化实施操纵许多协议类型的通用流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface DealState : LinearState &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Generate a partial transaction representing an agreement (command) to this deal, allowing a general</span><br><span class="line">     * deal/agreement flow to generate the necessary transaction for potential implementations.</span><br><span class="line">     *</span><br><span class="line">     * TODO: Currently this is the &quot;inception&quot; transaction but in future an offer of some description might be an input state ref</span><br><span class="line">     *</span><br><span class="line">     * TODO: This should more likely be a method on the Contract (on a common interface) and the changes to reference a</span><br><span class="line">     * Contract instance from a ContractState are imminent, at which point we can move this out of here.</span><br><span class="line">     */</span><br><span class="line">    fun generateAgreement(notary: Party): TransactionBuilder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FixableDealState</code><br>一个交易状态，进一步的功能暴露以支持固定利率。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FixableDealState</span> : <span class="type">DealState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When is the next fixing and what is the fixing for?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextFixingOf</span><span class="params">()</span></span>: FixOf?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * What oracle service to use for the fixing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> oracle: Party</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a fixing command for this deal and fix.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> This would also likely move to methods on the Contract once the changes to reference</span></span><br><span class="line"><span class="comment">     * the Contract from the ContractState are in.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generateFix</span><span class="params">(ptx: <span class="type">TransactionBuilder</span>, oldState: <span class="type">StateAndRef</span>&lt;*&gt;, fix: <span class="type">Fix</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="NamedByHash和UniqueIdentifier"><a href="#NamedByHash和UniqueIdentifier" class="headerlink" title="NamedByHash和UniqueIdentifier"></a>NamedByHash和UniqueIdentifier</h4><p>散列作为标识的事物（如交易和附件）应该实现<code>NamedByHash</code>接口，这个接口标准化提取ID的操作。请注意，散列不是全局唯一标识符：它总是对基础数据内容的派生摘要。<b style="color:red">有时候这不是你想要的：两个具有完全相同参数并且同时生成但是在逻辑上不同的交易不能通过散列识别，因为它们的内容将是相同的。相反，你会使用<code>UniqueIdentifier</code>。</b> 这是一个（Java）UUID表示一个全球唯一的128位随机数，以及一个可与之配对的任意字符串。例如，为了方便起见，该字符串可以代表现有的“weak”（不保证唯一）标识符。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamedByHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: SecureHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueIdentifier</span></span>(<span class="keyword">val</span> externalId: String? = <span class="literal">null</span>, <span class="keyword">val</span> id: UUID = UUID.randomUUID()) : Comparable&lt;UniqueIdentifier&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用UUID标识，但是可以使用配对的字符串进行拼接</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (externalId != <span class="literal">null</span>) <span class="string">"<span class="subst">$&#123;externalId&#125;</span>_<span class="variable">$id</span>"</span> <span class="keyword">else</span> id.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/** Helper function for unit tests where the UUID needs to be manually initialised for consistency. */</span></span><br><span class="line">        <span class="meta">@VisibleForTesting</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromString</span><span class="params">(name: <span class="type">String</span>)</span></span>: UniqueIdentifier = UniqueIdentifier(<span class="literal">null</span>, UUID.fromString(name))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UniqueIdentifier</span>)</span></span>: <span class="built_in">Int</span> = id.compareTo(other.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (other <span class="keyword">is</span> UniqueIdentifier)</span><br><span class="line">            id == other.id</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = id.hashCode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="FungibleAssets-and-Cash"><a href="#FungibleAssets-and-Cash" class="headerlink" title="FungibleAssets and Cash"></a>FungibleAssets and Cash</h4><p><code>FungibleAsset</code>(可替代资产)是可模拟可替代资产的合约的一个共同的超类，它也为其子类的状态对象提供了一个标准接口来实现。将典型的用例就是<code>Cash</code>，然而<code>FungibleAsset</code>意图是容易扩展到覆盖其它资产，例如商品可以根据需要通过使用一个子类，其状态的对象包括进一步的细节（商品，产地，等级的位置等）进行建模。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FungibleAsset</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">OwnableState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount represents a positive quantity of some issued product which can be cash, tokens, assets, or generally</span></span><br><span class="line"><span class="comment">     * anything else that's quantifiable with integer quantities. See [Issued] and [Amount] for more details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> amount: Amount&lt;Issued&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * There must be an ExitCommand signed by these keys to destroy the amount. While all states require their</span></span><br><span class="line"><span class="comment">     * owner to sign, some (i.e. cash) also require the issuer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> exitKeys: Collection&lt;PublicKey&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies the underlying data structure, replacing the amount and owner fields with the new values and leaving the</span></span><br><span class="line"><span class="comment">     * rest (exitKeys) alone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwnerAndAmount</span><span class="params">(newAmount: <span class="type">Amount</span>&lt;<span class="type">Issued</span>&lt;<span class="type">T</span>&gt;&gt;, newOwner: <span class="type">AbstractParty</span>)</span></span>: FungibleAsset&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里<code>Cash</code>其实是一个<code>Contract</code>，里面包含<code>FungibleAssets</code>的状态子类，由于代码比较长，这里就不展示了。</p>
<h4 id="Transaction-生命周期类型"><a href="#Transaction-生命周期类型" class="headerlink" title="Transaction 生命周期类型"></a>Transaction 生命周期类型</h4><p><code>WireTransaction</code>类包含一个没有签名交易的核心，并带有附件的引用以代表附件本身。一旦对交易签名就封装成<code>SignedTransaction</code>类。为了处理交易（即验证它），它首先被转换为<code>LedgerTransaction</code>，这涉及到验证签名并将它们关联到相关命令，并对附件的引用进行附件解析。具有有效签名的命令被封装在<code>AuthenticatedObject</code>类中(新版中，这个类被重命名为<code>CommandWithParties</code>)。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WireTransaction</span></span>(componentGroups: List&lt;ComponentGroup&gt;, <span class="keyword">val</span> privacySalt: PrivacySalt = PrivacySalt()) : TraversableTransaction(componentGroups) &#123;</span><br><span class="line">    <span class="meta">@Deprecated(<span class="meta-string">"Required only in some unit-tests and for backwards compatibility purposes."</span>, ReplaceWith(<span class="meta-string">"WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)"</span>)</span>, DeprecationLevel.WARNING)</span><br><span class="line">    <span class="keyword">constructor</span>(inputs: List&lt;StateRef&gt;, <span class="comment">// 输入</span></span><br><span class="line">                attachments: List&lt;SecureHash&gt;, <span class="comment">// 附件hash集合</span></span><br><span class="line">                outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, <span class="comment">// 输出，这里我们可以看到TransactionState的意义了</span></span><br><span class="line">                commands: List&lt;Command&lt;*&gt;&gt;, <span class="comment">// 命令集合</span></span><br><span class="line">                notary: Party?,   <span class="comment">// 见证者</span></span><br><span class="line">                timeWindow: TimeWindow?, <span class="comment">// 时间窗口</span></span><br><span class="line">                privacySalt: PrivacySalt = PrivacySalt() <span class="comment">// 私钥密码</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看一下<code>SignedTransaction</code>的定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SignedTransaction</span></span>(<span class="keyword">val</span> txBits: SerializedBytes&lt;CoreTransaction&gt;,</span><br><span class="line">                             <span class="keyword">override</span> <span class="keyword">val</span> sigs: List&lt;TransactionSignature&gt;</span><br><span class="line">) : TransactionWithSignatures &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一下LedgerTransaction的定义。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LedgerTransaction</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="comment">/** The resolved input states which will be consumed/invalidated by the execution of this transaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;,           <span class="comment">// 输入</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;,     <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">/** Arbitrary data passed to the program of each input state. */</span></span><br><span class="line">        <span class="keyword">val</span> commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;,             <span class="comment">// 命令（具有有效签名的命令）</span></span><br><span class="line">        <span class="comment">/** A list of [Attachment] objects identified by the transaction that are needed for this transaction to verify. */</span></span><br><span class="line">        <span class="keyword">val</span> attachments: List&lt;Attachment&gt;,                               <span class="comment">// 解析好的附件</span></span><br><span class="line">        <span class="comment">/** The hash of the original serialised WireTransaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> id: SecureHash,                                     <span class="comment">// id，交易的hash</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> notary: Party?,                                     <span class="comment">// 见证者</span></span><br><span class="line">        <span class="keyword">val</span> timeWindow: TimeWindow?,                                     <span class="comment">// 时间窗口</span></span><br><span class="line">        <span class="keyword">val</span> privacySalt: PrivacySalt,                                    <span class="comment">// 密码盐，这个是不是太暴露了</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> networkParameters: NetworkParameters? = <span class="literal">null</span>         <span class="comment">// 网络配置参数</span></span><br><span class="line">) : FullTransaction() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AuthenticatedObject</code>类被重命名为<code>CommandWithParties</code>，这个类比较简单，具体的内容如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandWithParties</span>&lt;<span class="type">out T : CommandData</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> signers: List&lt;PublicKey&gt;,   <span class="comment">// 签署人，其实就是公钥</span></span><br><span class="line">        <span class="comment">/** If any public keys were recognised, the looked up institutions are available here */</span></span><br><span class="line">        <span class="keyword">val</span> signingParties: List&lt;Party&gt;, <span class="comment">// 找到签署人所属的Party</span></span><br><span class="line">        <span class="keyword">val</span> value: T</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#6ab0de">注意：<code>LedgerTransaction</code>没有必要运行它的合约，因此合约可以是无效的（但不是签名无效的）。您可以使用如下所示的verify方法运行合约。</b></p>
<p>可以使用<code>TransactionBuilder</code>构建新的交易，这是一个可修改的交易，一旦内部修改完成，就可以对其进行签名。合约类通常会暴露帮助方法，这些方法对<code>TransactionBuilder</code>会有所帮助。</p>
<p>以下是一个构建交易的例子，该交易创建了bananas的发行（请注意，bananas不是库中真正的合约类型）：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notaryToUse: Party = ... <span class="comment">// 见证者Party</span></span><br><span class="line"><span class="comment">// 创建交易，加入了State</span></span><br><span class="line"><span class="keyword">val</span> txb = TransactionBuilder(notary = notaryToUse).withItems(BananaState(Amount(<span class="number">20</span>, Bananas), fromCountry = <span class="string">"Elbonia"</span>))</span><br><span class="line"><span class="comment">// 使用私钥进行交易签名</span></span><br><span class="line">txb.signWith(myKey)</span><br><span class="line"><span class="comment">// 设置时间窗口</span></span><br><span class="line">txb.setTime(Instant.now(), notaryToUse, <span class="number">30.</span>seconds)</span><br><span class="line"><span class="comment">// We must disable the check for sufficient signatures, because this transaction is not yet notarised.</span></span><br><span class="line"><span class="comment">// 转化为SignedTransaction</span></span><br><span class="line"><span class="keyword">val</span> stx = txb.toSignedTransaction(checkSufficientSignatures = <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// Alternatively, let's just check it verifies pretending it was fully signed. To do this, we get</span></span><br><span class="line"><span class="comment">// a WireTransaction, which is what the SignedTransaction wraps. Thus by verifying that directly we</span></span><br><span class="line"><span class="comment">// skip signature checking.</span></span><br><span class="line">txb.toWireTransaction().toLedgerTransaction(services).verify()</span><br></pre></td></tr></table></figure></p>
<h4 id="Party和PublicKey"><a href="#Party和PublicKey" class="headerlink" title="Party和PublicKey"></a>Party和PublicKey</h4><p>使用网络的实体称为参与方（Party）。各方可以使用密钥签署结构，并且一方可以在其控制下拥有许多密钥。</p>
<p>Party有时候可能被伪名识别，例如，作为监管链的一部分发送给你的节点的交易中，重要的是你可以说服你自己了解交易的有效性，但是同样重要的是，你不知道在那次交易中涉及的是谁。在这些情况下，公钥可能不存在关于谁拥有它的任何标识信息。</p>
<p>参与签署交易的参与方(Party)的身份可以简单地用<code>PublicKey</code>表示，或者通过使用Party类的更多信息（如姓名）来表示。<code>CommandWithParties</code>表示由一组参与方签署的对象（如命令）。</p>
<p><b style="color:#6ab0de">注意: 这些类型是临时的，将来随着身份框架变得更加充实而将发生重大变化。</b></p>
<h4 id="多签名支持"><a href="#多签名支持" class="headerlink" title="多签名支持"></a>多签名支持</h4><p>Corda支持需要多个密钥或参与方授权进行状态对象转换的情况，例如：“首席执行官或其中三分之一的助理都需要提供签名”。</p>
<h5 id="CompositeKey-复合键"><a href="#CompositeKey-复合键" class="headerlink" title="CompositeKey(复合键)"></a>CompositeKey(复合键)</h5><p>这是通过使用树结构的公钥组合来实现的<code>CompositeKey</code>。<code>CompositeKey</code>是一棵树，<b style="color:red">它将密码公钥基元存储在其树叶中，并在中间节点中存储组合逻辑。每个中间节点指定它需要多少个孩子签名的阈值。</b></p>
<p>“Alice和Bob或Charlie”组合键的例证：</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/composite-key.png" alt=""></p>
<p>为了提供更大的灵活性，每个子节点都可以有一个相关的自定义权重（默认值为1）。该阈值 然后指定所需的所有子节点的最小总权重。我们之前的例子也可以表示为：</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/composite-key-2.png" alt=""></p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>签名验证分两个阶段进行：</p>
<ol>
<li>给定一个签名列表，每个签名都会根据预期的内容进行验证。</li>
<li>将与签名相对应的公钥与所讨论的组合密钥树的树叶进行匹配，并且针对每个中间节点计算所有孩子的总组合权重。如果所有阈值都满足，则认为组合密钥要求得到满足。</li>
</ol>
<h4 id="日期支持"><a href="#日期支持" class="headerlink" title="日期支持"></a>日期支持</h4><p>有许多支持接口和类供合约处理日期（特别是在截止日期范围内）使用。由于合约谈判通常涉及诸如“overnight”，“T+3”等期限的最后期限，因此希望允许将这些条款转换为相应的截止日期。<code>Tenor</code>在截止日期之前（例如3天等）对间隔进行建模，同时<code>DateRollConvention</code>描述如何修改最后期限以考虑银行假期或修改正常工作日的其他事件。</p>
<p>根据工作日计算期限的延期需要有关所涉银行假期的信息（以及合同各方在不同的国家/地区，例如，这可能涉及多套不同的银行假期）。<code>BusinessCalendar</code>类模拟这些商业假期的日历; 目前它从磁盘上的文件加载这些文件，但将来这可能涉及参考数据库，以确保所用日期的一致性。</p>
<h4 id="加密和数学支持"><a href="#加密和数学支持" class="headerlink" title="加密和数学支持"></a>加密和数学支持</h4><p><code>SecureHash</code>类代表未知算法的安全散列。我们目前只定义一个子类，<code>SecureHash.SHA256</code>。有实用的方法来创建它们，解析它们等等。</p>
<p>我们还提供了一些数学实用工具，特别是一组插值器和用于样条线的类。这些可以在<a href="https://docs.corda.net/releases/release-M7.0/api/net.corda.core.math/index.html" target="_blank" rel="noopener">数学包</a>中找到。</p>
<h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p>我们平台的基本数据结构之一就是交易。它可以通过签名和验证，也可以由第三方进行验证。交易的构建假定它们构成一个具有输入和输出状态，命令和附件的完整实体。但是，所有敏感数据都不应该透露给参与验证级别交易创建的其他节点（这种情况的一个很好的例子是只验证嵌入式命令的Oracle）。如何以一种让对方信服他们获得签名数据的方式来实现这一点，确实构成了交易的一部分？</p>
<p>我们决定使用众所周知的密码方案来提供包含和数据完整性的证明。Merkle树广泛用于点对点网络，区块链系统和git。</p>
<h4 id="Corda的Merkle树"><a href="#Corda的Merkle树" class="headerlink" title="Corda的Merkle树"></a>Corda的Merkle树</h4><p>交易分为叶子，每个叶子都包含输入，输出，命令或附件。计算中不使用时间戳或签名者等其他字段。接下来，Merkle树以正常方式构建，方法是将当前节点下方的节点散列连接在一起。它在下面的示例图像中可见，其中<code>H</code>表示sha256函数，“+” – 级联。</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/merkleTree.png" alt=""></p>
<p>该交易有一个输入状态，一个输出和三个命令。如果树不是完整的二叉树，则在散列计算（虚线）中重复最右边的节点。</p>
<p><b style="color:blue">最后，根的散列是交易的标识符，它也用于数据完整性的签名和验证。每个叶级别的更改都会改变交易的标识符。</b></p>
<h4 id="隐藏数据"><a href="#隐藏数据" class="headerlink" title="隐藏数据"></a>隐藏数据</h4><p><b style="color:red">隐藏数据并提供它构成交易一部分的证据通过构建部分Merkle树（或Merkle分支）来完成。</b>Merkle分支是一组散列，根据叶子的数据来计算根的散列。然后将该散列与整个交易的散列进行比较，如果它们匹配，则意味着我们获得的数据属于该特定交易。</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/partialMerkle.png" alt=""></p>
<p>在上面的例子中，红色节点是持有Oracle服务签名数据的节点。蓝色节点的哈希形成部分梅克尔树，不包括虚线的哈希。有了应该在红色节点位置和分支中的命令，我们可以计算这棵树的根，并将它与原始交易标识符进行比较 - 我们证明此命令属于此交易。</p>
<h3 id="共识模型"><a href="#共识模型" class="headerlink" title="共识模型"></a>共识模型</h3><p>Corda的基本共识单位是状态。共识的概念可以分为两部分：</p>
<ol>
<li>对状态有效性达成共识 - 各方可以确定定义输出状态的交易被各状态指定的合约接受并具有所有必需的签名。这是通过各方独立运行相同的合约代码和验证逻辑来​​实现的。</li>
<li>关于状态唯一性的共识 - 各方可以确定交易中创建的输出状态是该交易消耗的输入状态的唯一继承者（换句话说 - 一个状态未被用作多个交易的输入）</li>
</ol>
<h4 id="公证人"><a href="#公证人" class="headerlink" title="公证人"></a>公证人</h4><p>我们介绍了公证人（notary）的概念，该公证人是负责证明对于给定的交易没有签署另一个消耗其任何输入状态的交易的机构。数据模型被扩展，以便每个状态都有一个指定的公证人：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class TransactionState&lt;out T : ContractState&gt;(</span><br><span class="line">        /** The custom contract state */</span><br><span class="line">        val data: T,</span><br><span class="line">        /** Identity of the notary that ensures the state is not used as an input to a transaction more than once */</span><br><span class="line">        val notary: Party) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有交易都必须由其输入状态公证人签名，以使输出状态有效（除了发行交易，不包含输入状态）。</p>
<p>当公证人被要求签署交易时，它要么签署交易，证明输出是输入的唯一后继者，要么提供已经被之前签署的另一个交易消耗的任何输入状态的冲突信息。这样做，公证人提供了系统中的终点。在获得公证人签名之前，各方不能确定同等有效但冲突的交易不会被视为确认。获得签名后，双方知道该交易的输入已被该交易独有消耗。因此，这是我们可以说终结发生的地步。</p>
<h4 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h4><p>网络中可以存在一个以上的公证人。这提供了以下好处：</p>
<ol>
<li>自定义行为。我们可以同时拥有验证和隐私保护公证人 - 各方可以根据他们的具体要求做出选择</li>
<li>负载平衡。将事务处理负载分摊到多个公证处将会在整个平台中实现更高的事务吞吐量</li>
<li>低延迟。通过选择公证员与交易方更接近，延迟时间可以缩短</li>
</ol>
<p><b style="color:blue">如果一个交易的所有输入状态指向一个交易，交易只能由公证人签名。在交易涉及由多个公证人控制的状态的情况下，各状态首先必须被重新委托给同一公证人。这是通过使用一种特殊类型的交易来实现的，该交易不会修改任何内容，而是修改状态的公证指针。确保所有投入状态都指向同一公证人是每个相关方的责任（这是交易输出状态有效的另一个条件）</b></p>
<h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>要更改输入状态的公证，请使用NotaryChangeFlow。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Suspendable</span><br><span class="line">fun changeNotary(originalState: StateAndRef&lt;ContractState&gt;,</span><br><span class="line">                 newNotary: Party): StateAndRef&lt;ContractState&gt; &#123;</span><br><span class="line">    val flow = NotaryChangeFlow.Instigator(originalState, newNotary)</span><br><span class="line">    return subFlow(flow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流程如下：</p>
<ol>
<li>将旧状态作为输入，将新状态作为输出进行构建</li>
<li>从所有参与者获取签名（参与者是能够在有效交易中消费此状态的任何一方，如由状态本身定义的那样）</li>
<li>获得旧的公证人签名</li>
<li>记录并向参与者分发最终交易，以便每个人都拥有新的状态</li>
</ol>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>公证人的设计决定之一是在提交输入状态之前是否验证交易。</p>
<p>如果一个交易没有被检查有效性，它会打开平台进行“拒绝状态”攻击，任何人都可以建立一个无效的交易，消耗其他人的状态并将其提交给公证员以使状态“被阻止”。但是，对交易的验证需要公证人能够看到有问题交易的全部内容及其依赖关系。这是一个明显的隐私泄露。</p>
<p>我们的平台非常灵活，目前我们支持验证和非验证公证实施 - 一方可以根据自己的隐私要求选择使用哪一个。</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>在这个模型中，公证人还充当时间戳机构，验证交易时间戳命令。</p>
<h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><h3 id="corda网站"><a href="#corda网站" class="headerlink" title="corda网站"></a>corda网站</h3><p>这里是corda的<a href="https://www.corda.net/zh-hant/" target="_blank" rel="noopener">官方网站</a>。<br><a href="https://github.com/corda" target="_blank" rel="noopener">这个网站</a>是corda的github主页，你可在里面找到我们的corda项目，入门的cordapp example也可以在这里找到，还是比较实用的。</p>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>最后这里列一下Kotlin的学习的一些资料。</p>
<p>最棒的就是<a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Strings/Task.kt" target="_blank" rel="noopener">这个网站</a>的在线练习，做的的确棒极了。</p>
<p>当然对于Kotlin，我们不得不研究一下它的<a href="http://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">官方指南</a>. 你可以在这里查询文档和Api的说明文档，另外里面还做了一个全局的搜索，不管是文档，博客还是Api文档，你都可以一键搜索，很是方便。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>这个是志愿者翻译的<a href="https://dongchuan.gitbooks.io/gradle-user-guide-/content/overview/features.html" target="_blank" rel="noopener">Gradle User Guide中文版</a></p>
<p>当然如果你想自定义Gradle插件的话，就不得不研究<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure" target="_blank" rel="noopener">Gradle的文档</a>)，里面有相关的Api和概念。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.corda.net/releases/release-V3.2/key-concepts-ecosystem.html" target="_blank" rel="noopener">https://docs.corda.net/releases/release-V3.2/key-concepts-ecosystem.html</a><br><a href="https://docs.corda.net/releases/release-M7.0/index.html" target="_blank" rel="noopener">Corda API reference</a><br><a href="https://medium.com/corda/peer-to-peer-enterprise-blockchain-networking-with-the-corda-firewall-4f6a427ebd97" target="_blank" rel="noopener">Peer-to-Peer Enterprise Blockchain Networking with the Corda Firewall.</a><br><a href="http://cncorda.com/" target="_blank" rel="noopener">Corda中文网</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/ProcessBuilder简介/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/30/java/ProcessBuilder简介/" class="post-title-link" itemprop="url">ProcessBuilder简介</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-30 15:54:47 / 修改时间：16:09:49" itemprop="dateCreated datePublished" datetime="2018-05-30T15:54:47+08:00">2018-05-30</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学过C语言的都知道如何开启一个新的进行。自从我们学习了java之后，很少会开启新的进程，因为我们绝大部分的使用都是开启线程，以至于线程池的知识成了现在java面试的宝典了。</p>
<p>最近在研究Corda的源码，发现里面的启动都是通过相应的ProcessBuilder，这个类开启了若干进程，当然进程都是执行的shell代码，这里就不做更多说明了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ProcessBuilder类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由Process类处理实现进程的控制管理。每个 ProcessBuilder 实例管理一个进程属性集。它的start() 方法利用这些属性创建一个新的 Process 实例。start() 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p>每个进程生成器（即ProcessBuilder对象）管理这些进程属性： </p>
<ul>
<li><p>命令 command<br>是一个字符串列表，它表示要调用的外部程序文件及其参数（如果有）。在此，表示有效的操作系统命令的字符串列表是依赖于系统的。例如，每一个总体变量，通常都要成为此列表中的元素，但有一些操作系统，希望程序能自己标记命令行字符串——在这种系统中，Java 实现可能需要命令确切地包含这两个元素。</p>
</li>
<li><p>环境 environment<br>是从变量 到值 的依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅 System.getenv()）。</p>
</li>
<li><p>工作目录 working directory<br>默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</p>
</li>
<li><p>redirectErrorStream属性<br>最初，此属性为 false，意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 Process.getInputStream() 和 Process.getErrorStream() 方法来访问。如果将值设置为 true，标准错误将与标准输出合并。这使得关联错误消息和相应的输出变得更容易。在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</p>
</li>
</ul>
<h2 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h2><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p>
<p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>
<p>Process抽象类有以下6个抽象方法： </p>
<ul>
<li>destroy()<br>杀掉子进程。 </li>
<li>exitValue()<br>返回子进程的出口值。 </li>
<li>InputStream getErrorStream()<br>获得子进程的错误流。 </li>
<li>InputStream getInputStream()<br>获得子进程的输入流。 </li>
<li>OutputStream getOutputStream()<br>获得子进程的输出流。 </li>
<li>waitFor()<br>导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止。</li>
</ul>
<h3 id="如何创建Process对象？"><a href="#如何创建Process对象？" class="headerlink" title="如何创建Process对象？"></a>如何创建Process对象？</h3><p>一般有两种方法：</p>
<ol>
<li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象。</li>
<li>Runtime.exec() 方法创建一个本机进程，并返回 Process 子类的一个实例。</li>
</ol>
<h2 id="Runtime-exec"><a href="#Runtime-exec" class="headerlink" title="Runtime.exec()"></a>Runtime.exec()</h2><p>ProcessBuilder与Runtime.exec()的区别? </p>
<p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。 </p>
<p>ProcessBuilder.start() 和 Runtime.exec()传递的参数有所不同，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u013256816/article/details/54603910" target="_blank" rel="noopener">浅析ProcessBuilder</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/java线程状态的分析/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/30/java/java线程状态的分析/" class="post-title-link" itemprop="url">java线程状态的分析</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-30 15:35:06 / 修改时间：15:58:13" itemprop="dateCreated datePublished" datetime="2018-05-30T15:35:06+08:00">2018-05-30</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近阅读了《深入理解Linux内核》这本书，对于线程和进程的知识有了比较深入的理解，这里我就不做更多的介绍了，如果你想了解更多的知识可以阅读一下这本书，虽然阅读起来比较麻烦，但是确实是一本比较不错的书籍，里面的很多知识都是值得深入学习的。做好攻坚的准备就是了。</p>
<h2 id="关于线程的状态"><a href="#关于线程的状态" class="headerlink" title="关于线程的状态"></a>关于线程的状态</h2><p>以下是java的线程状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NEW</td>
<td style="text-align:center">初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td style="text-align:center">RUNNABLE</td>
<td style="text-align:center">运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td style="text-align:center">BLOCKED</td>
<td style="text-align:center">阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td style="text-align:center">WAITING</td>
<td style="text-align:center">等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td style="text-align:center">TIMED_WAITING</td>
<td style="text-align:center">超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<h2 id="改变线程状态"><a href="#改变线程状态" class="headerlink" title="改变线程状态"></a>改变线程状态</h2><p>大家都知道Thread类内部提供了几个方法可以改变线程的状态。</p>
<p>当然Future里面也有不少的改变线程状态的实现。</p>
<p>但是这些基础知识就不做更多的介绍了，这也不是我要说明的重点。</p>
<h2 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h2><p>今天主要是来说明这个类的作用的。这个类里面有很多的内容，今天就重点介绍里面的park方法。</p>
<p>因为park方法可以改变线程的状态，这种改变时操作系统级别的，这种调用一定是使用了系统调用，主要是你要明白这一点才能里面AQS里面的实现，这里就是简单的记录一下。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/缓存行与计算机缓存结构/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/30/java/缓存行与计算机缓存结构/" class="post-title-link" itemprop="url">缓存行与计算机缓存结构</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-30 15:18:20 / 修改时间：16:00:50" itemprop="dateCreated datePublished" datetime="2018-05-30T15:18:20+08:00">2018-05-30</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/base/" itemprop="url" rel="index"><span itemprop="name">base</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在读《深入理解Linux内核》读了不少关于计算机缓存的体系结构设计，这里就不做更多的说明，下面我们来看看这里面的知识吧！</p>
<p>计算机分为多级缓存，但是主要的还是要从内存条说起。</p>
<p>其实系统会在系统内存上单独开一片cache，而且这片的cache和普通的内存管理策略不同。这应该算是第一级缓存，但是这种提升不是很大。下面我们来讲高速缓存块cache。</p>
<p>对于高速缓存块cache也是有多种分法。一是主板级别的高速cache，这种是多CPU共享的。再上面一层就是CPU专用的高速cache块了。再上一层就是每个CPU核共享的高速cache。再上面一层就是寄存器了。</p>
<p>这就是背景知识。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>高速缓存块不是按照每一个字节进行缓存，而是按照一个内存块进行缓存。可是一旦这块中任何一个内容改变，都会导致整个块的Refresh。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里主要是指程序的改进，比如说你定义一个对象。以前这个对象在一个缓存行中，但是对象中改变的字段就是一个两个频繁改变，这样每次refresh的块比较大。所以方法就是将可变的属性放入一个缓存块中，将不可变的放入另一个缓存块中，这样刷新的少了，速度自然提升了。这就是缓存块的具体说明，具体可以查看具体的引用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://geek.csdn.net/news/detail/114619" target="_blank" rel="noopener">认识CPU Cache</a></p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <!-- 左侧菜单--站点概览 -->
<div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image"
      src="/images/user-avatar"
      alt="Gavin Zhang"/>
  
  <p class="site-author-name" itemprop="name">Gavin Zhang</p>
  <div class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</div>
</div>

<!-- 下方的分类标签 -->

  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>


<!-- rss -->

  <div class="feed-link motion-element">
    <a href="https://www.gitbook.com/" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>





  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/yourname" title="GitHub &rarr; https://github.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>







          
          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>

  

  
</div>


  <div class="powered-by">由 Gavin 强力驱动 v3.5.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
      <div>
        <!-- add this第三方工具 -->
<div class="addthis_inline_share_toolbox">
  <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d2f5e89bbcb7cce" async="async"></script>
</div>

      </div>
    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>







  



  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  


  

</body>
</html>
