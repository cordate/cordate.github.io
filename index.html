<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/blockchain/corda/Corda基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/blockchain/corda/Corda基础知识/" itemprop="url">Corda基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T16:28:29+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>corda是分布式账本技术的一种，另一种大家已经熟知的就是HyperLedger的Fabric。当然这种插件化的开发也有公共链上的石墨烯技术，这种技术也是插件化的挖矿节点的实现，但是石墨烯技术是C++语言的实现，这里我就不做更多的说明了，关于石墨烯更多的介绍可以点击<a href="https://github.com/cryptonomex/graphenes" target="_blank" rel="noopener">这里</a>。<a href="https://steemit.com/blockchain/@robinwen/bts-steem-eos" target="_blank" rel="noopener">这篇文章</a>也做了详细的介绍。</p>
<p>Corda与Fabric的区别，官网的说法是Corda专注于金融这块，而Fabric是基于组织联盟的，但是不管怎样分布式账本技术都是借鉴了区块链的设计思想的；Fabric是插件化的，而Corda是模块化的，我觉得这点在软件设计上有很大的区别。Corda是基于Kotlin开发的，而Fabric主力语言是Python，但是也可以使用其他语言，并不限制。</p>
<p>如果你想了解更多的Corda知识，可以参阅官网的<a href="https://docs.corda.net/releases/release-M7.0/_static/corda-introductory-whitepaper.pdf" target="_blank" rel="noopener">技术白皮书</a>。这个白皮书介绍了，这个系统最终的方案，现在还有很多未实现，正在实现中，当然在实现中可能会有与白皮书不一样的地方。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="包含的实现"><a href="#包含的实现" class="headerlink" title="包含的实现"></a>包含的实现</h3><p>Corda原型机目前包括：</p>
<ul>
<li>具有消息持久性和递送重试的对等网络。</li>
<li>用于定义合同和状态的关键数据结构。</li>
<li>智能合约，您可以在合约目录中找到。</li>
<li>与它们一起工作的算法，如序列化，散列，签名和签名验证。</li>
<li>API文档和教程（您正在阅读的内容）。</li>
<li>业务流程编排框架。</li>
<li>公证基础设施用于精确时间戳，并且在没有区块链的情况下消除双重花费。</li>
<li>一个简单的REST API和一个Web应用程序演示，用它来呈现IRS交易的前端。</li>
</ul>
<p>现在不包括，但是后面会进行实现的部分：</p>
<ul>
<li>沙盒，分销或发布智能合同代码</li>
<li>用于管理的用户界面</li>
</ul>
<p>现在的Corda版本仍然是创意的快速探索，所以为了提高开发的速度，会采取一些捷径，注意以下的一些事项：</p>
<ul>
<li>它使用一个对象映射序列化框架，而不是一个明确的，供应商中立的协议。</li>
<li>目前没有权限框架。（shiro或者Spring auth）</li>
<li>一些隐私技术尚未实施</li>
<li>它使用嵌入式SQL数据库，但尚未支持主流SQL供应商（Oracle，Postgres，MySQL，SQL Server等）的连接。</li>
</ul>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>在corda项目下定义了一些示例程序，这些程序在samples目录下，运行的命令如官网的命令，这里就不做更多说明了。</p>
<p><a href="https://docs.corda.net/releases/release-M7.0/running-the-demos.html" target="_blank" rel="noopener">运行演示</a></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>这里需要介绍状态（State）、交易（Transaction）和合约（Contract），以及它们之间的交互关系。</p>
<p>首先，交易消费的是状态（State），交易的作用就是将一个状态变换为一个新的状态。分类账被定义为一组不可变状态，由数字签名的交易创建和销毁。每个事务指向一组将要消耗/销毁的状态，这些状态称为输入，并且包含一组将会创建的新状态，这些状态称为 输出。</p>
<p>其次，合约定义了一个验证函数，这是一个纯函数，以交易为输入。要被视为有效，交易必须被输入和输出状态所指向的每个合约的验证功能所接受。</p>
<p>除了输入和输出之外，交易还可能包括命令，小数据包，平台不会自行解释，但可以参数化执行合约。<b style="color:blue">它们可以被认为是验证函数的参数。每个命令都有一个与之关联的公钥列表。该平台确保交易在合约开始执行之前由命令中列出的每个密钥签署。该平台确保交易在合同开始执行之前由命令中列出的每个密钥签署。因此，验证功能可以相信所有列出的密钥都签名了交易，但是负责验证交易从验证功能角度看是否有效所需的任何密钥都包含在列表中.</b></p>
<p><b style="color:red">命令总是嵌入在交易中。有时候，有很多数据可以在许多不同的交易中重复使用。这种使用的例子就是我们的附件。每个交易可以通过哈希引用0个或多个附件。附件始终都是ZIP/JAR文件，可能包含任何内容。</b></p>
<p><b style="color:red">请注意交易中可以有输入、输出、命令（Command）和附件（Attachment）。但是这些东西可能有也可能没有。交易中的数据需要合约来进行解释，并确保它们正确地结合在一起。</b></p>
<h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><h3 id="corda网站"><a href="#corda网站" class="headerlink" title="corda网站"></a>corda网站</h3><p>这里是corda的<a href="https://www.corda.net/zh-hant/" target="_blank" rel="noopener">官方网站</a>。<br><a href="https://github.com/corda" target="_blank" rel="noopener">这个网站</a>是corda的github主页，你可在里面找到我们的corda项目，入门的cordapp example也可以在这里找到，还是比较实用的。</p>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>最后这里列一下Kotlin的学习的一些资料。</p>
<p>最棒的就是<a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Strings/Task.kt" target="_blank" rel="noopener">这个网站</a>的在线练习，做的的确棒极了。</p>
<p>当然对于Kotlin，我们不得不研究一下它的<a href="http://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">官方指南</a>. 你可以在这里查询文档和Api的说明文档，另外里面还做了一个全局的搜索，不管是文档，博客还是Api文档，你都可以一键搜索，很是方便。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>这个是志愿者翻译的<a href="https://dongchuan.gitbooks.io/gradle-user-guide-/content/overview/features.html" target="_blank" rel="noopener">Gradle User Guide中文版</a></p>
<p>当然如果你想自定义Gradle插件的话，就不得不研究<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure" target="_blank" rel="noopener">Gradle的文档</a>)，里面有相关的Api和概念。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.corda.net/releases/release-M7.0/index.html" target="_blank" rel="noopener">Corda API reference</a><br><a href="https://medium.com/corda/peer-to-peer-enterprise-blockchain-networking-with-the-corda-firewall-4f6a427ebd97" target="_blank" rel="noopener">Peer-to-Peer Enterprise Blockchain Networking with the Corda Firewall.</a><br><a href="http://cncorda.com/" target="_blank" rel="noopener">Corda中文网</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/ProcessBuilder简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/ProcessBuilder简介/" itemprop="url">ProcessBuilder简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:54:47+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学过C语言的都知道如何开启一个新的进行。自从我们学习了java之后，很少会开启新的进程，因为我们绝大部分的使用都是开启线程，以至于线程池的知识成了现在java面试的宝典了。</p>
<p>最近在研究Corda的源码，发现里面的启动都是通过相应的ProcessBuilder，这个类开启了若干进程，当然进程都是执行的shell代码，这里就不做更多说明了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ProcessBuilder类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由Process类处理实现进程的控制管理。每个 ProcessBuilder 实例管理一个进程属性集。它的start() 方法利用这些属性创建一个新的 Process 实例。start() 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p>每个进程生成器（即ProcessBuilder对象）管理这些进程属性： </p>
<ul>
<li><p>命令 command<br>是一个字符串列表，它表示要调用的外部程序文件及其参数（如果有）。在此，表示有效的操作系统命令的字符串列表是依赖于系统的。例如，每一个总体变量，通常都要成为此列表中的元素，但有一些操作系统，希望程序能自己标记命令行字符串——在这种系统中，Java 实现可能需要命令确切地包含这两个元素。</p>
</li>
<li><p>环境 environment<br>是从变量 到值 的依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅 System.getenv()）。</p>
</li>
<li><p>工作目录 working directory<br>默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</p>
</li>
<li><p>redirectErrorStream属性<br>最初，此属性为 false，意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 Process.getInputStream() 和 Process.getErrorStream() 方法来访问。如果将值设置为 true，标准错误将与标准输出合并。这使得关联错误消息和相应的输出变得更容易。在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</p>
</li>
</ul>
<h2 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h2><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p>
<p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>
<p>Process抽象类有以下6个抽象方法： </p>
<ul>
<li>destroy()<br>杀掉子进程。 </li>
<li>exitValue()<br>返回子进程的出口值。 </li>
<li>InputStream getErrorStream()<br>获得子进程的错误流。 </li>
<li>InputStream getInputStream()<br>获得子进程的输入流。 </li>
<li>OutputStream getOutputStream()<br>获得子进程的输出流。 </li>
<li>waitFor()<br>导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止。</li>
</ul>
<h3 id="如何创建Process对象？"><a href="#如何创建Process对象？" class="headerlink" title="如何创建Process对象？"></a>如何创建Process对象？</h3><p>一般有两种方法：</p>
<ol>
<li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象。</li>
<li>Runtime.exec() 方法创建一个本机进程，并返回 Process 子类的一个实例。</li>
</ol>
<h2 id="Runtime-exec"><a href="#Runtime-exec" class="headerlink" title="Runtime.exec()"></a>Runtime.exec()</h2><p>ProcessBuilder与Runtime.exec()的区别? </p>
<p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。 </p>
<p>ProcessBuilder.start() 和 Runtime.exec()传递的参数有所不同，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u013256816/article/details/54603910" target="_blank" rel="noopener">浅析ProcessBuilder</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/java线程状态的分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/java线程状态的分析/" itemprop="url">java线程状态的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:35:06+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近阅读了《深入理解Linux内核》这本书，对于线程和进程的知识有了比较深入的理解，这里我就不做更多的介绍了，如果你想了解更多的知识可以阅读一下这本书，虽然阅读起来比较麻烦，但是确实是一本比较不错的书籍，里面的很多知识都是值得深入学习的。做好攻坚的准备就是了。</p>
<h2 id="关于线程的状态"><a href="#关于线程的状态" class="headerlink" title="关于线程的状态"></a>关于线程的状态</h2><p>以下是java的线程状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NEW</td>
<td style="text-align:center">初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td style="text-align:center">RUNNABLE</td>
<td style="text-align:center">运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td style="text-align:center">BLOCKED</td>
<td style="text-align:center">阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td style="text-align:center">WAITING</td>
<td style="text-align:center">等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td style="text-align:center">TIMED_WAITING</td>
<td style="text-align:center">超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<h2 id="改变线程状态"><a href="#改变线程状态" class="headerlink" title="改变线程状态"></a>改变线程状态</h2><p>大家都知道Thread类内部提供了几个方法可以改变线程的状态。</p>
<p>当然Future里面也有不少的改变线程状态的实现。</p>
<p>但是这些基础知识就不做更多的介绍了，这也不是我要说明的重点。</p>
<h2 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h2><p>今天主要是来说明这个类的作用的。这个类里面有很多的内容，今天就重点介绍里面的park方法。</p>
<p>因为park方法可以改变线程的状态，这种改变时操作系统级别的，这种调用一定是使用了系统调用，主要是你要明白这一点才能里面AQS里面的实现，这里就是简单的记录一下。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/缓存行与计算机缓存结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/缓存行与计算机缓存结构/" itemprop="url">缓存行与计算机缓存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:18:20+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/base/" itemprop="url" rel="index"><span itemprop="name">base</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在读《深入理解Linux内核》读了不少关于计算机缓存的体系结构设计，这里就不做更多的说明，下面我们来看看这里面的知识吧！</p>
<p>计算机分为多级缓存，但是主要的还是要从内存条说起。</p>
<p>其实系统会在系统内存上单独开一片cache，而且这片的cache和普通的内存管理策略不同。这应该算是第一级缓存，但是这种提升不是很大。下面我们来讲高速缓存块cache。</p>
<p>对于高速缓存块cache也是有多种分法。一是主板级别的高速cache，这种是多CPU共享的。再上面一层就是CPU专用的高速cache块了。再上一层就是每个CPU核共享的高速cache。再上面一层就是寄存器了。</p>
<p>这就是背景知识。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>高速缓存块不是按照每一个字节进行缓存，而是按照一个内存块进行缓存。可是一旦这块中任何一个内容改变，都会导致整个块的Refresh。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里主要是指程序的改进，比如说你定义一个对象。以前这个对象在一个缓存行中，但是对象中改变的字段就是一个两个频繁改变，这样每次refresh的块比较大。所以方法就是将可变的属性放入一个缓存块中，将不可变的放入另一个缓存块中，这样刷新的少了，速度自然提升了。这就是缓存块的具体说明，具体可以查看具体的引用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://geek.csdn.net/news/detail/114619" target="_blank" rel="noopener">认识CPU Cache</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/理解Java的AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/理解Java的AQS/" itemprop="url">理解Java的AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T19:48:46+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/aqs/" itemprop="url" rel="index"><span itemprop="name">aqs</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一提到java的锁机制，大家都会想到AQS（AbstractQueuedSynchronizer），意思就是抽象的同步队列，感觉就是使用队列来进行同步操作而已。（Java8版本）</p>
<h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>AbstractQueuedSynchronizer是继承自AbstractOwnableSynchronizer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 独占模式同步的当前所有者。</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个说明还是比较简单的，就是说这个同步独占这个线程而已。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>当然AbstractOwnableSynchronizer是队列，所以里面有内部类表示节点（Node），其实就是一个双向链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标记以指示节点正在以共享模式等待</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标记以指示节点正在以独占模式等待</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // 表示线程已取消的waitStatus值</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    // waitStatus值指示后继者的线程需要暂停</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    // waitStatus值指示线程正在等待状态</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    // waitStatus值指示下一个acquireShared应无条件传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Status field, taking on only the values:</span><br><span class="line">    *   SIGNAL: 值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="line">    *   CANCELLED:  值为1，表示当前的线程被取消；</span><br><span class="line">    *   CONDITION:  值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="line">    *   PROPAGATE:  值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="line">    *   0:        None of the above 表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter; // 存储condition队列中的后继节点。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Returns true if node is waiting in shared mode.</span><br><span class="line">    */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">首先这是一个双向链表，从这里我们可以看出AQS的功能可以分为两类：独占功能和共享功能</b>。另外，排队的节点有5中状态，就是<code>waitStatus</code>的值，Node需要记录排队的线程和下一个等待的节点（线程）。</p>
<p>## </p>
<p>未完待续！！！！！</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a><br><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a><br><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）</a><br><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/深入java类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/深入java类加载器/" itemprop="url">深入java类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T17:41:35+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>对于java的类加载机制，我想大家一定都知道双亲委派模型和JDK类中的加载器。主要有Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader和User Defined ClassLoader。这些基础知识就不多说了。</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)：<br>这个类加载器使用C++语言实现，并非ClassLoader的子类。主要负责加载存放在<code>JAVA_HOME/jre/lib/rt.jar</code>里面所有的class文件，或者被<code>-Xbootclasspath</code>参数所指定路径中以rt.jar命名的文件。</li>
<li>扩展类加载器(Extension ClassLoader)：<br>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>JAVA_HOME/lib/ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li>
<li>应用程序类加载器(Application ClassLoader)：<br>这个加载器由sun.misc.Launcher$AppClassLoader实现，它负责加载<code>classpath</code>对应的jar及目录。一般情况下这个就是程序中默认的类加载器。</li>
<li>自定义类加载器(User Defined ClassLoader)：<br>开发人员继承ClassLoader抽象类自行实现的类加载器，基于自行开发的ClassLoader可用于并非加载classpath中(例如从网络上下载的jar或二进制字节码)、还可以在加载class文件之前做些小动作 如：加密等。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>类加载器(ClassLoader)用来加载 class字节码到 Java 虚拟机中，并转换成 java.lang.Class 类的一个实例。当然class字节码的来源可能有多种，一种就是自己拼写class文件的内容。</p>
<p>Java中如何比较两个类相等呢？这里所指的“相等”包括代表类的Class对象的equal方法、isAssignableFrom()、isInstance()方法及instance关键字返回的结果。</p>
<p>其实在Java中，一个类是否是相同的，主要取决于类加载器和包名+类名，只有以上条件都满足了，我们才说这两个类是相等的。我并没有在class文件中发现equals方法，这说明类加载的去重完全是在definedClass方法中，调用了底层的一些C代码实现的。也就是说，我们无法自己实例化一个Class实例，这需要JVM底层帮我们处理，每个Class实例的去重，完全是JVM的底层代码帮忙处理的。但是我们可以在class类中发现一个ClassLoader类的成员。</p>
<h2 id="ParallelLoaders"><a href="#ParallelLoaders" class="headerlink" title="ParallelLoaders"></a>ParallelLoaders</h2><p>这是ClassLoader里面的一个内部类，用来封装一组并行能力的加载器类型。这个一般是用不到的，有兴趣可以先看一下。但是需要知道ClassLoader是支持并行加载的。</p>
<h2 id="类加载过程与双亲委派"><a href="#类加载过程与双亲委派" class="headerlink" title="类加载过程与双亲委派"></a>类加载过程与双亲委派</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123; // 获得要用的锁</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); // 检查这个类有没有被加载</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime(); // 时间</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123; // 如果父类加载器，就用父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 默认的父类加载器是启动类加载器</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123; // 如果最终没有加载到这个类</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime(); // 取得系统时间</span><br><span class="line">                c = findClass(name); // 如果没有父类加载器就自己加载</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很清楚，就不用过多解释了。双亲委派不是基于继承实现的，而是基于组合的方式实现的，默认使用启动类加载器作为父类加载器。如果类加器的父类加载器没有帮助我们加载到相应的类，那么就会调用findClass这个方法，所以为啥我们定义类加载器的时候需要重写findClass方法的原因就在这里。</p>
<p>默认的findClass实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，如果加载不了类就抛异常，我们进行重写的时候，也应该注意这点（这是典型的模板方法模式）。</p>
<p>其次我们发现loadClass不是final方法，也就是说我们可以打破双亲委派的模型，直接使用自己的类加载器，但这样会出现无法使用系统类的问题了，这个只是我的猜测，但是如果我想ClassLoader中会不会相应的信息，也许需要以后研究JVM底层的时候，才会有答案了。</p>
<h2 id="重写findClass"><a href="#重写findClass" class="headerlink" title="重写findClass"></a>重写findClass</h2><p>我们可以发现重写findClass完全达不到自己生成Class的目的。然后你会发现defineClass也是返回Class类型的，所以我们需要在方法中调用这个方法进行相应的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    // 从codeSource中获取类所在文件路径</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有趣发现这里也有模板方法模式，如果你想前后处理一些事情，可以重写preDefineClass、postDefineClass这两个方法，但是注意原来的方法时private的，你无法调用super里面的方法，这会带来很多的问题。</p>
<p>当然defineClass本省就是一个重载方法，所以详细的信息请查看源码，这里就不多说明了，其实用到才关注，一般的时候是不用管的。</p>
<h2 id="resolveClass方法"><a href="#resolveClass方法" class="headerlink" title="resolveClass方法"></a>resolveClass方法</h2><p>resolveClass 此方法负责完成Class对象的链接，如果链接过，则直接返回。</p>
<h2 id="findLibrary-loadLiberay"><a href="#findLibrary-loadLiberay" class="headerlink" title="findLibrary/loadLiberay"></a>findLibrary/loadLiberay</h2><p>这两个方法其实是为了加载动态链接库使用的，以前我也分析过里面的代码，有些印象，这里就不做更多的解释了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/编译原理/LLVM语言参考手册(类型系统到其他值)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/编译原理/LLVM语言参考手册(类型系统到其他值)/" itemprop="url">LLVM语言参考手册(类型系统到其他值)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T12:34:05+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>LLVM类型系统是中间表示的最重要的特征之一。类型化使得可以直接对中间表示执行许多优化，而不必在转换之前在侧面进行额外的分析。强大的类型系统使读取生成的代码变得更加容易，并且支持新的分析和转换，这些分析和转换在普通的三个地址代码表示上不可行。</p>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>概述：void类型不代表任何值并且没有大小。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void</span><br></pre></td></tr></table></figure></p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>概述：    函数类型可以被认为是函数签名。它由一个返回类型和一个形式参数类型列表组成。函数类型的返回类型是void类型或第一类类型 - <a href="http://llvm.org/docs/LangRef.html#t-label" target="_blank" rel="noopener">标签</a>和<a href="http://llvm.org/docs/LangRef.html#t-metadata" target="_blank" rel="noopener">元数据</a>类型除外。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;returntype&gt; (&lt;parameter list&gt;)</span><br></pre></td></tr></table></figure></p>
<p>…其中<code>&lt;parameter list&gt;</code>是逗号分隔的类型说明符列表。可选地，参数列表可以包括类型…，该类型指示该函数采用可变数目的参数。变量参数函数可以通过<a href="http://llvm.org/docs/LangRef.html#int-varargs" target="_blank" rel="noopener">处理内部函数的变量参数</a>来访问它们的参数。<code>&lt;returntype&gt;</code>是除<a href="http://llvm.org/docs/LangRef.html#t-label" target="_blank" rel="noopener">标签</a>和<a href="http://llvm.org/docs/LangRef.html#t-metadata" target="_blank" rel="noopener">元数据</a>之外的任何类型。</p>
<p>例子：<br><code>i32 (i32)</code>    函数接受i32，返回一个i32<br><code>float (i16, i32 *) *</code>    指针，以接受一个函数i16和一个i32指针来返回float。<br><code>i32 (i8*, ...)</code>    可变参数函数，它有至少一个指针到i8（在C中是char），它返回一个整数。LLVM中这是printf的签名。<br><code>{i32, i32} (i32)</code>    一个函数i32，返回一个包含两个i32值的<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构</a></p>
<h2 id="第一类类型（First-Class-Types）"><a href="#第一类类型（First-Class-Types）" class="headerlink" title="第一类类型（First Class Types）"></a>第一类类型（First Class Types）</h2><p>第一类的类型可能是最重要的。这些类型的值是唯一可以通过指令产生的类型。</p>
<h3 id="单值类型"><a href="#单值类型" class="headerlink" title="单值类型"></a>单值类型</h3><p>这些是从CodeGen的角度来看在寄存器中有效的类型。</p>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>概述：    整数类型是一个非常简单的类型，它简单地为所需的整数类型指定一个任意的位宽。可以指定从1位到2<sup>23</sup>-1（约8百万）的任何位宽。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iN</span><br></pre></td></tr></table></figure></p>
<p>整数将占据的位数由该<code>N</code>值指定。</p>
<p>例子：<br><code>i1</code>    一个单位整数。<br><code>i32</code>    一个32位整数。<br><code>i1942652</code>    一个超过100万位的大整数。</p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>half</td>
<td>16位浮点值</td>
</tr>
<tr>
<td>float</td>
<td>32位浮点值</td>
</tr>
<tr>
<td>double</td>
<td>64位浮点值</td>
</tr>
<tr>
<td>fp128</td>
<td>128位浮点值（112位尾数）</td>
</tr>
<tr>
<td>x86_fp80</td>
<td>80位浮点值（X87）</td>
</tr>
<tr>
<td>ppc_fp128</td>
<td>128位浮点值（两个64位）</td>
</tr>
</tbody>
</table>
<p>half，float，double和fp128的二进制格式分别对应于binary16，binary32，binary64和binary128的IEEE-754-2008规范。</p>
<h4 id="X86-mmx类型"><a href="#X86-mmx类型" class="headerlink" title="X86_mmx类型"></a>X86_mmx类型</h4><p>概述：    x86_mmx类型表示在x86机器上的MMX寄存器中保存的值。允许的操作相当有限：参数和返回值，load和store以及bitcast。用户指定的<code>MMX</code>指令表示为具有参数<code>and/or</code>此类型结果的内部调用或asm调用。没有这种类型的数组、向量或常量。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_mmx</span><br></pre></td></tr></table></figure></p>
<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>概述：    指针类型用于指定内存位置。指针通常用于引用内存中的对象。</p>
<p>指针类型可能有一个可选的地址空间属性，用于定义指向对象所在的编号地址空间。默认地址空间是数字零。非零地址空间的语义是特定于目标的。</p>
<p>请注意，LLVM不允许指向<code>void（void*）</code>的指针，也不允许指向标签<code>（label*）</code>的指针。改为使用<code>i8*</code>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; *</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>[4 x i32]*</code>    4个的i32值数组的指针。<br><code>i32 (i32*) *</code>    函数指针，它接受一个<code>i32*</code>，并返回i32。<br><code>i32 addrspace(5)*</code>    i32值的指针，驻留在地址空间<code>#5</code>中的值。</p>
<h4 id="矢量类型"><a href="#矢量类型" class="headerlink" title="矢量类型"></a>矢量类型</h4><p>概述：    矢量类型是表示元素矢量的简单派生类型。当使用单个指令（SIMD）并行操作多个原始数据时，使用矢量类型。矢量类型需要大小（元素数量）和基础原始数据类型。矢量类型被认为是<a href="http://llvm.org/docs/LangRef.html#t-firstclass" target="_blank" rel="noopener">第一类</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; &lt;# elements&gt; x &lt;elementtype&gt; &gt;</span><br></pre></td></tr></table></figure></p>
<p>元素的数量是一个大于0的常数整数值; <code>elementtype</code>可以是任何整数、浮点或指针类型。大小为零的矢量是不允许的。</p>
<p>例子：<br><code>&lt;4 x i32&gt;</code>    4个32位整数值的向量。<br><code>&lt;8 x float&gt;</code>    8个32位浮点值的向量。<br><code>&lt;2 x i64&gt;</code>    2个64位整数值的向量。<br><code>&lt;4 x i64*&gt;</code>    4个64位整数值指针的向量。</p>
<h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><p>概述：    标签类型代表代码标签。<br>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label</span><br></pre></td></tr></table></figure></p>
<h3 id="令牌-token-类型"><a href="#令牌-token-类型" class="headerlink" title="令牌(token)类型"></a>令牌(token)类型</h3><p>概述：    当值与指令相关联时使用token类型，但该值的所有用法不得试图反思或模糊它。因此，具有<a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">phi</a>或<a href="http://llvm.org/docs/LangRef.html#i-select" target="_blank" rel="noopener">select</a>类型令牌是不合适的。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token</span><br></pre></td></tr></table></figure></p>
<h3 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h3><p>概述：    元数据类型表示嵌入的元数据。除函数参数外，不得从元数据创建派生类型。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metadata</span><br></pre></td></tr></table></figure></p>
<h3 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h3><p>聚合类型是派生类型的一个子集，可以包含多个成员类型。<a href="http://llvm.org/docs/LangRef.html#t-array" target="_blank" rel="noopener">数组</a>和<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构</a>是聚合类型。<a href="http://llvm.org/docs/LangRef.html#t-vector" target="_blank" rel="noopener">向量</a>不被视为聚合类型。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>概述：    数组类型是一种非常简单的派生类型，它将元素按顺序排列在内存中。数组类型需要大小（元素数量）和基础数据类型。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;# elements&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure></p>
<p>元素的数量是一个常数整数值; <code>elementtype</code>可以是任何尺寸的类型。</p>
<p>例子：<br><code>[40 x i32]</code>    包含40个32位整数值的数组。<br><code>[41 x i32]</code>    41个32位整数值的数组。<br><code>[4 x i8]</code>    包含4个8位整数值的数组。<br>以下是多维数组的一些示例：<br><code>[3 x [4 x i32]]</code>    3x4 32位整数值数组。<br><code>[12 x [10 x float]]</code>    单精度浮点值的12×10数组。<br><code>[2 x [3 x [4 x i16]]]</code>    2x3x4的16位整数值数组。</p>
<p>除了静态类型隐含的数组末尾之外，没有对索引的限制（尽管在某些情况下索引超出了分配对象的范围）。这意味着可以在零长度数组类型的LLVM中实现单维“可变大小数组”。例如，在LLVM中实现“pascal样式数组”可以使用类型“<code>{ i32, [0 x float]}</code>”。</p>
<h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>概述：    结构类型用于在内存中一起表示数据成员的集合。结构的元素可以是任何具有大小的类型。</p>
<p>使用’<code>load</code>‘和’<code>store</code>‘通过使用’<code>getelementptr</code>‘指令获取指向字段的指针来访问内存中的结构。使用’<code>extractvalue</code>‘和’<code>insertvalue</code>‘指令访问寄存器中的结构。</p>
<p>结构可以选择是“压缩”结构，其指示结构的对齐是一个字节，并且元素之间没有填充。在非压缩结构中，字段类型之间的填充按照DataLayout字符串在模块中定义的方式插入，该模块需要与基础代码生成器的预期匹配。</p>
<p>结构可以是“文字”或“识别符”。字面结构与其他类型（例如<code>{i32, i32}*</code>）内联定义，而标识类型始终在顶层使用名称定义。文字类型被其内容所独占，因为没有办法编写它们，所以永远不会递归或不透明。识别符的类型可以是递归的，可以是不透明的，并且永远不会被分离。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 = type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 = type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>{ i32, i32, i32 }</code>    三个i32值的结构<br><code>{ float, i32 (i32) * }</code>    一对，其中第一个元素是a float，第二个元素是一个指向函数的指针，该函数接受一个i32返回值i32。<br><code>&lt;{ i8, i32 }&gt;</code>    一个已知为5字节大小的打包结构。</p>
<h4 id="不透明结构类型"><a href="#不透明结构类型" class="headerlink" title="不透明结构类型"></a>不透明结构类型</h4><p>概述：    不透明结构类型用于表示没有指定主体的命名结构类型。这符合（例如）正向声明结构的C概念。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%X = type opaque</span><br><span class="line">%52 = type opaque</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>opaque</code>    一种不透明的类型。</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>LLVM有几种不同的基本类型的常量。本节介绍它们的全部和它们的语法。</p>
<h2 id="简单常量"><a href="#简单常量" class="headerlink" title="简单常量"></a>简单常量</h2><ul>
<li>布尔常量: 两个字符串’ true’和’ false’都是该i1类型的有效常量。</li>
<li>整型常量: 标准整数（如’4’）是整数类型的常量 。负数可能与整数类型一起使用。</li>
<li>浮点常量: 浮点常量使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e + 2）或更精确的十六进制表示法（请参见下文）。汇编器需要浮点常量的精确十进制值。例如，汇编程序接受1.25，但拒绝1.3，因为1.3是二进制中的重复小数。浮点常量必须具有 浮点类型。</li>
<li>空指针常量: 标识符’<code>null</code>‘被识别为空指针常量，并且必须是指针类型。</li>
<li>令牌(Token)常量: 标识符’none’被识别为空的标记常量，并且必须是标记类型。</li>
</ul>
<p>常量的一个非直观符号是浮点常量的十六进制形式。例如，形式为’<code>double    0x432ff973cafa8000</code>‘等同于（但难以阅读）’<code>double 4.5e+15</code>‘。唯一需要十六进制浮点常量（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能用合理数目的十进制浮点数表示的浮点常量数字。例如，<code>NaN&#39;s</code>，<code>infinities</code>和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位发生更改。</p>
<p>当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字形式表示（与IEEE754表示符合double）; 然而，half和float值必须分别精确表示为IEEE 754的半精度和单精度。十六进制格式总是用于长双，并有三种形式的长双。x86使用的80位格式表示0xK后跟20个十六进制数字。PowerPC使用的128位格式（两个相邻的双精度） 0xM由32个十六进制数字表示。IEEE 128位格式0xL由32个十六进制数字表示。长双打只有在你的目标上的长双重格式匹配时才有效。IEEE 16位格式（半精度）由表示0xH 后跟4个十六进制数字。所有的十六进制格式都是big-endian（左边的符号位）。</p>
<p>没有<code>x86_mmx</code>类型的常量。</p>
<h2 id="复杂（Complex）常量"><a href="#复杂（Complex）常量" class="headerlink" title="复杂（Complex）常量"></a>复杂（Complex）常量</h2><p>复杂常量是简单常量和较小复常量的（可能递归）组合。</p>
<h3 id="结构常数"><a href="#结构常数" class="headerlink" title="结构常数"></a>结构常数</h3><p>结构常量用类似于结构类型定义的符号表示（逗号分隔的元素列表，用大括号（{}）括起来）。例如：“<code>{ i32 4, float 17.0, i32* @G }</code>”，其中“<code>@G</code>”被声明为“<code>@G = external global i32</code>”。结构常量必须具有<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构类型</a>，并且元素的数量和类型必须与该类型指定的类型匹配。</p>
<h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号（[]）括起来）。例如：“<code>[ i32 42, i32 11, i32 74 ]</code>”。数组常量必须具有<a href="http://llvm.org/docs/LangRef.html#t-array" target="_blank" rel="noopener">数组类型</a>，并且元素的数量和类型必须与该类型指定的数量和类型相匹配。作为一种特殊情况，字符数组常量也可以用 前缀表示为双引号字符串。例如：“c<code>&quot;Hello World\0A\00&quot;</code>”。</p>
<h3 id="矢量-Vector-常量"><a href="#矢量-Vector-常量" class="headerlink" title="矢量(Vector)常量"></a>矢量(Vector)常量</h3><p>向量常量用类似于向量类型定义的符号表示（逗号分隔的元素列表，由小于/大于（（&lt;&gt;））围绕）。例如：“<code>&lt; i32 42, i32 11, i32 74, i32 100 &gt;</code>”。向量常量必须具有向量类型，并且元素的数量和类型必须与该类型指定的类型匹配。</p>
<h3 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h3><p>字符串“<code>zeroinitializer</code>‘可用于将零值初始化为任何类型的零，包括标量和<a href="http://llvm.org/docs/LangRef.html#t-aggregate" target="_blank" rel="noopener">聚合类型</a>。这通常用于避免必须打印大型零初始化器（例如，用于大型数组），并且始终完全等同于使用显式零初始化器。</p>
<h3 id="元数据节点"><a href="#元数据节点" class="headerlink" title="元数据节点"></a>元数据节点</h3><p>元数据节点是一个没有类型的常量元组。例如：“<code>!{!0, !{!2, !0}, !&quot;test&quot;}</code>”。元数据可以引用常量值，例如：“<code>!{!0, i32 0, i8* @global, i64 (i64)* @function, !&quot;str&quot;}</code>”。与其他类型化的常量不同，它们被解释为指令流的一部分，元数据是附加附加信息的地方，例如调试信息。</p>
<h2 id="全局变量和函数地址"><a href="#全局变量和函数地址" class="headerlink" title="全局变量和函数地址"></a>全局变量和函数地址</h2><p><a href="http://llvm.org/docs/LangRef.html#globalvars" target="_blank" rel="noopener">全局变量</a>和 <a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数</a>总是隐式有效（链接时间）常量。当使用<a href="http://llvm.org/docs/LangRef.html#identifiers" target="_blank" rel="noopener">全局标识符</a>并且总是有指针类型时，这些常量被明确引用。例如，以下是合法的LLVM文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@X = global i32 17</span><br><span class="line">@Y = global i32 42</span><br><span class="line">@Z = global [2 x i32*] [ i32* @X, i32* @Y ]</span><br></pre></td></tr></table></figure></p>
<h2 id="未定义的值"><a href="#未定义的值" class="headerlink" title="未定义的值"></a>未定义的值</h2><p>字符串’<code>undef</code>‘可以用于任何需要常量的地方，并且表示该值的用户可能会收到未指定的位模式。未定义的值可以是任何类型（除了’<code>label</code>‘或’<code>void</code>‘），并且可以在任何允许常量的地方使用。</p>
<p>未定义的值非常有用，因为它们向编译器指出，无论使用什么值，该程序都已定义良好。这为编译器提供了更多的优化自由度。下面是一些有效的（可能令人惊讶的）转换的例子（在伪IR中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  %A = add %X, undef</span><br><span class="line">  %B = sub %X, undef</span><br><span class="line">  %C = xor %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure></p>
<p>这是安全的，因为所有的输出位都受<code>undef</code>位的影响。任何输出位都可以有一个零或一个依赖的输入位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = or %X, undef</span><br><span class="line">  %B = and %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = -1</span><br><span class="line">  %B = 0</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X  ;; By choosing undef as 0</span><br><span class="line">  %B = %X  ;; By choosing undef as -1</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br></pre></td></tr></table></figure></p>
<p>这些逻辑操作的位不总是受输入的影响。例如，如果%X有一个零位，那么“<code>and</code>‘操作的输出将始终为该位的零，而不管”<code>undef</code>‘ 的相应位是什么。因此，优化或假设<code>and</code>的结果是<code>undef</code>是不安全的。但是，假设<code>undef</code>的所有位都可以是0，并且将’<code>and</code>‘优化为0是安全的。同样，假设可以设置<code>undef</code>的<code>or</code>操作的所有位是安全的，允许’<code>or</code>‘被折叠为-1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = select undef, %X, %Y</span><br><span class="line">  %B = select undef, 42, %Y</span><br><span class="line">  %C = select %X, %Y, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X     (or %Y)</span><br><span class="line">  %B = 42     (or %Y)</span><br><span class="line">  %C = %Y</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure></p>
<p>这组例子表明，未定义的’<code>select</code>‘（和条件分支）条件可以采取任何方式，但它们必须来自两个操作数中的一个。在<code>%A</code>例子中，如果<code>%X</code>和<code>%Y</code>是两个已知具有明显的低位，那么<code>%A</code>就必须有一个清除低位。然而，在这个<code>%C</code>例子中，优化器被允许假设’<code>undef</code>‘操作可以是和<code>%Y</code>相同的，允许整个’<code>select</code>‘被消除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  %A = xor undef, undef</span><br><span class="line"></span><br><span class="line">  %B = undef</span><br><span class="line">  %C = xor %B, %B</span><br><span class="line"></span><br><span class="line">  %D = undef</span><br><span class="line">  %E = icmp slt %D, 4</span><br><span class="line">  %F = icmp gte %D, 4</span><br><span class="line"></span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br><span class="line">  %D = undef</span><br><span class="line">  %E = undef</span><br><span class="line">  %F = undef</span><br></pre></td></tr></table></figure></p>
<p>这个例子指出两个<code>undef</code>操作不一定相同。这对于人们来说可能是令人惊讶的（并且也匹配C语义），他们认为“<code>X^X</code>”总是零，即使 X未定义也是如此。由于多种原因，这是不正确的，但简单的答案是，一个<code>undef</code>“变量”可以在其“生存范围”内随意改变它的值。这是真的，因为这个变量实际上并没有生存范围。相反，该值是从任意寄存器中逻辑读取的，这些寄存器恰好在需要时发生变化，因此该值不一定随时间变化。事实上，<code>%A</code>和<code>%C</code>需要有相同的语法或核心LLVM“全部替换与使用”的概念将不成立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = sdiv undef, %X</span><br><span class="line">  %B = sdiv %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = 0</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure></p>
<p>这些示例显示了未定义的值 和未定义的行为之间的关键区别。一个未定义的值（如’<code>undef</code>‘）允许有一个任意的位模式。这意味着<code>%A</code>操作可以不断折叠为’0’，因为’<code>undef</code>‘可能为零，并且零除以任何值为零。但是，在第二个例子中，我们可以做一个更积极的假设：因为<code>undef</code>允许它是一个任意值，我们可以假设它可能为零。由于被零除以具有未定义的行为，我们被允许假设该操作根本不执行。这允许我们删除分割和所有代码。由于未定义的操作“不可能发生”，因此优化器可以假定它发生在死代码中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:  store undef -&gt; %X</span><br><span class="line">b:  store %X -&gt; undef</span><br><span class="line">Safe:</span><br><span class="line">a: &lt;deleted&gt;</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure></p>
<p>存储的未定义的值可以被假设为不具有任何影响; 我们可以假设这个值被恰好与已经存在的相匹配的位覆盖。然而，一个存储到一个未定义的位置可能破坏任意的内存，因此，它具有未定义行为。</p>
<h2 id="毒药（Poison）值"><a href="#毒药（Poison）值" class="headerlink" title="毒药（Poison）值"></a>毒药（Poison）值</h2><p>毒性（Poison）值与undef值相似，但它们也表示这样的事实，即不能引起副作用的指令或常量表达式已经检测到导致未定义行为的条件。</p>
<p>目前在IR中无法表示毒物值; 它们只存在于某些操作的调用，如带有<code>nsw</code>标志的<code>add</code>操作。</p>
<p>毒药值行为是根据值依赖来定义的：</p>
<ul>
<li><a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">phi</a>节点以外的值取决于它们的操作数。</li>
<li><a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">Phi</a>节点取决于对应于其动态前驱基本块的操作数。</li>
<li>函数参数取决于其函数的动态调用者中相应的实际参数值。</li>
<li>调用(<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener">call</a>)指令取决于将控制动态传回给它们的<a href="http://llvm.org/docs/LangRef.html#i-ret" target="_blank" rel="noopener">ret</a>指令。</li>
<li>调用(<a href="http://llvm.org/docs/LangRef.html#i-invoke" target="_blank" rel="noopener">invoke</a>)指令取决于ret， <a href="http://llvm.org/docs/LangRef.html#i-resume" target="_blank" rel="noopener">resume</a>或异常抛出调用指令，动态地将控制权交还给它们。</li>
<li>非易失性加载和存储取决于所有引用的内存地址的最新存储，遵循IR中的命令（包括由<a href="mailto:`@llvm.memcpy" target="_blank" rel="noopener">`@llvm.memcpy</a>`等内在函数隐含的加载和存储）。</li>
<li>具有外部可见副作用的指令取决于最近的先前的指令，其具有外部可见的副作用，遵循IR中的顺序。（这包括易失性操作。）</li>
<li>指令控制依赖于一个终止指令，如果终止子指令有多个后继者和指令总是被执行时控制转移到后继的一个，并且当控制被转移到另一个可以不执行。</li>
<li>此外，指令也是控制 - 取决于终止指令，如果终止指令已将控制权转移给不同的后继者，则其所依赖的指令集将会不​​同。</li>
<li>依赖性是传递性的。</li>
</ul>
<p>Poison值具有与undef值相同的行为，另外的效果是任何依赖poison值的指令都具有未定义的行为。</p>
<p>这里有些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  %poison = sub nuw i32 0, 1           ; Results in a poison value.</span><br><span class="line">  %still_poison = and i32 %poison, 0   ; 0, but also poison.</span><br><span class="line">  %poison_yet_again = getelementptr i32, i32* @h, i32 %still_poison</span><br><span class="line">  store i32 0, i32* %poison_yet_again  ; memory at @h[0] is poisoned</span><br><span class="line"></span><br><span class="line">  store i32 %poison, i32* @g           ; Poison value stored to memory.</span><br><span class="line">  %poison2 = load i32, i32* @g         ; Poison value loaded back from memory.</span><br><span class="line"></span><br><span class="line">  store volatile i32 %poison, i32* @g  ; External observation; undefined behavior.</span><br><span class="line"></span><br><span class="line">  %narrowaddr = bitcast i32* @g to i16*</span><br><span class="line">  %wideaddr = bitcast i32* @g to i64*</span><br><span class="line">  %poison3 = load i16, i16* %narrowaddr ; Returns a poison value.</span><br><span class="line">  %poison4 = load i64, i64* %wideaddr  ; Returns a poison value.</span><br><span class="line"></span><br><span class="line">  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.</span><br><span class="line">  br i1 %cmp, label %true, label %end  ; Branch to either destination.</span><br><span class="line"></span><br><span class="line">true:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This is control-dependent on %cmp, so</span><br><span class="line">                                       ; it has undefined behavior.</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  %p = phi i32 [ 0, %entry ], [ 1, %true ]</span><br><span class="line">                                       ; Both edges into this PHI are</span><br><span class="line">                                       ; control-dependent on %cmp, so this</span><br><span class="line">                                       ; always results in a poison value.</span><br><span class="line"></span><br><span class="line">  store volatile i32 0, i32* @g        ; This would depend on the store in %true</span><br><span class="line">                                       ; if %cmp is true, or the store in %entry</span><br><span class="line">                                       ; otherwise, so this is undefined behavior.</span><br><span class="line"></span><br><span class="line">  br i1 %cmp, label %second_true, label %second_end</span><br><span class="line">                                       ; The same branch again, but this time the</span><br><span class="line">                                       ; true block doesn&apos;t have side effects.</span><br><span class="line"></span><br><span class="line">second_true:</span><br><span class="line">  ; No side effects!</span><br><span class="line">  ret void</span><br><span class="line"></span><br><span class="line">second_end:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This time, the instruction always depends</span><br><span class="line">                                       ; on the store in %end. Also, it is</span><br><span class="line">                                       ; control-equivalent to %end, so this is</span><br><span class="line">                                       ; well-defined (ignoring earlier undefined</span><br><span class="line">                                       ; behavior in this example).</span><br></pre></td></tr></table></figure></p>
<h2 id="基本块的地址"><a href="#基本块的地址" class="headerlink" title="基本块的地址"></a>基本块的地址</h2><p><code>blockaddress(@function, %block)</code></p>
<p>在“<code>blockaddress</code>”常数计算在指定函数指定的基本块的地址，并总是有一个<code>i8*</code>类型。取出输入块的地址是非法的。</p>
<p>当用作’<code>indirectbr</code>‘指令的操作指令时，或者用于与空值进行比较时，该值仅具有已定义的行为。标签地址之间的指针相等测试会导致未定义的行为 - 但是，再次，与null进行比较是可以的，并且没有标签等于空指针。只要这些位未被检查，这可以作为不透明的指针大小值传递。ptrtoint只要原始值在indirectbr 指令之前重新构成，就允许和计算这些值。</p>
<p>最后，有些目标可能会在使用该值作为内联程序集的操作数时提供定义的语义，但这是目标特定的。</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式用于允许涉及其他常量的表达式用作常量。常量表达式可以是任何<a href="http://llvm.org/docs/LangRef.html#t-firstclass" target="_blank" rel="noopener">第一类类型</a>，并且可能涉及没有副作用的任何LLVM操作（例如，不支持加载和调用）。以下是常量表达式的语法：</p>
<ul>
<li><code>trunc (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-trunc" target="_blank" rel="noopener">trunc操作</a>。</li>
<li><code>zext (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-zext" target="_blank" rel="noopener">zext操作</a>。</li>
<li><code>sext (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-sext" target="_blank" rel="noopener">sext操作</a>。</li>
<li><code>fptrunc (CST to TYPE)</code>: 将浮点常量截断为另一个浮点类型。CST的大小必须大于TYPE的大小。这两种类型都必须是浮点型。</li>
<li><code>fpext (CST to TYPE)</code>: 浮点将常量扩展为另一种类型。CST的大小必须小于或等于TYPE的大小。这两种类型都必须是浮点型。</li>
<li><code>fptoui (CST to TYPE)</code>: 将浮点常量转换为相应的无符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li>
<li><code>fptosi (CST to TYPE)</code>: 将浮点常量转换为相应的有符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li>
<li><code>uitofp (CST to TYPE)</code>: 将无符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li>
<li><code>sitofp (CST to TYPE)</code>: 将有符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li>
<li><code>ptrtoint (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-ptrtoint" target="_blank" rel="noopener">ptrtoint操作</a>。</li>
<li><code>inttoptr (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-inttoptr" target="_blank" rel="noopener">inttoptr操作</a>。这个真的很危险！</li>
<li><code>bitcast (CST to TYPE)</code>: 将常数CST转换为另一个TYPE。操作数的限制与<a href="http://llvm.org/docs/LangRef.html#i-bitcast" target="_blank" rel="noopener">bitcast指令</a>的限制相同 。</li>
<li><code>addrspacecast (CST to TYPE)</code>: 将指针CST的常量指针或常量向量转换为另一个地址空间中的另一个TYPE。操作数的约束与<a href="http://llvm.org/docs/LangRef.html#i-addrspacecast" target="_blank" rel="noopener">addrspacecast指令</a>的约束相同。</li>
<li><code>getelementptr (TY, CSTPTR, IDX0, IDX1, ...)， getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr操作</a>。与<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a> 指令一样，索引列表可能有一个或多个索引，这些索引对于“指向TY的指针”类型是有意义的。</li>
<li><code>select (COND, VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-select" target="_blank" rel="noopener">选择操作</a>。</li>
<li><code>icmp COND (VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-icmp" target="_blank" rel="noopener">icmp操作</a>。</li>
<li><code>fcmp COND (VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-fcmp" target="_blank" rel="noopener">fcmp操作</a>。</li>
<li><code>extractelement (VAL, IDX)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-extractelement" target="_blank" rel="noopener">extractelement操作</a>。</li>
<li><code>insertelement (VAL, ELT, IDX)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-insertelement" target="_blank" rel="noopener">insertelement操作</a>。</li>
<li><code>shufflevector (VEC1, VEC2, IDXMASK)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-shufflevector" target="_blank" rel="noopener">shufflevector操作</a>。</li>
<li><code>extractvalue (VAL, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-extractvalue" target="_blank" rel="noopener">extractvalue操作</a>。索引列表的解释方式与“<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a>”操作中的索引类似。至少必须指定一个索引值。</li>
<li><code>insertvalue (VAL, ELT, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-insertvalue" target="_blank" rel="noopener">insertvalue操作</a>。索引列表的解释方式与“<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a>”操作中的索引类似。至少必须指定一个索引值。</li>
<li><code>OPCODE (LHS, RHS)</code>: 执行LHS和RHS常量的指定操作。操作码可以是任何<a href="http://llvm.org/docs/LangRef.html#binaryops" target="_blank" rel="noopener">二进制</a>或<a href="http://llvm.org/docs/LangRef.html#bitwiseops" target="_blank" rel="noopener">按位二进制</a>操作。操作数的限制与相应指令的限制相同（例如，不允许对浮点值进行按位操作）。</li>
</ul>
<h1 id="其他值"><a href="#其他值" class="headerlink" title="其他值"></a>其他值</h1><h2 id="内嵌汇编表达式"><a href="#内嵌汇编表达式" class="headerlink" title="内嵌汇编表达式"></a>内嵌汇编表达式</h2><p>LLVM 通过使用特殊值支持内联汇编表达式（与模块级内联汇编相反）。该值表示内联汇编程序作为模板字符串（包含要发出的指令），操作数约束列表（存储为字符串），指示内联asm表达式是否具有副作用的标志以及指示是否包含asm的函数需要保守地调整堆栈。</p>
<p>模板字符串支持使用<code>$</code>后跟一个数字的参数替换，以指示由约束字符串指定的给定寄存器/内存位置的替换。“<code>${NUM:MODIFIER}</code>”也可以使用，其中MODIFIER是如何打印操作数的特定于目标的注释（请参阅<a href="http://llvm.org/docs/LangRef.html#inline-asm-modifiers" target="_blank" rel="noopener">Asm模板参数修饰符</a>）。</p>
<p>字符<code>$</code>可以在模板中使用“<code>$$</code>”。要在输出中包含其他特殊字符，可以使用通常的“<code>\XX</code>”转义符，就像在其他字符串中一样。请注意，在模板替换之后，生成的汇编字符串将由LLVM的集成汇编器进行分析，除非它被禁用 - 即使发出<code>.s</code>文件 - 也必须包含LLVM已知的汇编语法。</p>
<p>LLVM还支持一些有用的内联汇编代码：</p>
<ul>
<li><code>${:uid}</code>：扩展为这个内联汇编blob唯一的十进制整数。在声明本地标签时，这种替换很有用。许多标准的编译器优化（如内联）可能会复制内联asm blob。添加blob唯一标识符可确保这两个标签在装配过程中不会发生冲突。这用于实现<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">GCC的％=特殊格式字符串</a>。</li>
<li><code>${:comment}</code>：扩展为当前目标的汇编方言的注释字符。这通常是<code>#</code>，但很多指标使用其他字符串，例如<code>;</code>，<code>//</code>或<code>!</code>。</li>
<li><code>${:private}</code>：扩展为汇编器专用标签前缀。带有此前缀的标签不会出现在组装对象的符号表中。通常前缀是<code>L</code>，但目标可能使用其他字符串。<code>.L</code>是比较受欢迎的。</li>
</ul>
<p>LLVM对inline asm的支持与Clang的GCC兼容的inline-asm支持的要求紧密相关。因此，这里列出的特征集以及约束和修饰符代码与GCC内联asm支持中的代码类似或相同。然而，要清楚的是，这里描述的模板和约束字符串的语法与GCC和Clang所接受的语法并不相同，并且尽管大多数约束字母是通过Clang原样传递的，但当从C源代码转换为LLVM程序集时，有些字符会被转换为其他代码。</p>
<p>一个内联汇编表达式的例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i32 (i32) asm &quot;bswap $0&quot;, &quot;=r,r&quot;</span><br></pre></td></tr></table></figure></p>
<p>内联汇编程序表达式只能用作调用(call)或调用(invoke)指令的被调用者操作数。因此，通常我们有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%X = call i32 asm &quot;bswap $0&quot;, &quot;=r,r&quot;(i32 %Y)</span><br></pre></td></tr></table></figure></p>
<p>带有在约束列表中不可见的副作用的内联asms必须标记为具有副作用。这是通过使用’sideeffect’关键字完成的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下，内联asms将包含无法工作的代码，除非堆栈以某种方式对齐，例如x86上的调用或SSE指令，但不会包含在asm中执行对齐的代码。编译器应该对asm可能包含的内容做出保守的假设，并且如果’alignstack’关键字存在，应该在序言中生成其通常的堆栈对齐代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm alignstack &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>内联asms也支持使用非标准汇编方言。假定的方言是ATT。当’<code>inteldialect</code>‘关键字存在时，内联asm使用英特尔方言。目前，ATT和Intel是唯一支持的方言。一个例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm inteldialect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>如果出现多个关键字，则’<code>sideeffect</code>‘关键字必须首先出现，’<code>alignstack</code>‘关键字第二关键字和’<code>inteldialect</code>‘关键字最后出现。</p>
<h3 id="内联汇编约束字符串"><a href="#内联汇编约束字符串" class="headerlink" title="内联汇编约束字符串"></a>内联汇编约束字符串</h3><p>约束列表是逗号分隔的字符串，每个元素包含一个或多个约束代码。</p>
<p>对于约束列表中的每个元素，将选择一个适当的寄存器或内存操作数，并且将对<code>$0</code>列表中的第一个约束，<code>$1</code>第二个等将使其可用于组件模板字符串扩展。</p>
<p>有三种不同类型的约束，它们通过约束代码前面的前缀符号进行区分：输出，输入和Clobber。必须始终按照以下顺序给出约束：先输出，然后输入，然后是clobbers。他们不能混在一起。</p>
<p>还有三种不同类型的约束代码：</p>
<ul>
<li>注册约束。这是一个寄存器类，或者是一个固定的物理寄存器。这种约束将分配一个寄存器，并且如果必要的话，将该参数或结果进行bitcast到适当的类型。</li>
<li>内存约束。这种约束用于获取内存操作数的指令。不同的约束允许目标使用不同的寻址模式。</li>
<li>立即值限制。这种约束是针对整数或其他立即值的，它可以直接渲染到指令中。各种特定于目标的约束条件允许为您希望使用的指令选择合适范围内的值。</li>
</ul>
<h4 id="输出约束"><a href="#输出约束" class="headerlink" title="输出约束"></a>输出约束</h4><p>输出约束由“<code>=</code>”前缀（例如“<code>=r</code>”）指定。这表示程序集将写入此操作数，然后操作数将作为asm表达式的返回值提供。输出约束不会消耗调用指令中的参数。（除了下面关于间接输出的内容）。</p>
<p>通常，在读取所有输入之前，预计没有输出位置被汇编表达式写入。因此，LLVM可以将相同的寄存器分配给输出和输入。如果这不安全（例如，如果程序集包含两条指令，其中第一条写入一个输出，第二条读取输入并写入第二条输出），则必须使用“<code>&amp;</code>”修饰符（例如“<code>=&amp;r</code>”）来指定输出是“早期破坏”输出。将输出标记为“<code>early-clobber</code>”可确保LLVM不会对任何输入（除了与此输出关联的输入）使用相同的寄存器。</p>
<h4 id="输入约束"><a href="#输入约束" class="headerlink" title="输入约束"></a>输入约束</h4><p><b style="color:green">输入约束没有前缀 - 只是约束代码。每个输入约束将从调用指令中消耗一个参数。asm不允许写入任何输入寄存器或存储单元（除非该输入连接到输出）。还要注意，如果LLVM可以确定它们必然都包含相同的值，则可以将多个输入全部分配给相同的寄存器。</b></p>
<p>通过提供一个整数作为约束字符串，输入约束可以将它们自己绑定到输出约束，而不是提供约束代码。被绑定的输入仍然会从调用指令中消耗一个参数，并且按照通常的方式在asm模板编号中占据一个位置 - 它们将被简单地限制为始终使用与其绑定的输出相同的寄存器。例如，一个约束字符串“<code>=r,0</code>”表示为输出分配一个寄存器，并将该寄存器用作输入（它是第<code>0</code>个约束）。</p>
<p>允许将输入连接到“早期破坏(early-clobber)”输出。在这种情况下，没有 其他输入可能与连接到早期触发器的输入共享相同的寄存器（即使其他输入具有相同的值）。</p>
<p>您只能将输入绑定到具有寄存器约束但不受内存约束的输出。只有一个输入可能与输出相关联。</p>
<p>还有一个“有趣”的特性，值得一点解释：如果寄存器类约束分配的寄存器对于作为输入提供的值类型操作数来说太小，则输入值将被分成多个寄存器，并且所有寄存器传递给内联asm。</p>
<p>但是，此功能通常不如您想象的那么有用。</p>
<p>首先，寄存器不保证连续。因此，在那些具有多条连续指令操作指令的体系结构上，这不是支持它们的适当方式。（例如，32位SparcV8具有64位加载，该指令只需要一个32位寄存器，然后硬件将加载到指定的寄存器和下一个寄存器中。内联asm的此功能对于此的支持将不会有用。）</p>
<p>几个目标提供了一个模板字符串修改，允许两寄存器操作数的第二个寄存器明确的访问（例如MIPS L，M和 D）。在这样的体系结构中，您实际上可以访问第二个已分配的寄存器（但是，仍然没有任何后续的寄存器）。但是，在这种情况下，为了清晰起见，将这个值简化为两个独立的操作数仍然可能更好。（例如，请参阅AX86 上的约束描述，尽管该特性仅用于此功能，但使用并不是一个好主意）</p>
<h4 id="间接投入和产出"><a href="#间接投入和产出" class="headerlink" title="间接投入和产出"></a>间接投入和产出</h4><p>间接输出或输入约束可以由“<code>*</code>”修饰符（在输出的情况下在“<code>=</code>”之后）指定。这表明asm将写入或读取作为输入参数提供的地址的内容。（注意，在这种方式，间接输出更像一个输入而不是输出：只是像输入，它们消耗的调用表达式的参数，而不是产生一个返回值。间接输出约束是“输出”仅是希望在asm可以写入输入内存位置的内容，而不是从中读取）。</p>
<p><b style="color:green">这通常用于内存约束，例如“<code>=*m</code>”，以将变量的地址作为值传递。</b></p>
<p>也可以使用间接寄存器约束，但仅限于输出（例如“<code>=*r</code>”）。这会导致LLVM正常地为输出值分配一个寄存器，然后在提供的内联asm之后，单独发送一个存储到作为输入提供的地址。（与在asm语句后明确写入store相比，此功能提供了什么值尚不清楚，而且它只能生成更糟糕的代码，因为它绕过了许多优化过程，我建议不要使用它。）</p>
<h4 id="Clobber约束"><a href="#Clobber约束" class="headerlink" title="Clobber约束"></a>Clobber约束</h4><p>一个clobber约束由一个“<code>~</code>”前缀表示。clobber不会消耗输入操作数，也不会生成输出。Clobbers不能使用任何一般的约束代码字母 - 它们可能只使用明确的寄存器约束，例如“<code>~{eax}</code>”。一个例外是，“<code>~{memory}</code>” 的clobber字符串表示程序集写入任意未声明的内存位置 - 不仅是由声明的间接输出指向的内存。</p>
<p>请注意，输出约束中也存在的clobbering命名寄存器是不合法的。</p>
<h4 id="约束代码"><a href="#约束代码" class="headerlink" title="约束代码"></a>约束代码</h4><p>潜在的前缀来了约束代码或代码之后。</p>
<p>约束代码可以是单个字母（例如“<code>r</code>”），“<code>^</code>”字符后跟两个字母（例如“<code>^wc</code>”）或“<code>{”寄存器名称“ }</code>”（例如“<code>{eax}</code>”）。</p>
<p>通常选择单字母和双字母约束代码与GCC的约束代码相同。</p>
<p>一个约束可能包含一个或多个约束代码，而让LLVM选择使用哪一个约束代码。这主要包括与来自clang的GCC inline asm的翻译兼容。</p>
<p>有两种方式可以指定替代方案，并且可以在内联asm约束列表中使用其中之一或两者。</p>
<ol>
<li>相互追加代码，制作约束代码集。例如“<code>im</code>”或“ <code>{eax}m</code>”。这意味着“选择集合中的任何选项”。对约束列表中的每个约束独立进行约束的选择。</li>
<li>在约束代码集之间使用“<code>|</code>”，创建替代方案。约束列表中的每个约束都必须具有相同数量的备选集。使用这种语法，约束列表中所有项目中的相同备选项将一起选择。</li>
</ol>
<p>把它们放在一起，你可能会有两个操作数约束字符串,像”<code>rm|r,ri|rm</code>“。这表明如果操作数0是r或m，则操作数1可以是r或i。如果操作数0是r，则操作数1可以是r或m。但是，操作数0和1不能都是m类型。</p>
<p>但是，不推荐使用其中任何一种替代功能，因为LLVM无法对使用哪种替代功能做出明智选择。（在当前需要选择的时候，没有足够的信息可以用聪明的方式来实现。）因此，它只是试图做出最有可能编译的选择，而不是最优性能的选择。（例如，给定“rm”，它总是选择使用内存，而不是寄存器）。而且，如果给定多个寄存器或多个寄存器类，它将简单地选择第一个。（实际上，目前它甚至不确保明确指定的物理寄存器是唯一的，因此指定多个物理寄存器作为替代，例如 {r11}{r12},{r11}{r12}，将r11分配给两个操作数，而不是所有打算的。）</p>
<h4 id="支持的约束代码列表"><a href="#支持的约束代码列表" class="headerlink" title="支持的约束代码列表"></a>支持的约束代码列表</h4><p>一般来说，约束代码的行为与GCC中的一样。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p>
<p>所有目标通常都支持一些约束代码：</p>
<ul>
<li>r：目标通用寄存器类中的寄存器。</li>
<li>m：存储器地址操作数。它支持哪些寻址模式，典型的例子是寄存器，寄存器+寄存器偏移量，或寄存器+直接偏移量（某些目标特定的大小）。</li>
<li>i：一个整数常量（目标特定宽度）。允许简单的即时或可重定位的值。</li>
<li>n：一个整数常量 - 不包括可重定位值。</li>
<li>s：一个整数常量，但只允许重定位值。</li>
<li>X：允许任何类型的操作数，不受任何限制。通常用于为asm分支或call传递标签。</li>
<li>{register-name}：需要完整的指定物理寄存器。</li>
</ul>
<p>其他约束是针对具体目标的：</p>
<p>AArch64：</p>
<ul>
<li>z：一个立即数整数0.输出WZR或者XZR视情况而定。</li>
<li>I：对一个ADD或SUB指令有效的立即整数，即0到4095，可选的移位12。</li>
<li>J：一个立即数，取反时对一个ADD或 SUB指令有效，即-1到-4095，可选左移12。</li>
<li>K：一个直接整数，它是有效的“位掩码即时32”的逻辑指令等AND，EOR或ORR与32位寄存器。</li>
<li>L：一个直接整数，它是有效的“位掩码即时64”的逻辑指令等AND，EOR或ORR与64位寄存器。</li>
<li>M：与MOV32位寄存器上的程序集别名一起使用的立即整数。这是一个超集K：除了bitmask立即数，还允许立即可以装载单个MOVZ或MOVL指令的整数 。</li>
<li>N：用于MOV64位寄存器上的程序集别名的立即整数。这是一个超集L。</li>
<li>Q：存储器地址操作数必须位于单个寄存器中（无偏移量）。（但是，LLVM目前也为m约束做了这个。）</li>
<li>r：32位或64位整数寄存器（W <em>或X </em>）。</li>
<li>w：一个32,64或128位浮点/ SIMD寄存器。</li>
<li>x：较低的128位浮点/ SIMD寄存器（V0至V15）。</li>
</ul>
<p>AMDGPU：</p>
<ul>
<li>r：32位或64位整数寄存器。</li>
<li>[0-9]v：32位VGPR寄存器，编号0-9。</li>
<li>[0-9]s：32位SGPR寄存器，编号0-9。</li>
</ul>
<p>所有ARM模式：</p>
<ul>
<li>Q，Um，Un，Uq，Us，Ut，Uv，Uy：内存地址的操作数。目前处理方式与操作数相同m。</li>
</ul>
<p>ARM和ARM的Thumb2模式：</p>
<ul>
<li>j：0到65535之间的一个立即数（有效MOVW）</li>
<li>I：对数据处理指令有效的立即整数。</li>
<li>J：一个介于-4095和4095之间的直接整数。</li>
<li>K：一个立即数，它的位反转对数据处理指令有效。（可以与模板修饰符“ B”一起使用以打印反转的值）。</li>
<li>L：一个立即整数，其否定对数据处理指令有效。（可以与模板修饰符“ n”一起使用以打印否定值）。</li>
<li>M：2的幂或0到32之间的整数。</li>
<li>N：无效的即时约束。</li>
<li>O：无效的即时约束。</li>
<li>r：一个通用的32位整数寄存器（r0-r15）。</li>
<li>l：在Thumb2模式下，低32位GPR寄存器（r0-r7）。在ARM模式下，与r。</li>
<li>h：在Thumb2模式下，一个高32位的GPR寄存器（r8-r15）。在ARM模式下，无效。</li>
<li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li>
<li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li>
<li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li>
</ul>
<p>ARM的Thumb1模式：</p>
<ul>
<li>I：0到255之间的立即数。</li>
<li>J：-255和-1之间的立即数。</li>
<li>K：0到255之间的直接整数，可选左移一定数量。</li>
<li>L：-7和7之间的立即数。</li>
<li>M：0到1020之间的整数，是4的倍数。</li>
<li>N：0到31之间的立即数。</li>
<li>O：在-508和508之间的立即数，是4的倍数。</li>
<li>r：一个低32位的GPR寄存器（r0-r7）。</li>
<li>l：一个低32位的GPR寄存器（r0-r7）。</li>
<li>h：高GPR寄存器（r0-r7）。</li>
<li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li>
<li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li>
<li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li>
</ul>
<p>Hexagon：</p>
<ul>
<li>o，v：此时存储器地址操作数，与约束一样对待m。</li>
<li>r：一个32位或64位寄存器。</li>
</ul>
<p>MSP430：</p>
<ul>
<li>r：一个8位或16位寄存器。</li>
</ul>
<p>MIPS：</p>
<ul>
<li>I：一个直接带符号的16位整数。</li>
<li>J：一个立即整数零。</li>
<li>K：一个直接无符号的16位整数。</li>
<li>L：一个直接的32位整数，其中低16位是0。</li>
<li>N：-65535和-1之间的立即数。</li>
<li>O：一个立即有符号的15位整数。</li>
<li>P：1到65535之间的立即数。</li>
<li>m：存储器地址操作数。在MIPS-SE模式下，允许一个基址寄存器加上16位立即数偏移量。在MIPS模式下，只需一个基址寄存器。</li>
<li>R：存储器地址操作数。在MIPS-SE模式下，允许一个基地址寄存器加上一个9位有符号偏移量。在MIPS模式下，与约束相同 m。</li>
<li>ZC：一个存储器地址操作数，适用于使用pref，ll或 sc在给定的子目标指令（细节有所不同）。</li>
<li>r，d， y：一个32位或64位GPR寄存器。</li>
<li>f：一个32位或64位FPU寄存器（F0-F31）或一个128位MSA寄存器（W0-W31）。在MSA寄存器的情况下，建议使用w 参数修饰符与GCC兼容。</li>
<li>c：适用于间接跳转（始终25）的32位或64位GPR寄存器 。</li>
<li>l：lo寄存器，32或64位。</li>
<li>x：无效。</li>
</ul>
<p>NVPTX：</p>
<ul>
<li>b：1位整数寄存器。</li>
<li>c或者h：一个16位整数寄存器。</li>
<li>r：一个32位整数寄存器。</li>
<li>l或者N：一个64位整数寄存器。</li>
<li>f：一个32位浮点寄存器。</li>
<li>d：一个64位的浮点寄存器。</li>
</ul>
<p>PowerPC的：</p>
<ul>
<li>I：一个直接带符号的16位整数。</li>
<li>J：直接无符号的16位整数，左移16位。</li>
<li>K：一个直接无符号的16位整数。</li>
<li>L：立即带符号的16位整数，左移16位。</li>
<li>M：大于31的立即数。</li>
<li>N：是2的精确幂的立即数。</li>
<li>O：立即整数常量0。</li>
<li>P：一个立即整型常量，其否定是一个有符号的16位常量。</li>
<li>es，o，Q，Z，Zy：一个存储器地址操作数，目前一样对待m。</li>
<li>r：32位或64位整数寄存器。</li>
<li>b：32位或64位整数寄存器，不包括R0（即 ：）R1-R31。</li>
<li>f：32位或64位浮点寄存器（F0-F31）或QPX使能时，128位或256位QPX寄存器（Q0-Q31;用于别名F寄存器）。</li>
<li>v：对于或类型，当启用QPX时，为128或256位QPX寄存器（），否则为128位altivec向量寄存器（）。4 x f324 x f64Q0-Q31V0-V31</li>
<li>y：条件寄存器（CR0-CR7）。</li>
<li>wc：CR寄存器中的单独CR位。</li>
<li>wa，wd，wf：任何128位VSX向量寄存器，从全VSX寄存器组（重叠两个浮点和向量寄存器文件）。</li>
<li>ws：来自完整的VSX寄存器组的32位或64位浮点寄存器。</li>
</ul>
<p>SPARC：</p>
<ul>
<li>I：一个立即的13位有符号整数。</li>
<li>r：一个32位整数寄存器。</li>
<li>f：SparcV8上的任何浮点寄存器或SparcV9上“低”一半寄存器中的浮点寄存器。</li>
<li>e：任何浮点寄存器。（与fSparcV8 相同。）</li>
</ul>
<p>SystemZ：</p>
<ul>
<li>I：直接无符号的8位整数。</li>
<li>J：直接无符号的12位整数。</li>
<li>K：一个直接带符号的16位整数。</li>
<li>L：一个直接签名的20位整数。</li>
<li>M：立即整数0x7fffffff。</li>
<li>Q：具有基地址和12位立即无符号位移的存储器地址操作数。</li>
<li>R：一个带有基地址的内存地址操作数，一个12位立即无符号位移和一个索引寄存器。</li>
<li>S：一个内存地址操作数，带有一个基址和一个20位立即带符号的位移。</li>
<li>T：一个带有基地址的内存地址操作数，一个20位立即带符号位移和一个索引寄存器。</li>
<li>r或者d：一个32位，64位或128位整数寄存器。</li>
<li>a：32,64或128位整数地址寄存器（不包括地址上下文中评估为0的R0）。</li>
<li>h：64位数据寄存器高位部分的32位值（LLVM专用）</li>
<li>f：一个32,64或128位浮点寄存器。</li>
</ul>
<p>X86：</p>
<ul>
<li>I：0到31之间的立即数。</li>
<li>J：0到64之间的立即数。</li>
<li>K：一个立即有符号的8位整数。</li>
<li>L：立即整数，0xff或0xffff或（仅在64位模式下）0xffffffff。</li>
<li>M：0到3之间的立即数。</li>
<li>N：直接无符号的8位整数。</li>
<li>O：0到127之间的立即数。</li>
<li>e：一个立即的32位有符号整数。</li>
<li>Z：一个立即的32位无符号整数。</li>
<li>o，v：目前处理方式与此相同m。</li>
<li>q：一个8,16,32或64位寄存器，可以作为8位 l整数寄存器访问。在X86-32，这是a，b，c，和d 寄存器，以及X86-64，它是所有的整数寄存器。</li>
<li>Q：一个8,16,32或64位寄存器，可以作为8位 h整数寄存器访问。这是a，b，c，和d寄存器。</li>
<li>r或者l：8,16,32或64位整数寄存器。</li>
<li>R：8,16,32或64位“传统”整数寄存器 - 自i386以来一直存在，并且可以在没有REX前缀的情况下访问。</li>
<li>f：一个32,64或80位’387 FPU堆栈伪寄存器。</li>
<li>y：如果启用MMX，则为64位MMX寄存器。</li>
<li>x：如果启用SSE：SSE寄存器中的32位或64位标量操作数或128位向量操作数。如果AVX也被使能，也可以是AVX寄存器中的256位向量操作数。如果AVX-512也被使能，也可以是AVX512寄存器中的512位向量操作数，否则会出错。</li>
<li>Y：同x，如果SSE2被启用，否则会出现错误。</li>
<li>A：特殊情况：首先为EAX分配EAX，然后再为EDX分配单个操作数（在32位模式下，64位整数操作数将分成两个寄存器）。不建议使用此约束，因为在64位模式下，64位操作数只会分配给RAX - 如果需要两个32位操作数，则最好在将其分配给它之前自行分割asm声明。</li>
</ul>
<p>XCore：</p>
<ul>
<li>r：一个32位整数寄存器。</li>
</ul>
<h3 id="Asm模板参数修饰符"><a href="#Asm模板参数修饰符" class="headerlink" title="Asm模板参数修饰符"></a>Asm模板参数修饰符</h3><p>在asm模板字符串中，可以在操作数引用上使用修饰符，如“<code>${0:n}</code>”。</p>
<p>一般来说，修饰符的行为与GCC中的相同。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p>
<p>目标无关的：</p>
<ul>
<li>c：不带目标特定的直接标点符号（例如无$前缀）打印一个立即的整数常量。</li>
<li>n：取消并打印立即数整数常量，不带目标特定的直接标点符号（例如无$前缀）。</li>
<li>l：打印为无标签的标签，没有特定于目标的标签标点（例如无$前缀）。</li>
</ul>
<p>AArch64：</p>
<ul>
<li>w：用w<em>名称而不是x</em>名称打印GPR寄存器。例如，而不是x30打印w30。</li>
<li>x：用x*名称打印GPR寄存器。（无论如何，这是默认的）。</li>
<li>b，h，s，d，q：打印浮点/ SIMD寄存器有 b<em>，h</em>，s<em>，d</em>，或q<em>名称，而不是默认的 v</em>。</li>
</ul>
<p>AMDGPU：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>ARM：</p>
<ul>
<li>a：打印操作数作为一个地址（[和]周围的寄存器）。</li>
<li>P： 没有效果。</li>
<li>q： 没有效果。</li>
<li>y：将VFP单精度寄存器作为索引双精度打印（例如打印d4[1]而不是s9）</li>
<li>B：按位反转并打印不带# 前缀的立即整数常量。</li>
<li>L：打印立即整数常量的低16位。</li>
<li>M：打印为适合ldm / stm的寄存器组。同时打印 指定的一个（！）后面的所有寄存器操作数，请谨慎使用。</li>
<li>Q：打印寄存器对的低位寄存器或双寄存器操作数的低位寄存器。</li>
<li>R：打印寄存器对的高位寄存器或双寄存器操作数的高位寄存器。</li>
<li>H：打印寄存器对的第二个寄存器。（在大端系统上， H相当于Q小端系统，H相当于R。）</li>
<li>e：打印NEON四路寄存器的低双字寄存器。</li>
<li>f：打印NEON四路寄存器的高位双字寄存器。</li>
<li>m：打印没有[和] 装饰的内存操作数的基址寄存器。</li>
</ul>
<p>Hexagon：</p>
<ul>
<li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li>
<li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li>
</ul>
<p>MSP430：</p>
<ul>
<li>没有额外的修饰符。</li>
</ul>
<p>MIPS：</p>
<ul>
<li>X：以十六进制形式打印一个立即数</li>
<li>x：以十六进制形式打印立即数的低16位。</li>
<li>d：以小数形式打印一个立即数。</li>
<li>m：减去一个并以十进制形式打印一个立即数。</li>
<li>z：如果立即为零，则打印$ 0，否则正常打印。</li>
<li>L：打印双寄存器操作数的低位寄存器，或打印双字存储器操作数的低位字的地址。</li>
<li>M：打印双寄存器操作数的高位寄存器，或者打印双字存储器操作数的高位字的地址。</li>
<li>D：打印双寄存器操作数的第二个寄存器，或打印双字存储器操作数的第二个字。（在大端系统上，D相当于L小端系统，D相当于 M。）</li>
<li>w： 没有效果。为了与需要此修饰符的GCC兼容才能打印W0-W31具有f 约束条件的MSA寄存器（）。</li>
</ul>
<p>NVPTX：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>PowerPC的：</p>
<ul>
<li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li>
<li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li>
<li>y：对于内存操作数，打印双寄存器X-form指令的格式化程序。（目前始终打印r0,OPERAND）。</li>
<li>U：如果内存操作数是更新形式，则打印’u’，否则不打印。（注意：LLVM不支持更新表单，所以它现在总是不会打印任何内容）</li>
<li>X：如果内存操作数是索引形式，则打印’x’。（注意：LLVM不支持索引形式，所以目前这总是不会打印任何东西）</li>
</ul>
<p>SPARC：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>SystemZ：</p>
<ul>
<li>SystemZ仅实现n，并且也不会支持任何其他目标无关的改性剂。</li>
</ul>
<p>X86：</p>
<ul>
<li>c：打印一个无用的整数或符号名称。（后者是这个典型的与目标无关的修饰符的目标特定行为）。</li>
<li>A：*在它之前用一个“ ‘ 打印一个注册名称。</li>
<li>b：打印一个8位寄存器名称（例如al）; 内存操作数不做任何事情。</li>
<li>h：打印上面的8位寄存器名称（例如ah）; 内存操作数不做任何事情。</li>
<li>w：打印16位寄存器名称（例如ax）; 内存操作数不做任何事情。</li>
<li>k：打印32位寄存器名称（例如eax）; 内存操作数不做任何事情。</li>
<li>q：打印64位寄存器名称（例如rax），如果64位寄存器可用，则返回32位寄存器名称; 内存操作数不做任何事情。</li>
<li>n：取反并打印一个未修饰的整数，或者，对于非立即整数的操作数（例如可重定位符号表达式），在操作数前面打印一个’ - ‘。（可重定位符号表达式的行为是针对此通常与目标无关的修饰符的目标特定行为）</li>
<li>H：用额外的偏移量+8打印存储器引用。</li>
<li>P：打印内存引用或操作数以用作调用指令的参数。（例如(rip)，即使它是PC相对的，也省略。）</li>
</ul>
<p>XCore：</p>
<ul>
<li>没有额外的修饰符。</li>
</ul>
<h3 id="内联Asm元数据"><a href="#内联Asm元数据" class="headerlink" title="内联Asm元数据"></a>内联Asm元数据</h3><p>包装内联asm节点的调用指令可能会附加一个“<code>!srcloc</code>”MDNode，它包含一个常量整数列表。如果存在，则当通过LLVMContext 错误报告机制报告错误时，代码生成器将使用该整数作为位置cookie值。这允许前端将内联asm中发生的后端错误与产生它的源代码关联起来。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;something bad&quot;, &quot;&quot;(), !srcloc !42</span><br><span class="line">...</span><br><span class="line">!42 = !&#123; i32 1234567 &#125;</span><br></pre></td></tr></table></figure></p>
<p>直到前端才能理解它在IR中的神奇数字。如果MDNode包含多个常量，则代码生成器将使用与发生错误的asm行相对应的那个常量。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/12/编译原理/LLVM语言参考手册(开始至高级结构)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/编译原理/LLVM语言参考手册(开始至高级结构)/" itemprop="url">LLVM语言参考手册(开始至高级结构)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T17:38:40+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文档是LLVM汇编语言的参考手册。LLVM是一种基于<a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener">静态单赋值</a>（SSA）的表现形式的语言。它提供类型安全、底层指令、灵活性以及干净地表示“所有”高级语言的能力。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><b style="color:green">LLVM代码表示被设计为以三种不同的形式使用：作为内存中编译器IR（中间码），作为磁盘上的位代码表示（适用于即时编译器进行快速加载）以及作为人可读汇编语言表达。这允许LLVM为有效的编译器的转换和分析提供强大的中间表示，同时提供调试和可视化转换的自然方式。LLVM的三种不同形式都是等价的。本文档描述了人类可读的表示形式和符号。</b></p>
<p>LLVM表示旨在轻量级和低级别，同时具有表现力，类型化和可扩展性。它的目标是成为一种“通用的IR”，通过处于足够低的水平，可以将高层次的想法清晰地映射到它（类似于微处理器是“通用IR”），允许将许多源语言映射到它们）。通过提供类型信息，LLVM可以用作优化的目标：例如，通过指针分析，可以证明C自动变量从不在当前函数之外访问，从而允许将它提升为简单的SSA值而不是一个内存位置。</p>
<h2 id="良好的格式"><a href="#良好的格式" class="headerlink" title="良好的格式"></a>良好的格式</h2><p>重要的是要注意，本文档描述了“良好格式”的LLVM汇编语言。 解析器接受什么和被认为是“良好格式”之间是有区别。例如，下面的指令在语法上没问题，但不是良好形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%x = add i32 1, %x</span><br></pre></td></tr></table></figure></p>
<p>因为<code>％x</code>的定义并不控制它的所有用途。 LLVM基础架构提供了一个验证过程，可用于验证LLVM模块是否格式良好。在解析输入的汇编程序之后和优化程序在输出bitcode之前，该过程由解析器自动运行。验证程序验证过程中指出的违规暗示转换过程中的错误或输入到解析器中的错误。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>LLVM标识符有两种基本类型：全局和本地。全局标识符（函数，全局变量）以<code>&#39;@&#39;</code>字符开头。本地标识符（寄存器名称，类型）以<code>&#39;%&#39;</code>字符开头 。此外，有三种不同的标识符格式，用于不同的目的：</p>
<ol>
<li>命名值用一串字符和前缀表示。例如<code>%foo</code>，<code>@DivisionByZero</code>， <code>%a.really.long.identifier</code>。实际使用的正则表达式是 <code>&#39;[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*&#39;</code>。在名称中需要其他字符的标识符可以用引号包裹起来。通过使用<code>&quot;\xx&quot;</code>，特殊字符可以被转义，<code>xx</code>是ASCII代码的十六进制字符的表示。这样，任何字符都可以用于名称值，甚至可以引用它们自己。全局变量可以使用前缀”\01”来阻止截断。</li>
<li>未命名的值用前缀表示为无符号数值。例如<code>%12</code>，<code>@2</code>，<code>%44</code>。</li>
<li>常量，在下面的<a href="http://llvm.org/docs/LangRef.html#constants" target="_blank" rel="noopener">常量</a>章节中进行了介绍。</li>
</ol>
<p>LLVM要求值以一个前缀开始，原因有两个：编译器不需要担心名称与保留字的冲突，并且保留字的集合可能在将来被扩展而不会产生什么不利。此外，未命名标识符允许编译器快速创建临时变量，而不必设法避免符号表冲突。</p>
<p>LLVM中的保留字与其他语言中的保留字非常相似。对于不同的操作码（<code>&#39;add&#39;</code>，<code>&#39;bitcast&#39;</code>，<code>&#39;ret&#39;</code>等等），对于原始类型名称（<code>&#39;void&#39;</code>，<code>&#39;i32&#39;</code>等等），以及其他的关键字。这些保留字不能与变量名冲突，因为它们都没有以前缀字符（<code>&#39;%&#39;</code>或<code>&#39;@&#39;</code>）开始。</p>
<p>以下是将整数变量“%X’乘以8的LLVM代码示例：<br>简单的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = mul i32 %X, 8</span><br></pre></td></tr></table></figure></p>
<p>减少强度之后（也是最推荐的方式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = shl i32 %X, 3</span><br></pre></td></tr></table></figure></p>
<p>最复杂的方式是(很有意思)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = add i32 %X, %X           ; yields i32:%0</span><br><span class="line">%1 = add i32 %0, %0           ; yields i32:%1</span><br><span class="line">%result = add i32 %1, %1</span><br></pre></td></tr></table></figure></p>
<p><code>%X</code>乘以8的最后一种方式说明了LLVM的几个重要的词法特征：</p>
<ol>
<li>注释用分号<code>&#39;;&#39;</code>分隔，直到行尾。</li>
<li>当计算结果未分配给指定命名值时，将创建未命名的临时对象。</li>
<li>未命名的临时对象按序号进行编号（使用预处理函数递增计数器，从0开始）。<b style="color:green">请注意，此编号中包含基本块和未命名的函数参数。例如，如果基本块入口没有给出标签名称并且所有函数参数都被命名，则它将得到编号0。</b></li>
</ol>
<p>它也显示了我们在本文件中遵循的惯例。在展示说明时，我们将按照说明书的注释来说明所产生值的类型和名称。</p>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>LLVM程序由<code>Module&#39;s</code>组成，每个模块都是输入程序的翻译单元。每个模块由函数，全局变量和符号表入口（symbol table entries）组成。模块可以与LLVM链接器组合在一起，LLVM链接器合并函数（和全局变量）定义，解析前置声明并合并符号表入口。以下是“hello world”模块的示例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Declare the string constant as a global constant.</span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; External declaration of the puts function</span></span><br><span class="line"><span class="comment">declare i32 @puts(i8* nocapture) nounwind</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Definition of main function</span></span><br><span class="line"><span class="comment">define i32 @main() &#123;   ; i32()*</span></span><br><span class="line"><span class="comment">  ; Convert [13 x i8]* to i8*...</span></span><br><span class="line"><span class="comment">  %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ; Call puts function to write out the string to stdout.</span></span><br><span class="line"><span class="comment">  call i32 @puts(i8* %cast210)</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Named metadata</span></span><br><span class="line"><span class="comment">!0 = !&#123;i32 42, null, !"string"&#125;</span></span><br><span class="line"><span class="comment">!foo = !&#123;!0&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子由一个名为<code>.str</code>的<a href="http://llvm.org/docs/LangRef.html#globalvars" target="_blank" rel="noopener">全局变量</a>，<code>“puts”</code>函数的外部声明，<code>&quot;main&quot;</code>的<a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数定义</a>和<code>”foo“</code>的<a href="http://llvm.org/docs/LangRef.html#namedmetadatastructure" target="_blank" rel="noopener">命名元数据</a>组成。</p>
<p><b style="color:green">通常，模块由全局值列表组成（其中函数和全局变量都是全局值）。全局值由指向内存位置的指针表示（在本例中，指向char数组的指针和指向函数的指针），并且具有以下<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>之一。</b></p>
<h3 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a><a href="https://msdn.microsoft.com/zh-cn/library/0yw6at8e.aspx" target="_blank" rel="noopener">链接类型</a></h3><p>所有全局变量和函数都具有以下链接类型之一：</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>具有<code>“private”</code>连接的全局值只能由当前模块中的对象直接访问。特别是，将代码链接到具有private全局值的模块中可能会导致private变量重新命名以避免冲突。由于符号对模块是私有的，因此所有引用都可以更新。这不会在对象文件的任何符号表中显示。</p>
<h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>与私有类似，但该值在对象文件中显示为本地符号（STB_LOCAL在ELF的情况下）。这就像<code>C</code>中的<code>&#39;static&#39;</code>关键字。</p>
<h4 id="available-externally"><a href="#available-externally" class="headerlink" title="available_externally"></a>available_externally</h4><p>具有<code>“available_externally”</code>链接的全局程序永远不会被发送到对应于LLVM模块的目标文件中。从链接器的角度来看，<code>available_externally</code>全局相当于external声明。它们的存在是为了允许内联和其他优化在知道全局变量（函数或语句块）的定义的情况下发生，这被称为模块之外的某个地方。具有<code>available_externally</code>链接的全局值可以随意丢弃，并允许内联和其他优化。这种连接类型只允许定义，而不允许声明。</p>
<h4 id="linkonce"><a href="#linkonce" class="headerlink" title="linkonce"></a>linkonce</h4><p><code>linkonce</code>连接的全局值在链接发生时，可以与其他同名的全局值合。这可以用来实现某些形式的内联函数，模板（templates）或其他代码，这些代码必须在使用它的每个翻译单元中生成，但是稍后可能会在更明确的定义中覆盖正文。未引用的<code>linkonce</code>全局变量允许被丢弃。请注意，<code>linkonce</code>链接实际上并不允许优化器将此函数的主体内联到调用者中，因为它不知道该函数的定义是否是程序中的权威定义，或者是否会被更强的定义覆盖。要启用内联和其他优化器，请使用<code>“linkonce_odr”</code>链接。</p>
<h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><p><code>“weak”</code>链接具有与<code>linkonce</code>链接相同的合并语义，除了未引用<code>weak</code>链接的全局可能不会被丢弃。这用于在C源代码中声明为<a href="http://www.cnblogs.com/hgfrzh/p/4064098.html" target="_blank" rel="noopener"><code>weak</code></a>的全局变量。</p>
<h4 id="common"><a href="#common" class="headerlink" title="common"></a>common</h4><p><code>common</code>连接与<code>weak</code>连接最为相似，但它们用于C中的临时定义，例如：全局作用域的<code>int x</code>。带有<code>common</code>连接的符号与<code>weak</code>是相同的方式合并；如果未引用<code>common</code>符号，它们可能不会被删除。<code>common</code>符号可能没有明确的部分，必须具有零初始化器，并且可能未被标记为“<code>constant</code>”。函数和别名可能没有共同的连接。</p>
<h4 id="appending"><a href="#appending" class="headerlink" title="appending"></a>appending</h4><p>“<code>appending</code>”链接可能只适用于指向数组类型的全局变量。当两个具有appending链接的全局变量链接在一起时，这两个全局数组被附加在一起。这是LLVM类型安全的，当<code>.o</code>文件被链接时，系统链接器将具有相同的名称的<code>“sections”</code>附加在一起。</p>
<p>不幸的是，这不符合<code>.o</code>文件中的任何特性，所以它只能用于像<code>llvm.global_ctors</code>的变量，<code>llvm</code>专门解释这样的变量。</p>
<h4 id="extern-weak"><a href="#extern-weak" class="headerlink" title="extern_weak"></a>extern_weak</h4><p>这个链接的语义遵循<code>ELF</code>目标文件模型：符号在链接之前是弱的，如果不链接，符号变为空，而不是未定义的引用。</p>
<h4 id="linkonce-odr，-weak-odr"><a href="#linkonce-odr，-weak-odr" class="headerlink" title="linkonce_odr， weak_odr"></a><code>linkonce_odr</code>， <code>weak_odr</code></h4><p>有些语言允许合并不同的全局变量，比如两个具有不同语义的函数。其他语言，例如C++，确保只有等效的全局变量被合并（“一个定义规则(one definition rule)” - “ODR”）。这些语言可以使用<code>linkonce_odr</code>和<code>weak_odr</code>连接类型来表示全局将仅与等效的全局变量合并。对于其他不支持<code>ODR</code>的语言，这些链接类型与其<code>非odr</code>的链接相同。</p>
<h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>如果没有使用上述标识符，则全局变量是外部可见的，这意味着它参与链接并可用于解析外部符号引用。</p>
<p><b style="color:red">对于函数声明，除<code>external</code>或<code>extern_weak</code>之外的任何链接类型都是非法的。</b></p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">调用约定</a></h3><p>LLVM<a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数(functions)</a>，<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener">调用(calls)</a>和 <a href="http://llvm.org/docs/LangRef.html#i-invoke" target="_blank" rel="noopener">调用(invokes)</a>都可以为该调用指定一个可选的调用约定。任何一对动态<code>调用者(caller)/被调用者(callee)</code>的调用约定都必须匹配，否则程序的行为是未定义的。<b style="color:green">LLVM支持以下调用约定，未来还可能添加更多调用约定：</b></p>
<h4 id="ccc-C调用约定"><a href="#ccc-C调用约定" class="headerlink" title="ccc - C调用约定"></a><code>ccc</code> - <a href="https://blog.csdn.net/fly2k5/article/details/544112" target="_blank" rel="noopener">C调用约定</a></h4><p>这个调用约定（如果没有指定其他调用约定，则默认是这个调用约定）匹配目标C调用约定。这个调用约定支持可变参数函数调用，并且允许在声明的原型和实现的函数声明中存在一些不匹配（就像普通的C一样）。</p>
<h4 id="“fastcc”-快速调用约定"><a href="#“fastcc”-快速调用约定" class="headerlink" title="“fastcc” - 快速调用约定"></a>“<code>fastcc</code>” - 快速调用约定</h4><p>这个调用约定试图尽可能快地进行调用（例如通过在寄存器中传递参数）。这个调用约定允许目标使用任何想要为目标生成快速代码的技巧，而不必遵守外部指定的<code>ABI</code>（应用程序二进制接口）。<a href="http://llvm.org/docs/CodeGenerator.html#id80" target="_blank" rel="noopener">只有在使用此调用约定、<code>GHC</code>调用约定或<code>HiPE</code>调用约定时，才能<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener"><b style="color:red">优化尾部调用</b></a></a>。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。</p>
<h4 id="“coldcc”-冷调用约定"><a href="#“coldcc”-冷调用约定" class="headerlink" title="“coldcc” - 冷调用约定"></a>“<code>coldcc</code>” - 冷调用约定</h4><p>这个调用约定尝试在调用不是共同执行的条件下尽可能高效地在调用者中编写代码。因此，这些调用通常会保留所有的寄存器，以便调用不会破坏调用方的任何实时范围（live range）。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。此外，内联器不考虑这种内联函数调用。</p>
<h4 id="“cc-10”-GHC约定"><a href="#“cc-10”-GHC约定" class="headerlink" title="“cc 10” - GHC约定"></a>“<code>cc 10</code>” - <code>GHC</code>约定</h4><p>这个调用约定专门供<a href="http://www.haskell.org/ghc" target="_blank" rel="noopener">格拉斯哥Haskell编译器（GHC）</a>使用。它在寄存器中的传递所有内容，通过禁用被调用者保存寄存器来达到极限。这种调用约定不应该被轻率使用，而只能用于特定情况下，例如替代实现函数式编程语言时经常使用的寄存器锁定性能技术。目前只有X86支持这种约定，它有以下限制：</p>
<ul>
<li>在X86-32上最多只支持4位类型参数。不支持浮点类型。</li>
<li>在X86-64上最多只支持10位类型参数和6个浮点参数。</li>
</ul>
<p>这种调用约定支持<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾部调用优化</a>，但要求主调方和被调方都在使用它。</p>
<h4 id="“cc-11”-HiPE调用约定"><a href="#“cc-11”-HiPE调用约定" class="headerlink" title="“cc 11” - HiPE调用约定"></a>“<code>cc 11</code>” - <code>HiPE</code>调用约定</h4><p>该调用约定专门用于<a href="http://www.it.uu.se/research/group/hipe/" target="_blank" rel="noopener">高性能Erlang（HiPE）</a>编译器，即<a href="http://www.erlang.org/download.shtml" target="_blank" rel="noopener">爱立信开源Erlang/OTP系统</a>的本地代码编译器。它比通常的C调用约定使用更多的寄存器进行参数传递，并且不定义被调者使用的保存寄存器。调用约定正确支持<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾部调用优化</a>，但要求调用者和被调用者都使用它。它使用寄存器固定机制，与<code>GHC</code>调用约定类似，用于将频繁访问的运行时组件固定到特定的硬件寄存器。目前只有X86支持这种约定（32位和64位）。</p>
<h4 id="“webkit-jscc”-WebKit的JavaScript调用约定"><a href="#“webkit-jscc”-WebKit的JavaScript调用约定" class="headerlink" title="“webkit_jscc” - WebKit的JavaScript调用约定"></a>“<code>webkit_jscc</code>” - WebKit的JavaScript调用约定</h4><p>此调用约定已针对<a href="https://trac.webkit.org/wiki/FTLJIT" target="_blank" rel="noopener">WebKit FTL JIT</a>实施。它将堆栈上的参数从右向左传递（如<code>cdecl</code>那样），并在平台的惯用返回寄存器中返回一个值。</p>
<h4 id="“anyregcc”-代码修补的动态调用约定"><a href="#“anyregcc”-代码修补的动态调用约定" class="headerlink" title="“anyregcc” - 代码修补的动态调用约定"></a>“<code>anyregcc</code>” - 代码修补的动态调用约定</h4><p>这是一个特殊的约定，它支持在调用点增补任意代码序列。这个约定强制调用参数进入寄存器，但允许它们动态分配。目前只能用于调用<code>llvm.experimental.patchpoint</code>，因为只有这个内部函数将其参数的位置记录在旁边表中。请参阅<a href="http://llvm.org/docs/StackMaps.html" target="_blank" rel="noopener">LLVM中的堆栈映射和修补程序点</a>。</p>
<h4 id="“preserve-mostcc”-PreserveMost调用约定"><a href="#“preserve-mostcc”-PreserveMost调用约定" class="headerlink" title="“preserve_mostcc” - PreserveMost调用约定"></a>“<code>preserve_mostcc</code>” - <code>PreserveMost</code>调用约定</h4><p>此调用约定会尽可能使调用方中的代码尽可能是非侵入性的。该约定的行为与C 调用约定的参数和返回值的传递方式相同，但它使用了一组不同的调用方/被调用方保存的寄存器。<b style="color:green">这减轻了在调用者调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</b></p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。浮点寄存器（<code>XMMs/YMMs</code>）不会保留，需要由调用者保存。</li>
</ul>
<p>这个约定背后的想法是支持对具有热路径和冷路径的运行时（Runtime）函数调用。<b style="color:green">热路径通常是一小段不使用多个寄存器的代码。冷路径可能需要调用另一个函数，因此只需要保留调用者保存的寄存器，这些寄存器还未被调用者保存</b>。就调用者/被调用者保存的寄存器方面，<code>PreserveMost</code>调用约定是与冷（cold）调用约定非常相似的，但它们用于不同类型的函数调用。<code>coldcc</code>适用于很少执行的函数调用，而<code>preserve_mostcc</code>函数调用旨在处于热路径上，并且相对执行更多一些。此外<code>preserve_mostcc</code>不会阻止内联器的内联函数调用。</p>
<p>这个调用约定将被未来版本的ObjectiveC运行时使用，因此此时应该仍被认为是实验性的。虽然此惯例是为了优化对ObjectiveC运行时的某些运行时调用而创建的，但它并不局限于此运行时，并且在将来也可能会被其他运行时使用。目前的实现只支持X86-64，但其目的是在未来支持更多架构。</p>
<h4 id="“preserve-allcc”-PreserveAll调用约定"><a href="#“preserve-allcc”-PreserveAll调用约定" class="headerlink" title="“preserve_allcc” - PreserveAll调用约定"></a>“<code>preserve_allcc</code>” - <code>PreserveAll</code>调用约定</h4><p>此调用约定会尝试使调用方中的代码比<code>PreserveMost</code>调用约定更不具侵入性。此调用约定的行为与C调用约定的参数和返回值的传递方式相同，但它使用一组不同的调用方/被调用方保存的寄存器。这消除了在调用者的调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。此外，它还保留所有浮点寄存器（<code>XMM/YMM</code>）。</li>
</ul>
<p>这个约定背后的想法是支持对不需要调用任何其他函数的运行时(Runtime)函数的调用。</p>
<p>此调用约定与<code>PreserveMost</code>调用约定一样，将被未来版本的ObjectiveC运行时使用，此时应视为实验性的。</p>
<h4 id="“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定"><a href="#“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定" class="headerlink" title="“cxx_fast_tlscc” - 访问函数的CXX_FAST_TLS调用约定"></a>“<code>cxx_fast_tlscc</code>” - 访问函数的<code>CXX_FAST_TLS</code>调用约定</h4><p>Clang生成一个访问函数来访问C++风格的TLS。访问函数通常有一个入口块，一个出口块和一个初次运行的初始化块。入口和出口块可以访问一些TLS IR变量，每个访问将被降低到平台特定的序列。</p>
<p>此调用约定旨在通过保留尽可能多的寄存器（所有寄存器保存在快速路径中，由入口和出口块组成）来尽量减少调用者的开销。</p>
<p>这个调用约定的行为与C调用约定在参数和返回值的传递方式上是一样的，但它使用了一组不同的调用者/被调用者保存的寄存器。</p>
<p>鉴于每个平台都有自己的降序序列，因此它有自己的一组保存的寄存器，所以我们不能使用现有的<code>PreserveMost</code>。</p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>RDI</code>和<code>RAX</code>除外。</li>
</ul>
<h4 id="“swiftcc”-这个调用约定用于Swift语言。"><a href="#“swiftcc”-这个调用约定用于Swift语言。" class="headerlink" title="“swiftcc” - 这个调用约定用于Swift语言。"></a>“<code>swiftcc</code>” - 这个调用约定用于Swift语言。</h4><ul>
<li>在X86-64上，<code>RCX</code>和<code>R8</code>可用于额外的整数返回，并且<code>XMM2</code>和<code>XMM3</code>可用于其他<code>FP/vector</code>返回。</li>
<li>在iOS平台上，我们使用<code>AAPCS-VFP</code>调用约定。<br>“<code>cc &lt;n&gt;</code>” - 编号调用约定<br>任何调用约定都可以用数字指定，从而允许使用特定于目标的调用约定。目标特定调用约定从64开始。</li>
</ul>
<p>可以根据需要添加/定义更多调用约定，以支持<code>Pascal</code>约定或任何其他众所周知的目标独立的调用约定。</p>
<h3 id="可见性风格"><a href="#可见性风格" class="headerlink" title="可见性风格"></a>可见性风格</h3><p>所有全局变量和函数都具有以下可见性样式之一：</p>
<h4 id="“default”-默认风格"><a href="#“default”-默认风格" class="headerlink" title="“default” - 默认风格"></a>“<code>default</code>” - 默认风格</h4><p>在使用<a href="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html" target="_blank" rel="noopener">ELF（Executable and Linking Format,可执行文件）</a>对象文件格式的目标上，默认可见性意味着该声明对其他模块可见，并且在共享库中，意味着声明的实体可能被覆盖。在Darwin上，default可见性意味着该声明对其他模块可见。default可见性对应于语言中的“外部链接”。</p>
<h4 id="“hidden”-隐藏的风格"><a href="#“hidden”-隐藏的风格" class="headerlink" title="“hidden” - 隐藏的风格"></a>“<code>hidden</code>” - 隐藏的风格</h4><p>具有隐藏可见性的对象的两个声明指向同一个对象，如果它们在同一个共享对象中。通常，隐藏的可见性表示该符号不会被放入动态符号表中，因此其他模块（可执行文件或共享库）不能直接引用它。</p>
<h4 id="“protected”-受保护的风格"><a href="#“protected”-受保护的风格" class="headerlink" title="“protected” - 受保护的风格"></a>“<code>protected</code>” - 受保护的风格</h4><p>在<a href="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html" target="_blank" rel="noopener">ELF</a>上，protected可见性表示该符号将被放置在动态符号表中，但定义的模块内的引用将绑定到本地符号。也就是说，该符号不能被另一个模块覆盖。</p>
<p>带有<code>internal</code>或<code>private</code>链接类型的符号必须具有<code>default</code>可见性。</p>
<h3 id="DLL存储类"><a href="#DLL存储类" class="headerlink" title="DLL存储类"></a>DLL<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B1%BB/10420072" target="_blank" rel="noopener">存储类</a></h3><p>所有全局变量，函数和别名都可以具有以下DLL存储类之一：</p>
<h4 id="dllimport"><a href="#dllimport" class="headerlink" title="dllimport"></a><a href="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx" target="_blank" rel="noopener"><code>dllimport</code></a></h4><p>“<code>dllimport</code>”会导致编译器通过全局指针引用函数或变量，该全局指针指向由导出符号的DLL设置的指针。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。</p>
<h4 id="dllexport"><a href="#dllexport" class="headerlink" title="dllexport"></a><a href="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx" target="_blank" rel="noopener"><code>dllexport</code></a></h4><p>“<code>dllexport</code>”会导致编译器提供一个指向DLL中的指针的全局指针，以便它可以引用<code>dllimport</code>属性。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。由于这个存储类是为了定义dll接口而存在，因此编译器，汇编器和链接器知道它是从外部引用的，并且不会删除该符号。</p>
<p>其实这个指令是用来加载动态链接库，相关的信息可以查看：<a href="https://stackoverflow.com/questions/3586023/dllimport-doesnt-work-as-advertised-in-mono-linux-c" target="_blank" rel="noopener">DllImport doesn’t work as advertised in Mono (Linux, C#)</a></p>
<h3 id="线程局部存储-TLS-模型"><a href="#线程局部存储-TLS-模型" class="headerlink" title="线程局部存储(TLS)模型"></a>线程局部存储(TLS)模型</h3><p><b style="color:green">一个变量可以被定义为<a href="http://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener"><code>thread_local</code></a>，这意味着它不会被线程共享（每个线程将有一个变量的分离副本）</b>。并非所有的目标机都支持线程局部变量。可选地，可以指定<a href="https://docs.oracle.com/cd/E19253-01/819-7050/6n918j8o0/index.html" target="_blank" rel="noopener">TLS模型</a>：</p>
<ul>
<li><code>localdynamic</code>: 对于仅在当前共享库中使用的变量。</li>
<li><code>initialexec</code>: 对于模块中不会动态加载的变量。</li>
<li><code>localexec</code>: 对于在可执行文件中定义的变量，只能在其中使用。</li>
</ul>
<p>如果没有给出显式模型，则使用“general dynamic”模型。</p>
<p>这些模型对应于ELF TLS模型; 请参阅<a href="http://people.redhat.com/drepper/tls.pdf" target="_blank" rel="noopener">ELF对thread_local存储的处理</a>获取更多信息，在这篇文章中提到的不同的场景下可能使用不同的模型。如果指定的TLS模型不受支持，或者可以选择一个更好的模型，则目标机可能会选择不同的TLS模型。</p>
<p>模型也可以在别名中指定，但它只能控制别名的访问方式。这对使用别名的地方不会有任何影响。</p>
<p>对于没有ELF TLS模型链接器支持的平台，<code>-femulated-tls</code>标志可用于生成GCC兼容的模拟TLS代码。</p>
<h3 id="运行时抢占说明"><a href="#运行时抢占说明" class="headerlink" title="运行时抢占说明"></a>运行时抢占说明</h3><p>全局变量，函数和别名可以有一个可选的运行时抢占说明符。如果没有明确给出抢先说明符，则假定符号是<code>dso_preemptable</code>。</p>
<h4 id="dso-preemptable"><a href="#dso-preemptable" class="headerlink" title="dso_preemptable"></a><code>dso_preemptable</code></h4><p>表示在运行时，可以用链接单元外部的符号替换该函数或变量。</p>
<h4 id="dso-local"><a href="#dso-local" class="headerlink" title="dso_local"></a><code>dso_local</code></h4><p>编译器可以假定标记为<code>dso_local</code>的函数或变量将解析为相同链接单元中的符号。即使定义不在此编译单元中，也会生成直接访问。</p>
<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>LLVM IR（中间码）允许您指定“可识别（identified）”和“文字（Literal）”<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构类型</a>。文字类型在结构上是独一无二的，但是identified类型从来都不是独一无二的。一个<a href="http://llvm.org/docs/LangRef.html#t-opaque" target="_blank" rel="noopener">不透明的结构类型</a>也可以用来向前声明一个还不能使用的类型。</p>
<p>identified（可识别的）结构规范的一个例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mytype = type &#123; %mytype*, i32 &#125;</span><br></pre></td></tr></table></figure></p>
<p>在LLVM 3.0发布之前，identified类型在结构上是独一无二的。在最新版本的LLVM中，只有文字类型是唯一的。</p>
<h3 id="非整型指针类型"><a href="#非整型指针类型" class="headerlink" title="非整型指针类型"></a>非整型指针类型</h3><p>注意：非整型指针类型是正在进行的工作，并且此时它们应该被认为是实验性的。</p>
<p>LLVM IR可选地允许前端通过<a href="http://llvm.org/docs/LangRef.html#langref-datalayout" target="_blank" rel="noopener">数据布局字符串</a>将某些地址空间中的指针表示为“非整数” 。非整型指针类型表示具有未指定的按位表示的指针; 也就是说，完整性表示可能是目标机相关的或不稳定（不由固定整数支持）。</p>
<p><code>inttoptr</code>指令将整数转换为非整型指针类型的ptrtoint指令是错误类型(ill-typed)的，<code>ptrtoint</code>指令将非整型指针类型的值转换为整数。所述指令的矢量版本也是不正确的(ill-typed)。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量定义了编译时分配的内存区域，而不是运行期。</p>
<p>全局变量定义必须被初始化。</p>
<p>其他编译单元中的全局变量也可以声明，在这种情况下，它们没有初始化程序。</p>
<p>无论是全局变量定义还是声明都可以有一个显式的部分放在里面，并且可以有一个可选的显式对齐。如果变量声明的显式或推断区段信息与其定义之间存在不匹配，则结果行为未定义。</p>
<p>一个变量可以被定义为一个全局<code>constant</code>，它表示变量的内容永远不会被修改（开启更好的优化，允许全局数据被放置在可执行文件的只读部分等）。请注意，需要运行时初始化的变量不能标记<code>constant</code>,因为变量在存储区中。</p>
<p>LLVM明确允许将全局变量的声明标记为常量，即使全局变量的定义中没有指定。此功能可用于对程序进行稍微更好的优化，但需要语言定义以保证基于“constantness”的优化对于在定义中不包含<code>constant</code>的编译单元有效。</p>
<p>作为SSA（静态单赋值）值，全局变量定义了程序中所有基本块的范围内的指针值（即它们是可控的）。全局变量总是定义一个指向其“内容”类型的指针，因为它们描述了一个内存区域，并且LLVM中的所有内存对象都是通过指针访问的。</p>
<p>全局变量可以用<code>unnamed_addr</code>来标记，表示地址不重要，只有内容。如果它们具有相同的初始化程序，标记为<code>unnamed_addr</code>的常量可以与其他常量合并。请注意，一个具有显着地址的常量可以与一个<code>unnamed_addr</code>常量合并，结果是一个地址明确的(significant)常量。</p>
<p>如果给出<code>local_unnamed_addr</code>属性，则这个属性的地址在模块内是不明确的。</p>
<p>全局变量可能被声明为驻留在特定目标机的编号地址空间中。对于支持它们的目标机，地址空间可能会影响优化的执行方式，可能也会影响使用什么目标机指令访问变量。默认地址空间为零。地址空间限定符必须在任何其他属性之前。</p>
<p>LLVM允许为全局指定显式部分（section）。如果目标机支持它，它会将globals发送到指定的section。此外，如果目标机有必要的支持，全局变量可以放在一个comdat中。</p>
<p>外部声明可能有明确的section指定。对于使用此信息的目标机器，section信息保留在LLVM IR中。将section信息附加到外部声明是一个断言，其定义位于指定的section。如果定义位于不同的section，则行为是未定义的。</p>
<p>默认情况下，全局初始化器通过假设在全局初始化器开始之前在模块内定义的全局变量未从其初始值修改而得到优化。即使对于可能从模块外部访问的变量（包括具有外部链接的或者出现在<code>@llvm.used</code>或<code>dllexported</code>中的变量）也是如此。这个假设可以通过将变量标记为<code>externally_initialized</code>来消除。</p>
<p>可以为全局变量指定明确的<a href="http://www.cnblogs.com/bakari/archive/2012/10/23/2734772.html" target="_blank" rel="noopener">对齐方式</a>，它必须是2的幂。如果不存在，或者如果对齐方式设置为零，则全局对齐由目标机器设置为任何方便的方式。如果指定了明确的对齐，则全局被强制完全按照指定的对齐方式。如果全局变量具有分配的section，则不允许目标机和优化器过度对齐（over-align）全局变量。在这种情况下，额外的对齐方式可以被观察到：例如，代码可以假定全局变量被密集包装在它们的section中，并尝试将它们作为数组进行迭代，对齐填充将会破坏这个迭代。最大对齐是<code>1 &lt;&lt; 29</code>.</p>
<p>全局变量还可以具有<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时抢占说明符</a>，可选的<a href="http://llvm.org/docs/LangRef.html#glattrs" target="_blank" rel="noopener">全局属性</a>和可选的附加<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>列表。</p>
<p>变量和别名可以有一个<a href="http://llvm.org/docs/LangRef.html#tls-model" target="_blank" rel="noopener">线程本地存储模型</a>。</p>
<p><b style="color:red">句法(这个例子要好好学习，也包含了上面的知识)：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@&lt;GlobalVarName&gt; = [Linkage] [PreemptionSpecifier] [Visibility]</span><br><span class="line">                   [DLLStorageClass] [ThreadLocal]</span><br><span class="line">                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]</span><br><span class="line">                   [ExternallyInitialized]</span><br><span class="line">                   &lt;global | constant&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]</span><br><span class="line">                   [, section &quot;name&quot;] [, comdat [($name)]]</span><br><span class="line">                   [, align &lt;Alignment&gt;] (, !name !N)*</span><br></pre></td></tr></table></figure></p>
<p>例如，下面在带有初始值设定项，节(section)和对齐的编号地址空间中定义全局变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = addrspace(5) constant float 1.0, section &quot;foo&quot;, align 4</span><br></pre></td></tr></table></figure></p>
<p>以下示例仅声明一个全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = external global i32</span><br></pre></td></tr></table></figure></p>
<p><b style="color:green">以下示例使用<code>initialexec</code>TLS模型定义了一个thread-local全局变量：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = thread_local(initialexec) global i32 0, align 4</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>LLVM函数定义包括了“的define”关键字，可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时间抢占标识符</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见风格</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#callingconv" target="_blank" rel="noopener">调用约定</a>，一个可选的<code>unnamed_addr</code>属性，返回类型，可选的返回类型<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>，函数名称，（可能为空的）参数列表（每个参数都带有可选的<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>），可选的<a href="http://llvm.org/docs/LangRef.html#fnattrs" target="_blank" rel="noopener">函数属性</a>，可选的section(节)，可选的对齐，可选的<a href="http://llvm.org/docs/LangRef.html#langref-comdats" target="_blank" rel="noopener">comdat</a>，可选的<a href="http://llvm.org/docs/LangRef.html#gc" target="_blank" rel="noopener">垃圾收集器名称</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prefixdata" target="_blank" rel="noopener">前缀</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prologuedata" target="_blank" rel="noopener">序言</a>，可选的<a href="http://llvm.org/docs/LangRef.html#personalityfn" target="_blank" rel="noopener">个性</a>，附加<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>的可选列表，开启大括号，基本块列表以及关闭大括号。</p>
<p>LLVM函数声明由“<code>declare</code>”关键字，可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#callingconv" target="_blank" rel="noopener">调用约定</a>，可选的<code>unnamed_addr</code>或<code>local_unnamed_addr</code>属性，返回类型，返回类型的可选<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>，函数名称，可能为空的参数列表，可选的对齐方式，可选的<a href="http://llvm.org/docs/LangRef.html#gc" target="_blank" rel="noopener">垃圾收集器名称</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prefixdata" target="_blank" rel="noopener">前缀</a>以及可选的<a href="http://llvm.org/docs/LangRef.html#prologuedata" target="_blank" rel="noopener">序言</a>。</p>
<p>一个函数定义包含一个基本块列表，形成该函数的<code>CFG</code>（控制流图）。每个基本块可以有选择地以一个标签开始（赋予基本块一个符号表入口），包含指令列表，并以<a href="http://llvm.org/docs/LangRef.html#terminators" target="_blank" rel="noopener">终止</a>指令（如分支或函数返回）结束。如果未提供显式标签，一个块被赋值给一个隐含的编号标签，编号使用从计数器中返回下一个值，就像用于未命名的临时对象那样（<a href="http://llvm.org/docs/LangRef.html#identifiers" target="_blank" rel="noopener">参见上文</a>）。例如，如果函数入口块没有明确的标签，则会分配标签“<code>％0</code>”，那么该块中的第一个未命名的临时块将为“<code>％1</code>”，以此类推。</p>
<p>函数中的第一个基本块在两个方面是特殊的：在函数入口时立即执行，并且不允许有祖先基本块（即不能有任何分支到函数的入口块）。由于该块可以没有前驱，它也不能有任何<a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">PHI节点</a>。</p>
<p>LLVM允许为函数指定显式section。如果目标机支持它，它将函数发送给指定的section。另外，该函数可以放置在COMDAT中。</p>
<p>可以为函数指定明确的对齐方式。如果不存在，或者如果对齐方式设置为零，则函数的对齐由目标机设置为任何感觉方便的方式。如果指定了明确的对齐方式，则该函数被强制至少具有那么多的对齐。所有对齐必须是2的幂。</p>
<p>如果<code>unnamed_addr</code>给出该属性，则知道该地址不重要，并且可以合并两个相同的函数。</p>
<p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内是不明显的。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [fn Attrs] [section &quot;name&quot;]</span><br><span class="line">       [comdat [($name)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>参数列表是逗号分隔的参数序列，其中每个参数具有以下形式：</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; [parameter Attrs] [name]</span><br></pre></td></tr></table></figure></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>与函数或变量不同，别名不会创建任何新数据。它们只是现有位置的新符号和元数据。</p>
<p>别名有一个名称和别名，可以是全局值或常量表达式。</p>
<p>别名可能具有可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时抢占说明符</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>和可选的<a href="http://llvm.org/docs/LangRef.html#tls-model" target="_blank" rel="noopener">tls模型</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias &lt;AliaseeTy&gt;, &lt;AliaseeTy&gt;* @&lt;Aliasee&gt;</span><br></pre></td></tr></table></figure></p>
<p>链接必须是一个<code>private</code>，<code>internal</code>，<code>linkonce</code>，<code>weak</code>，<code>linkonce_odr</code>，<code>weak_odr</code>，<code>external</code>。请注意，某些系统链接器可能无法正确处理丢弃具有别名的弱符号(就是内存溢出的问题)。</p>
<p>不是<code>unnamed_addr</code>的别名保证具有与别名表达式相同的地址。<code>unnamed_addr</code>只保证指向相同的内容。</p>
<p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内不显著。</p>
<p>由于别名只是第二个名称，因此有些限制适用，其中一些只能在生成对象文件时进行检查：</p>
<ul>
<li>定义别名的表达式必须在汇编时可计算。因为它只是一个名字，不能使用重定位。</li>
<li>表达式中的别名不会很弱，因为中间别名被覆盖的可能性无法在对象文件中表示。</li>
<li>表达式中的全局值不能是一个声明，因为这需要重定位，这是不可能的。</li>
</ul>
<h3 id="IFuncs"><a href="#IFuncs" class="headerlink" title="IFuncs"></a>IFuncs</h3><p>IFuncs就像别名一样，不会创建任何新的数据或func。它们只是动态链接器通过调用解析器函数在运行时解析的一个新符号。</p>
<p>IFuncs有一个名称和一个解析器，它是动态链接器调用的函数，它返回与该名称关联的另一个函数的地址。</p>
<p>IFunc可能具有可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>和可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [Visibility] ifunc &lt;IFuncTy&gt;, &lt;ResolverTy&gt;* @&lt;Resolver&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Comdats"><a href="#Comdats" class="headerlink" title="Comdats"></a>Comdats</h3><p>Comdat IR提供对COFF和ELF目标文件COMDAT功能的访问。</p>
<p><b style="color:red">关于什么是COMDAT，在<a href="https://zhuanlan.kanxue.com/article-4299.htm" target="_blank" rel="noopener">这篇文章</a>中提到<code>COMDAT</code>，即<code>common data</code>. 编译器将一些函数（具体是哪些函数，编译器自行决定）打包放到单独的section中，这有个专有名词叫COMDAT,即common data，意思是打包的函数或者打包的数据。按微软大拿Raymond Chen的说法，COMDAT这个概念最早来自FORTRAN语言。gcc和llvm对COMDAT都有对应的支持。链接器在链接阶段，可以对COMDAT中重复的函数进行消重（folding，折叠）。如果编译器不把函数打包成COMDAT项，链接器是不敢贸然优化掉对应的函数的，因为缺少这些函数的引用信息。</b></p>
<p>Comdats有一个代表COMDAT键的名称。如果链接器选择了某个其他键的键，则指定的这个键的所有全局对象只会在最终的对象文件中结束。如果有别名，别名将放置在相同的COMDAT中以及进行别名计算。</p>
<p>Comdats有一种选择类型来提供关于链接器如何在两个不同对象文件中的键之间进行选择的输入。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&lt;Name&gt; = comdat SelectionKind</span><br></pre></td></tr></table></figure></p>
<p>选择种类必须是以下之一：</p>
<ul>
<li><code>any</code>: 链接器可以选择任何COMDAT键，选择是任意的。</li>
<li><code>exactmatch</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同的数据。</li>
<li><code>largest</code>: 链接器将选择包含最大值COMDAT键的section。</li>
<li><code>noduplicates</code>: 链接器要求只有具有此COMDAT密钥的section存在。</li>
<li><code>samesize</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同数量的数据。</li>
</ul>
<p>请注意，Mach-O平台不支持COMDAT key，而ELF和WebAssembly仅支持<code>any</code>作为选择类型。</p>
<p><b style="color:green">这里是<code>COMDAT</code>组的一个例子，其中只有当COMDAT键的section最大时才会选择一个函数：</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat largest</span><br><span class="line">@foo = global i32 2, comdat($foo)</span><br><span class="line"></span><br><span class="line">define void @bar() comdat($foo) &#123;</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为一个语法糖，$name如果名称与全局名称相同，则可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">@foo = global i32 2, comdat</span><br></pre></td></tr></table></figure></p>
<p>在COFF对象文件中，这将创建一个COMDAT section，它的选择类型是<code>IMAGE_COMDAT_SELECT_LARGEST</code>，包含<code>@foo</code>符号的内容和另一个COMDAT section；这个section的选择类型是<code>IMAGE_COMDAT_SELECT_ASSOCIATIVE</code>,这个选择类型与第一个COMDAT section相关并包含在<code>@bar</code>符号的内容。</p>
<p>全局对象的属性有一些限制。它或它的别名在定位COFF时必须与COMDAT组具有相同的名称。COFF对象的内容和大小可以在链接期间使用，根据选择种类确定选择哪个COMDAT组。因为对象的名称必须与COMDAT组的名称相匹配，所以全局对象的链接不能是本地的; 如果符号表中发生冲突，则可以重命名本地符号。</p>
<p>组合使用COMDATS和段(section)属性可能会产生令人惊讶的结果。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">$bar = comdat any</span><br><span class="line">@g1 = global i32 42, section &quot;sec&quot;, comdat($foo)</span><br><span class="line">@g2 = global i32 42, section &quot;sec&quot;, comdat($bar)</span><br></pre></td></tr></table></figure></p>
<p>从对象文件的角度来看，这需要创建具有相同名称的两个段（section）。这是必要的，因为全局变量属于不同的COMDAT组，在对象文件级别，COMDAT由段（section）表示。</p>
<p>请注意，除了使用COMDAT IR指定的内容之外，某些IR结构（如全局变量和函数）可能会在对象文件中创建COMDAT。当代码生成器配置为在各个段（section）中发出全局变量时（例如， 向llc提供<code>-data-sections</code>或<code>-function-sections</code>选项时），就会出现这种情况。</p>
<h3 id="命名元数据"><a href="#命名元数据" class="headerlink" title="命名元数据"></a>命名元数据</h3><p>命名的元数据是元数据的集合。<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据节点</a>（但不是元数据字符串）是命名元数据的唯一有效操作数。</p>
<ol>
<li>命名的元数据被表示为一个带有元数据前缀的字符串。元数据名称的规则与标识符相同，但引用的名称不被允许。”\xx”类型转义仍然有效，它允许任何字符成为名称的一部分。</li>
</ol>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; Some unnamed metadata nodes, which are referenced by the named metadata.</span><br><span class="line">!0 = !&#123;!&quot;zero&quot;&#125;</span><br><span class="line">!1 = !&#123;!&quot;one&quot;&#125;</span><br><span class="line">!2 = !&#123;!&quot;two&quot;&#125;</span><br><span class="line">; A named metadata.</span><br><span class="line">!name = !&#123;!0, !1, !2&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>返回类型和函数类型的每个参数都可能具有一组与其关联的参数属性。参数属性用于传递有关函数结果或参数的附加信息。参数属性被认为是函数的一部分，而不是函数类型，所以具有不同参数属性的函数可以具有相同的函数类型。</p>
<p>参数属性是遵循指定类型的简单关键字。如果需要多个参数属性，则它们是空格分隔的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @printf(i8* noalias nocapture, ...)</span><br><span class="line">declare i32 @atoi(i8 zeroext)</span><br><span class="line">declare signext i8 @returns_signed_char()</span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>function result (nounwind, readonly)</code>的任何属性都会立即出现在参数列表之后。</p>
<p>目前，仅定义了以下参数属性：</p>
<ul>
<li><code>zeroext</code>: 这向代码生成器指示参数或返回值应该被调用者（对于参数）或被调用者（对于返回值）被零扩展到目标机ABI所需的范围。</li>
<li><code>signext</code>: 这向代码生成器指示参数或返回值应该由调用方（对于参数）或被调用方（对于返回值）进行符号扩展到目标机的ABI（通常为32位）所需的范围内。</li>
<li><code>inreg</code>: 这表明这个参数或返回值应该以特定的与目标机相关的方式处理，同时为函数调用或返回发送代码（通常通过将其放入寄存器而不是内存中，尽管有些目标机使用它来区分两个不同类型的寄存器）。使用此属性是特定于目标机的。</li>
<li><code>byval</code>: 这表明指针参数应该真的按值传递给函数。该属性意味着指向者的隐藏拷贝在调用者和被调用者之间建立，所以被调用者无法修改调用者中的值。该属性仅对LLVM指针参数有效。它通常用于按值传递结构和数组，但在指向标量的指针上也是有效的。复制被认为属于调用者而不是被调用者（例如，readonly函数不应写入byval参数）。这不是返回值的有效属性。<br>byval属性还支持使用align属性指定对齐方式。它指示要形成的堆栈槽的对齐以及指定给调用点的指针的已知对齐。如果未指定对齐，则代码生成器会进行特定于目标机的假设。</li>
<li><code>inalloca</code>: inalloca参数属性允许调用者采取传出栈参数的地址。一个inalloca参数必须是堆栈内存指针，<code>alloca</code>指令生成堆栈内存。alloca或参数分配也必须使用<code>inalloca</code>关键字进行标记。只有最后一个参数可能具有该<code>inalloca</code>属性，并且该参数保证在内存中传递。<br>参数分配最多可以由一个调用使用一次，因为调用可能会释放它。影响参数存储的属性，象<code>inreg</code>，<code>nest</code>，<code>sret</code>，或<code>byval</code>，<code>inalloca</code>属性不能结合这些属性一起使用。<code>inalloca</code>属性还禁止LLVM隐式降低大型聚合返回值，这意味着前端作者必须用<code>sret</code>指针降低它们(意思就是不要直接返回大型的值，改用返回指针)。<br>到达呼叫点时，参数分配必须是最新的还存活的堆栈分配，否则结果未定义。可以在参数分配之后、其调用点之前分配额外的堆栈空间，但必须使用<code>[llvm.stackrestore](http://llvm.org/docs/LangRef.html#int-stackrestore)</code>清除它。<br>有关如何使用此属性的更多信息，请参阅<a href="http://llvm.org/docs/InAlloca.html" target="_blank" rel="noopener">InAlloca属性的设计和使用</a>。</li>
<li><code>sret</code>: 这表明指针参数指定了作为源程序中函数返回值的结构地址。该指针必须由调用者保证是有效的：加载和存储到结构可以由被调用者假定不要陷入并且被正确对齐。这不是返回值的有效属性。</li>
<li><code>align &lt;n&gt;</code>: 这表明优化器可能会假定指针值具有指定的对齐方式。<br>请注意，该属性在与<code>byval</code>属性组合时具有额外的语义 。</li>
<li><code>noalias</code>: 这表明，通过<a href="http://llvm.org/docs/LangRef.html#pointeraliasing" target="_blank" rel="noopener">基于</a>所述参数或返回值的指针值访问的对象不可以访问，该函数的执行过程中，通过不基于所述参数或返回值的指针值。返回值的属性也具有下面描述的附加语义。调用方与被调用方分担责任，确保满足这些要求。有关更多详细信息，请参阅<a href="http://llvm.org/docs/AliasAnalysis.html#must-may-or-no" target="_blank" rel="noopener">别名分析</a>中 NoAlias回应的讨论。<br>请注意，这个<code>noalias</code>定义有意地类似于C99中用于函数参数的<a href="https://www.zhihu.com/question/41653775" target="_blank" rel="noopener"><code>restrict</code></a>定义。<br>对于函数返回值，C99的restrict意义不大，而对LLVM的<code>noalias</code>是有意义的。此外，在函数参数上使用时，返回值上的<code>noalias</code>属性的语义强于该属性的语义。在函数返回值上，<code>noalias</code>属性指示该函数的作用类似于系统内存分配函数，它返回一个指针，指向调用者可访问的任何其他对象的存储器的已分配存储空间。</li>
<li><code>nocapture</code>: 这表明被调用者不会创建超出被调用者本身的指针的任何副本。这不是返回值的有效属性。在易变的操作中使用的地址被认为是被捕获的。</li>
<li><code>nest</code>: 这表明指针参数可以使用弹性（trampoline）内联函数删除 。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>returned</code>: 这表明函数总是返回参数作为其返回值。这是在生成调用者时使用的优​​化器和代码生成器的提示，允许值传播，尾部调用优化以及在某些情况下省略寄存器保存和恢复; 在生成被调用者时不检查或强制执行。该参数和函数返回类型必须是<a href="http://llvm.org/docs/LangRef.html#i-bitcast" target="_blank" rel="noopener">bitcast指令</a>的有效操作数 。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>nonnull</code>: 这表明参数或返回指针不为null。该属性可能只适用于指针型参数。这不是LLVM检查或执行的，调用者必须确保传入的指针非空，或者被调用者必须确保返回的指针非空。</li>
<li><code>dereferenceable(&lt;n&gt;)</code>: 这表明参数或返回指针是可逆向引用的(dereferenceable，就是用*pr引用值)。该属性可能只适用于指针型参数。一个可逆向引用的指针可以从投机加载而没有陷入的风险。已知可逆向引用的字节数必须在括号中提供。字节数小于指点人类型的大小是合法的。该nonnull属性并不意味着可引用性（考虑一个指向数组末尾的一个元素的指针），但是<code>dereferenceable(&lt;n&gt;)</code>暗含<code>nonnull</code>在 <code>addrspace(0)</code>中（这是默认地址空间）。</li>
<li><code>dereferenceable_or_null(&lt;n&gt;)</code>: 这表明参数或返回值不能同时为非空和不可逆向引用(达到<code>&lt;n&gt;</code>字节）。标记为<code>dereferenceable_or_null(&lt;n&gt;)</code>的所有非空指针是<code>dereferenceable(&lt;n&gt;)</code>。对于地址空间0 <code>dereferenceable_or_null(&lt;n&gt;)</code>意味着一个指针是正好一个<code>dereferenceable(&lt;n&gt;)</code>或null; 在其它的地址空间<code>dereferenceable_or_null(&lt;n&gt;)</code> 意味着一个指针中的至少一个<code>dereferenceable(&lt;n&gt;)</code>或<code>null</code>（它也可以是<code>null</code>和<code>dereferenceable(&lt;n&gt;)</code>）。该属性可能只适用于指针型参数。</li>
<li><code>swiftself</code>: 这表明该参数是<code>self/context</code>参数。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>swifterror</code>: 这个属性被激发来模拟和优化Swift错误处理。它可以应用于指针指向指针类型或指针大小的alloca的参数。在调用点，与参数相对应的实际<code>swifterror</code>参数必须来自<code>swifterroralloca</code>或<code>swifterror</code>调用者的参数。甲swifterror值（参数或ALLOCA）只能加载和存储的，或用作一个swifterror参数。这不是返回值的有效属性，只能应用于一个参数。<br>这些约束允许调用约定swifterror通过将它们与在调用边界的特定寄存器相关联来优化对变量的访问， 而不是将它们放置在内存中。由于这确实改变了调用约定，所以swifterror在参数上使用属性的函数不是ABI兼容的。<br>这些约束条件还允许LLVM假定swifterror参数不会在函数swifterror中使其他内存可见，并且作为参数传递的 alloca不会转义。</li>
</ul>
<h3 id="垃圾收集器策略的名称"><a href="#垃圾收集器策略的名称" class="headerlink" title="垃圾收集器策略的名称"></a>垃圾收集器策略的名称</h3><p>每个函数都可以指定一个垃圾收集器策略名称，它只是一个字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() gc &quot;name&quot; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>名称的支持值包括<a href="http://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies" target="_blank" rel="noopener">LLVM内置的</a>值以及由加载的插件提供的值。指定GC策略将导致编译器更改其输出以支持指定的垃圾回收算法。请注意，LLVM本身不包含垃圾收集器，此功能仅限于生成可与外部提供的收集器互操作的机器代码。</p>
<h3 id="前缀数据"><a href="#前缀数据" class="headerlink" title="前缀数据"></a>前缀数据</h3><p>前缀数据是与函数关联的数据，代码生成器在函数入口点之前立即发出的。此功能的目的是允许前端（frontends）将语言特定的运行时元数据与特定函数相关联，并通过函数指针使其可用，同时仍允许调用函数指针。</p>
<p>要访问给定函数的数据，程序可以将函数指针bitcast到指向常量类型和取消逆向引用索引(dereference index，可能是指内容-1处的索引)-1的指针。这意味着IR符号刚刚超过前缀数据的末尾。例如，以单个<code>i32</code>注释的函数为例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prefix i32 123 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>前缀数据可以被引用为，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = bitcast void* () @f to i32*</span><br><span class="line">%a = getelementptr inbounds i32, i32* %0, i32 -1</span><br><span class="line">%b = load i32, i32* %a</span><br></pre></td></tr></table></figure></p>
<p>前缀数据的布局就好像它是前缀数据类型的全局变量的初始化程序。该函数将被放置为使得前缀数据的开始对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点不会对齐。如果需要对齐函数的入口点，则必须将填充添加到前缀数据中。</p>
<p>一个函数可能有前缀数据但没有主体。这与available_externally链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标机文件中发送数据。</p>
<h3 id="序言（Prologue）资料"><a href="#序言（Prologue）资料" class="headerlink" title="序言（Prologue）资料"></a>序言（Prologue）资料</h3><p>该prologue属性允许在函数体之前插入任意代码（以字节编码）。这可以用于启用函数热修补和仪器。</p>
<p>为了保持普通函数调用的语义，序言数据必须有特定的格式。具体来说，它必须以一系列字节开始，该字节序列解码为一系列机器指令，对模块的目标代码有效，将控制转移到紧接在序言数据之后的位置，而不执行任何其他可见动作。这允许内联和其他传递推理函数定义的语义，而不需要推理序言数据。显然这使得序言数据的格式高度依赖于目标。</p>
<p>x86体系结构的有效序言数据的一个简单示例是<code>i8 144</code>, 对指令<code>nop</code>进行编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prologue i8 144 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，可以通过对跳过元数据的相对分支指令进行编码来形成序言数据，如x86_64体系结构的有效序言数据的示例，其中前两个字节编码为：<code>jmp .+10</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = type &lt;&#123; i8, i8, i8* &#125;&gt;</span><br><span class="line"></span><br><span class="line">define void @f() prologue %0 &lt;&#123; i8 235, i8 8, i8* @md&#125;&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>一个函数可能有序言数据，但没有主体。这与<code>available_externally</code>链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标文件中发送数据。</p>
<h3 id="Personality功能"><a href="#Personality功能" class="headerlink" title="Personality功能"></a>Personality功能</h3><p>该<code>personality</code>属性允许函数指定用于异常处理的函数。</p>
<h3 id="属性组"><a href="#属性组" class="headerlink" title="属性组"></a>属性组</h3><p>属性组是由IR内的对象引用的属性组。它们对于保持<code>.ll</code>文件可读性很重要，因为许多函数将使用同一组属性。在与单个.c文件相对应的<code>.ll</code>文件的退化(degenerative)情况下，单个属性组将捕获用于构建该文件的重要命令行标志。</p>
<p>一个属性组是一个模块级别的对象。要使用属性组，对象引用属性组的ID（例如<code>#37</code>）。一个对象可能涉及多个属性组。在这种情况下，来自不同组的属性被合并。</p>
<p>下面是一个应该总是内联的函数的属性组的示例，其堆栈对齐方式为4，不应使用SSE指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Target-independent attributes:</span><br><span class="line">attributes #0 = &#123; alwaysinline alignstack=4 &#125;</span><br><span class="line"></span><br><span class="line">; Target-dependent attributes:</span><br><span class="line">attributes #1 = &#123; &quot;no-sse&quot; &#125;</span><br><span class="line"></span><br><span class="line">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span><br><span class="line">define void @f() #0 #1 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><p>函数属性被设置为传递关于函数的附加信息。函数属性被认为是函数的一部分，而不是函数类型的一部分，因此具有不同函数属性的函数可以具有相同的函数类型。</p>
<p>函数属性是遵循指定类型的简单关键字。如果需要多个属性，它们是空格分隔的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define void @f() noinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline optsize &#123; ... &#125;</span><br><span class="line">define void @f() optsize &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>alignstack(&lt;n&gt;)</code>: 这个属性表明，当发布序言和尾声(epilogue)时，后端应该强制堆栈指针对齐。在圆括号中指定所需的对齐方式，该对齐方式必须是2的幂。</li>
<li><code>allocsize(&lt;EltSizeParam&gt;[, &lt;NumEltsParam&gt;])</code>: 该属性指示注释的函数将始终返回至少给定数量的字节（或null）。它的参数是零索引参数号; 如果提供了一个参数，则假定至少有<code>CallSite.Args[EltSizeParam]</code>字节在返回的指针处可用。如果提供了两个参数，则假定<code>CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]</code>字节可用。引用的参数必须是整数类型。没有关于返回的内存块的内容的假设。</li>
<li><code>alwaysinline</code>: 该属性表示内联器应尽可能将该函数内联到调用者中，而忽略此调用者的任何活动内联大小阈值。</li>
<li><code>builtin</code>: 这表明，即使函数的声明使用<code>nobuiltin</code>属性，调用点上的被调用函数也应该被识别为内置函数。这仅在调用点有效，才能直接调用<code>nobuiltin</code>属性声明的函数。</li>
<li><code>cold</code>: 这个属性表明这个函数很少被调用。在计算边权重时，由冷函数调用后支配的基本块也被认为是冷的; 因此，轻量级。</li>
<li><code>convergent</code>: 在一些并行执行模型中，存在无法根据任何附加值进行控制的操作。我们称之为这样的操作<code>convergent</code>，并用这个属性标记它们。<br><code>convergent</code>属性可能出现在函数或<code>call/invoke</code>指令上。当它出现在一个函数上时，它表示对这个函数的调用不应该取决于附加值的控制。例如，内在的<code>llvm.nvvm.barrier0</code>是<code>convergent</code>，所以对这个内在的调用不能取决于附加值的控制。<br>当它出现在一个<code>call/invoke</code>中时，<code>convergent</code>属性表明我们应该把这个调用看作是我们正在调用一个收敛函数。这对间接调用特别有用; 没有这个，我们可以把这样的调用视为目标不收敛。<br>当可以证明函数不执行任何收敛操作时，优化器可以删除函数的<code>convergent</code>属性。同样，优化程序可以在<code>call/invoke</code>不能调用收敛函数时删除<code>calls/invokes</code>上的<code>convergent</code>。</li>
<li><code>inaccessiblememonly</code>: 该属性表明该函数只能访问正在编译的模块而无法访问的内存。这是一种较弱的<code>readnone</code>形式。</li>
<li><code>inaccessiblemem_or_argmemonly</code>: 该属性表明该函数只能访问被编译的模块而无法访问的内存，或者其指针参数指向的内存。这是一种较弱的<code>argmemonly</code>形式。</li>
<li><code>inlinehint</code>: 这个属性表明源代码包含一个暗示这个函数内联的提示是可取的（比如C / C ++中的“inline”关键字）。这只是一个暗示; 它对内联没有要求。</li>
<li><code>jumptable</code>: 该属性表示应该在代码生成时将函数添加到跳转指令表中，并且应将所有对此函数的地址引用引用替换为对相应的跳转指令表函数指针的引用。请注意，这会为原始函数创建一个新指针，这意味着依赖于函数指针标识的代码可能会中断。所以，<code>jumptable</code>注解的任何函数也必须是<code>unnamed_addr</code>。</li>
<li><code>minsize</code>: 此属性表明，优化途径（passes）和代码生成器途径之间进行选择，以使该函数的代码大小尽可能小，并执行可能牺牲运行时性能的优化，以最小化生成的代码的大小。</li>
<li><code>naked</code>: 该属性禁用该函数的序言/尾声(prologue/epilogue)发射。这可能会导致系统特定的后果。</li>
<li><code>no-jump-tables</code>: 当此属性设置为true时，可以从生成的跳转表和查找表被禁用。这些表都是会转换为小写的字母。</li>
<li><code>nobuiltin</code>: 这表明调用点的被调用方函数不被识别为内置函数。除非调用点使用该<code>builtin</code>属性，否则LLVM将保留原始调用并且不会使用基于内置函数的语义的等效代码替换它。这在调用点以及函数声明和定义中是有效的。</li>
<li><code>noduplicate</code>: 此属性表示对函数的调用不能重复。对<code>noduplicate</code>函数的调用可能会在其父函数内移动，但不能在其父函数内复制。<br>包含<code>noduplicate</code>调用的函数可能仍然是内联候选人，前提是调用不通过内联复制。这意味着该功能具有内部链接功能，并且只有一个调用点，所以原始调用在内联后死亡。</li>
<li><code>noimplicitfloat</code>: 该属性禁用隐式浮点指令。</li>
<li><code>noinline</code>: 该属性表示内联器在任何情况下都不应该内联该函数。该属性不能与<code>alwaysinline</code>属性一起使用。</li>
<li><code>nonlazybind</code>: 该属性禁止该函数的延迟符号绑定。如果在程序启动期间未调用该函数，则可能会以更多的程序启动时间为代价来更快地调用该函数。</li>
<li><code>noredzone</code>: 该属性指示代码生成器不应使用红色区域，即使目标特定的ABI通常允许它。</li>
<li><code>noreturn</code>: 该函数属性指示函数永远不会正常返回。如果函数在动态返回时会在运行时产生未定义的行为。</li>
<li><code>norecurse</code>: 该函数属性指示该函数不会直接或间接地调用自己的任何可能的调用路径。如果该函数执行递归，这会在运行时产生未定义的行为。</li>
<li><code>nounwind</code>: 该函数属性指示该函数不会引发异常。如果该函数确实引发异常，则其运行时行为未定义。但是，标记为<code>nounwind</code>的函数仍可能陷入或生成异步异常。由LLVM识别以处理异步异常（如SEH）的异常处理方案仍将提供其实现定义的语义。</li>
<li><code>optforfuzzing</code>: 该属性表示该函数应该针对最大模糊信号进行优化。</li>
<li><code>optnone</code>: 该函数属性指示大多数优化过程将跳过此函数，但过程间优化过程除外。代码生成默认为“<code>fast</code>”指令选择器。该属性不能与<code>alwaysinline</code>属性一起使用; 此属性也与<code>minsize</code>属性和<code>optsize</code>属性不兼容。<br>这个属性需要在<code>noinline</code>函数中指定属性，所以函数不会被内联到任何调用者中。只有具有该<code>alwaysinline</code>属性的函数才是用于内联到此函数主体中的有效候选项。</li>
<li><code>optsize</code>: 此属性表明，优化传递(passes)和代码生成器传递之间进行选择，以保持此函数的代码大小较低，否则，只要不会显着影响运行时性能，就会专门减少代码大小进行优化。</li>
<li>“<code>patchable-function</code>“: 这个属性告诉代码生成器，为这个函数生成的代码需要遵循特定的约定，以便运行时函数稍后可以修补它。该属性本身并不意味着对程序间优化的限制。所有修补语义效应可能必须通过连接类型单独传送。该属性的确切效果取决于其字符串值，目前有一个合法的可能性：<ul>
<li>“<code>prologue-short-redirect</code>“ - 这种类型的可修补函数旨在支持修补函数序言，以线程安全的方式将控制权重定向到函数之外。它保证函数的第一条指令足够大以容纳短跳转指令，并且将被充分对齐以允许通过原子比较和交换指令进行完全更改。尽管可以通过插入足够大的<code>NOP</code>来满足第一个要求，但LLVM可以并且将尝试将现有指令（即，不得不被发射的指令）重新用作大于短跳跃的可修改指令。<br>“<code>prologue-short-redirect</code>“目前仅在x86-64上受支持。</li>
</ul>
</li>
<li>“<code>probe-stack</code>“: 该属性表明该函数将在堆栈的末尾触发一个防护区域。它确保对堆栈的访问必须不会远离保护区域的大小，保护域是堆栈的先前访问。它需要一个必需的字符串值，即将被调用的堆栈探测函数的名称。<br>如果具有”<code>probe-stack</code>“属性的函数内联到另一个”<code>probe-stack</code>“属性的函数中，对调用者而言，则结果函数具有”<code>probe-stack</code>“属性。如果具有”<code>probe-stack</code>“属性的函数被内联到完全没有”<code>probe-stack</code>“属性的函数中，则结果函数具有”<code>probe-stack</code>“被调用者的属性。</li>
<li><code>readnone</code>: 在一个函数上，这个属性表明函数严格基于它的参数来计算它的结果（或者决定展开一个异常），而不需要逆向引用任何指针参数或者访问任何对调用者函数可见的可变状态（例如内存，控制寄存器等）。它不写任何指针参数（包括<code>byval</code>参数），也不会改变调用者可见的任何状态。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在参数上，该属性指示该函数不会对指针参数进行逆向引用，即使它可以读取或写入指针指向的内存（如果通过其他指针访问的话）。</li>
<li><code>readonly</code>: 在一个函数中，这个属性表明函数不会通过任何指针参数（包括<code>byval</code>参数）进行写入，也不会修改调用者函数可见的任何状态（例如内存，控制寄存器等）。它可能会逆向引用（就是*号操作）指针参数并读取调用者可能设置的状态。readonly函数在调用相同的参数集和全局状态时始终返回相同的值（或者展开相同的异常）。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在一个参数上，这个属性表明函数不会通过这个指针参数写入，即使它可能写入指针指向的内存。</li>
<li>“<code>stack-probe-size</code>“: 该属性控制堆栈探测器的行为：”<code>probe-stack</code>“属性或ABI所需的堆栈探测器（如果有的话）。它定义了防护区的大小。它确保如果函数可能会使用比保护区大小更多的堆栈空间，则会发出堆栈探测序列。它需要一个必需的整数值，默认为<code>4096</code>。<br>如果具有”<code>stack-probe-size</code>“属性的函数内联到另一个”<code>stack-probe-size</code>“属性函数中，则生成的函数具有”<code>stack-probe-size</code>“数值较小的属性。如果具有”<code>stack-probe-size</code>“属性的函数被内联到完全没有”stack-probe-size”属性的函数中，则结果函数具有”<code>stack-probe-size</code>“被调用者的属性。</li>
<li>“<code>no-stack-arg-probe</code>“: 该属性禁用ABI所需的堆栈探测器（如果有的话）。</li>
<li><code>writeonly</code>: 在一个函数上，这个属性表明函数可以写入但不从内存中读取。<br>在一个参数上，这个属性表明函数可以写入但不读取这个指针参数（即使它可以从指针指向的内存中读取）。</li>
<li><code>argmemonly</code>: 这个属性表明函数内部唯一的内存访问是加载并存储指针类型参数所指向的对象的任意偏移量。换句话说，函数中的所有内存操作都可以仅使用基于其函数参数的指针来引用内存。请注意，<code>argmemonly</code>可以与<code>readonly</code>属性一起使用，以便指定该函数只从其参数中读取。</li>
<li><code>returns_twice</code>: 该属性表示该函数可以返回两次。C的<a href="https://zh.wikipedia.org/wiki/Setjmp.h" target="_blank" rel="noopener"><code>setjmp</code></a>（<a href="http://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html" target="_blank" rel="noopener">这里</a>有一个更好的例子）是这种功能的一个例子。编译器在这些函数的调用者中禁用某些优化（如tail调用）。</li>
<li><code>safestack</code>: 此属性表示已为此函数启用<a href="http://clang.llvm.org/docs/SafeStack.html" target="_blank" rel="noopener">SafeStack</a>保护。<br>如果具有<code>safestack</code>属性的函数被内联到一个函数，这个函数不具有<code>safestack</code>属性或具有一个<code>ssp</code>，<code>sspstrong</code>或<code>sspreq</code>属性，然后将所得的函数将有一个<code>safestack</code>属性。</li>
<li><code>sanitize_address</code>: 此属性表明已为此函数启用<code>AddressSanitizer</code>检查（动态地址安全分析）。</li>
<li><code>sanitize_memory</code>: 此属性表示对此函数启用<code>MemorySanitizer</code>检查（对未初始化内存的访问的动态检测）。</li>
<li><code>sanitize_thread</code>: 此属性表示为此函数启用了<code>ThreadSanitizer</code>检查（动态线程安全分析）。</li>
<li><code>sanitize_hwaddress</code>: 此属性表示为此函数启用了<code>HWAddressSanitizer</code>检查（基于标记指针的动态地址安全分析）。</li>
<li><code>speculatable</code>: 这个函数属性表明函数除了计算结果之外没有任何影响，并且没有未定义的行为。请注意，这<code>speculatable</code>还不足以断定沿着任何特定的执行路径，对此函数的调用次数不会在外部可观察到。该属性仅适用于函数和声明，而不适用于单个调用点。如果一个函数被错误地标记为<code>speculatable</code>，并且确实表现出未定义的行为，即使该调用点是死代码，也可能会观察到未定义的行为。</li>
<li><p><code>ssp</code>: 该属性表示该函数应该发出一个<a href="https://blog.csdn.net/mantis_1984/article/details/72119575" target="_blank" rel="noopener">堆栈溢出保护器(stack smashing detected)</a>。它的形式是“canary” - 在从函数返回时检查局部变量以查看它是否被覆盖之前放置在堆栈上的随机值。启发式用于确定函数是否需要堆栈保护器。使用的启发式将使保护器具有以下特性的函数：</p>
<ul>
<li>大于<code>ssp-buffer-size</code>（默认8）的字符数组。</li>
<li>包含大于<code>ssp-buffer-size</code>的字符数组的聚合。</li>
<li>大小大于<code>ssp-buffer-size</code>的变量或者常量调用<code>alloca()</code>.</li>
</ul>
<p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。<br>如果一个具有<code>ssp</code>属性的函数被内联到一个没有<code>ssp</code>属性的函数中，那么结果函数将具有一个<code>ssp</code>属性。</p>
</li>
<li><p><code>sspreq</code>: 该属性表示该函数应该始终发出堆栈溢出保护器。这覆盖了<code>ssp</code>函数属性。<br>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p>
<ol>
<li>大型数组和包含大型数组（&gt;= ssp-buffer-size）的结构最接近堆栈保护器。</li>
<li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li>
<li>已经取得地址的变量是第三接近保护者。</li>
</ol>
<p>如果其具有<code>sspreq</code>属性的函数被内联到一个函数，它不具有<code>sspreq</code>属性或具有一个<code>ssp</code>或<code>sspstrong</code>属性，然后将所得的函数将有一个<code>sspreq</code>属性。</p>
</li>
<li><p><code>sspstrong</code>: 该属性表示该函数应该发出一个堆栈溢出保护器。该属性在确定函数是否需要堆栈保护器时会使用强启发式。强大的启发式功能可以为以下函数提供保护：</p>
<ul>
<li>任何大小和类型的阵列</li>
<li>包含任何大小和类型的数组的聚合。</li>
<li>调用alloca（）。</li>
<li>已经取得地址的局部变量。</li>
</ul>
<p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p>
<ol>
<li>大型数组和包含大型数组的结构（&gt;= ssp-buffer-size）最接近堆栈保护器。</li>
<li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li>
<li>已经取得地址的变量是第三接近保护者。</li>
</ol>
<p>这覆盖了<code>ssp</code>函数属性。<br>如果一个具有<code>sspstrong</code>属性的函数被内联到一个没有<code>sspstrong</code>属性的函数中，那么结果函数将具有一个<code>sspstrong</code>属性。</p>
</li>
<li><code>strictfp</code>: 该属性指示该函数是从需要严格浮点语义的作用域调用的。LLVM不会尝试任何需要假设浮点舍入模式的优化，或者可能会改变可能通过调用此函数来设置或清除的浮点状态标志的状态。</li>
<li>“<code>thunk</code>“: 该属性表示该函数将通过尾部调用委托给某个其他函数。不应将<code>thunk</code>的原型用于优化目的。预计调用者将投掷<code>thunk</code>原型以匹配<code>thunk</code>目标原型。</li>
<li><code>uwtable</code>: 这个属性表明被定位的ABI需要为这个函数生成一个展开的表入口，即使我们能够证明没有异常通过它。这通常适用于ELF x86-64 abi，​​但对于某些编译单元可以禁用它。</li>
<li><code>nocf_check</code>: 此属性表示不会对属性实体执行控制流检查。它会禁用特定实体的<code>-fcf-protection = &lt;&gt;</code>以细化HW控制流保护机制。该标志是目标独立的，并且当前属于函数或函数指针。</li>
<li><code>shadowcallstack</code>: 此属性表示为该函数启用了<code>ShadowCallStack</code>检查。仪器检查（instrumentation checks）函数的返回地址在函数<code>prolog</code>和<code>eiplog</code>之间没有改变。它目前是x86_64特定的。</li>
</ul>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>可以设置属性来传达关于全局变量的附加信息。与<a href="http://llvm.org/docs/LangRef.html#fnattrs" target="_blank" rel="noopener">函数属性</a>不同，全局变量上的属性被分组到单个<a href="http://llvm.org/docs/LangRef.html#attrgrp" target="_blank" rel="noopener">属性组中</a>。</p>
<h3 id="操作数捆绑-Operand-Bundles"><a href="#操作数捆绑-Operand-Bundles" class="headerlink" title="操作数捆绑(Operand Bundles)"></a>操作数捆绑(Operand Bundles)</h3><p>操作数捆绑是可与某些LLVM指令相关联的SSA值的标签set集（当前仅包含calls和invokes）。在某种程度上，它们就像元数据，但删除它们是不正确的，并且会改变程序的语义。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operand bundle set ::= &apos;[&apos; operand bundle (, operand bundle )* &apos;]&apos;</span><br><span class="line">operand bundle ::= tag &apos;(&apos; [ bundle operand ] (, bundle operand )* &apos;)&apos;</span><br><span class="line">bundle operand ::= SSA value</span><br><span class="line">tag ::= string constant</span><br></pre></td></tr></table></figure></p>
<p>操作数绑定不是函数签名的一部分，并且可以从具有不同类型操作数绑定的多个位置调用给定函数。这反映了操作数绑定在概念上是call（或invoke）的一部分，而不是被调度的被调用者。</p>
<p>操作数绑定是一种通用机制，旨在支持托管语言的类似运行时自反功能。虽然操作数绑定的确切语义取决于绑定标记，但操作数绑定的存在可以影响程序的语义有一定的限制。这些限制被描述为“unknown”操作数绑定的语义。只要操作数绑定的行为可以在这些限制内进行描述，LLVM就不需要对操作数绑定有特殊的了解，就不会错误地编译包含它的程序。</p>
<ul>
<li>未知操作数绑定的捆绑操作数在控制权转移给被调用者或调用者之前以未知方式转义。</li>
<li>使用操作数绑定进行调用和调用对入口和出口处的堆（即使调用目标是readnone或readonly）在堆上具有未知的读/写效果 ，除非它们被特定于调用点的属性覆盖。</li>
<li>调用点的操作数绑定不能更改被调用函数的实现。只要它们考虑到头两个属性，程序间优化就像往常一样工作。</li>
</ul>
<p>下面描述了更具体的操作数绑定类型。</p>
<h4 id="逆优化（Deoptimization）操作数绑定"><a href="#逆优化（Deoptimization）操作数绑定" class="headerlink" title="逆优化（Deoptimization）操作数绑定"></a>逆优化（Deoptimization）操作数绑定</h4><p>逆优化（Deoptimization）操作数绑定由”<code>deopt</code>“操作数绑定标签表征。这些操作数绑定表示它们所连接的调用点的替代“安全”延续，并且可以由适当的运行时使用，以便在指定的调用点对编译后的帧进行去优化。最多可以有一个”<code>deopt</code>“操作数绑定附加到调用点。逆优化（Deoptimization）的确切细节超出了语言参考的范围，但它通常涉及将编译帧重写为一组解释帧。</p>
<p>从编译器的角度来看，逆优化（Deoptimization）操作数绑定使得它们所连接的调用点至少是<code>readonly</code>。他们通读他们所有的指针类型操作数（即使它们没有被转义）和整个可见的堆。逆优化操作数绑定不会捕获它们的操作数，除非在逆优化过程中，在这种情况下，控制将不会返回到编译帧。</p>
<p>内联器知道如何通过具有逆优化操作数绑定的调用进行内联。就像通过一个正常的调用点进行内联，包括构成正常的和特殊的延续一样，通过调用点内联去耦优化操作数捆绑定需要适当地组成“安全”去优化延续。内联器通过在内联体中对每个逆优化延续预先实现父代的逆优化延续。例如内联<code>@f</code>到<code>@g</code>在下面的例子中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define void @f() &#123;</span><br><span class="line">  call void @x()  ;; no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @g() &#123;</span><br><span class="line">  call void @f() [ &quot;deopt&quot;(i32 20) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会导致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define void @g() &#123;</span><br><span class="line">  call void @x()  ;; still no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前端(frontend)的责任是以句法上将调用者的逆最优化状态预先加入到被调用者的逆最优化状态的方式来构造或编码逆最优化状态，这在语义上等同于在被调用者的逆最佳化延续之后构成调用者的逆最佳化延续。</p>
<h4 id="Funclet操作数捆绑"><a href="#Funclet操作数捆绑" class="headerlink" title="Funclet操作数捆绑"></a>Funclet操作数捆绑</h4><p>Funclet操作数绑定由”<code>funclet</code>“操作数绑定标签表征。这些操作数绑定表明调用点位于特定<code>funclet</code>内。最多可以有一个”<code>funclet</code>“操作数绑定附加到调用点，并且它必须只有一个捆绑操作数。</p>
<p>如果任何<code>funclet</code> EH焊盘(pads)已被“entered”但不是“exited”（根据<a href="http://llvm.org/docs/ExceptionHandling.html#wineh-constraints" target="_blank" rel="noopener">EH文档中的描述</a>），则对下面的执行一个call或者invoke是未定义的行为：</p>
<ul>
<li>没有”<code>funclet</code>“捆绑，并且不是对nounwind intrinsic的call，或者</li>
<li>有一个”<code>funclet</code>绑定，它的操作数不是最近输入的尚未退出funclet EH板（pad）。</li>
</ul>
<p>类似地，如果没有funclet EH焊盘（pads）进入但尚未退出，在一个”<code>funclet</code>“bundle中执行一个call或invoke是未定义的行为。</p>
<h4 id="GC转换操作数绑定"><a href="#GC转换操作数绑定" class="headerlink" title="GC转换操作数绑定"></a>GC转换操作数绑定</h4><p>GC转换操作数绑定由”gc-transition”操作数绑定标记表征。这些操作数绑定将一个调用标记为具有一个GC策略的函数与具有不同GC策略的函数之间的过渡。如果协调GC策略之间的转换需要在调用点生成额外的代码，则这些软件绑定可能包含生成的代码所需的任何值。有关更多详细信息，请参阅<a href="http://llvm.org/docs/Statepoints.html#gc-transition-args" target="_blank" rel="noopener">GC转场</a>。</p>
<h3 id="模块级内联汇编"><a href="#模块级内联汇编" class="headerlink" title="模块级内联汇编"></a>模块级内联汇编</h3><p>模块可能包含“模块级内联asm”块，它对应于GCC“文件范围inline asm”块。这些块由LLVM内部连接并作为一个单元进行处理，但如果需要可以在<code>.ll</code>文件中分开。语法非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module asm &quot;inline asm code goes here&quot;</span><br><span class="line">module asm &quot;more can go here&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串可以通过转义不可打印的字符来包含任何字符。使用的转义序列只是“\xx”，其中“xx”是数字的两位十六进制代码。</p>
<p>请注意，汇编字符串必须由LLVM的集成汇编程序解析（除非它被禁用），即使在发送<code>.s</code>文件时也是如此。</p>
<h3 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h3><p>模块可以指定目标特定数据布局字符串，该字符串指定数据如何布置在内存中。数据布局的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target datalayout = &quot;layout specification&quot;</span><br></pre></td></tr></table></figure></p>
<p>该布局规范包括规范用减号字符分隔（“-”）的列表中。每个规范都以字母开头，并可能在字母后包含其他信息以定义数据布局的某些方面。接受的规格如下：</p>
<ul>
<li><code>E</code>: 指定目标以big-endian格式显示数据。也就是说，最重要的位具有最低的地址位置。</li>
<li><code>e</code>: 指定目标以little-endian形式显示数据。也就是说，具有最低重要性的位具有最低的地址位置。</li>
<li><code>S&lt;size&gt;</code>: 指定堆栈的自然对齐位数。堆栈变量的对齐提升仅限于自然堆栈对齐，以避免动态堆栈重新对齐。堆栈对齐必须是8位的倍数。如果省略，则自然堆栈对齐默认为“未指定”，这不会阻止任何对齐升级。</li>
<li><code>P&lt;address space&gt;</code>: 指定对应于程序内存的地址空间。哈佛（Harvard）体系结构可以使用它来指定LLVM应该在哪些空间放置诸如函数之类的东西。如果省略，程序存储器空间默认为默认地址空间0，这对应于具有相同空间中的代码和数据的冯诺依曼体系结构。</li>
<li><code>A&lt;address space&gt;</code>: 指定由’<code>alloca</code>‘创建的对象的地址空间。默认为默认地址空间0。</li>
<li><code>p[n]:&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;:&lt;idx&gt;</code>: 这将指定大小的指针和它的<code>&lt;abi&gt;</code>和 <code>&lt;pref&gt;</code>错误的地址的空间对齐n。第四个参数<code>&lt;idx&gt;</code>是用于地址计算的索引大小。如果未指定，则默认索引大小等于指针大小。所有尺寸都是位。地址空间n是可选的，如果未指定，则表示默认地址空间0.值n必须在<code>[1,2^23)</code>范围内。</li>
<li><code>i&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的整数类型的对齐方式。值<code>&lt;size&gt;</code>必须在<code>[1,2^23)</code>范围内。</li>
<li><code>v&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的向量类型的对齐方式。</li>
<li><code>f&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的浮点类型的对齐方式。只有目标支持的<code>&lt;size&gt;</code>值才有效。所有目标都支持32（浮动）和64（双）。一些目标也支持80或128（不同长度的双重版本）。</li>
<li><code>a:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了聚合类型对象的对齐方式。</li>
<li><code>m:&lt;mangling&gt;</code>: 如果存在，则指定llvm名称在输出中被损坏。以mangling转义字符作为前缀的符号<code>\01</code>直接传递给汇编器而不使用转义字符。mangling风格选项是<ul>
<li><code>e</code>：ELF mangling：专用符号获取<code>.L</code>前缀。</li>
<li><code>m</code>：Mips mangling：私有符号获取<code>$</code>前缀。</li>
<li><code>o</code>：Mach-O修改：专用符号获取<code>L</code>前缀。其他符号会得到一个<code>_</code>前缀。</li>
<li><code>x</code>：Windows x86 COFF mangling：私有符号获取通常的前缀。普通的C符号会得到一个<code>_</code>前缀。带有<code>__stdcall</code>，<code>__fastcall</code>，和<code>__vectorcall</code>的函数具有附加的自定义修剪(mangling)，<code>@N</code>其中N是用于传递参数的字节数。以<code>?</code>开头的C++符号不会以任何方式的变形（mangling）。</li>
<li><code>w</code>：Windows COFF mangling：类似于<code>x</code>，除了普通的C符号不接受<code>_</code>前缀。</li>
</ul>
</li>
<li><code>n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</code>: 这为位目标CPU指定了一组本地整数宽度。例如，它可能包含32位PowerPC的n32，对于PowerPC 64是<code>n32:64</code>或对于X86-64是<code>n8:16:32:64</code>。这组元素被认为可以有效地支持大多数一般的算术运算。</li>
<li><code>ni:&lt;address space0&gt;:&lt;address space1&gt;:&lt;address space2&gt;...</code>: 这指定具有指定地址空间的指针类型作为<a href="http://llvm.org/docs/LangRef.html#nointptrtype" target="_blank" rel="noopener">非整体指针类型</a>。该<code>0</code>地址空间不能被指定为非积分(non-integral)。</li>
</ul>
<p>在每个采用的<code>&lt;abi&gt;:&lt;pref&gt;</code>规范上，指定<code>&lt;pref&gt;</code>对齐是可选的。如果省略，则前面的内容也应该省略, 并且<code>&lt;pref&gt;</code>等于<code>&lt;abi&gt;</code>。</p>
<p>在为给定目标构建数据布局时，LLVM从默认的一组规范开始，然后（可能）由<code>datalayout</code>关键字中的规范覆盖。默认规格在此列表中给出：</p>
<ul>
<li><code>E</code> - 大端</li>
<li><code>p:64:64:64</code> - 与64位对齐的64位指针。</li>
<li><code>p[n]:64:64:64</code> - 其他地址空间被假定为与默认地址空间相同。</li>
<li><code>S0</code> - 自然堆栈对齐未指定</li>
<li><code>i1:8:8</code> - i1是8位（字节）对齐</li>
<li><code>i8:8:8</code> - i8是8位（字节）对齐</li>
<li><code>i16:16:16</code> - i16是16位对齐的</li>
<li><code>i32:32:32</code> - i32是32位对齐的</li>
<li><code>i64:32:64</code> - i64具有32位的ABI对齐，但优选对齐64位</li>
<li><code>f16:16:16</code> - 一半是16位对齐的</li>
<li><code>f32:32:32</code> - 浮点数是32位对齐的</li>
<li><code>f64:64:64</code> - 双是64位对齐</li>
<li><code>f128:128:128</code> - 四位是128位对齐</li>
<li><code>v64:64:64</code> - 64位向量是64位对齐的</li>
<li><code>v128:128:128</code> - 128位向量是128位对齐的</li>
<li><code>a:0:64</code> - 聚合是64位对齐</li>
</ul>
<p>当LLVM确定给定类型的对齐时，它使用以下规则：</p>
<ol>
<li>如果所寻找的类型与其中一个规格完全匹配，则使用该规格。</li>
<li>如果未找到匹配项，并且所查找的类型是整数类型，则使用大于所查找类型的位宽的最小整数类型。如果没有任何规格大于位宽，则使用最大的整数类型。例如，给定上面的默认规格，<code>i7</code>类型将使用<code>i8</code>（次大）的对齐，而<code>i65</code>和<code>i256</code>将使用<code>i64</code>（最大指定）的对齐。</li>
<li>如果找不到匹配，并且所寻找的类型是矢量类型，那么将使用小于所寻找的矢量类型的最大矢量类型作为回退。发生这种情况是因为<code>&lt;128 x double&gt;</code>可以用<code>64 &lt;2 x double&gt;</code>来实现，例如。</li>
</ol>
<p>数据布局字符串的功能可能不是您所期望的。值得注意的是，这不是来自代码生成器应该使用的对齐前端(frontend)的规范。</p>
<p>相反，如果指定，则需要目标数据布局来匹配最终代码生成器所期望的内容。这个字符串被中级优化器用来改进代码，这只有在它与最终的代码生成器使用的匹配时才有效。没有办法生成IR，这并不会将这个特定于目标的细节嵌入到IR中。如果您未指定字符串，则将使用默认规格来生成数据布局，并且优化阶段将相应地运行，并针对这些默认规格向IR中引入目标特异性。</p>
<h3 id="目标机三重表示法-Target-Triple"><a href="#目标机三重表示法-Target-Triple" class="headerlink" title="目标机三重表示法(Target Triple)"></a>目标机三重表示法(Target Triple)</h3><p>模块可以指定描述目标主机的目标机三元字符串。目标三元组的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target triple = &quot;x86_64-apple-macosx10.7.0&quot;</span><br></pre></td></tr></table></figure></p>
<p>该目标机三重串包括由减号（“<code>-</code>”）字符分隔的一系列标识符。规范形式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM</span><br><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT</span><br></pre></td></tr></table></figure></p>
<p>这些信息被传递到后端，以便为适当的架构生成代码。可以使用<code>-mtriple</code>命令行选项在命令行上覆盖它。</p>
<h3 id="指针别名规则"><a href="#指针别名规则" class="headerlink" title="指针别名规则"></a>指针别名规则</h3><p>任何内存访问都必须通过与内存访问的地址范围关联的指针值来完成，否则行为是不确定的。根据以下规则，指针值与地址范围相关联：</p>
<ul>
<li>指针值与关联基于任何值的地址相关联。（这其实是比较绕口的废话）</li>
<li>全局变量的地址与变量存储的地址范围相关联。</li>
<li>分配指令的结果值与分配的存储器的地址范围相关联。</li>
<li>默认地址空间中的空指针与无地址相关联。</li>
<li>一个非零整数常量或从未在LLVM中定义的函数返回的指针值可能与通过LLVM提供的机制以外的机制分配的地址范围关联。这些范围不得与由LLVM提供的机制分配的任何地址范围重叠。</li>
</ul>
<p>根据以下规则，指针值基于另一个指针值：</p>
<ul>
<li>由标量<code>getelementptr</code>操作符形成的指针值基于指针类型的操作符<code>getelementptr</code>。</li>
<li>在车道(lane)中的指针/升的矢量的结果的<code>getelementptr</code>操作是基于对车道(lane)指针升的的类型的载体的指针操作符<code>getelementptr</code>。</li>
<li><code>bitcast</code>的结果值是基于操作符<code>bitcast</code>。</li>
<li>由<code>inttoptr</code>形成的指针值是基于对造成（直接或间接）到指针的值的计算中的所有指针值。</li>
<li>“基于”的关系是传递性的。</li>
</ul>
<p>请注意，这个“based”的定义有意地类似于C99 中“based”的定义，尽管它稍微弱一些。</p>
<p>LLVM IR不会将类型与内存相关联。<code>load</code>的结果类型仅指示要加载的内存的大小和对齐方式，以及对值的解释。类似的第一个操作数类型store仅指示存储的大小和对齐方式。</p>
<p>因此，基于类型的别名分析，又名TBAA，也就是说<code>-fstrict-aliasing</code>，不适用于通用的非LLVM IR。<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>可用于编码额外的信息，专门的优化过程可用于实现基于类型的别名分析。</p>
<h3 id="易失性-volatile-内存访问"><a href="#易失性-volatile-内存访问" class="headerlink" title="易失性(volatile)内存访问"></a>易失性(volatile)内存访问</h3><p>某些内存访问，如<a href="http://llvm.org/docs/LangRef.html#i-load" target="_blank" rel="noopener">load</a>‘s，<a href="http://llvm.org/docs/LangRef.html#i-store" target="_blank" rel="noopener">store</a>‘s和<a href="http://llvm.org/docs/LangRef.html#int-memcpy" target="_blank" rel="noopener">llvm.memcpy</a>‘s可能被标记<code>volatile</code>。优化器不得更改易失性操作的数量或更改其相对于其他volatile操作的执行顺序。优化器可以改变相对于非volatile操作的易失性操作的顺序。<b style="color:red">这不是Java的“volatile”，并且没有跨线程同步行为。</b></p>
<p>即使那些内部函数被标记为<code>volatile</code>，IR级别的volatile加载和存储也不能安全地优化到<code>llvm.memcpy</code>或<code>llvm.memmove</code>内在函数中。同样，后端不应该拆分或合并目标机器合法的易失性加载/存储指令。</p>
<table>
<thead>
<tr>
<th>合理</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台可能依赖volatile加载，并且本地支持的数据宽度存储将作为单条指令执行。例如，在C中，这适用于具有本地硬件支持的易失性基本类型的l值，但不一定适用于聚合类型。前端支持这些预期，这在IR中是故意没有说明的。上述规则确保IR转换不会违反前端（应该是前置的语言）与该语言的合同。</td>
</tr>
</tbody>
</table>
<h3 id="并发操作的内存模型"><a href="#并发操作的内存模型" class="headerlink" title="并发操作的内存模型"></a>并发操作的内存模型</h3><p>LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有特定于平台的方式来创建它们，并且我们定义LLVM IR他们存在的行为。该模型受C++ 0x内存模型的启发。</p>
<p>有关此模型的更多非正式介绍，请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">LLVM原子指令和并发指南</a>。</p>
<p>我们将发生之前的偏序定义为最小偏序(partial order).</p>
<ul>
<li>是单线程程序顺序的超集，并且</li>
<li>当同步<code>b</code>时，包含一个从<code>a</code>到<code>b</code>的边缘。通过特定于平台的技术（如pthread锁，线程创建，线程连接等）以及原子指令引入同步对。（另请参<a href="http://llvm.org/docs/LangRef.html#ordering" target="_blank" rel="noopener">阅原子内存排序约束</a>）。</li>
</ul>
<p>请注意，程序顺序不会在线程和该线程内执行的信号之间引入边界之前发生的事件。</p>
<p>每个（定义的）读取操作（加载指令，memcpy，原子加载/读取-修改-写入等）<code>R</code>读取由（定义的）写入操作写入的一系列字节（存储指令，原子存储/读取-修改-写入，memcpy等）。就本节而言，已初始化的全局变量被认为是写入了初始化程序，它是原子化的，并且在任何其他读或写有问题的内存之前发生。对于读R的每个字节，R<sub>byte</sub> 可能会看到对相同字节的任何写入，除了：</p>
<ul>
<li>如果write<sub>1</sub> 发生在write<sub>2</sub>之前，并且write<sub>2</sub>发生在R<sub>byte</sub>之前，则R<sub>byte</sub>不会看到Write<sub>1</sub>。</li>
<li>如果R<sub>byte</sub>在write<sub>3</sub>之前发生，则R<sub>byte</sub>不会看到write<sub>3</sub>。</li>
</ul>
<p>鉴于该定义，R<sub>byte</sub>定义如下：</p>
<ul>
<li>如果R是volatile的，则结果与目标相关。（Volatile应该提供可以在C/C++中支持<code>sig_atomic_t</code>的保证，并且可以用于访问不像正常内存那样行为的地址，它通常不会提供跨线程同步。）</li>
<li>否则，如果没有写入R<sub>byte</sub>发生之前的相同字节，则R<sub>byte</sub>会对该字节返回<code>undef</code>。</li>
<li>否则，如果R<sub>byte</sub>可能只看到一次写入，则R<sub>byte</sub>将返回该写入写入的值。</li>
<li>否则，如果R是原子的，并且所有写入的R<sub>byte</sub>可能看到的都是原子的，它将选择其中一个写入的值。请参阅<a href="http://llvm.org/docs/LangRef.html#ordering" target="_blank" rel="noopener">原子内存排序约束</a>部分了解如何进行选择的其他限制条件。</li>
<li>否则R<sub>byte</sub>返回undef。</li>
</ul>
<p>R返回由它读取的一系列字节组成的值。这意味着该值内的一些字节可能是<code>undef</code>，没有整个值的<code>undef</code>。请注意，这只定义了操作的语义; 这并不意味着目标将发出多个指令来读取一系列字节。</p>
<p>请注意，在没有使用任何原子内在函数的情况下，此模型仅对单线程执行所需的IR转换放置一个限制：将store引入可能不会被存储的字节一般是不允许的。（具体来说，在另一个线程可以写入和读取地址的情况下，引入一个store可以改变一个load，可以看到只有一个写入可能看到多个写入的load。）</p>
<h3 id="原子内存排序约束"><a href="#原子内存排序约束" class="headerlink" title="原子内存排序约束"></a>原子内存排序约束</h3><p>原子指令（<a href="http://llvm.org/docs/LangRef.html#i-cmpxchg" target="_blank" rel="noopener">cmpxchg</a>，<a href="http://llvm.org/docs/LangRef.html#i-atomicrmw" target="_blank" rel="noopener">atomicrmw</a>，<a href="http://llvm.org/docs/LangRef.html#i-fence" target="_blank" rel="noopener">fence</a>，<a href="http://llvm.org/docs/LangRef.html#i-load" target="_blank" rel="noopener">atomic load</a>和<a href="http://llvm.org/docs/LangRef.html#i-store" target="_blank" rel="noopener">atomic store</a>）使用排序参数来确定与它们同步的同一地址上的其他原子指令。这些语义是从Java和C ++ 0x中借用的，但是更通俗一点。如果这些描述不够精确，请检查这些规格（请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">Atomic指南</a>中的规格参考）。<a href="http://llvm.org/docs/LangRef.html#i-fence" target="_blank" rel="noopener">fence</a>指令对待这些排序有些不同，因为他们没有收到地址。有关详细信息，请参阅该说明文档。</p>
<p>有关排序约束的更简单介绍，请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">LLVM原子指令和并发指南</a>。</p>
<ul>
<li><code>unordered</code>: 可以读取的一组值由发生前的部分顺序决定。除非某些操作写入，否则无法读取值。这旨在提供足够强大的保证来模拟Java的非volatile共享变量。此顺序不能指定为读取-修改-写入操作; 它不足以使它们以任何有趣的方式成为原子。</li>
<li><code>monotonic</code>: 除了保证<code>unordered</code>之外，每个地址上的<code>monotonic</code>操作都有单个总顺序。所有修改顺序都必须与先发生的订单兼容。不能保证修改顺序可以合并到整个程序的全局总顺序中（而这通常是不可能的）。原子读取-修改-写入操作（<code>cmpxchg</code>和<code>atomicrmw</code>）中的读取会在写入值之前立即读取修改顺序中的值。如果在同一地址的另一个原子读取之前发生一次原子读取，则稍后的读取必须在地址的修改顺序中看到相同的值或更高的值。这不允许重新排序<code>monotonic</code>（或更强大）的操作。如果地址是由一个线程<code>monotonic-ally</code>写入和其他线程monotonic-ally读取的 - 反复读取该地址，其他线程最终必须看到写入。这对应于C++ 0x/C1x的<code>memory_order_relaxed</code>。</li>
<li><code>acquire</code>: 除了<code>monotonic</code>的保障，一个进行同步边缘可以与形成release操作。这是为了模拟C++的<code>memory_order_acquire</code>。</li>
<li><code>release</code>: 除了保证<code>monotonic</code>，如果此操作写入随后由<code>acquire</code>操作读取的值，则与该操作同步。（这不是一个完整的描述;请参阅发布序列的C++0x定义。）这对应于C ++ 0x/C1x的<code>memory_order_release</code>。</li>
<li><code>acq_rel （获取+释放）</code>: <code>acquire</code>和<code>release</code>操作作为地址的一部分。这对应于C ++ 0x / C1x <code>memory_order_acq_rel</code>。</li>
<li><code>seq_cst （顺序一致）</code>: 除了保证<code>acq_rel</code>（<code>acquire</code>对于仅读取的操作，<code>release</code>对于仅写入的操作），对于所有地址上的所有顺序一致的操作，存在全局总顺序，这与在部分顺序之前发生的以及与所有受影响地址的修改顺序一致。每个按顺序一致的读取将按照此全局顺序查看最后一个先前写入相同地址的内容。这对应于C ++ 0x / C1x <code>memory_order_seq_cst</code>和Java <code>volatile</code>。</li>
</ul>
<p>如果标记了一个原子操作<code>syncscope(&quot;singlethread&quot;)</code>，它只会同步并仅参与在同一线程中运行的其他操作（例如，在信号处理程序中）的<code>seq_cst</code>总排序。</p>
<p>如果标记了一个原子操作<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>，其中 <code>&lt;target-scope&gt;</code>是目标特定的同步范围，那么它与目标相关，如果它与其他操作的<code>seq_cst</code>总排序同步并参与其中。</p>
<p>否则，未标记的原子操作<code>syncscope(&quot;singlethread&quot;)</code> 或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code> 与同步和参与未标记<code>syncscope(&quot;singlethread&quot;)</code>或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>的其它操作的<code>seq_cst</code>总排序 。</p>
<h3 id="浮点环境"><a href="#浮点环境" class="headerlink" title="浮点环境"></a>浮点环境</h3><p>默认的LLVM浮点环境假定浮点指令没有副作用。结果假设为舍入到舍入模式。此环境中不保留浮点异常状态。因此，在这些示例中，不会尝试创建或保留无效操作（SNaN）或零除异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = fdiv 0x7ff0000000000001, %X  ; 64-bit SNaN hex value</span><br><span class="line">  %B = fdiv %X, 0.0</span><br><span class="line">Safe:</span><br><span class="line">  %A = NaN</span><br><span class="line">  %B = NaN</span><br></pre></td></tr></table></figure></p>
<p>这种无异常假设的好处是可以自由推测浮点运算，而无需对浮点模型进行任何其他快速数学放松(fast-math relaxations)。</p>
<p>需要与此不同的行为的代码应使用<a href="http://llvm.org/docs/LangRef.html#constrainedfp" target="_blank" rel="noopener">约束浮点内部函数</a>。</p>
<h3 id="快速数学标志"><a href="#快速数学标志" class="headerlink" title="快速数学标志"></a>快速数学标志</h3><p>LLVM IR浮点运算（<a href="http://llvm.org/docs/LangRef.html#i-fadd" target="_blank" rel="noopener"><code>fadd</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fsub" target="_blank" rel="noopener"><code>fsub</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fmul" target="_blank" rel="noopener"><code>fmul</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fdiv" target="_blank" rel="noopener"><code>fdiv</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-frem" target="_blank" rel="noopener"><code>frem</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fcmp" target="_blank" rel="noopener"><code>fcmp</code></a>）和<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener"><code>call</code></a>可以使用以下标志来启用其他不安全的浮点转换。</p>
<ul>
<li><code>nnan</code>: 没有NaNs - 允许优化假设参数和结果不是NaN。需要进行这样的优化才能在NaN上保留已定义的行为，但结果的值未定义。</li>
<li><code>ninf</code>: 无Infs - 允许优化假设参数和结果不是<code>+/-Inf</code>。需要进行这样的优化才能在<code>+/-Inf</code>上保留已定义的行为，但结果的值未定义。</li>
<li><code>nsz</code>: 无签名零 - 允许优化将零参数或结果的符号视为无关紧要。</li>
<li><code>arcp</code>: 允许互惠(Reciprocal) - 允许优化使用参数的倒数而不是执行除法。</li>
<li><code>contract</code>: 允许浮点收缩（例如，融合乘法，然后将加法融合为融合乘加）。</li>
<li><code>afn</code>: 近似函数 - 允许用近似计算代替函数（<code>sin</code>，<code>log</code>，<code>sqrt</code>等）。有关可应用于LLVM的内在数学函数的位置，请参阅浮点内在定义。</li>
<li><code>reassoc</code>: 允许重新关联转换为浮点指令。这可能会显着改变浮点结果。</li>
<li><code>fast</code>: 这个标志暗示其他所有的。</li>
</ul>
<h3 id="使用列表顺序指令"><a href="#使用列表顺序指令" class="headerlink" title="使用列表顺序指令"></a>使用列表顺序指令</h3><p>使用列表指令对每个使用列表的内存顺序进行编码，从而允许重新创建订单。<code>&lt;order-indexes&gt;</code>是分配给引用值用途的索引的逗号分隔列表。引用值的使用列表会立即按这些索引排序。</p>
<p>Use-List指令可能出现在函数作用域或全局作用域中。它们不是指令，对IR的语义没有影响。当它们在函数范围内时，它们必须出现在最终基本块的终止符之后。</p>
<p>如果基本块的地址是通过<code>blockaddress()</code>表达式获取的， <code>uselistorder_bb</code>则可用于从其函数范围之外对其使用列表重新排序。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uselistorder &lt;ty&gt; &lt;value&gt;, &#123; &lt;order-indexes&gt; &#125;</span><br><span class="line">uselistorder_bb @function, %block &#123; &lt;order-indexes&gt; &#125;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define void @foo(i32 %arg1, i32 %arg2) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line">bb:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line"></span><br><span class="line">  ; At function scope.</span><br><span class="line">  uselistorder i32 %arg1, &#123; 1, 0, 2 &#125;</span><br><span class="line">  uselistorder label %bb, &#123; 1, 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; At global scope.</span><br><span class="line">uselistorder i32* @global, &#123; 1, 2, 0 &#125;</span><br><span class="line">uselistorder i32 7, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder i32 (i32) @bar, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder_bb @foo, %bb, &#123; 5, 1, 3, 2, 0, 4 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h3><p>源文件名字符串设置为原来的模块标识符，当通过clang前端从源代码编译时，例如，这将是编译的源文件的名称。然后通过IR和比特码进行保存。</p>
<p>目前，这对于为配置文件数据中使用的本地函数生成一致的唯一全局标识符是非常必要的，该配置文件将源文件名预先设置为本地函数名称。</p>
<p>源文件名的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_filename = &quot;/path/to/source.c&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章，翻译起来的确是非常麻烦，由于没有通读全文，里面应该有不少错误的地方，日后会重新修改。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/12/编译原理/LLVM简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/编译原理/LLVM简介/" itemprop="url">LLVM简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T15:28:52+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是LLVM"><a href="#什么是LLVM" class="headerlink" title="什么是LLVM"></a>什么是LLVM</h2><p>官方的解释是：LLVM可以被看作是一系列的编译器和工具链技术的集合，而且它们是模块化并且是可重用的。官方网站是：<a href="http://llvm.org/" target="_blank" rel="noopener">http://llvm.org/</a> 。 不过从名称上看像一个虚拟机，然而与虚拟机没有一点关系，LLVM是这个项目的名称而已。</p>
<p>LLVM最初是伊利诺伊大学的一个研究项目，其目标是提供一种现代的，基于<a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener">SSA</a>（static single assignment form，静态单赋值形式）的编译策略，能够支持任意编程语言的静态和动态编译。 从那时起，LLVM已经发展成为一个由多个子项目组成的综合项目，其中许多子项目正在各种商业和开源项目的生产中使用，并且被广泛用于学术研究。 LLVM项目中的代码遵循“UIUC”BSD-Style许可证.</p>
<p>LLVM的主要子项目有：</p>
<ol>
<li>LLVM核心库提供了一个独立于现代的源和目标的<a href="http://llvm.org/docs/Passes.html" target="_blank" rel="noopener">优化器</a>，以及支持许多流行CPU的<a href="http://llvm.org/docs/CodeGenerator.html" target="_blank" rel="noopener">代码生成</a>（以及一些不太常见的CPU）。这些库是围绕一个<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">良好规范</a>的代码表示而建立的，称为LLVM<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%96%93%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">中间语言</a>（“LLVM IR”）。 LLVM Core库有<a href="http://llvm.org/docs/" target="_blank" rel="noopener">详细的文档</a>，并且<a href="http://llvm.org/docs/tutorial/" target="_blank" rel="noopener">使用LLVM用作优化器和代码生成器</a>，将使你特别容易地将创建自己的语言（或移植现有的编译器）。</li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="noopener">Clang</a>是一种“LLVM原生”的C/C++/Objective-C编译器，它旨在提供惊人的快速编译（例如，在编译调试配置中编译Objective-C代码时<a href="http://clang.llvm.org/features.html#performance" target="_blank" rel="noopener">比GCC快大约3倍</a>），非常有用的<a href="http://clang.llvm.org/diagnostics.html" target="_blank" rel="noopener">错误和警告消息</a>，为构建优秀的源代码级工具提供了一个平台。<a href="http://clang-analyzer.llvm.org/" target="_blank" rel="noopener">Clang静态分析器</a>是一个可以自动发现代码中的错误的工具，并且它是使用Clang前端作为库来解析C/C++代码的工具。</li>
<li><a href="http://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a>项目建立在由LLVM和Clang提供的库上，以提供一个出色的本地调试器。 它使用Clang AST和表达式解析器，LLVM JIT，LLVM反汇编器等，以便提供“正常工作”的体验。 在加载符号时，它比GDB更快速，内存效率更高。</li>
<li><a href="http://libcxx.llvm.org/" target="_blank" rel="noopener">libc++</a>和<a href="http://libcxxabi.llvm.org/" target="_blank" rel="noopener">libc++ ABI</a>项目提供了C++标准库的标准一致性和高性能实现，包括对C++11的全面支持。</li>
<li><a href="http://compiler-rt.llvm.org/" target="_blank" rel="noopener">编译器rt</a>项目提供高级优化的低级代码生成器支持例程的实现，例如<code>“__fixunsdfdi”</code>以及当目标没有执行核心IR操作的短序列本机指令时生成的其他调用。 它还为动态测试工具（如<a href="http://clang.llvm.org/docs/AddressSanitizer.html" target="_blank" rel="noopener">AddressSanitizer</a>，<a href="http://clang.llvm.org/docs/ThreadSanitizer.html" target="_blank" rel="noopener">ThreadSanitizer</a>，<a href="http://clang.llvm.org/docs/MemorySanitizer.html" target="_blank" rel="noopener">MemorySanitizer</a>和<a href="http://clang.llvm.org/docs/DataFlowSanitizer.html" target="_blank" rel="noopener">DataFlowSanitizer</a>）提供了运行时库的实现。</li>
<li><a href="http://openmp.llvm.org/" target="_blank" rel="noopener">OpenMP</a>子项目提供<a href="http://www.openmp.org/" target="_blank" rel="noopener">OpenMP</a> Runtime，以便与Clang中的OpenMP实现一起使用。</li>
<li><a href="http://polly.llvm.org/" target="_blank" rel="noopener">polly</a>项目实现了一套缓存局部优化以及使用多面体模型的自动并行和向量化。</li>
<li><a href="http://libclc.llvm.org/" target="_blank" rel="noopener">libclc</a>项目旨在实现OpenCL标准库。</li>
<li><a href="http://klee.llvm.org/" target="_blank" rel="noopener">klee</a>项目实现了一个“符号虚拟机”，它使用定理证明器来尝试评估程序中的所有动态路径，以努力寻找错误并证明函数的属性。 klee的一个主要特点是它可以在检测到错误的情况下生成一个测试用例。</li>
<li><a href="http://safecode.cs.illinois.edu/" target="_blank" rel="noopener">SAFECode</a>项目是用于C/C++程序的内存安全编译器。它使用运行时检查代码来检测运行时的内存安全错误（例如，缓冲区溢出）。它可以用来保护软件免受安全攻击，也可以用作Valgrind之类的内存安全错误调试工具。</li>
<li><a href="http://lld.llvm.org/" target="_blank" rel="noopener">lld</a>项目旨在成为clang/llvm的内置链接器。目前，clang必须调用系统链接器来生成可执行文件。</li>
</ol>
<p>除了LLVM的官方子项目之外，还有各种各样<a href="http://llvm.org/ProjectsWithLLVM/" target="_blank" rel="noopener">使用LLVM组件执行各种任务的其他项目</a>。 通过这些外部项目，您可以使用LLVM编译Ruby，Python，Haskell，Java，D，PHP，Pure，Lua和一些其他语言。 LLVM的一个主要优势是其多功能性，灵活性和可重用性，这就是为什么它被用于如此广泛的各种不同任务的原因：从Lua等嵌入式语言的轻量级JIT编译到编译Fortran代码以实现大规模超级电脑。</p>
<p>和其他所有事情一样，LLVM拥有广泛而友好的社区，他们对构建优秀的底层工具感兴趣。如果您有兴趣参与，首先要浏览<a href="http://blog.llvm.org/" target="_blank" rel="noopener">LLVM博客</a>并注册<a href="http://lists.llvm.org/mailman/listinfo/llvm-dev" target="_blank" rel="noopener">LLVM Developer邮件列表</a>。 有关如何发送补丁程序，获取提交权限以及版权和许可证主题的信息，请参阅<a href="http://llvm.org/docs/DeveloperPolicy.html" target="_blank" rel="noopener">LLVM开发者规则</a>。</p>
<h2 id="关于LLVM"><a href="#关于LLVM" class="headerlink" title="关于LLVM"></a><b style="color:red">关于LLVM</b></h2><p><b style="color:green">看上面的说明可能有点懵，但其实就是LLVM定义了一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%96%93%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">中间语言</a>或称<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">通用中间语言</a>,提供了丰富的中间码(IR),这样就为我们创建自己的语言提供了极大的便利，其实就是感觉自己用IR去生成自己的命令，类似于CPU中的微指令了。另外就是将自己的语言转成对应的LLVM IR，那么就可以直接使用LLVM子项目中的JIT，这样你就不用自己写虚拟机了，的确是带来了极大的遍历。</b></p>
<p><b style="color:blue">再比如像solidity这样的语言需要运行在以太坊的CPP节点，Go节点，Parity的Scala节点，这样的话我们要写很多的编译器和虚拟机，但是有了LLVM后，一切都不用担心了，实现起来还是比较靠谱的，不是吗？</b></p>
<p><b style="color:green">另外通过LLVM我们可以实现不同语言之间的互转，比如C++代码转成node代码。中间只要通过LLVM就可以了。以前不明白微软怎么支持多种语言实现在win10上安装，现在终于有思路了，只是微软要写多种编译器，可能这个过程比较难吧，他们放弃了。还有就比如以太坊的<a href="https://github.com/ethereum/solc-bin" target="_blank" rel="noopener">solc-bin</a>里面有用的文件只有一个7M多的js文件，而且还是压缩的，从ReadMe中我们可以发现，这个项目中的文件都是通过emscripten生成的；而emscripten是将LLVM中间语言转化为node代码，一切已然明了。</b></p>
<p><b style="color:blue">所以我觉得学习LLVM语言还是很有必要的过程，应该深入去学习一下。</b></p>
<h2 id="关于emscripten"><a href="#关于emscripten" class="headerlink" title="关于emscripten"></a>关于emscripten</h2><p>这是一个很棒的项目，将LLVM中间语言转化为node的代码。更多的东西就不用多介绍了，也不进行深入地学习了，这要精通node的编译器和语法知识才行，我就读读Readme、WIKI和api文档就好了。下面列一下学习的资料吧！<br><a href="https://github.com/kripken/emscripten" target="_blank" rel="noopener">官方github项目</a><br><a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="noopener">Emscripten Wiki</a><br><a href="http://kripken.github.io/emscripten-site/index.html" target="_blank" rel="noopener">Emscripten 文档</a></p>
<h2 id="LLVM的命令指南"><a href="#LLVM的命令指南" class="headerlink" title="LLVM的命令指南"></a>LLVM的命令指南</h2><p>以下文档是所有LLVM工具的命令描述。 这些页面描述如何使用LLVM命令以及它们的选项。 请注意，这些页面没有描述所有工具可用的所有选项。 要获得完整列表，请将–help（常规选项）或–help-hidden（常规和调试选项）参数传递给您感兴趣的工具。</p>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-as.html" target="_blank" rel="noopener">llvm-as - LLVM汇编程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-dis.html" target="_blank" rel="noopener">llvm-dis - LLVM反汇编程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/opt.html" target="_blank" rel="noopener">opt - LLVM优化器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llc.html" target="_blank" rel="noopener">llc - LLVM静态编译器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/lli.html" target="_blank" rel="noopener">lli - 直接从LLVM位码执行程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-link.html" target="_blank" rel="noopener">llvm-link - LLVM位码链接器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-ar.html" target="_blank" rel="noopener">llvm-ar - LLVM归档打包 archiver</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-lib.html" target="_blank" rel="noopener">llvm-lib - LLVM lib.exe lib.exe兼容库工具</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-nm.html" target="_blank" rel="noopener">llvm-nm - 列出LLVM位码和目标文件的符号表</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-config.html" target="_blank" rel="noopener">llvm-config - 打印LLVM编译选项</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-diff.html" target="_blank" rel="noopener">llvm-diff - LLVM结构差异</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-cov.html" target="_blank" rel="noopener">llvm-cov - 发布覆盖信息</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-profdata.html" target="_blank" rel="noopener">llvm-profdata - 配置数据工具</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-stress.html" target="_blank" rel="noopener">llvm-stress - 生成随机的.ll文件</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-symbolizer.html" target="_blank" rel="noopener">llvm-symbolizer - 将地址转换为源代码位置</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-dwarfdump.html" target="_blank" rel="noopener">llvm-dwarfdump - 转储并验证DWARF调试信息</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/dsymutil.html" target="_blank" rel="noopener">dsymutil - 处理归档的DWARF调试符号文件</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-mca.html" target="_blank" rel="noopener">llvm-mca - LLVM机器代码分析器</a></li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li><a href="http://llvm.org/docs/CommandGuide/bugpoint.html" target="_blank" rel="noopener">bugpoint - 自动测试案例缩减工具</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-extract.html" target="_blank" rel="noopener">llvm-extract - 从LLVM模块中提取函数</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html" target="_blank" rel="noopener">llvm-bcanalyzer - LLVM位码分析器</a></li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li><a href="http://llvm.org/docs/CommandGuide/FileCheck.html" target="_blank" rel="noopener">FileCheck - 灵活的模式匹配文件验证器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/tblgen.html" target="_blank" rel="noopener">tblgen - 目标描述到C ++代码生成器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/lit.html" target="_blank" rel="noopener">lit - LLVM综合测试仪</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-build.html" target="_blank" rel="noopener">llvm-build - LLVM项目构建实用程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-exegesis.html" target="_blank" rel="noopener">llvm-exegesis - LLVM机器指令基准</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-pdbutil.html" target="_blank" rel="noopener">llvm-pdbutil - PDB文件取证和诊断</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-readobj.html" target="_blank" rel="noopener">llvm-readobj - LLVM对象读取器</a></li>
</ul>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://llvm.org/" target="_blank" rel="noopener">The LLVM Compiler Infrastructure</a><br><a href="http://llvm.org/docs/CommandGuide/" target="_blank" rel="noopener">LLVM Command Guide</a><br><a href="https://blog.csdn.net/snsn1984/article/details/8232943" target="_blank" rel="noopener"> LLVM每日谈之七 Clang</a><br><a href="https://blog.csdn.net/snsn1984/article/details/8593380" target="_blank" rel="noopener">七天LLVM零基础入门（Linux版本）——第一天</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/11/golang/Go的汇编程序快速指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/golang/Go的汇编程序快速指南/" itemprop="url">Go的汇编程序快速指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T17:14:18+08:00">2018-04-11</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go语言/" itemprop="url" rel="index"><span itemprop="name">Go语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近日在研究solidity语言的时候，发现了很多关于汇编的有趣知识，感觉知识无涯，勤奋是道呀！要学习的东西还是很多的，今天就来研究一下这个Go语言的汇编。本文是参考Go语言官方的文档，好像这个没有详细的文档，就先入个门吧！</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档提到里面的内容是不全面的，试问全面的在哪？</p>
<p>Go的汇编语言基于<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB" target="_blank" rel="noopener">Plan 9</a>的汇编，<a href="https://9p.io/plan9/" target="_blank" rel="noopener">Plan 9网站</a>的页面上有详细描述。如果你想编写汇编语言，你应该读<a href="https://9p.io/sys/doc/asm.html" target="_blank" rel="noopener">这篇文档</a>，虽然它是Plan 9相关的。这边文档总结了汇编的语法，并且描述了使用汇编语言和Go程序交互时的特殊之处。</p>
<p>有一点是很重要的是，Go的汇编中没有直接体现出底层的机器。有些汇编细节能直接对应到机器，但有些不是。这是因为编译器套件在常规过程中不需要汇编语言。取而代之的是，编译器产生二进制的不完整的汇编指令集，链接器会完成它。<b style="color:blue">实际上，链接器做了汇编指令的选择，所以当你看到类似于MOV这样的指令，链接器的实际操作可能不是一个移动指令，也许是清除或者载入</b>。或者可能会根据指令的名字对应到真实的机器指令。总体上，机器相关的指令操作趋向于体现出真实的机器指令，但是一些通用的概念类似于移动内存数据、调用子例程、返回等操作就更抽象了。具体的细节和架构相关，我们为这种不精确性道歉;情况并不明确。</p>
<p>汇编程序是生成中间码的一种方法，未完整定义的指令集作为链接器的输入。如果你想看到特定CPU架构下的汇编指令集，如amd64，在Go标准库的源文件中就有许多例子，在<a href="https://golang.org/pkg/runtime/" target="_blank" rel="noopener">runtime</a>和<a href="https://golang.org/pkg/math/big/" target="_blank" rel="noopener">math/big</a>包中。 或者你还可以参照下面的程序，来检查编译器的汇编输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat x.go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> GOOS=linux GOARCH=amd64 go tool compile -S x.go        <span class="comment"># or: go build -gcflags -S x.go</span></span></span><br><span class="line"></span><br><span class="line">--- prog list "main" ---</span><br><span class="line">0000 (x.go:3) TEXT    main+0(SB),$8-0</span><br><span class="line">0001 (x.go:3) FUNCDATA $0,gcargs·0+0(SB)</span><br><span class="line">0002 (x.go:3) FUNCDATA $1,gclocals·0+0(SB)</span><br><span class="line">0003 (x.go:4) MOVQ    $3,(SP)</span><br><span class="line">0004 (x.go:4) PCDATA  $0,$8</span><br><span class="line">0005 (x.go:4) CALL    ,runtime.printint+0(SB)</span><br><span class="line">0006 (x.go:4) PCDATA  $0,$-1</span><br><span class="line">0007 (x.go:4) PCDATA  $0,$0</span><br><span class="line">0008 (x.go:4) CALL    ,runtime.printnl+0(SB)</span><br><span class="line">0009 (x.go:4) PCDATA  $0,$-1</span><br><span class="line">0010 (x.go:5) RET     ,</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>FUNCDATA和PCDATA指令包含一些垃圾收集器需要的信息。它们由编译器产生。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>尽管汇编程序从Plan 9汇编程序中获得了指导，但它是一个独特的程序，因此存在一些差异。一个是不断的评估。汇编器中的常量表达式使用Go的运算符优先级解析，而不是原始的类C优先级。因此<code>3&amp;1&lt;&lt;2</code>是4，而不是0–它解析为<code>(3&amp;1)&lt;&lt;2</code> 不是<code>3&amp;(1&lt;&lt;2)</code>。而且，常量总是被评估为64位无符号整数。因此-2，不是整数值负2，而是具有相同位模式的无符号64位整数。这种区别无关紧要，但是这是为了当右操作数的高位被设置，避免除法或右移的歧义性。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>一些符号（如R1或LR）是预定义的，并且指的是寄存器。确切的集合取决于体系结构。</p>
<p><b style="color:red">有四个预先标记的符号表示伪寄存器。这些不是真正的寄存器，而是由工具链维护的虚拟寄存器，例如帧指针</b>。所有体系结构的伪寄存器组都是相同的：</p>
<ul>
<li>FP：帧（frame）指针：参数和本地变量。</li>
<li>PC：程序计数器：跳转和分支。</li>
<li>SB：静态基址指针：全局符号。</li>
<li>SP：堆栈指针：堆栈顶部。</li>
</ul>
<p>所有用户定义的符号都被写为伪寄存器FP（参数和本地变量）和SB（全局）的偏移量 。</p>
<p>SB伪寄存器可以被认为是内存的原点，所以符号<code>foo(SB)</code>的名称是foo在内存中的地址。这种格式用于命名全局函数和数据。在名称中添加&lt;&gt;，就像<code>foo&lt;&gt;(SB)</code>一样，那么该名称只能在当前源文件中看到，就像C文件中的<code>static</code>顶级声明。给名称添加一个偏移量就是指符号地址的偏移量，因此<code>foo+4(SB)</code>是foo开始处的四个字节。</p>
<p><code>FP</code>伪寄存器是用来指向函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈中的参数作为该伪寄存器的偏移量。因此<code>0(FP)</code>是函数的第一个参数，<code>8(FP)</code>第二个参数（在64位机器上）等等。但是，当以这种方式引用函数参数时，有必要在开始处放置一个名称，如<code>first_arg+0(FP)</code>和<code>second_arg+8(FP)</code>。（帧指针的偏移量，偏移量的含义 - 与其使用SB的偏移量不同，它是与符号的偏移量。）有些汇编程序强制执行这个约定，拒绝普通的<code>0(FP)</code>和<code>8(FP)</code>。实际名称在语义上不相关，但应该用来记录参数的名称。值得强调的是<code>FP</code>始终是伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的体系结构中也是如此。</p>
<p>对于使用Go的汇编函数，<code>go vet</code>将检查参数名称和偏移量是否匹配。在32位系统上，64位值的低32位和高32位通过在名称中添加<code>_lo</code>或<code>_hi</code>后缀来区分，如<code>arg_lo+0(FP)</code>或<code>arg_hi+4(FP)</code>。如果Go原型没有命名它的结果，那么预期的汇编名称是<code>ret</code>。</p>
<p><code>SP</code>伪寄存器是虚拟堆栈指针，用来指向帧局部变量和为函数调用准备的参数。它指向本地堆栈帧的顶部，因此引用应使用负数表示的范围<code>[-framesize，0）</code>中：例如：<code>x-8(SP)</code>，<code>y-4(SP)</code>等等。</p>
<p><b style="color:blue">在名<code>SP</code>为硬件寄存器的体系结构中，名称前缀将对虚拟堆栈指针的引用与对帧（frame）SP寄存器的引用进行区分。即，<code>x-8(SP)</code>和<code>-8(SP)</code> 是不同的存储位置：所述第一指虚拟堆栈指针伪寄存器，而第二指硬件的SP寄存器。</b></p>
<p><b style="color:blue">在物理机器上SP和PC是传统的物理地址寄存器中的别名，在Go汇编中名称SP和PC仍然特殊处理; 例如，SP引用要求符号，很像FP。要访问实际的硬件寄存器，请使用真实的寄存器名称。例如，在ARM体系结构上的硬件上硬件SP，PC可作为R13和R15访问。</b></p>
<p>分支和直接跳转总是在PC中写为的偏移量，或跳转到标签：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">	MOVW $0, R1</span><br><span class="line">	JMP label</span><br></pre></td></tr></table></figure></p>
<p>每个标签只能在其定义的函数中可见。因此允许文件中的多个函数定义和使用相同的标签名称。直接跳转和调用指令可以将文本符号作为目标，例如<code>name(SB)</code>,但不是符号的偏移量<code>name+4(SB)</code>。</p>
<p>指令，寄存器和汇编程序指令总是以大写形式提醒您，汇编编程是一项艰巨的工作。（例外：在ARM平台下，代表当前goroutine的g寄存器被重新命名。）</p>
<p>在Go对象文件和二进制文件中，符号的完整名字是包的路径加上一个句点：<code>fmt.Printf</code>或<code>math/rand.Int</code>。由于汇编器的解析器将句点和斜线视为标点符号，因此这些字符串不能直接用作标识符名称。相反，汇编程序允许标识符中的中点字符<code>U+00B7</code>和除法斜杠<code>U+2215</code>，并将它们重写为纯句点和斜杠。在汇编源代码文件中，上面的符号写成<code>fmt·Printf</code>和<code>math∕rand·Int</code>。通过在编译时使用-S标志看到的汇编代码列表中直接显示了句点和斜杠，而不是在汇编程序中需要的Unicode替代字符(指上面的两个特殊Unicode字符)。</p>
<p>大部分手写的汇编文件中，不要在符号名中包含完整的包路径，因为链接器会在任何以句点开头的名字前面插入当前对象文件的路径：包含<code>math/rand</code>包的汇编源文件中，rand包的Int函数可以当做<code>·Int</code>来引用。这种便捷性避免了需要在自身的源代码中硬编码导入路径，可以让代码从一个地方移动到另一个地方时变得更容易。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>汇编程序使用各种指令将文本和数据绑定到符号名称。例如，这里是一个简单但是完整的函数定义。<code>TEXT</code>指令声明符号<code>runtime·profileloop</code>, 指令紧接在类似于函数的主体中。<code>TEXT</code>块中的最后一条指令必须是某种跳转，通常是<code>RET</code>（伪）指令。（如果不是，链接器会追加跳转到块自身的指令;<code>TEXT</code>块中没有<code>fallthrough</code>。）在符号之后，参数是<code>标志</code>（见下面）和<code>栈帧</code>的大小，是一个常量（参见下面的代码）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·profileloop(SB),NOSPLIT,$8</span><br><span class="line">    MOVQ    $runtime·profileloop1(SB), CX</span><br><span class="line">    MOVQ    CX, 0(SP)</span><br><span class="line">    CALL    runtime·externalthreadhandler(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">这个函数的栈帧大小为8字节(MOVQ CX, 0(SP)操作栈指针)，没有参数</b></p>
<p>一般情况下，栈帧大小后面跟着一个由减号分隔的参数大小。（这不是一个减法，只是特殊的语法。）栈帧大小是<code>$24-8</code>描述该函数有一个24字节的栈帧，并且需要一个8个字节的参数，它位于调用者的栈帧上。如果没有为<code>TEXT</code>指定<code>NOSPLIT</code>标志，则必须提供参数大小。对于使用Go标准的汇编函数，<code>go vet</code>将检查参数大小是否正确。</p>
<p>请注意，符号名称使用中点分隔组件，并且被定义为从伪寄存器SB开始的一个offsets。在Go源码的runtime包中，使用简称profileloop来调用。</p>
<p>全局数据符号使用初始化的一系列<code>DATA</code>指令来定义，并且跟在一个<code>GLOBAL</code>指令之后。每个<code>DATA</code>指令初始化一块指定的内存区域。没有明确初始化的内存区域会被置为零。标准的<code>DATA</code>指令形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA	symbol+offset(SB)/width, value</span><br></pre></td></tr></table></figure></p>
<p>这样就初始化了symbol，内存在指定的offset处，带有指定的width和给定的value。一个symbol中的DATA指令必须是逐渐增长的offsets。</p>
<p><code>GLOBL</code>指令声明一个符号是全局的。参数是可选的标志和需要声明为全局的数据的大小，除非<code>DATA</code>指令已初始化它，否则初始值将全部为零。<code>GLOBAL</code>指令必须跟在对应的<code>DATA</code>指令之后。</p>
<p>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA divtab&lt;&gt;+0x00(SB)/4, $0xf4f8fcff</span><br><span class="line">DATA divtab&lt;&gt;+0x04(SB)/4, $0xe6eaedf0</span><br><span class="line">...</span><br><span class="line">DATA divtab&lt;&gt;+0x3c(SB)/4, $0x81828384</span><br><span class="line">GLOBL divtab&lt;&gt;(SB), RODATA, $64</span><br><span class="line"></span><br><span class="line">GLOBL runtime·tlsoffset(SB), NOPTR, $4</span><br></pre></td></tr></table></figure></p>
<p>声明并初始化<code>divtab&lt;&gt;</code>, 一个只读的64位<code>table</code>含有4字节的整数值。并声明<code>runtime·tlsoffset</code>一个4字节的，隐式地置零的变量，该变量不包含指针。</p>
<p>指令可能有一个或两个参数。如果有两个，第一个是比特掩码的标志，它可以写成数字表达式，多个掩码之间可以相加或者做逻辑或运算，或者可以写成友好可读的形式。这些值定义在头文件<code>textflag.h</code>中：</p>
<ul>
<li><code>NOPROF = 1</code> (TEXT项使用.) 不优化NOPROF标记的函数。这个标志已废弃。</li>
<li><code>DUPOK = 2</code> 在二进制文件中允许一个符号的多个实例。链接器会选择其中之一。</li>
<li><code>NOSPLIT = 4</code> (TEXT项使用.) 不插入预先检测是否将栈空间分裂的代码。程序的栈帧中，如果调用任何其他代码都会增加栈帧的大小，必须在栈顶留出可用空间。用来保护处理栈空间分裂的代码本身。</li>
<li><code>RODATA = 8</code> (DATA和GLOBAL项使用.) 将这个数据放在只读的块中。</li>
<li><code>NOPTR = 16</code> (DATA和GLOBAL项使用.)这个数据不包含指针所以就不需要垃圾收集器来扫描。</li>
<li><code>WRAPPER = 32</code> (TEXT项使用.) This is a wrapper function and should not count as disabling recover.</li>
<li><code>NEEDCTXT= 64</code> （对于TEXT项目。）这个函数是一个闭包，所以它使用它的传入上下文寄存器。</li>
</ul>
<h2 id="协调Runtime"><a href="#协调Runtime" class="headerlink" title="协调Runtime"></a>协调Runtime</h2><p>要使垃圾收集正确运行，运行时必须知道所有全局数据和大多数堆栈帧中指针的位置。Go编译器在编译Go源文件时会发出此信息，但汇编程序必须明确定义这些信息。</p>
<p>标有NOPTR标志的数据符号（见上面）被视为不包含指向Runtime分配数据的指针。带有<code>RODATA</code>标志的数据符号被分配在只读存储器中，因此被视为隐式标记<code>NOPTR</code>。总的大小小于指针大小的数据符号也被视为隐式标记<code>NOPTR</code>。无法在汇编语言中定义包含指针的符号; 这种符号必须在Go源文件中定义。汇编源文件仍然可以通过名称来引用符号，即使这个符号没有使用<code>DATA</code>和<code>GLOBL</code>指令也是如此。一个很好的通用规则是，在Go代码中定义非只读的数据，而不是在汇编程序中。</p>
<p>每个函数都需要注释，标明在其参数、返回结果和本地栈帧上给出活动指针的位置。如果汇编函数没有指针类型的结果并且没有本地栈帧，或者没有调用函数，唯一需要做的是为函数在同名的包中定义一个Go函数原型（例如，syscall包中的函数Syscall应该在其TEXT指令中使用名称·Syscall而不是等效名称syscall·Syscall）。在更复杂的情况下，需要明确的注释出。这些注释使用在头文件<code>funcdata.h</code>中定义的伪指令。</p>
<p>如果一个函数没有参数并且没有结果，指针信息可以省略。这可以通过在TEXT指令中使用参数大小<code>$n-0</code>指出。否则，指针信息必须由Go源文件中的Go原型函数提供，即使汇编函数不是直接被Go代码调用的。（原型还会使用<code>go vet</code>检查参数引用。）在函数的开头，参数都假设是已经被初始化的，但是函数的返回结果会假设是未初始化的。如果在执行CALL指令时，结果中HOLD住一个指针，函数应该在开头就将返回结果初始化为零值，并且接着执行伪指令<code>GO_RESULTS_INITIALIZED</code>。这个指令记录了当前返回结果已经被初始化，并且在当栈帧转移和垃圾收集的时候扫描返回结果。非常具有代表性的是会安排汇编函数不返回指针或者不包含任何CALL指令；在Go标准库中的汇编函数都没有使用<code>GO_RESULTS_INITIALIZED</code>。</p>
<p>如果函数没有本地堆栈帧，则可以省略指针信息。这可以通过在TEXT指令中使用栈帧大小$0-n指出。如果函数不包含<code>CALL</code>指令，指针信息也可以省略。否则，本地栈帧不能包含指针，汇编必须通过执行<code>NO_LOCAL_POINTERS</code>伪指令来确认这种情况。由于堆栈大小调整是通过移动堆栈来实现的，栈指针可能在函数调用的时候发生改变：即使指向堆栈数据的指针也不能保存在局部变量中。</p>
<p>汇编程序函数应该总是给出Go原型，以提供参数和结果的指针信息，并用<code>go vet</code>检查访问偏移量的偏移量是否正确。</p>
<h2 id="架构相关的细节"><a href="#架构相关的细节" class="headerlink" title="架构相关的细节"></a>架构相关的细节</h2><p>列出某种机器的全部指令和细节是不切实际的。如果要查看为特定机器定义了哪些指令，比如ARM，请查看该体系结构支持库的obj源代码，源码在<code>src/cmd/internal/obj/arm</code>目录中。在那个目录中是一个文件<code>a.out.go</code>; 它包含一长串以<code>A</code>开头的常量，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	AAND = obj.ABaseARM + obj.A_ARCHSPECIFIC + iota</span><br><span class="line">	AEOR</span><br><span class="line">	ASUB</span><br><span class="line">	ARSB</span><br><span class="line">	AADD</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>这是该架构的汇编器和链接器已知的指令及其拼写列表。该列表中的每条指令都以首字母<code>A</code>开始，因此<code>AAND</code>表示按位和指令 <code>AND</code>（不带前导A），并以<code>AND</code>写入汇编源代码。枚举主要按字母顺序排列。（<code>AXXX</code>体系结构无关，在<code>cmd/internal/obj</code>程序包中定义 ，代表无效指令）。这些A名称的顺序与机器指令的实际编码无关。<code>cmd/internal/obj</code>包负责处理这些细节。</p>
<p>有关386和AMD64体系结构的说明均已列入<code>cmd/internal/obj/x86/a.out.go</code>。</p>
<p>这些架构共享共同寻址模式的标签名，例如 <code>(R1)</code>（直接寄存器寻址）， <code>4(R1)</code>（寄存器间接偏移）和 <code>$foo(SB)</code>（绝对地址）。汇编器还支持每种体系结构特有的一些（不一定是全部）寻址模式。下面的部分列出了这些。</p>
<p>前面几部分示例中的一个细节是指令中的数据从左向右流动： <code>MOVQ $0, CX</code>清除<code>CX</code>。即使在某些架构上顺序是相反的，这种规则也是适用的。</p>
<p>这里有一些对于Go所指的架构的相关的细节的描述。</p>
<h3 id="32位英特尔386"><a href="#32位英特尔386" class="headerlink" title="32位英特尔386"></a>32位英特尔386</h3><p>指向g(goroutine)结构的Runtime指针通过MMU中其他未使用（就go而言）寄存器的值进行维护。如果源文件包含一个特别的头<code>go_asm.h</code>, 则为汇编程序定义一个与操作系统相关的宏<code>get_tls</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;go_asm.h&quot;</span><br></pre></td></tr></table></figure></p>
<p>runtime中，<code>get_tls</code>宏通过一个指向<code>g</code>指针的指针来加载它的参数寄存器，<code>g</code>结构包含<code>m</code>指针。加载<code>g</code>和<code>m</code>的序列使用<code>CX</code>，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_tls(CX)</span><br><span class="line">MOVL	g(CX), AX     // Move g into AX.</span><br><span class="line">MOVL	g_m(AX), BX   // Move g.m into BX.</span><br></pre></td></tr></table></figure></p>
<p>寻址模式：</p>
<ul>
<li><code>(DI)(BX*2)</code>：地址<code>DI</code>加上<code>BX*2</code>的位置。</li>
<li><code>64(DI)(BX*2)</code>：地址<code>DI</code>加上<code>BX*2</code>加上<code>64</code> 的位置。这些模式只接受1,2,4和8作为比例因子。</li>
</ul>
<p>在使用编译器和汇编程序的<code>-dynlink</code>或<code>-shared</code>模式时，固定内存位置任何加载或存储（如全局变量）必须假定重写<code>CX</code>。因此，为了安全使用这些模式，除了在内存引用之间外，汇编源码通常应避免使用<code>CX</code>。</p>
<h3 id="64位Intel-386（又名amd64）"><a href="#64位Intel-386（又名amd64）" class="headerlink" title="64位Intel 386（又名amd64）"></a>64位Intel 386（又名amd64）</h3><p>这两种体系结构在汇编程序级别上表现基本相同。访问 64位版本的<code>m</code>和<code>g</code>指针的汇编代码与32位386相同，只是它使用MOVQ而不是MOVL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_tls(CX)</span><br><span class="line">MOVQ	g(CX), AX     // Move g into AX.</span><br><span class="line">MOVQ	g_m(AX), BX   // Move g.m into BX.</span><br></pre></td></tr></table></figure></p>
<h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>寄存器<code>R10</code>和<code>R11</code> 由编译器和链接保留使用。</p>
<p><b style="color:red"><code>R10</code>指向<code>g</code>（<code>goroutine</code>）结构</b>。在汇编源代码中，这个指针必须被称为g; 名称<code>R10</code>不被识别。</p>
<p>为了让人们和编译器更容易地编写汇编代码，ARM链接器允许一般寻址形式和<code>DIV</code>或者<code>MOD</code>伪指令，这些伪指令使用单个硬件指令可能无法表达。它实现这些多条指令形式，通常使用<code>R11</code>寄存器来保存临时值。手写汇编可以使用<code>R11</code>，但这样做需要确保链接程序不会使用它来实现函数中的任何其他指令。</p>
<p>定义一个<code>TEXT</code>时，指定帧大小<code>$-4</code>告诉链接器，这是一个叶函数，不需要在Entry上保存<code>LR</code>。</p>
<p><code>SP</code>始终指向前面描述的虚拟堆栈指针。对于硬件寄存器，请使用<code>R13</code>。</p>
<p>条件码的语法是在指令中添加一个句点和一个或两个字母的代码，如下所示<code>MOVW.EQ</code>。可以附加多个代码：<code>MOVM.IA.W</code>。代码修饰符的顺序是无关紧要的。</p>
<p>寻址模式：</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0-&gt;16 </span><br><span class="line">R0&gt;&gt;16 </span><br><span class="line">R0&lt;&lt;16 </span><br><span class="line">R0@&gt;16：对于&lt;&lt;，左移16位的R0。其他代码是-&gt;（算术右移）， &gt;&gt;（逻辑右移）和 @&gt;（右旋）。</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0-&gt;R1 </span><br><span class="line">R0&gt;&gt;R1 </span><br><span class="line">R0&lt;&lt;R1 </span><br><span class="line">R0@&gt;R1：因为&lt;&lt;，R0计数在左移R1。其他代码是-&gt;（算术右移）， &gt;&gt;（逻辑右移）和 @&gt;（右旋）。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[R0,g,R12-R15]</code>：对于多寄存器指令，该组包括 <code>R0</code>，<code>g</code>，和<code>R12</code>到<code>R15</code>。</p>
</li>
<li><code>(R5, R6)</code>：目的寄存器对。</li>
</ul>
<h3 id="ARM64"><a href="#ARM64" class="headerlink" title="ARM64"></a>ARM64</h3><p>ARM64端口处于实验状态。</p>
<p>指令修饰符附加到指令后的句点。只有修饰符P（后置）和W（前递增）： <code>MOVW.P</code>，<code>MOVW.W</code></p>
<p>寻址模式：</p>
<ul>
<li><code>(R5, R6)</code>：LDP/STP的寄存器对。</li>
</ul>
<h3 id="64位PowerPC，又名ppc64"><a href="#64位PowerPC，又名ppc64" class="headerlink" title="64位PowerPC，又名ppc64"></a>64位PowerPC，又名ppc64</h3><p>64位PowerPC端口处于试验状态。</p>
<p>寻址模式：</p>
<ul>
<li><code>(R5)(R6*1)</code>：<code>R5</code>加<code>R6</code>的位置。它是x86上的缩放模式，但是唯一允许的扩展是1。</li>
<li><code>(R5+R6)</code>：<code>(R5)(R6*1)</code>的别名</li>
</ul>
<h3 id="IBM-z-Architecture，又名s390x"><a href="#IBM-z-Architecture，又名s390x" class="headerlink" title="IBM z/Architecture，又名s390x"></a>IBM z/Architecture，又名s390x</h3><p>寄存器<code>R10</code>和<code>R11</code>保留。汇编程序在汇编某些指令时使用它们来保存临时值。</p>
<p><code>R13</code>指向<code>g</code>（goroutine）结构。这个寄存器必须被称为g; 名称<code>R13</code>不被识别。</p>
<p><code>R15</code>指向堆栈帧，通常只能使用虚拟寄存器<code>SP</code>和<code>FP</code>。</p>
<p>加载和存储多条指令在一系列寄存器上运行。寄存器范围由开始寄存器和结束寄存器指定。例如，<code>LMG(R9)</code>, <code>R5</code>, <code>R7</code>将加载<code>R5</code>，<code>R6</code>和<code>R7</code>与在64位值<code>0(R9)</code>，<code>8(R9)</code>和<code>16(R9)</code>分别。</p>
<p>存储和存储指令（如<code>MVC</code>和<code>XC</code>）的长度作为第一个参数写入。例如，<code>XC $8, (R9)</code>, (R9)将在指定的地址处清除R9中八个字节。</p>
<p>如果一个向量指令将长度或索引作为参数，那么它将成为第一个参数。例如，<code>VLEIF $1, $16, V2</code>将16个值加载到V2索引之一中。使用向量指令时应注意确保它们在运行时可用。要使用矢量指令，机器必须同时具有矢量功能（设施列表中的位129）和内核支持。如果没有内核支持，矢量指令将不起作用（它将相当于一条<code>NOP</code>指令）。</p>
<p>寻址模式：</p>
<ul>
<li><code>(R5)(R6*1)</code>：R5加R6的位置。它是x86上的缩放模式，但是唯一允许的尺寸是1。</li>
</ul>
<h3 id="MIPS，MIPS64"><a href="#MIPS，MIPS64" class="headerlink" title="MIPS，MIPS64"></a>MIPS，MIPS64</h3><p>通用寄存器被命名<code>R0</code>到<code>R31</code>，浮点寄存器<code>F0</code>到<code>F31</code>。</p>
<p><code>R30</code>保留指向g。 <code>R23</code>被用作临时寄存器。</p>
<p>在<code>TEXT</code>指令中，栈大小MIPS是<code>$-4</code>，对于MIPS64是<code>$-8</code>，指示链接器不保存LR。</p>
<p><code>SP</code>指的是虚拟堆栈指针。对于硬件寄存器，请使用<code>R29</code>。</p>
<p>寻址模式：</p>
<ul>
<li>16(R1)：位置在R1加16。</li>
<li>(R1)：别名0(R1)。</li>
</ul>
<p>GOMIPS的环境变量的值（<code>hardfloat</code>或 <code>softfloat</code>）由预先定义<code>GOMIPS_hardfloat</code>或<code>GOMIPS_softfloat</code>提供给汇编代码。</p>
<h3 id="不支持的操作码"><a href="#不支持的操作码" class="headerlink" title="不支持的操作码"></a>不支持的操作码</h3><p>汇编器旨在支持编译器，因此并非所有硬件指令都针对所有体系结构定义：如果编译器不生成它，它可能不在那里。如果您需要使用缺少的指令，有两种方法可以继续。</p>
<ul>
<li>一种是直接修改汇编程序以支持该指令，这是直接的，但只有在指令可能再次使用时才值得。</li>
<li>相反，对于简单的一次性修改案例，可以使用<code>BYTE</code> 和<code>WORD</code>指令将明确的数据放入<code>TEXT</code>的指令流中。以下是386运行时如何定义64位原子加载函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// uint64 atomicload64(uint64 volatile* addr);</span><br><span class="line">// so actually</span><br><span class="line">// void atomicload64(uint64 *res, uint64 volatile *addr);</span><br><span class="line">TEXT runtime·atomicload64(SB), NOSPLIT, $0-12</span><br><span class="line">	MOVL	ptr+0(FP), AX</span><br><span class="line">	TESTL	$7, AX</span><br><span class="line">	JZ	2(PC)</span><br><span class="line">	MOVL	0, AX // crash with nil ptr deref</span><br><span class="line">	LEAL	ret_lo+4(FP), BX</span><br><span class="line">	// MOVQ (%EAX), %MM0</span><br><span class="line">	BYTE $0x0f; BYTE $0x6f; BYTE $0x00</span><br><span class="line">	// MOVQ %MM0, 0(%EBX)</span><br><span class="line">	BYTE $0x0f; BYTE $0x7f; BYTE $0x03</span><br><span class="line">	// EMMS</span><br><span class="line">	BYTE $0x0F; BYTE $0x77</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想看一些具体的例子，可以查看<a href="https://www.bbsmax.com/A/l1dyrW0zem/" target="_blank" rel="noopener">Golang汇编命令解读</a></p>
<p>我在网上也找到了一个比较有意思的<a href="https://talks.golang.org/2016/asm.slide#1" target="_blank" rel="noopener">Go汇编设计</a>的介绍。</p>
<p>Also, <a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/" target="_blank" rel="noopener">here</a> is another blog about go assembly programming from Scott Mansfield.</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://golang.org/doc/asm#arm64" target="_blank" rel="noopener">A Quick Guide to Go’s Assembler</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">95</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">92</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
