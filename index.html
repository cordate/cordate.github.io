<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/10/13/团队与思考/关于招聘的想法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/13/团队与思考/关于招聘的想法/" itemprop="url">关于招聘的想法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-13T15:54:14+08:00">2018-10-13</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/团队与思考/" itemprop="url" rel="index"><span itemprop="name">团队与思考</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>程序员招聘已经成了一个话题，之前做团队leader的时候我就在想什么样的团队是我们想要的。加入阿里才3个月，却面对团队的压力需要帮忙招聘，有的团队还引入到了KPI中，而我们所在的团队希望我们每周找简历，达不到要求就处理罚钱的规定。这个规定让我无所适从，甚至有了很强的离职想法！所以我决定写一篇文章来阐述一下我对这件事的看法。（当然团队内部是不能去说的。）</p>
<h1 id="如何让团队招聘"><a href="#如何让团队招聘" class="headerlink" title="如何让团队招聘"></a>如何让团队招聘</h1><p>其实我觉得之前所叙述的，可以简单的归纳为任务驱动式的。其实我觉得简单地任务驱动式没有啥问题，因为很多团队都采用这种管理的方式，的确有一些弊端。但是我觉得招聘是我们工作之外的事情，如果采用任务驱动式势必会让人产生反感，也许是个人觉得反感。那么既然是任务就必然会产生奖罚制度。这个思维就是这样的思路，所以就有了我文章开头的遭遇。</p>
<p>而我觉得重要的制度就是一种文化，团队工作之外的事情怎么让团队去做呢？当然动员是必须的，你不说别人也不会去采取行动呀，毕竟每天都在想这个团队缺啥的人还是比较少的，但是我觉得优秀的团队被动的人应该是少数，你只要动员他们总会有想法的。我觉得更多的是让团队有种归属感，团队文化的认同感，这样他们才会为你打广告，在这种情况下，大家都是自愿的，会认真帮助团队将事情做好，比如检查候选人是否合适，如果是任务式的，候选人只要不要太离谱，可能都会被推荐进来，因为任务要达成。所以这个时候大家开始关注质量，于是开始奖惩制度。关于奖惩制度我也想说，适合工作成果；工作之外的事情，尽量少用罚款，否则团队的认同感就会被降低，应该使用奖而不罚的态度；而对于工作成果使用有奖有罚，我觉得是应该的。不同的场景下，应该使用不同的制度去应对。</p>
<p>总结下来就是使用团队认同感和文化推动成员帮助团队招兵买马，奖励做出贡献的员工；但是注意有的员工是有资源的，就是说达成同样一件事，有的员工可能不费事，而有的人付出的代价可能会比较大。这个需要心中有数，能力这个事情有的时候并不体现在成果上。就是将工作成果和业余成果做一个区分，不要交叉和影响。</p>
<h1 id="人才短期战略"><a href="#人才短期战略" class="headerlink" title="人才短期战略"></a>人才短期战略</h1><p>我们招聘人才往往是比较急，可是等团队人够了，正真的人才来了也只能拒绝，所以我觉得招聘中，不管多急，人才应该有余量，当有合适人选的时候，也可压缩余量，但是不能饱和。饱和的缺点是不能引入外部人才，同时内部工作饱和，大家做的事情也比较少，工作的余量可以检测一个员工的好坏。</p>
<p>关于短期招聘，其实就是扩宽渠道，这就是一个我找人才的过程，这个过程会异常痛苦。其实如果你平时就比较关注这个人才战略，你就可以实现人才找你，只要你发布了相应信息，可能就会有人才响应，所以我觉得这个过程就是人才找你。</p>
<p>所以说伯乐和人才都在相互寻找，渠道真的很重要，不是吗？那么就提一下人才找你之人才战略。</p>
<h1 id="人才是一种战略"><a href="#人才是一种战略" class="headerlink" title="人才是一种战略"></a>人才是一种战略</h1><p>做过Leader或者面试过别人的，应该都知道招聘人才是一个漫长的过程。能找到团队需要的人那是很难的。这个就是我们团队现在的错误，那就是没有人才战略，而强制团队每一个去找，其实就是广撒网多捞鱼。其实人才的招聘是有战略思维的，绝大分的人才不会自荐，简历写的也许也不行，甚至还有各种性格缺陷，这些都是我们发现一个人才能的阻碍。所以除了HR那边的硬性指标，我们也应该通过很多方式发现人才的真实才能。</p>
<h2 id="建立人才库"><a href="#建立人才库" class="headerlink" title="建立人才库"></a>建立人才库</h2><p>这个大家都知道，每个公司都有相应的人才库，甚至有大数据分析等，从人才库中找到适合自己的人才。人才库可以是自己的，也可以通过第三方网站进行爬取，也可以进行购买。总之建立人才库的方式有很多的。</p>
<h2 id="品牌形象"><a href="#品牌形象" class="headerlink" title="品牌形象"></a>品牌形象</h2><p>建立品牌形象来找人才，这个其实和公司的形象有很大关系。其实我们公司虽然很多人想进，但是我觉得他的影响力已经下降，因为大家都可以从论坛中发现这里面的真实情况，所以需要改革内部制度，建立完善的制度吸引人才。</p>
<h2 id="技术影响"><a href="#技术影响" class="headerlink" title="技术影响"></a>技术影响</h2><p>比如说建立技术网站，向全网普及知识扩大影响力的同时，也可以让更多的人才关注到你，只要你在里面发布消息，这种影响力还是比较客观的，也容易加大伯乐和千里马之间的认知，因为有时人才也怕遇到坑。</p>
<h2 id="渠道"><a href="#渠道" class="headerlink" title="渠道"></a>渠道</h2><p>各大招聘网站是渠道，这个大家都明白。但是大家也可以关注行业的新闻，从里面找到人才都在关注啥，然后从这里面发现人才的聚集地，将人才招为己用。还有比如博客，git库等等各种地方，都可以找到你想要的人才。</p>
<h2 id="猎头"><a href="#猎头" class="headerlink" title="猎头"></a>猎头</h2><p>上面说的渠道维护成本很高，所以猎头的出现就可以解决这个问题，而且老板和应聘者直接沟通必然有些话是不能说的，但是和猎头可以聊得多一些。但是猎头也有好坏之分的。而且猎头非专业人士，对人才的感知更多是凭感觉。</p>
<h1 id="留住人才"><a href="#留住人才" class="headerlink" title="留住人才"></a>留住人才</h1><p>奖罚分明，维护良好的制度，培养积极的团队文化和氛围。让员工工作的爽，生活愉快，减少工作和生活的交织对于留住一个人才确实是比不可少的。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/09/30/机器学习/机器学习实战笔记——k-近邻算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/机器学习/机器学习实战笔记——k-近邻算法/" itemprop="url">机器学习实战笔记——k-近邻算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T00:51:10+08:00">2018-09-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>k-近邻算法采用<b style="color:#f33b45">测量不同特征值之间的距离</b>方法进行分类。</p>
<p>算法特点：</p>
<ul>
<li>优点：精度高、对异常值不敏感、无数据输入假定。</li>
<li>缺点：计算复杂度高、空间复杂度高。（<b style="color:#f33b45">耗时，耗计算资源，例如中间数据的存储，另外是测试对象，要和所有的样本对象进行比较，没有训练的过程，只有测试过程。</b>）。最大的缺点就是<b style="color:#f33b45">无法给出数据的内在含义</b>。</li>
<li>适用数据范围：数值型（<b style="color:#f33b45">可以通过范围进行散列</b>）和标称型。（散列）</li>
</ul>
<p>工作原理：<b style="color:#f33b45">存在一个样本数据集合，也称训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。</b></p>
<p>K值的意思：<b style="color:#f33b45">一般来说，我们只选择样本数据集中前k个最相似的数据，这就是K-近邻算法中K的出处，通常k是不大于20的整数。最后少数服从多数。</b></p>
<p>注意这里需要说明的是：</p>
<ul>
<li>距离：<b style="color:#3399ea">可以是加权距离，集合距离或者矩阵距离，总之是算法的核心所在。这里比较常用的距离有曼哈顿距离（L1）和欧氏距离（L2）</b></li>
<li>分类：<b style="color:#3399ea">这个是决定业务场景的字段，有这个字段我们就知道，本算法的应用所在。</b></li>
</ul>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/20180929142841702.png?raw=true" alt=""></p>
<p><b style="color:#7c79e5;">k-近邻算法的一般流程：</b></p>
<ol>
<li>收集数据集</li>
<li>准备数据：距离计算所需要的数值，最好是结构化的数据格式。</li>
<li>分析数据</li>
<li><b style="color:#ffbb66">训练算法：此步骤不适合此算法。（但是可以验证距离函数是否是比较好的设计）</b></li>
<li>测试算法：计算错误率</li>
<li>使用算法</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一.、电影分类</p>
<p>二、使用k-近邻算法改进约会网站的配对效果</p>
<p>三、手写识别系统</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p><b style="color:#f33b45">要将算法的结果可视化的话，需要选择二维或者三维的模型，然后确定坐标系的特征指数，以及特征指数之间的关系。这里我想到的特征指数如下：</b></p>
<p><b style="color:#f33b45">距离、k的取值、多种特征值的组合特征、趋势等等。</b></p>
<p><b style="color:#f33b45">其实这里比较注意的是特征值的组合特征；这种组合特征可能是比率，趋势，平方差，偏移值，信息熵等等。注意这些特征之间的关系，只有有关系的特征才能这样去做。</b></p>
<p><b style="color:#f33b45">另外还有一种降维的做法就是将一个值取出来，设置几个值，使用多张图表进行展示。</b></p>
<p><img src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/20180929143041755.png?raw=true" alt=""></p>
<p>上面是数据图的一种表示！</p>
<hr>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/09/29/机器学习/机器学习实战笔记——机器学习基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/机器学习/机器学习实战笔记——机器学习基础/" itemprop="url">机器学习实战笔记——机器学习基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-29T00:41:17+08:00">2018-09-29</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p>1、机器学习分为监督学习和无监督学习。</p>
<p>2、监督学习一般使用两种类型的目标变量：标称型和数值型</p>
<ul>
<li><b style="color:#f33b45">标称型：就是取值比较固定的类型。有点像枚举类型，有穷值。这种特性的数据比较适合用于分类。</b></li>
<li>数值型：在无限的数据集中取值。比较适合找规律和线性回归，另外范围限定后也会成为标称型。</li>
</ul>
<p>3、 我们可以将数据集分为测试集、验证集和训练集。</p>
<ul>
<li>训练集用于处理训练模型</li>
<li>验证集用于调试自己的训练出来的模型</li>
<li>测试集是对最终模型的验证，防止最终验证的时候，这些数据集被使用。</li>
</ul>
<p>4、 关于交叉验证：将数据集分为多个部分，随机选取一个作为测试集，其他的都是训练集。</p>
<p>5、 简单地说，机器学习就是将无用的数据转化为有用的信息。将无联系的数据转化为有序的价值。</p>
<p>6、 前期的ETL就是建立数学模型来解决问题。而机器学习是数据算法转化数据的价值。</p>
<p>7、 数据的采集：各种数据的采集是各种系统的运行结果，最重要的数据采集来自于传感器数据。</p>
<p>8、 <b style="color:#f33b45">机器学习的主要任务就是分类，使用标称型的数据。机器学习的另一个任务就是回归。分类和回归属于监督学习，之所以被称为监督学习，是因为这类算法必须知道预测什么，即目标变量的分类信息。</b></p>
<p>9、 无监督学习：数据没有类别信息，也不会给定目标值。在无监督学习中，将数据集合分成由类似的对象组成的多个类的过程被称为<b style="color:#f33b45">聚类</b>；将寻找描述数据统计值的过程称之为<b style="color:#f33b45">密度估计</b>。无监督学习还可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息。</p>
<p>10、 如何选择合适的算法</p>
<ol>
<li>首先考虑使用机器学习的目的。</li>
<li>考虑数据是离散型还是连续型。离散型适合分类，连续型适合回归。</li>
<li>是否考虑将数据划分成离散的，可以使用无监督学习中的<b style="color:#f33b45">聚类</b>；如果还需要估计数据与每个分组的相似程度，则需要使用<b style="color:#f33b45">密度估计</b>算法。</li>
</ol>
<p>上面提到的原则不是一成不变的，要敢于打破常规解决问题。除此之外也有其他的考量指标：</p>
<ul>
<li>特征值是连续型还是离散型</li>
<li>特征值中是否存在缺失的值，何种原因导致值缺失</li>
<li>数据中是否存在异常值</li>
<li>某个特征发生的概率如何</li>
</ul>
<p>同时还要尝试不同的算法的执行效果，一般来说发现最好算法的关键环节是反复试错的迭代过程。</p>
<p>11、 机器学习开发的步骤：</p>
<ol>
<li>收集数据</li>
<li>准备输入数据</li>
<li>分析输入数据：通过一维、二维、三维图形展示数据也是不错的方法，但是一般是多维的。但是多维也可以通过图形化展示的。这一步的作用主要是确保没有垃圾数据。</li>
<li>训练算法：机器学习算法从这一步才真正开始学习。</li>
<li>测试算法</li>
<li>使用算法：将机器学习算法转换为应用程序。</li>
</ol>
<p>12、 NumPy函数库的使用基础知识。</p>
<hr>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/13/java/内存栅栏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/java/内存栅栏/" itemprop="url">内存栅栏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T12:36:20+08:00">2018-06-13</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/base/" itemprop="url" rel="index"><span itemprop="name">base</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是内存栅栏？"><a href="#什么是内存栅栏？" class="headerlink" title="什么是内存栅栏？"></a>什么是内存栅栏？</h2><p>内存栅栏(Memory Barriers)，是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p>
<h3 id="内存栅栏提供了两个功能"><a href="#内存栅栏提供了两个功能" class="headerlink" title="内存栅栏提供了两个功能"></a>内存栅栏提供了两个功能</h3><ol>
<li>确保从另一个CPU来看栅栏的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；</li>
<li>实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。</li>
</ol>
<h2 id="为什么需要内存栅栏？"><a href="#为什么需要内存栅栏？" class="headerlink" title="为什么需要内存栅栏？"></a>为什么需要内存栅栏？</h2><p><b style="color:blue">对主存的一次访问一般花费硬件的数百次时钟周期。为了减少这种操作，CPU通过使用Cache来达到高效获取数据的目的。然后Cache为了提高性能，会对指令进行重排序。</b></p>
<p><b style="color:red">当重排序对最终的结果没有影响的时候，这种优化是有益的。但是当多线程共享数据时，重排序将导致错误的结果。所以为了在共享变量的情况下依然可以使用指令重排序，产生了内存栅栏来保证程序的正确性。</b></p>
<h2 id="内存栅栏是怎么实现的？"><a href="#内存栅栏是怎么实现的？" class="headerlink" title="内存栅栏是怎么实现的？"></a>内存栅栏是怎么实现的？</h2><p>在底层，内存栅栏是一组指令，一般包括<code>Store Barrier</code>、<code>Load Barrier</code>和<code>Full Barrier</code>。</p>
<p>几乎所有的处理器至少支持一种粗粒度的屏障指令，通常被称为“栅栏（Fence）”，它保证在栅栏前初始化的load和store指令，能够严格有序的在栅栏后的load和store指令之前执行。</p>
<p>不同的CPU架构有不同的实现方式，以X86为例：</p>
<ul>
<li>Store Barrier,强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到主存</li>
<li>Load Barrier,强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。</li>
<li>Full Barrier，复合了load和store屏蔽指令。</li>
</ul>
<p><b style="color:red">无论在何种处理器上，这几乎都是最耗时的操作之一（与原子指令差不多，甚至更消耗资源），所以大部分处理器还会支持更细粒度的屏障指令。</b></p>
<p>下图是CPU的Local Memory与主存的通信过程：<br><img src="https://github.com/gavin-account/blog-pics/blob/master/java/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%9B%BE1.jpg?raw=true" alt=""></p>
<h2 id="Java中内存栅栏的使用"><a href="#Java中内存栅栏的使用" class="headerlink" title="Java中内存栅栏的使用"></a>Java中内存栅栏的使用</h2><p>Java内存模型中volatile变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。一个类的final字段会在初始化后插入一个store屏障，来确保final字段在构造函数初始化完成并可被使用时可见。</p>
<h2 id="内存栅栏对性能的影响"><a href="#内存栅栏对性能的影响" class="headerlink" title="内存栅栏对性能的影响"></a>内存栅栏对性能的影响</h2><p>内存栅栏阻止了 CPU 很多隐式的内存延迟技术的执行，因此是有性能损耗的，不过在上层看来这种损耗并不大。在合适的时候使用内存栅栏，仍然是一种高效的做法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C" target="_blank" rel="noopener">维基百科 - 内存屏障</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/08/blockchain/corda/Corda教程-流程相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/blockchain/corda/Corda教程-流程相关/" itemprop="url">Corda教程-流程相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T17:46:22+08:00">2018-06-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用客户端RPC-API"><a href="#使用客户端RPC-API" class="headerlink" title="使用客户端RPC API"></a>使用客户端RPC API</h1><p>在本教程中，我们将构建一个简单的命令行实用程序，该实用程序连接到节点，创建一些现金交易并将交易图转储到标准输出。然后，我们将在顶部放置一些简单的可视化。有关Corda如何在Corda中工作的说明，请参阅<a href="https://docs.corda.net/head/clientrpc.html" target="_blank" rel="noopener">Client RPC</a>。</p>
<p>我们首先连接到节点本身。为了本教程的目的，我们将使用Driver来启动一个公证人和一个可以发行、移动和退出现金的Alice节点。</p>
<p>下面是我们如何将节点配置为创建具有权限的用户来启动<code>CashIssueFlow</code>， <code>CashPaymentFlow</code>以及<code>CashExitFlow</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOrVisualise</span> </span>&#123;</span><br><span class="line">    Print,</span><br><span class="line">    Visualise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    require(args.isNotEmpty()) &#123; <span class="string">"Usage: &lt;binary&gt; [Print|Visualise]"</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> printOrVisualise = PrintOrVisualise.valueOf(args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> baseDirectory = Paths.<span class="keyword">get</span>(<span class="string">"build/rpc-api-tutorial"</span>)</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"user"</span>, <span class="string">"password"</span>, permissions = setOf(startFlow&lt;CashIssueFlow&gt;(),</span><br><span class="line">            startFlow&lt;CashPaymentFlow&gt;(),</span><br><span class="line">            startFlow&lt;CashExitFlow&gt;(),</span><br><span class="line">            invokeRpc(CordaRPCOps::nodeInfo)</span><br><span class="line">    ))</span><br><span class="line">    driver(DriverParameters(driverDirectory = baseDirectory, extraCordappPackagesToScan = listOf(<span class="string">"net.corda.finance"</span>), waitForAllNodesToFinish = <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">val</span> node = startNode(providedName = ALICE_NAME, rpcUsers = listOf(user)).<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以使用有效的RPC用户登录连接到节点本身，并使用<code>generateTransactions</code>（稍后定义）开始在不同线程中生成交易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val client = CordaRPCClient(node.rpcAddress)</span><br><span class="line">val proxy = client.start(&quot;user&quot;, &quot;password&quot;).proxy</span><br><span class="line"></span><br><span class="line">thread &#123;</span><br><span class="line">    generateTransactions(proxy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>proxy 公开节点的完整RPC接口：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the RPC protocol version, which is the same the node's Platform Version. Exists since version 1 so guaranteed</span></span><br><span class="line"><span class="comment"> * to be present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> protocolVersion: <span class="built_in">Int</span> <span class="keyword">get</span>() = nodeInfo().platformVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a list of currently in-progress state machine infos. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachinesSnapshot</span><span class="params">()</span></span>: List&lt;StateMachineInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a data feed of currently in-progress state machine infos and an observable of</span></span><br><span class="line"><span class="comment"> * future state machine adds/removes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachinesFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;StateMachineInfo&gt;, StateMachineUpdate&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of vault states for a given query criteria (and optional order and paging specification)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Generic vault query function which takes a [QueryCriteria] object to define filters,</span></span><br><span class="line"><span class="comment"> * optional [PageSpecification] and optional [Sort] modification criteria (default unsorted),</span></span><br><span class="line"><span class="comment"> * and returns a [Vault.Page] object containing the following:</span></span><br><span class="line"><span class="comment"> *  1. states as a List of &lt;StateAndRef&gt; (page number and size defined by [PageSpecification])</span></span><br><span class="line"><span class="comment"> *  2. states metadata as a List of [Vault.StateMetadata] held in the Vault States table.</span></span><br><span class="line"><span class="comment"> *  3. total number of results available if [PageSpecification] supplied (otherwise returns -1)</span></span><br><span class="line"><span class="comment"> *  4. status types used in this query: UNCONSUMED, CONSUMED, ALL</span></span><br><span class="line"><span class="comment"> *  5. other results (aggregate functions with/without using value groups)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> VaultQueryException if the query cannot be executed for any reason</span></span><br><span class="line"><span class="comment"> *        (missing criteria or parsing error, paging errors, unsupported query, underlying database error)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes</span></span><br><span class="line"><span class="comment"> *   If no [PageSpecification] is provided, a maximum of [DEFAULT_PAGE_SIZE] results will be returned.</span></span><br><span class="line"><span class="comment"> *   API users must specify a [PageSpecification] if they are expecting more than [DEFAULT_PAGE_SIZE] results,</span></span><br><span class="line"><span class="comment"> *   otherwise a [VaultQueryException] will be thrown alerting to this condition.</span></span><br><span class="line"><span class="comment"> *   It is the responsibility of the API user to request further pages and/or specify a more suitable [PageSpecification].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DOCSTART VaultQueryByAPI</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryBy</span><span class="params">(criteria: <span class="type">QueryCriteria</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     paging: <span class="type">PageSpecification</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     sorting: <span class="type">Sort</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultQueryByAPI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">Note:</span> cannot apply @JvmOverloads to interfaces nor interface implementations</span></span><br><span class="line"><span class="comment">// Java Helpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOCSTART VaultQueryAPIHelpers</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQuery</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryByCriteria</span><span class="params">(criteria: <span class="type">QueryCriteria</span>, contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryByWithPagingSpec</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, paging: <span class="type">PageSpecification</span>)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryByWithSorting</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, sorting: <span class="type">Sort</span>)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultQueryAPIHelpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot (as per queryBy) and an observable of future updates to the vault for the given query criteria.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Generic vault query function which takes a [QueryCriteria] object to define filters,</span></span><br><span class="line"><span class="comment"> * optional [PageSpecification] and optional [Sort] modification criteria (default unsorted),</span></span><br><span class="line"><span class="comment"> * and returns a [DataFeed] object containing</span></span><br><span class="line"><span class="comment"> * 1) a snapshot as a [Vault.Page] (described previously in [CordaRPCOps.vaultQueryBy])</span></span><br><span class="line"><span class="comment"> * 2) an [Observable] of [Vault.Update]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes: the snapshot part of the query adheres to the same behaviour as the [CordaRPCOps.vaultQueryBy] function.</span></span><br><span class="line"><span class="comment"> *        the [QueryCriteria] applies to both snapshot and deltas (streaming updates).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DOCSTART VaultTrackByAPI</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackBy</span><span class="params">(criteria: <span class="type">QueryCriteria</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     paging: <span class="type">PageSpecification</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     sorting: <span class="type">Sort</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultTrackByAPI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">Note:</span> cannot apply @JvmOverloads to interfaces nor interface implementations</span></span><br><span class="line"><span class="comment">// Java Helpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOCSTART VaultTrackAPIHelpers</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrack</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackByCriteria</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackByWithPagingSpec</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, paging: <span class="type">PageSpecification</span>)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackByWithSorting</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, sorting: <span class="type">Sort</span>)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultTrackAPIHelpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@suppress</span> Returns a list of all recorded transactions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO This method should be removed once SGX work is finalised and the design of the corresponding API using [FilteredTransaction] can be started</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">"This method is intended only for internal use and will be removed from the public API soon."</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">internalVerifiedTransactionsSnapshot</span><span class="params">()</span></span>: List&lt;SignedTransaction&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@suppress</span> Returns a data feed of all recorded transactions and an observable of future recorded ones.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO This method should be removed once SGX work is finalised and the design of the corresponding API using [FilteredTransaction] can be started</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">"This method is intended only for internal use and will be removed from the public API soon."</span>)</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">internalVerifiedTransactionsFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;SignedTransaction&gt;, SignedTransaction&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a snapshot list of existing state machine id - recorded transaction hash mappings. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachineRecordedTransactionMappingSnapshot</span><span class="params">()</span></span>: List&lt;StateMachineTransactionMapping&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot list of existing state machine id - recorded transaction hash mappings, and a stream of future</span></span><br><span class="line"><span class="comment"> * such mappings as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachineRecordedTransactionMappingFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;StateMachineTransactionMapping&gt;, StateMachineTransactionMapping&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns all parties currently visible on the network with their advertised services. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">networkMapSnapshot</span><span class="params">()</span></span>: List&lt;NodeInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns all parties currently visible on the network with their advertised services and an observable of</span></span><br><span class="line"><span class="comment"> * future updates to the network.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">networkMapFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;NodeInfo&gt;, NetworkMapCache.MapChange&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns [DataFeed] object containing information on currently scheduled parameters update (null if none are currently scheduled)</span></span><br><span class="line"><span class="comment"> * and observable with future update events. Any update that occurs before the deadline automatically cancels the current one.</span></span><br><span class="line"><span class="comment"> * Only the latest update can be accepted.</span></span><br><span class="line"><span class="comment"> * Note: This operation may be restricted only to node administrators.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TODO This operation should be restricted to just node admins.</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">networkParametersFeed</span><span class="params">()</span></span>: DataFeed&lt;ParametersUpdateInfo?, ParametersUpdateInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Accept network parameters with given hash, hash is obtained through [networkParametersFeed] method.</span></span><br><span class="line"><span class="comment"> * Information is sent back to the zone operator that the node accepted the parameters update - this process cannot be</span></span><br><span class="line"><span class="comment"> * undone.</span></span><br><span class="line"><span class="comment"> * Only parameters that are scheduled for update can be accepted, if different hash is provided this method will fail.</span></span><br><span class="line"><span class="comment"> * Note: This operation may be restricted only to node administrators.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parametersHash hash of network parameters to accept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if network map advertises update with different parameters hash then the one accepted by node's operator.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if failed to send the approval to network map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TODO This operation should be restricted to just node admins.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptNewNetworkParameters</span><span class="params">(parametersHash: <span class="type">SecureHash</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start the given flow with the given arguments. [logicType] must be annotated</span></span><br><span class="line"><span class="comment"> * with [net.corda.core.flows.StartableByRPC].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">startFlowDynamic</span><span class="params">(logicType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">FlowLogic</span>&lt;<span class="type">T</span>&gt;&gt;, <span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: FlowHandle&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start the given flow with the given arguments, returning an [Observable] with a single observation of the</span></span><br><span class="line"><span class="comment"> * result of running the flow. [logicType] must be annotated with [net.corda.core.flows.StartableByRPC].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">startTrackedFlowDynamic</span><span class="params">(logicType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">FlowLogic</span>&lt;<span class="type">T</span>&gt;&gt;, <span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: FlowProgressHandle&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to kill a flow. This is not a clean termination and should be reserved for exceptional cases such as stuck fibers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the flow existed and was killed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">killFlow</span><span class="params">(id: <span class="type">StateMachineRunId</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns Node's NodeInfo, assuming this will not change while the node is running. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nodeInfo</span><span class="params">()</span></span>: NodeInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns network's notary identities, assuming this will not change while the node is running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the identities are sorted based on legal name, and the ordering might change once new notaries are introduced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">notaryIdentities</span><span class="params">()</span></span>: List&lt;Party&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add note(s) to an existing Vault transaction. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addVaultTransactionNote</span><span class="params">(txnId: <span class="type">SecureHash</span>, txnNote: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Retrieve existing note(s) for a given Vault transaction. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getVaultTransactionNotes</span><span class="params">(txnId: <span class="type">SecureHash</span>)</span></span>: Iterable&lt;String&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether an attachment with the given hash is stored on the node. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">attachmentExists</span><span class="params">(id: <span class="type">SecureHash</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Download an attachment JAR by ID. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openAttachment</span><span class="params">(id: <span class="type">SecureHash</span>)</span></span>: InputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Uploads a jar to the node, returns it's hash. */</span></span><br><span class="line"><span class="meta">@Throws(java.nio.file.FileAlreadyExistsException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadAttachment</span><span class="params">(jar: <span class="type">InputStream</span>)</span></span>: SecureHash</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Uploads a jar including metadata to the node, returns it's hash. */</span></span><br><span class="line"><span class="meta">@Throws(java.nio.file.FileAlreadyExistsException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadAttachmentWithMetadata</span><span class="params">(jar: <span class="type">InputStream</span>, uploader: <span class="type">String</span>, filename: <span class="type">String</span>)</span></span>: SecureHash</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Queries attachments metadata */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">queryAttachments</span><span class="params">(query: <span class="type">AttachmentQueryCriteria</span>, sorting: <span class="type">AttachmentSort</span>?)</span></span>: List&lt;AttachmentId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the node's current time. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">currentNodeTime</span><span class="params">()</span></span>: Instant</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a [CordaFuture] which completes when the node has registered wih the network map service. It can also</span></span><br><span class="line"><span class="comment"> * complete with an exception if it is unable to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">waitUntilNetworkReady</span><span class="params">()</span></span>: CordaFuture&lt;<span class="built_in">Void</span>?&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO These need rethinking. Instead of these direct calls we should have a way of replicating a subset of</span></span><br><span class="line"><span class="comment">// the node's state locally and query that directly.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the well known identity from an abstract party. This is intended to resolve the well known identity</span></span><br><span class="line"><span class="comment"> * from a confidential identity, however it transparently handles returning the well known identity back if</span></span><br><span class="line"><span class="comment"> * a well known identity is passed in.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> party identity to determine well known identity for.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> well known identity, if found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wellKnownPartyFromAnonymous</span><span class="params">(party: <span class="type">AbstractParty</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the [Party] corresponding to the given key, if found. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partyFromKey</span><span class="params">(key: <span class="type">PublicKey</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the [Party] with the X.500 principal as it's [Party.name]. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wellKnownPartyFromX500Name</span><span class="params">(x500Name: <span class="type">CordaX500Name</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a notary identity by name.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the notary identity, or null if there is no notary by that name. Note that this will return null if there</span></span><br><span class="line"><span class="comment"> * is a peer with that name but they are not a recognised notary service.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">notaryPartyFromX500Name</span><span class="params">(x500Name: <span class="type">CordaX500Name</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may</span></span><br><span class="line"><span class="comment"> * get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results</span></span><br><span class="line"><span class="comment"> * but rather show them via a user interface and let the user pick the one they wanted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> query The string to check against the X.500 name components</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exactMatch If true, a case sensitive match is done against each component of each X.500 name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partiesFromName</span><span class="params">(query: <span class="type">String</span>, exactMatch: <span class="type">Boolean</span>)</span></span>: Set&lt;Party&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Enumerates the class names of the flows that this node knows about. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registeredFlows</span><span class="params">()</span></span>: List&lt;String&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a node's info from the network map cache, where known.</span></span><br><span class="line"><span class="comment"> * Notice that when there are more than one node for a given name (in case of distributed services) first service node</span></span><br><span class="line"><span class="comment"> * found will be returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node info if available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nodeInfoFromParty</span><span class="params">(party: <span class="type">AbstractParty</span>)</span></span>: NodeInfo?</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Clear all network map data from local node cache. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">clearNetworkMapCache</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Sets the value of the node's flows draining mode.</span></span><br><span class="line"><span class="comment"> * If this mode is [enabled], the node will reject new flows through RPC, ignore scheduled flows, and do not process</span></span><br><span class="line"><span class="comment"> * initial session messages, meaning that P2P counterparties will not be able to initiate new flows involving the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> enabled whether the flows draining mode will be enabled.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setFlowsDrainingModeEnabled</span><span class="params">(enabled: <span class="type">Boolean</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the flows draining mode is enabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> setFlowsDrainingModeEnabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isFlowsDrainingModeEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shuts the node down. Returns immediately.</span></span><br><span class="line"><span class="comment"> * This does not wait for flows to be completed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们需要用来转储交易图的RPC操作是<code>internalVerifiedTransactionsFeed</code>。类型签名告诉我们RPC操作将返回一系列交易和一个<code>Observable</code>流。这是一种普遍的模式，我们查询一些数据，节点将返回当前的快照和将来的更新。<a href="https://docs.corda.net/head/clientrpc.html" target="_blank" rel="noopener">客户端RPC</a>更详细地描述了可观察对象.<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (transactions: List&lt;SignedTransaction&gt;, futureTransactions: Observable&lt;SignedTransaction&gt;) = proxy.internalVerifiedTransactionsFeed()</span><br></pre></td></tr></table></figure></p>
<p>该图将被定义如下：</p>
<ul>
<li>每个交易都是一个顶点，由打印<code>NODE &lt;txhash&gt;</code>表示 </li>
<li>每个输入 - 输出关系都是一个边，由prining <code>EDGE &lt;txhash&gt; &lt;txhash&gt;</code>表示</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (printOrVisualise) &#123;</span><br><span class="line">    PrintOrVisualise.Print -&gt; &#123;</span><br><span class="line">        futureTransactions.startWith(transactions).subscribe &#123; transaction -&gt;</span><br><span class="line">            println(<span class="string">"NODE <span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            transaction.tx.inputs.forEach &#123; (txhash) -&gt;</span><br><span class="line">                println(<span class="string">"EDGE <span class="variable">$txhash</span> <span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们只需要自己创建交易！<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateTransactions</span><span class="params">(proxy: <span class="type">CordaRPCOps</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vault = proxy.vaultQueryBy&lt;Cash.State&gt;().states</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ownedQuantity = vault.fold(<span class="number">0</span>L) &#123; sum, state -&gt;</span><br><span class="line">        sum + state.state.<span class="keyword">data</span>.amount.quantity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> issueRef = OpaqueBytes.of(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> notary = proxy.notaryIdentities().first()</span><br><span class="line">    <span class="keyword">val</span> me = proxy.nodeInfo().legalIdentities.first()</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">val</span> random = SplittableRandom()</span><br><span class="line">        <span class="keyword">val</span> n = random.nextDouble()</span><br><span class="line">        <span class="keyword">if</span> (ownedQuantity &gt; <span class="number">10000</span> &amp;&amp; n &gt; <span class="number">0.8</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> quantity = Math.abs(random.nextLong()) % <span class="number">2000</span></span><br><span class="line">            proxy.startFlow(::CashExitFlow, Amount(quantity, USD), issueRef)</span><br><span class="line">            ownedQuantity -= quantity</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ownedQuantity &gt; <span class="number">1000</span> &amp;&amp; n &lt; <span class="number">0.7</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> quantity = Math.abs(random.nextLong() % Math.min(ownedQuantity, <span class="number">2000</span>))</span><br><span class="line">            proxy.startFlow(::CashPaymentFlow, Amount(quantity, USD), me)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> quantity = Math.abs(random.nextLong() % <span class="number">1000</span>)</span><br><span class="line">            proxy.startFlow(::CashIssueFlow, Amount(quantity, USD), issueRef, notary)</span><br><span class="line">            ownedQuantity += quantity</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在这里使用几个RPC函数来查询节点集群或我们自己的库中的公证信息。<b style="color:red">这些RPC函数还会返回<code>Observable</code>对象，以便节点可以向我们发送更新的值。但是，我们在这里不需要更新，因此我们将这些观察值标记为<code>notUsed</code>（通常，您应该始终订阅一个<code>Observable</code> 或将其标记为未使用，否则会泄漏节点中的资源）。</b></p>
<p>然后在一个循环中，我们随机生成一个Issue，一个Pay或一个Exit交易。</p>
<p>我们需要启动一个现金交易的RPC是<code>startFlow</code>在足够的权限下启动一个任意的流程。</p>
<p>最后，我们掌握了一切：我们启动几个节点，连接到它们，并开始创建交易，同时监听已成功创建的交易，并将这些交易转储到控制台。我们只需要运行它！<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Build the example</span></span><br><span class="line">./gradlew docs/source/example-code:installDist</span><br><span class="line"><span class="meta">#</span><span class="bash"> Start it</span></span><br><span class="line">./docs/source/example-code/build/install/docs/source/example-code/bin/client-rpc-tutorial Print</span><br></pre></td></tr></table></figure></p>
<p>现在让我们尝试对交易图进行可视化。我们将使用一个名为<code>graphstream</code>的图形绘制库。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    PrintOrVisualise.Visualise -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> graph = MultiGraph(<span class="string">"transactions"</span>)</span><br><span class="line">        transactions.forEach &#123; transaction -&gt;</span><br><span class="line">            graph.addNode&lt;Node&gt;(<span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        transactions.forEach &#123; transaction -&gt;</span><br><span class="line">            transaction.tx.inputs.forEach &#123; ref -&gt;</span><br><span class="line">                graph.addEdge&lt;Edge&gt;(<span class="string">"<span class="variable">$ref</span>"</span>, <span class="string">"<span class="subst">$&#123;ref.txhash&#125;</span>"</span>, <span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        futureTransactions.subscribe &#123; transaction -&gt;</span><br><span class="line">            graph.addNode&lt;Node&gt;(<span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            transaction.tx.inputs.forEach &#123; ref -&gt;</span><br><span class="line">                graph.addEdge&lt;Edge&gt;(<span class="string">"<span class="variable">$ref</span>"</span>, <span class="string">"<span class="subst">$&#123;ref.txhash&#125;</span>"</span>, <span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        graph.display()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们使用<code>Visualise</code>运行客户端，我们应该看到随着新交易的创建，会绘制一个简单的随机图。</p>
<h2 id="将您的CorDapp与Corda节点上的类列入白名单"><a href="#将您的CorDapp与Corda节点上的类列入白名单" class="headerlink" title="将您的CorDapp与Corda节点上的类列入白名单"></a>将您的CorDapp与Corda节点上的类列入白名单</h2><p>如<a href="https://docs.corda.net/head/clientrpc.html" target="_blank" rel="noopener">Client RPC</a>所述，您必须将您添加的RPC请求或Corda节点响应中所需的任何其他类添加到白名单中。这里有一个例子，你可以通过这两种方法来做几个示例类。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not annotated, so need to whitelist manually.</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRPCValue</span></span>(<span class="keyword">val</span> foo: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Annotated, so no need to whitelist manually.</span></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRPCValue2</span></span>(<span class="keyword">val</span> bar: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleRPCSerializationWhitelist</span> : <span class="type">SerializationWhitelist &#123;</span></span></span><br><span class="line">    <span class="comment">// Add classes like this.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> whitelist = listOf(ExampleRPCValue::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://docs.corda.net/head/running-a-node.html" target="_blank" rel="noopener">在本地运行节点</a>这里查看更多插件。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>与客户端关联的RPC凭证必须与服务器节点上配置的权限集匹配。这涉及身份验证（用户名和密码）和基于角色的授权（授权用户有权运行的一组经过授权的RPC操作）。</p>
<p><b style="color:blue">注意：权限以String的形式表示，以允许RPC实现添加他们自己的权限。目前唯一定义的权限类型是StartFlow，它定义了经过身份验证的使用可能执行的白名单流程的列表。管理员用户（或开发人员）也可能被分配ALL权限，该权限授予对任何流量的访问权限。</b></p>
<p>在上面的说明中，服务器节点权限是以编程方式driver代码中配置的：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver(driverDirectory = baseDirectory) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"user"</span>, <span class="string">"password"</span>, permissions = setOf(startFlow&lt;CashFlow&gt;()))</span><br><span class="line">    <span class="keyword">val</span> node = startNode(<span class="string">"CN=Alice Corp,O=Alice Corp,L=London,C=GB"</span>, rpcUsers = listOf(user)).<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure></p>
<p>当使用配置文件启动独立节点时，我们必须提供RPC凭证，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user, password=password, permissions=[ StartFlow.net.corda.finance.flows.CashFlow ] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>在使用Gradle Cordformation插件配置和部署节点时，您必须以类似的方式提供RPC凭据：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [</span><br><span class="line">        [<span class="string">'username'</span> : <span class="string">"user"</span>,</span><br><span class="line">         <span class="string">'password'</span> : <span class="string">"password"</span>,</span><br><span class="line">         <span class="string">'permissions'</span> : [<span class="string">"StartFlow.net.corda.finance.flows.CashFlow"</span>]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>然后，您可以按如下方式部署和启动节点（公证人和Alice）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> to create a <span class="built_in">set</span> of configs and installs under ``docs/<span class="built_in">source</span>/example-code/build/nodes`` run</span></span><br><span class="line">./gradlew docs/source/example-code:deployNodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> to open up two new terminals with the two nodes run</span></span><br><span class="line">./docs/source/example-code/build/nodes/runnodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> followed by the same commands as before:</span></span><br><span class="line">./docs/source/example-code/build/install/docs/source/example-code/bin/client-rpc-tutorial Print</span><br><span class="line">./docs/source/example-code/build/install/docs/source/example-code/bin/client-rpc-tutorial Visualise</span><br></pre></td></tr></table></figure></p>
<p>关于启动流RPC，还有一个额外的安全层，要执行的流必须注解<code>@StartableByRPC</code>。没有此注解的流程无法使用RPC执行。</p>
<p>请参阅<a href="https://docs.corda.net/head/secure-coding-guidelines.html" target="_blank" rel="noopener">安全编码指南</a>中的安全性，<a href="https://docs.corda.net/head/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>中的节点配置以及<a href="https://docs.corda.net/head/running-a-node.html" target="_blank" rel="noopener">本地运行节点</a>中的<code>Cordformation</code> 。</p>
<h1 id="构建交易"><a href="#构建交易" class="headerlink" title="构建交易"></a>构建交易</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>理解和实施Corda中的交易是构建和实施真实世界智能合约的关键。只有通过构建包含适当数据的有效Corda交易，分类账上的节点才能将真实世界的业务对象映射到Corda分类账中数据的共享数字视图。更重要的是，作为新智能合约的开发者，它是决定哪些数据格式良好以及哪些数据应该被拒绝为错误或防止恶意活动的代码。本文档详细介绍了在构建交易作为流程的一部分时所使用的一些注意事项和API。</p>
<h2 id="交易的基本生命周期"><a href="#交易的基本生命周期" class="headerlink" title="交易的基本生命周期"></a>交易的基本生命周期</h2><p>Corda的交易包含许多要素：</p>
<ol>
<li>一组将被最终接受的交易处理的输入状态引用</li>
<li>一组输出状态，用于创建/替换使用状态，从而成为分类账上新的最新数据版本</li>
<li>一系列<code>Attachment</code>可以包含法律文件，合同代码或专用加密部分作为原生合同状态之外的扩展的项目</li>
<li>一组<code>Command</code>项目，用于指示在交易中编码的分类帐转换的类型。每个命令还有一组相关联的签名者密钥，这些签名者密钥将用于签署交易</li>
<li>签名者列表，它是各个<code>Command</code>对象上的签名者的联合</li>
<li>指定哪个公证节点正在跟踪状态消费的公证身份（如果交易的输入状态用不同的公证节点注册，那么流程将不得不插入额外的<code>NotaryChange</code>交易，以便在允许突变任何状态之前将状态迁移到一致的公证节点）</li>
<li>可选择一个时间窗口，公证人可以使用时间窗口来限定提议的交易可以提交给分类帐的时间段</li>
</ol>
<p>交易是通过填充一个<code>TransactionBuilder</code>。通常情况下，<code>TransactionBuilder</code>需要在各方之间进行交换，然后才能完全填充。这是Corda隐私模型的直接结果，其中输入状态很可能是其他节点未知的。</p>
<p>一旦builder完全填充，流程应该通过签署<code>TransactionBuilder</code>创建一个<code>SignedTransaction</code>来冻结它。这是分类账协议流程的关键 - 一旦流程将节点的签名附加到交易中，它就有效地声明它接受交易的所有细节。</p>
<p>对于流程来说，最好的做法是接收其他Party的<code>TransactionSignature</code>而不是完整的<code>SignedTransaction</code>对象，因为否则我们必须单独检查它是否仍然是相同的<code>SignedTransaction</code>，而不是恶意的替代品。</p>
<p>将交易提交给分类帐的最后阶段是公证<code>SignedTransaction</code>，并将其分发给所有适当的当事人并将数据记录到分类账中。这些操作最好委托给<code>FinalityFlow</code>，而不是手动调用各个步骤。但是，请注意，对其他节点的最终广播是异步的，因此必须小心在单元测试中正确等待Vault更新。</p>
<h2 id="收集输入"><a href="#收集输入" class="headerlink" title="收集输入"></a>收集输入</h2><p>形成交易的第一步是收集一组输入引用。根据智能合约所捕获的业务流程的性质以及请求的参数化细节，此流程将会有明显的不同。但是，它通常涉及通过<code>ServiceHub</code>里的<code>VaultService</code>接口来搜索vault来定位输入状态。</p>
<p>给一些更具体的细节考虑两个简化的现实世界的情况。首先是基本的外汇现金交易。这笔交易需要找到一组资金进行交易。流程建模，这是在<code>FxTransactionBuildTutorial.kt</code>实现了 （见docs/source/example-code/src/main/kotlin/net/corda/docs/FxTransactionBuildTutorial.kt的 主<a href="https://github.com/corda/corda" target="_blank" rel="noopener">corda代码库</a>中）。其次，一个简单的商业模式，其中parties手动接受或拒绝对方的贸易提案，这是在<code>WorkflowTransactionBuildTutorial.kt</code>中实现的（见 docs/source/example-code/src/main/kotlin/net/corda/docs/WorkflowTransactionBuildTutorial.kt的 主<a href="https://github.com/corda/corda" target="_blank" rel="noopener">corda代码库</a>中）。要使用IntelliJ IDE运行和浏览这些示例，可以run/step完成<code>FxTransactionBuildTutorialTest.kt</code>和<code>WorkflowTransactionBuildTutorialTest.kt</code>中的相应单元测试，这些测试将流程驱动为模拟内存节点网络的一部分。</p>
<p>注意：创建这些单元测试的IntelliJ运行配置之前，转到 运行- &gt;编辑配置- &gt;默认设置- &gt; JUnit中，添加 <code>-javaagent:lib/quasar.jar</code> 到VM选项，并设置工作目录<code>$PROJECT_DIR$</code>，那么<code>Quasar</code>仪器的配置就正确完成了。</p>
<p>对于现金交易，假设我们使用的是在<code>:financial</code>gradle模块的标准<code>CashState</code>。<code>Cash</code>合同利用<code>FungibleAsset</code>状态与模型互换资产的持有量，并允许拆分，合并和求状态的总和，以满足合同义务。我们通常会使用该 Cash.generateSpend方法将所需数量的现金收集到a中TransactionBuilder，设置输出并生成Move 命令。然而，为了使事情更加清楚，这里示出的示例性流程的代码将手动通过指定相关的查询条件的过滤器到进行输入的查询tryLockFungibleStatesForSpending的方法VaultService。</p>
<p>// This is equivalent to the Cash.generateSpend<br>// Which is brought here to make the filtering logic more visible in the example<br>private fun gatherOurInputs(serviceHub: ServiceHub,<br>                            lockId: UUID,<br>                            amountRequired: Amount&lt;Issued<currency>&gt;,<br>                            notary: Party?): Pair&lt;List&lt;StateAndRef&lt;Cash.State&gt;&gt;, Long&gt; {<br>    // extract our identity for convenience<br>    val ourKeys = serviceHub.keyManagementService.keys<br>    val ourParties = ourKeys.map { serviceHub.identityService.partyFromKey(it) ?: throw IllegalStateException(“Unable to resolve party from key”) }<br>    val fungibleCriteria = QueryCriteria.FungibleAssetQueryCriteria(owner = ourParties)</currency></p>
<pre><code>val notaries = notary ?: serviceHub.networkMapCache.notaryIdentities.first()
val vaultCriteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(notary = listOf(notaries as AbstractParty))

val logicalExpression = builder { CashSchemaV1.PersistentCashState::currency.equal(amountRequired.token.product.currencyCode) }
val cashCriteria = QueryCriteria.VaultCustomQueryCriteria(logicalExpression)

val fullCriteria = fungibleCriteria.and(vaultCriteria).and(cashCriteria)

val eligibleStates = serviceHub.vaultService.tryLockFungibleStatesForSpending(lockId, fullCriteria, amountRequired.withoutIssuer(), Cash.State::class.java)

check(eligibleStates.isNotEmpty()) { &quot;Insufficient funds&quot; }
val amount = eligibleStates.fold(0L) { tot, (state) -&gt; tot + state.data.amount.quantity }
val change = amount - amountRequired.quantity

return Pair(eligibleStates, change)
</code></pre><p>}<br>这是一项外汇交易，所以我们预计另一种来自交易对手货币的投入状态。然而，Corda隐私模型意味着我们不知道其他节点的状态。因此，我们的流程必须要求另一个节点执行类似的查询并将额外的输入返回给交易（参见 ForeignExchangeFlow交换的更多细节）。我们现在拥有所有必需的输入StateRef项目，并可转而收集输出。</p>
<p>对于贸易审批流程，我们需要实施一个简单的工作流程模式。我们首先将未经确认的交易细节记录在实现LinearState界面的状态对象中。此记录的一个字段用于将业务工作流映射到枚举状态。最初，发起者创建一个新的状态对象，该对象UniqueIdentifier在其linearId属性中接收新的状态， 并且启动工作流状态为NEW。该Contract.verify方法的写法是允许发起者签署该初始事务并将其发送给另一方。该模式确保为了审计目的在两个分类帐上都记录永久性副本，但是可以防止状态被恶意置于批准状态。接下来的工作流程步骤随后将消耗状态作为一方输入的事务处理，然后输出一个新的版本，其中包含任何状态更新，或者与业务流程相匹配linearId的修改，这些更改将保留在整个变更中。附Command对象有助于验证方法将更改限制在工作流中每个步骤的相应字段和签名者。在这种情况下，通常双方都签署了变更交易，但如果允许单方面签署，例如一方可以阻止拒绝，那么这是有效的。通常，这些工作流的手动启动器将通过RPC接口向Vault查询正确合同类型的状态以及正确的工作流状态。然后，RPC将启动相关流程StateRef或使用linearId值作为流程的参数，以识别正在进行操作的状态。因此，收集给定的最新输入状态的代码StateRef将使用VaultService如下代码：</p>
<p>val criteria = VaultQueryCriteria(stateRefs = listOf(ref))<br>val latestRecord = serviceHub.vaultService.queryBy&lt;TradeApprovalContract.State&gt;(criteria).states.single()<br>生成命令<br>对于要添加到事务中的命令，这些命令需要正确反映当前的任务。这些必须匹配，因为在该Contract.verify方法中该命令将用于选择验证码路径。Contract.verify然后该方法将限制事务的允许内容以反映该上下文。典型的限制可能包括输入现金金额必须等于输出现金金额，或者工作流步骤仅允许更改状态字段。有时，命令可能会捕获一些数据，例如外汇汇率或一方的身份，或者在批量操作中产生命令的特定输入的StateRef。这些数据将被用来进一步帮助Contract.verify，因为为了确保分布式环境中的一致性，安全性和可重复性Contract.verify，交易是唯一允许使用交易内容来决定合法性的。</p>
<p>命令的另一个基本要求是将正确的PublicKey对象集 添加到Command构建器上，这将用于在最终验证的事务上形成一组必需的签名者。这些必须与Contract.verify方法的期望保持一致 ，这应该写成防御性的检查。特别是，预计至少资产的所有者必须签署许可转让该资产。另外，在进行资产交换时，通常还需要其他签署方，例如甲骨文公司的Oracle身份标识或双方。</p>
<p>生成输出<br>找到一StateAndRefs组作为交易输入后，流程必须生成输出状态。通常，这是对Kotlin copy方法的简单调用，以修改将在事务中转换的几个字段。generateXXX如果任务更复杂，合同代码可能会提供一种帮助此流程的 方法。对于工作流程状态，稍微修改的副本状态通常就足够了，特别是因为我们希望保留linearId状态修订版本之间的关系，以便Vault查询可以找到最新的修订版本。</p>
<p>对于可替代的合同状态，例如cash在分配大量输入状态时，通常会分配和分配总金额，例如为原始所有者产生剩余的余额输出状态。请记住，成功交易的结果总是要完全消耗/消耗输入状态，因此需要这样才能节省总现金。例如来自演示代码：</p>
<p>// Gather our inputs. We would normally use VaultService.generateSpend<br>// to carry out the build in a single step. To be more explicit<br>// we will use query manually in the helper function below.<br>// Putting this into a non-suspendable function also prevents issues when<br>// the flow is suspended.<br>val (inputs, residual) = gatherOurInputs(serviceHub, lockId, sellAmount, request.notary)</p>
<p>// Build and an output state for the counterparty<br>val transferedFundsOutput = Cash.State(sellAmount, request.counterparty)</p>
<p>val outputs = if (residual &gt; 0L) {<br>    // Build an output state for the residual change back to us<br>    val residualAmount = Amount(residual, sellAmount.token)<br>    val residualOutput = Cash.State(residualAmount, serviceHub.myInfo.singleIdentity())<br>    listOf(transferedFundsOutput, residualOutput)<br>} else {<br>    listOf(transferedFundsOutput)<br>}<br>return Pair(inputs, outputs)<br>构建SignedTransaction<br>收集了交易的所有组件后，我们现在需要使用a TransactionBuilder来构建完整的SignedTransaction。我们实例化一个TransactionBuilder并提供一个与输出状态相关的公证。然后我们不断添加输入，输出，命令和附件以完成交易。</p>
<p>一旦交易完成后，我们呼吁ServiceHub.signInitialTransaction签署TransactionBuilder 并将其转换为SignedTransaction。</p>
<p>这个过程的例子是：</p>
<p>// Modify the state field for new output. We use copy, to ensure no other modifications.<br>// It is especially important for a LinearState that the linearId is copied across,<br>// not accidentally assigned a new random id.<br>val newState = latestRecord.state.data.copy(state = verdict)</p>
<p>// We have to use the original notary for the new transaction<br>val notary = latestRecord.state.notary</p>
<p>// Get and populate the new TransactionBuilder<br>// To destroy the old proposal state and replace with the new completion state.<br>// Also add the Completed command with keys of all parties to signal the Tx purpose<br>// to the Contract verify method.<br>val tx = TransactionBuilder(notary).<br>        withItems(<br>                latestRecord,<br>                StateAndContract(newState, TRADE_APPROVAL_PROGRAM_ID),<br>                Command(TradeApprovalContract.Commands.Completed(),<br>                        listOf(ourIdentity.owningKey, latestRecord.state.data.source.owningKey)))<br>tx.setTimeWindow(serviceHub.clock.instant(), 60.seconds)<br>// We can sign this transaction immediately as we have already checked all the fields and the decision<br>// is ultimately a manual one from the caller.<br>// As a SignedTransaction we can pass the data around certain that it cannot be modified,<br>// although we do require further signatures to complete the process.<br>val selfSignedTx = serviceHub.signInitialTransaction(tx)<br>private fun buildTradeProposal(ourInputStates: List&lt;StateAndRef&lt;Cash.State&gt;&gt;,<br>                               ourOutputState: List&lt;Cash.State&gt;,<br>                               theirInputStates: List&lt;StateAndRef&lt;Cash.State&gt;&gt;,<br>                               theirOutputState: List&lt;Cash.State&gt;): SignedTransaction {<br>    // This is the correct way to create a TransactionBuilder,<br>    // do not construct directly.<br>    // We also set the notary to match the input notary<br>    val builder = TransactionBuilder(ourInputStates.first().state.notary)</p>
<pre><code>// Add the move commands and key to indicate all the respective owners and need to sign
val ourSigners = ourInputStates.map { it.state.data.owner.owningKey }.toSet()
val theirSigners = theirInputStates.map { it.state.data.owner.owningKey }.toSet()
builder.addCommand(Cash.Commands.Move(), (ourSigners + theirSigners).toList())

// Build and add the inputs and outputs
builder.withItems(*ourInputStates.toTypedArray())
builder.withItems(*theirInputStates.toTypedArray())
builder.withItems(*ourOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())
builder.withItems(*theirOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())

// We have already validated their response and trust our own data
// so we can sign. Note the returned SignedTransaction is still not fully signed
// and would not pass full verification yet.
return serviceHub.signInitialTransaction(builder, ourSigners.single())
</code></pre><p>}<br>完成SignedTransaction<br>创建完成TransactionBuilder并将其转换为a后SignedTransaction，验证和形成完整的过程SignedTransaction开始，然后通过公证完成。在实践中，这是一个相对刻板的过程，因为假设SignedTransaction构建正确，验证应立即进行。但是，重新检查从外部节点接收的任何数据的业务详情也很重要，因为恶意方在返回事务之前总是可以修改内容。因此，每个远程流程应该尽可能多地检查SignedTransaction内部的初始状态unwrap的同意签署前的接收。任何问题都应立即抛出异常来中止流程。同样，始发者应始终对其原始提案应用任何新签名，以确保交易内容未被远程方更改。</p>
<p>因此，典型的代码SignedTransaction 使用该verifySignaturesExcept方法检查收到的信息，但不包括其本身，公证人以及尚未申请其签名的任何其他方。SignedTransaction应该通过扩展toLedgerTransaction和调用 进一步充分验证内容verify。因此，应该进行更多的特定于上下文的业务检查，因为Contract.verify不允许访问外部上下文。例如，流程可能需要检查当事人是否正确，或者Command交易中的现在是否符合特定流程的预期。演示代码中的一个例子是：</p>
<p>// First we receive the verdict transaction signed by their single key<br>val completeTx = sourceSession.receive<signedtransaction>().unwrap {<br>    // Check the transaction is signed apart from our own key and the notary<br>    it.verifySignaturesExcept(ourIdentity.owningKey, it.tx.notary!!.owningKey)<br>    // Check the transaction data is correctly formed<br>    val ltx = it.toLedgerTransaction(serviceHub, false)<br>    ltx.verify()<br>    // Confirm that this is the expected type of transaction<br>    require(ltx.commands.single().value is TradeApprovalContract.Commands.Completed) {<br>        “Transaction must represent a workflow completion”<br>    }<br>    // Check the context dependent parts of the transaction as the<br>    // Contract verify method must not use serviceHub queries.<br>    val state = ltx.outRef&lt;TradeApprovalContract.State&gt;(0)<br>    require(serviceHub.myInfo.isLegalIdentity(state.state.data.source)) {<br>        “Proposal not one of our original proposals”<br>    }<br>    require(state.state.data.counterparty == sourceSession.counterparty) {<br>        “Proposal not for sent from correct source”<br>    }<br>    it<br>}<br>在验证之后，远程流程将把其签名返回给始发者。发起人应该将该签名应用于开始 SignedTransaction并重新检查签名匹配。</signedtransaction></p>
<p>提交交易<br>一旦将所有签名应用于该签名SignedTransaction，最后的步骤都是公证，并确保所有节点都记录完全签署的交易。代码为FinalityFlow：</p>
<p>// Notarise and distribute the completed transaction.<br>subFlow(FinalityFlow(allPartySignedTx, setOf(newState.source)))<br>部分可见交易<br>迄今为止的讨论认为，各方需要对交易进行充分的可见性签署。但是，可能会出现以下情况：各方需要存储用于审计目的的私人数据，或者向监管机构提供证据，但不希望与其他贸易伙伴分享。Corda的拆解/ Merkle树支持允许流程发送完整事务的一部分以限制对远程方的可见性。要做到这一点，可以使用 SignedTransaction.buildFilteredTransaction扩展方法来产生一个FilteredTransaction。SignedTransaction 我们希望隐藏的元素将被替换为其安全散列。总体事务ID仍然可以通过FilteredTransaction防止私有数据的更改来证明 ，但我们不会将该数据直接暴露给其他节点。在这里可以找到完整的例子NodeInterestRatesirs-demo与RatesFixFlow流程交互的项目中的Oracle代码 。另外，请参阅交易拆分。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/08/blockchain/corda/Corda教程——合约部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/blockchain/corda/Corda教程——合约部分/" itemprop="url">Corda教程——合约部分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T11:11:59+08:00">2018-06-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h1><p>本教程将带您通过撰写合同，以简单的商业纸张合同为例。Corda的智能合约有三个关键要素：</p>
<ul>
<li>可执行代码（验证逻辑）</li>
<li>状态对象</li>
<li>命令</li>
</ul>
<p>智能合约的核心是验证交易中状态对象更改的可执行代码。状态对象是分类账中保存的数据，它代表合约实例的当前状态，并用作交易的输入和输出。命令是包含在交易中的附加数据，用于描述发生了什么，用于指示可执行代码如何验证交易。例如，一个<code>Issue</code>命令可能指示验证逻辑应该看到一个输出，该输出不存在作为输入的输出，由签署该命令的相同实体发出。</p>
<p>首先要考虑的是合约状态的生命周期，它们是如何发行的，它们发布后会发生什么，以及它们如何销毁（如果适用）。对于商业票据合约，状态是由希望创建合约在未来（到期日）支付货款的法律实体签发的，现在换取较少的付款。然后，他们被转移（转移）给另一个所有者，作为交易的一部分，发行人在收到付款资金后，通过向所有者支付商业票据的面值销毁（赎回）后来的（到期日之后）。</p>
<p><b style="color:red">商业票据的生命周期如下图所示：</b><br><img src="https://docs.corda.net/head/_images/contract-cp.png" alt=""></p>
<h2 id="开始商业票据（paper）类"><a href="#开始商业票据（paper）类" class="headerlink" title="开始商业票据（paper）类"></a>开始商业票据（paper）类</h2><p>智能合约是一个实现<code>Contract</code>接口的类。这可以直接实现，就像这里所做的那样，或者通过继承一个抽象合约，比如<code>OnLedgerAsset</code>。Corda任何合约的核心是确定给定交易是否有效的<code>verify</code>方法。这个例子展示了如何从头开始编写一个<code>verify</code>函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaper</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        TODO()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每份合约都必须至少有一个<code>verify</code>方法。验证方法不返回任何内容。这是故意的：函数要么正确地完成，要么抛出异常，在这种情况下，交易被拒绝。</p>
<p><b style="color:blue">到目前为止，这么简单。现在我们需要定义商业票据状态，它代表一张已发行票据的所有权事实。</b></p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>状态是存储由合约检查的数据的类。商业票据状态的结构如下：<br><img src="https://docs.corda.net/head/_images/contract-cp-state.png" alt=""></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(</span><br><span class="line">        <span class="keyword">val</span> issuance: PartyAndReference,</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> owner: AbstractParty,</span><br><span class="line">        <span class="keyword">val</span> faceValue: Amount&lt;Issued&lt;Currency&gt;&gt;,</span><br><span class="line">        <span class="keyword">val</span> maturityDate: Instant</span><br><span class="line">) : OwnableState &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> participants = listOf(owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withoutOwner</span><span class="params">()</span></span> = copy(owner = AnonymousParty(NullKeys.NullPublicKey))</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwner</span><span class="params">(newOwner: <span class="type">AbstractParty</span>)</span></span> = CommandAndState(CommercialPaper.Commands.Move(), copy(owner = newOwner))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义一个实现<code>ContractState</code>接口的类。</p>
<p>我们的状态有四个领域：</p>
<ul>
<li><code>issuance</code>，是对某一方发布的特定商业票据的参考。</li>
<li><code>owner</code>，当前所有者的公钥。这与在比特币中看到的概念是一样的：公钥没有附加的身份，并且由于隐私原因预计会一次性使用。然而，与比特币不同的是，我们将个体所有权视为个别状态层面而不是平台层面的概念，因为我们认为平台上的许多（可能是大多数）合约不代表“所有者/发行人”关系，而是“party/party“衍生合约等关系。</li>
<li><code>faceValue</code>，一个<code>Amount&lt;Issued&lt;Currency&gt;&gt;</code>包装整数个便士和特定于一些发行者（例如正规银行，中央银行等）的货币的货币。你可以在<a href="https://docs.corda.net/head/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a>中阅读更多关于这个非常常见的类型。</li>
<li><code>maturityDate</code>中，即时，这是从Java 8标准时间库中的类型。它定义了时间线上的一个点。</li>
</ul>
<p>状态是不可变的，因此这个类也被定义为不可变的。Kotlin版本中的修饰符<code>data</code>会导致编译器自动生成equals/hashCode/toString方法，以及可用于创建原始对象变体的复制方法。如果您熟悉该语言，则数据类与Scala中的案例类相似。<code>withoutOwner</code>方法使用自动生成的复制方法来返回状态的一个版本，其拥有者公钥已被删除：稍后将证明这一点很有用。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><b style="color:red">合约的验证逻辑可能会有所不同，具体取决于它自动执行的状态级生命周期的哪个阶段。因此，将附加数据传递到并非永久存在于分类帐中的状态所代表的合约代码中以便明确交易的意图会很有用。</b></p>
<p>为此我们有命令。通常他们不需要包含任何数据，他们只需要存在。<b style="color:red">命令是与某些签名关联的一段数据</b>。在合约运行时签名已经被检查过，<b style="color:red">所以从合约代码的角度来看，一个命令只是一个带有连接公钥列表的数据结构</b>。每个密钥都有一个签名，证明相应的私钥用于签名。由于这种方法，合约永远不会直接与数字签名进行交互或处理。</p>
<p>现在我们来定义一些命令：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Commands</span> : <span class="type">CommandData &#123;</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Move</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Redeem</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Issue</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个简单的分组接口或静态类，这给了我们一个类型，我们所有的命令有共通之处，那么我们就创建三个命令：<code>Move</code>，<code>Redeem</code>，<code>Issue</code>。<code>TypeOnlyCommandData</code>对于命令内部没有数据的情况是一个有用的工具; 只有存在很重要。它定义了equals和hashCode，以便任何实例始终将相等值和散列值与相同的值进行比较。</p>
<h2 id="verify方法"><a href="#verify方法" class="headerlink" title="verify方法"></a><code>verify</code>方法</h2><p>智能合约的核心是验证一组状态转换（交易）的代码。该函数很简单：给定一个表示交易的类，如果该函数返回，则该交易被认为是可接受的。如果它抛出异常，则交易被拒绝。</p>
<p>每个交易可以有多个不同类型的输入和输出状态。要运行的合约集合取决于每个状态中的代码引用。每份合约只运行一次。例如，一份包含2个现金状态和1个商业票据状态作为输入的合同，其输出为1个现金状态和1个商业票据状态，将分别运行两次合同：现金和商业票据。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Group by everything except owner: any modification to the CP at all is considered changing it fundamentally.</span></span><br><span class="line">    <span class="keyword">val</span> groups = tx.groupStates(State::withoutOwner)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are two possible things that can be done with this CP. The first is trading it. The second is redeeming</span></span><br><span class="line">    <span class="comment">// it for cash on or after the maturity date.</span></span><br><span class="line">    <span class="keyword">val</span> command = tx.commands.requireSingleCommand&lt;CommercialPaper.Commands&gt;()</span><br></pre></td></tr></table></figure>
<p>我们从使用<code>groupStates</code>方法开始，它使用一个类型和一个函数。状态分组是确保您的合同可以在同一个交易中处理同一类型的多个不相关的状态的一种方式，这是资产拆分/合并，原子交换等所需的。接下来会有更多说明。</p>
<p>第二行代码的作用就是：它搜索一个从超类<code>CommercialPaper.Commands</code>类型继承的命令对象 ，并返回它，或者在有零个或多个这样的命令时抛出异常。</p>
<h2 id="使用状态组"><a href="#使用状态组" class="headerlink" title="使用状态组"></a>使用状态组</h2><p>写一个智能合约最简单的方法就是说，每个交易可以有一个单一的输入状态和该合约所涵盖的单一输出状态。这对开发者来说很容易，但会阻止很多重要的用例。</p>
<p>编写合约的下一个最简单的方法是迭代每个输入状态，并期望它具有输出状态。现在你可以建立一个单一的交易，例如，同时以不同的货币移动两个不同的现金状态。但是当你想在移动另一个状态的同时发出或退出一个状态时，它会变得复杂。</p>
<p>一旦你想分裂和合并状态，事情会变得更加困难。我们说，如果接受者对待彼此的状态是可以互相替代的，尽管它们并不完全相同。美元账单是可以替代的，因为即使一个人可能穿着/有点脏，另一个可能是新鲜的，他们仍然价值正好1美元。同样的，十美元的钞票几乎完全相当于十美元的钞票。另一方面，10美元和10英镑是不可替代的：如果你试图用10美元+ 10美元的票据支付20英镑的东西，你的交易将不被接受。</p>
<p>为了使这一切更容易，合同API提供了一个组的概念。一组是一组输入状态和输出状态，应该一起检查有效性。</p>
<p>考虑以下简化的货币交易交易：</p>
<ul>
<li>输入：Alice拥有12,000美元（A）</li>
<li>输入：Alice拥有3,000美元（A）</li>
<li>输入：Bob拥有10,000英镑（B）</li>
<li>输出：爱丽丝拥有的10,000英镑（B）</li>
<li>输出：Bob拥有15,000美元（A）</li>
</ul>
<p>在这笔交易中，爱丽丝和鲍勃以10,000英镑交易15,000美元。爱丽丝以两种不同的投入形式出钱，例如因为她收到了两笔款项中的美元。输入和输出金额确实平衡，但现金智能合约必须单独考虑英镑和美元，因为它们不可替代：它们不能合并在一起。所以我们有两个组：A和B.</p>
<p><code>LedgerTransaction.groupStates</code>方法为我们处理这个逻辑：首先，它只选择给定类型的状态（因为交易可能包括其他类型的状态，例如表示债券所有权的状态，或者多信号状态），然后它需要一个函数将状态映射到分组key。共享相同密钥的所有状态都组合在一起。在上述现金示例的情况下，分组key将是货币。</p>
<p>在这种合约中，我们不希望CP可以替换：合并和拆分（在我们的例子中）是不允许的。所以我们只使用状态的副本减去所有者字段作为分组键。</p>
<p>以下是一些代码示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type of groups is List&lt;InOutGroup&lt;State, Pair&lt;PartyReference, Currency&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">val</span> groups = tx.groupStates &#123; it: Cash.State -&gt; it.amount.token &#125;</span><br><span class="line">  <span class="keyword">for</span> ((inputs, outputs, key) <span class="keyword">in</span> groups) &#123;</span><br><span class="line">      <span class="comment">// Either inputs or outputs could be empty.</span></span><br><span class="line">      <span class="keyword">val</span> (deposit, currency) = key</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>groupStates</code>调用使用提供的功能来计算“分组键”。所有具有相同分组键的状态都放在同一组中。分组键可以是实现equals / hashCode的任何内容，但它总是不应在输入和输出之间改变的字段的集合。在上面的例子中，我们选择了我们想要的字段并将它们打包成一个<code>Pair</code>。它返回一个列表<code>InOutGroup</code>，它只是输入，输出和用于定义组的密钥的持有者。在Kotlin版本中，我们使用解构来解压缩这些数据，以便方便地访问输入，输出，存款数据和货币。</p>
<p>这些规则可以应用于输入和输出，就好像它是单个交易一样。一个组可能有零输入或零输出：当将资产发放到分类帐或删除它们时可能会发生这种情况。</p>
<p>在这个例子中，我们采用不同的方式，并使用状态类本身作为聚合器。我们只是删除允许更改的字段，使分组键成为“不是那样的一切”：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> groups = tx.groupStates(State::withoutOwner)</span><br></pre></td></tr></table></figure>
<p>对于有许多字段必须保持不变且只有一两个真正可变的字段的大型状态来说，通过这种方式做事通常比专门命名每个必须保持不变的字段更容易。<code>withoutOwner</code>这里的函数只是返回对象的一个​​副本，但是将<code>owner</code>字段设置为<code>NullPublicKey</code>，这只是全零的公钥。这是无效和无用的，但没关系，因为我们所做的只是防止字段在equals和hashCode中出现问题。</p>
<h2 id="检查要求"><a href="#检查要求" class="headerlink" title="检查要求"></a>检查要求</h2><p>在提取命令和组之后，我们遍历每个组并验证它是否满足所需的业务逻辑。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> timeWindow: TimeWindow? = tx.timeWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((inputs, outputs, _) <span class="keyword">in</span> groups) &#123;</span><br><span class="line">    <span class="keyword">when</span> (command.value) &#123;</span><br><span class="line">        <span class="keyword">is</span> Commands.Move -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> input = inputs.single()</span><br><span class="line">            requireThat &#123;</span><br><span class="line">                <span class="string">"the transaction is signed by the owner of the CP"</span> using (input.owner.owningKey <span class="keyword">in</span> command.signers)</span><br><span class="line">                <span class="string">"the state is propagated"</span> using (outputs.size == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// Don't need to check anything else, as if outputs.size == 1 then the output is equal to</span></span><br><span class="line">                <span class="comment">// the input ignoring the owner field due to the grouping.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">is</span> Commands.Redeem -&gt; &#123;</span><br><span class="line">            <span class="comment">// Redemption of the paper requires movement of on-ledger cash.</span></span><br><span class="line">            <span class="keyword">val</span> input = inputs.single()</span><br><span class="line">            <span class="keyword">val</span> received = tx.outputs.map &#123; it.<span class="keyword">data</span> &#125;.sumCashBy(input.owner)</span><br><span class="line">            <span class="keyword">val</span> time = timeWindow?.fromTime ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Redemptions must be timestamped"</span>)</span><br><span class="line">            requireThat &#123;</span><br><span class="line">                <span class="string">"the paper must have matured"</span> using (time &gt;= input.maturityDate)</span><br><span class="line">                <span class="string">"the received amount equals the face value"</span> using (received == input.faceValue)</span><br><span class="line">                <span class="string">"the paper must be destroyed"</span> using outputs.isEmpty()</span><br><span class="line">                <span class="string">"the transaction is signed by the owner of the CP"</span> using (input.owner.owningKey <span class="keyword">in</span> command.signers)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">is</span> Commands.Issue -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> output = outputs.single()</span><br><span class="line">            <span class="keyword">val</span> time = timeWindow?.untilTime ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Issuances must be timestamped"</span>)</span><br><span class="line">            requireThat &#123;</span><br><span class="line">                <span class="comment">// Don't allow people to issue commercial paper under other entities identities.</span></span><br><span class="line">                <span class="string">"output states are issued by a command signer"</span> using (output.issuance.party.owningKey <span class="keyword">in</span> command.signers)</span><br><span class="line">                <span class="string">"output values sum to more than the inputs"</span> using (output.faceValue.quantity &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="string">"the maturity date is not in the past"</span> using (time &lt; output.maturityDate)</span><br><span class="line">                <span class="comment">// Don't allow an existing CP state to be replaced by this issuance.</span></span><br><span class="line">                <span class="string">"can't reissue an existing state"</span> using inputs.isEmpty()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unrecognised command"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个循环是合约的核心逻辑。</p>
<p>第一行只是简单地从交易中获取时间窗口。在交易中设置时间窗口是可选的，所以在这里可能会丢失时间。我们稍后检查它是否为空。</p>
<p><b style="color:blue">警告： 在Kotlin版本中，只要我们先与交易时间进行比较，编译器就会验证我们是否忘记检查是否缺失。不幸的是，由于需要流畅的Java互操作性，如果我们编写<code>someDate &gt; time</code>，它不会发生这种检查。所以最好总是先写<code>time &lt; someDate</code>交易时间窗口。</b></p>
<p>接下来，根据命令对象的类型，我们选取​​三条路径中的一条路径。</p>
<h3 id="如果该命令是“Move”命令："><a href="#如果该命令是“Move”命令：" class="headerlink" title="如果该命令是“Move”命令："></a>如果该命令是“Move”命令：</h3><p>第一行（Java中的前三行）强制要求该组中有一张商业票据。我们不允许多个单位的CP分拆或合并，即使它们属于同一个所有者。<code>single()</code>方法是由Kotlin标准库定义的静态扩展方法：给定一个列表，如果列表大小不是1，则抛出异常，否则返回该列表中的单个项目。在Java中，这看起来像许多<code>FooUtils</code>类型单例类熟悉的类型的常规静态方法，我们在这里静态地导入它。在Kotlin中，它显示为可以在任何JDK列表上调用的方法。语法略有不同，但在幕后，代码编译为相同的字节码。</p>
<p>接下来，我们检查交易是否被标记为商业票据当前所有者的公钥签署。由于该平台已经在合同开始执行之前验证了所有数字签名，因此我们所要做的就是验证所有者的公钥是签署交易的密钥之一。Java代码很简单：我们只是使用<code>Preconditions.checkStateGuava</code> 的方法。Kotlin版本看起来有点奇怪：我们有一个<code>requireThat</code>构造，看起来像它构建在语言中。实际上需要这是平台合同API提供的普通功能。Kotlin支持创建特定于域的语言 通过语言的几个特征的交集，我们在这里使用它来支持需求的自然列表。要查看它编译的内容，请查看Java版本。<code>requireThat</code>中的每个<code>&quot;string&quot; using (expression)</code>语句都会变成断言，表明给定的表达式为真， 并且抛出包含该字符串（如果没有）的断言的<code>IllegalArgumentException</code>异常。这只是写出定期断言的另一种方式，但将英语要求放在前面和中心。</p>
<p>接下来，我们简单地验证输出状态是否存在：移动不允许从分类账中删除CP。分组逻辑已经确保细节相同并且没有被更改，除了所有者的公钥之外。</p>
<h3 id="如果该命令是“Redeem”命令，则需求更为复杂："><a href="#如果该命令是“Redeem”命令，则需求更为复杂：" class="headerlink" title="如果该命令是“Redeem”命令，则需求更为复杂："></a>如果该命令是“Redeem”命令，则需求更为复杂：</h3><ol>
<li>我们仍检查是否有CP输入状态。</li>
<li>我们希望看到CP的面值正在作为针对某一方的现金债权，即CP的发行人真正偿还了面值。</li>
<li>交易必须在到期日之后进行。</li>
<li>商业票据（paper）不得通过此交易进行传播：它必须由无输出状态的群组删除。这可以防止相同的CP被认为可以多次兑换。</li>
</ol>
<p>为了计算现金流动的多少，我们使用<code>sumCashBy</code>效用函数。再一次，这是一个扩展函数，所以在Kotlin代码中，即使JDK没有提供这种方法，它看起来好像是一种<code>List&lt;Cash.State&gt;</code>类型的方法。在Java中，我们看到它的真实性质：它实际上是一个名为<code>CashKt.sumCashBy</code>的静态方法。该方法只返回一个<code>Amount</code>对象，该对象包含该给定公钥所拥有的交易输出中所有现金状态的总和，或者如果没有这样的状态则抛出异常或如果在产出中有不同的货币代表！所以我们可以看到，这个合约对赎回交易的结构施加了限制：您不允许在CP不涉及的同一交易中移动货币。如果它是一个真正的限制，这个限制可以通过更好的API来解决。</p>
<h3 id="最后，我们支持一个Issue命令，在分类账上创建商业票据的新实例。"><a href="#最后，我们支持一个Issue命令，在分类账上创建商业票据的新实例。" class="headerlink" title="最后，我们支持一个Issue命令，在分类账上创建商业票据的新实例。"></a>最后，我们支持一个<code>Issue</code>命令，在分类账上创建商业票据的新实例。</h3><p>它同样在发布时实施各种不变量，例如，必须有一个输出CP状态。</p>
<p>这份合同很简单，并没有实现真正的商业纸张生命周期管理计划所能实现的所有业务逻辑。例如，没有逻辑需要发行人签名进行赎回：假设与赎回同时发生的任何货币转移足够好。也许这应该是收紧的。同样，如果发行人已经破产，如果发生争议等，没有逻辑处理会发生什么情况。</p>
<p>随着原型的发展，将会探索这些要求并更新本教程以反映合同API的改进。</p>
<h2 id="如何测试你的合同"><a href="#如何测试你的合同" class="headerlink" title="如何测试你的合同"></a>如何测试你的合同</h2><p>当然，单元测试你的新业务逻辑块是非常重要的，以确保它的行为像你期望的那样。由于合约代码只是一个常规的Java函数，因此您可以用通常的方式手工完全写出逻辑。但是这样做会很不方便，然后你会厌倦写作测试，那很糟糕：你可能会想要跳过一些。</p>
<p>为了使合同测试更加方便Corda为Kotlin和Java提供了类似于语言的API，使您可以轻松构建交易链并验证它们是通过验证还是失败并显示特定的错误消息。</p>
<p>使用该领域特定语言测试合同在单独的教程，<a href="https://docs.corda.net/head/tutorial-test-dsl.html" target="_blank" rel="noopener">编写合同测试</a>中有介绍。</p>
<h2 id="将生成API添加到您的合同"><a href="#将生成API添加到您的合同" class="headerlink" title="将生成API添加到您的合同"></a>将生成API添加到您的合同</h2><p>合同类必须提供验证功能，但他们也可以选择提供帮助功能来简化其使用。大多数合同提供的一个简单的函数类是生成函数，它可以创建或修改交易以执行某些操作（操作通常可以 1:1 映射到命令，但不一定如此）。</p>
<p>生成可能涉及复杂的逻辑。例如，现金合同有一个<code>generateSpend</code>方法，给定一组现金状态并选择一种方法将它们组合在一起以满足发送的金额。在我们正在使用的不可变状态模型中，账单（状态）只能被创建和删除，但从未被修改过。因此，当我们只有900美元和500美元需要将两种状态结合在一起时，发送1200美元，然后创建1200美元和200美元的两种新输出状态。后一种状态被称为变化，并且是任何使用比特币的人都应该熟悉的概念。</p>
<p>作为另一个例子，我们可以想象实现网络算法的代码可能会产生复杂的交易，这些交易必须由很多人签名。虽然这样的代码对于单个实用方法来说可能太大（它可能更像一个模块），但基本概念是相同的：使用复杂逻辑准备交易。</p>
<p>然而，对于我们的商业票据合同，可以用它来完成的事情非常简单。让我们从一个方法来结束发行过程：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateIssue</span><span class="params">(issuance: <span class="type">PartyAndReference</span>, faceValue: <span class="type">Amount</span>&lt;<span class="type">Issued</span>&lt;<span class="type">Currency</span>&gt;&gt;, maturityDate: <span class="type">Instant</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  notary: <span class="type">Party</span>)</span></span>: TransactionBuilder &#123;</span><br><span class="line">    <span class="keyword">val</span> state = State(issuance, issuance.party, faceValue, maturityDate)</span><br><span class="line">    <span class="keyword">val</span> stateAndContract = StateAndContract(state, CP_PROGRAM_ID)</span><br><span class="line">    <span class="keyword">return</span> TransactionBuilder(notary = notary).withItems(stateAndContract, Command(Commands.Issue(), issuance.party.owningKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们提及发行方（即调用方），并可能包含我们可能需要的任何内部簿记/参考号码。参考字段是放置（例如）连接键的理想场所。然后是票据的面值和到期日。它返回一个<code>TransactionBuilder</code>。<code>TransactionBuilder</code>是该平台提供的少数几个可变类之一。它允许您添加输入，输出和命令，并且可以在多个合同之间传递。</p>
<p>注意：生成方法理想情况下应该写成彼此合作，即它们应该将<code>TransactionBuilder</code>作为一个参数而不是返回，除非您确定将这种类型的交易与其他交易结合起来没有意义。在这种情况下，在做其他事情的同时发行CP只会带来不值得的复杂性，因此我们每次都会返回一个新对象：发行人应该发行CP（由他们自己），然后在一个单独的交易中出售。</p>
<p>我们定义的函数创建一个<code>CommercialPaper.State</code>对象，该对象通常只使用我们提供的参数，但它填充状态的所有者字段与发布方相同。</p>
<p>然后，我们将<code>CommercialPaper.State</code>对象与对<code>CommercialPaper</code>合同内部定义的合同的引用进行合并<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    const <span class="keyword">val</span> CP_PROGRAM_ID: ContractClassName = <span class="string">"net.corda.finance.contracts.CommercialPaper"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此值是合同的完全限定类名，它告诉Corda平台在哪里查找应该用于验证包含此合同类型的输出状态的交易的合约代码。通常，合约代码将作为附件包含在交易中（请参阅使用附件）。</p>
<p>返回的部分交易有一个<code>Command</code>对象作为参数。这是实现<code>CommandData</code>接口的任何对象的容器，以及预计要签署此交易的密钥列表。在这种情况下，签发要求签发方签字，所以我们把派对的钥匙放在那里。</p>
<p><code>TransactionBuilder</code>具有便利的<code>withItems</code>的方法，需要一个可变参数列表。你可以传入任何<code>StateAndRef</code>（输入），<code>StateAndContract</code>（输出）或<code>Command</code>对象，它会为你建立交易。</p>
<p>最后要注意的一件事是：我们要求调用者选择一个公证人来控制这个状态，并防止它被双重花费。您可以在公证文章中了解关于此主题的更多信息。</p>
<p>注意： 现在，不要担心如何挑选公证人。稍后会有更多基础设施为您自动执行此决定。</p>
<p>如何移动票据，即将所有权重新分配给其他人？<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateMove</span><span class="params">(tx: <span class="type">TransactionBuilder</span>, paper: <span class="type">StateAndRef</span>&lt;<span class="type">State</span>&gt;, newOwner: <span class="type">AbstractParty</span>)</span></span> &#123;</span><br><span class="line">    tx.addInputState(paper)</span><br><span class="line">    <span class="keyword">val</span> outputState = paper.state.<span class="keyword">data</span>.withNewOwner(newOwner).ownableState</span><br><span class="line">    tx.addOutputState(outputState, CP_PROGRAM_ID)</span><br><span class="line">    tx.addCommand(Command(Commands.Move(), paper.state.<span class="keyword">data</span>.owner.owningKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，该方法需要预先存在<code>TransactionBuilder</code>并添加到该方法中。这是正确的，因为通常情况下，您会希望将原子CP(商业票据 Commercial Paper)的销售与某些其他资产（如现金）的移动结合起来。所以这两种生成方法都应该在同一个交易上运行。您可以在商业票据合同的单元测试中看到这样的例子。</p>
<p>票据是作为一个<code>StateAndRef&lt;CommercialPaper.State&gt;</code>对象给予我们的。这听起来就像是一个小对象，它有一个状态对象（副本），还有一个<code>(txhash, index)</code>表示这个状态在分类帐上的位置。</p>
<p>我们将现有票据状态添加为输入，将所有者字段调整为输出的相同票据状态，最后添加具有旧所有者公钥的移动命令：这是强制当前所有者签名出现在交易中的原因，这是合同中检查的内容。</p>
<p>最后，我们可以做到赎回。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(InsufficientBalanceException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateRedeem</span><span class="params">(tx: <span class="type">TransactionBuilder</span>, paper: <span class="type">StateAndRef</span>&lt;<span class="type">State</span>&gt;, services: <span class="type">ServiceHub</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Add the cash movement using the states in our vault.</span></span><br><span class="line">    Cash.generateSpend(</span><br><span class="line">            services = services,</span><br><span class="line">            tx = tx,</span><br><span class="line">            amount = paper.state.<span class="keyword">data</span>.faceValue.withoutIssuer(),</span><br><span class="line">            ourIdentity = services.myInfo.singleIdentityAndCert(),</span><br><span class="line">            to = paper.state.<span class="keyword">data</span>.owner</span><br><span class="line">    )</span><br><span class="line">    tx.addInputState(paper)</span><br><span class="line">    tx.addCommand(Command(Commands.Redeem(), paper.state.<span class="keyword">data</span>.owner.owningKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们可以看到一个组合合约的例子。当所有者希望赎回商业票据时，发行人（即调用者）必须从其vault中收取现金，并将面值发送给票据所有人。</p>
<p>注意：这份合同没有明确的轮转概念。</p>
<p>该库是可以从Bitcoin和ethereum熟悉的概念。它只是一组由调用方拥有的状态（如现金）。在这里，我们使用保险库（Vault）来更新我们交易的部分交易，从商业票据发行人到当前所有者的现金流动。如果我们的Vault中没有足够的现金，则会抛出异常。然后，我们将票据本身作为输入添加，但不是输出（因为我们希望将其从分类帐中移除）。最后，我们添加应由商业票据所有者签署的兑换命令。</p>
<p>警告：我们传递给<code>Cash.generateSpend</code>函数的数量必须首先处理<code>withoutIssuer</code>。这反映了我们处理发行人约束的方式仍在演变的事实; 商业票据合同要求以特定方（例如中央银行或发行人自己的银行）发行的货币形式支付。但是，保险库(Vault)希望利用任何发行人的现金状态来组合花费交易，因此我们必须在此剥离它。这表示设计不匹配，我们将在未来的版本中使用更完整的方式来表达发行者约束。</p>
<p><code>TransactionBuilder</code>本身并不准备随时使用，所以首先，我们必须将其转换为网络认可的东西。最重要的下一步是参与实体签署它。通常，启动流程将<code>SignedTransaction</code>通过调用<code>serviceHub.toSignedTransaction</code>方法创建一个部分签名的初始化。然后冻结<code>SignedTransaction</code>可以通过流程传递给其他节点，这些可以使用<code>serviceHub.createSignature</code>签名和分发。在<code>CollectSignaturesFlow</code>提供了一个这个过程的通用实现，可以作为<code>subFlow</code>使用。</p>
<p>您可以通过检查商业票据单元测试来了解交易流程构建的不同阶段。</p>
<h2 id="如何构建和传播多方交易"><a href="#如何构建和传播多方交易" class="headerlink" title="如何构建和传播多方交易"></a>如何构建和传播多方交易</h2><p>好的，现在我们知道如何定义分类账的规则，并且我们知道如何构建满足这些规则的交易……并且如果我们所做的只是维护我们自己的数据就足够了。但我们不是：Corda是关于保持许多不同的方面彼此同步。</p>
<p>在经典的区块链系统中，所有数据都传输给每个人，如果您想要做一些奇特的事情，比如多方交易，那么您就是自己的。在Corda数据只传输给有需要的人，多方交易是一种生活方式，所以我们为管理他们提供了很多支持。</p>
<p>您可以了解交易如何在同级之间移动，并通过单独的教程“<a href="https://docs.corda.net/head/flow-state-machines.html" target="_blank" rel="noopener">编写流程</a>”中的构建签名公证-广播流程进行。</p>
<h2 id="非资产导向的智能合约"><a href="#非资产导向的智能合约" class="headerlink" title="非资产导向的智能合约"></a>非资产导向的智能合约</h2><p>尽管本教程介绍了如何实施自有资产，但并不要求状态和代码合同 必须关心资产的所有权。把状态视为代表有关世界的有用事实，并且（代码）合约是强加关于事实如何结合以产生新事实的逻辑关​​系最好。<b style="color:blue">或者，您可以想象，状态就像关系数据库中的行一样，合约就像存储过程和关系约束。</b></p>
<p>在编写处理交易类实体而不是资产类实体的合约时，您可能希望参考“<a href="https://docs.corda.net/head/contract-irs.html" target="_blank" rel="noopener">利率掉期交易</a>”和随附的源代码。虽然所有概念都是相同的，但交易通常不是可拆分的或可合并的，因此您不必担心很多关于状态分组的问题。注：关于利率掉期交易可以参见<a href="https://zh.wikipedia.org/wiki/%E5%88%A9%E7%8E%87%E6%8E%89%E6%9C%9F%E4%BA%A4%E6%98%93" target="_blank" rel="noopener">维基百科</a>，缩写IRS。</p>
<h2 id="在特定的时间让事情发生"><a href="#在特定的时间让事情发生" class="headerlink" title="在特定的时间让事情发生"></a>在特定的时间让事情发生</h2><p>如果您可以对节点进行编程，使其在成熟后立即自动兑换商业票据，那将会很不错。Corda为各状态宣传将来发生的预定事件提供了一种途径。虽然这些信息在默认情况下被忽略，但如果相应的Cordapp已在您的节点中安装并处于活动状态，并且您的保管库认为该状态是相关的（例如因为您拥有该状态），则节点可自动开始创建交易的过程并贯穿整个生命周期。您可以在文章“ <a href="https://docs.corda.net/head/event-scheduling.html" target="_blank" rel="noopener">事件日程安排</a> ”中了解更多。</p>
<h2 id="产权负担"><a href="#产权负担" class="headerlink" title="产权负担"></a>产权负担</h2><p>所有合同状态可能最多由另一个状态担保，我们称之为产权负担。</p>
<p>如果存在这种负债状态，则会强制对设保状态进行额外的控制，因为在交易执行期间也会验证产权状态合同。例如，合同状态可能会受到时间锁定合同状态的影响; 那么状态只能在一个交易中进行处理，以验证在保留时间锁定中指定的时间已过。</p>
<p>设保状态指的是按索引产生的负担，而所提到的负债状态是创造担保状态的同一交易中特定位置上的输出状态。请注意，正在使用的已设置状态必须在同一交易中消耗其负担，否则交易无效。</p>
<p>在<code>ContractState</code>接口中，产权负担参考是可选的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> encumbrance: <span class="built_in">Int</span>? <span class="keyword">get</span>() = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>上面提到的时间锁定协议可以非常简单地实现：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTimeLock</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> time = tx.timeWindow?.untilTime ?: <span class="keyword">throw</span> IllegalStateException(...)</span><br><span class="line">        ...</span><br><span class="line">        requireThat &#123;</span><br><span class="line">            <span class="string">"the time specified in the time-lock has passed"</span> <span class="keyword">by</span></span><br><span class="line">                    (time &gt;= tx.inputs.filterIsInstance&lt;TestTimeLock.State&gt;().single().validFrom)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以设置一个设防状态：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> encumberedState = Cash.State(amount = <span class="number">1000.</span>DOLLARS `issued <span class="keyword">by</span>` defaultIssuer, owner = DUMMY_PUBKEY_1, encumbrance = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> fourPmTimelock = TestTimeLock.State(Instant.parse(<span class="string">"2015-04-17T16:00:00.00Z"</span>))</span><br></pre></td></tr></table></figure></p>
<p>当我们构造一个产生担保状态的交易时，我们必须将该负债放置在该交易的相应输出位置。当我们随后使用该设防状态时，同样的保留状态必须在输入状态组中的某处可用。</p>
<p>将来，我们会考虑立约的概念。这是产权负担与担保状态每次迭代并行的地方。例如，现金状态可能会受到居籍负担的影响，该现金状况会检查现金状态正在转移到的所有者身份的住所，以便维护制裁审查条例，并防止现金支付给住在如朝鲜。在这种情况下，产权负担应该永久地附加于由此产生的所有未来现金状态。</p>
<p>我们也会考虑标记能够成为产权负担的状态。这将防止状态无意中将其用作负担。例如，上面的时间锁定可以作为一种负担，但是能够用另一个锁定现金状态是没有意义的。</p>
<h1 id="撰写合同测试"><a href="#撰写合同测试" class="headerlink" title="撰写合同测试"></a>撰写合同测试</h1><p>本教程将带您完成使用Kotlin和Java编写合同测试所需的步骤。</p>
<p>测试DSL允许用交易相互引用来定义分类账的一部分，以及验证其正确性的方法。</p>
<h2 id="测试单个事务"><a href="#测试单个事务" class="headerlink" title="测试单个事务"></a>测试单个事务</h2><p>我们从空账本开始：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">emptyLedger</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ledger &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DSL关键字<code>ledger</code>需要一个可以建立多个交易的闭包，并且可以验证它们的整体正确性。分类账实际上是一个没有预先存在的交易或服务的新鲜世界。</p>
<p>我们将从定义返回<code>CommercialPaper</code>状态的帮助函数开始：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bigCorp = TestIdentity((CordaX500Name(<span class="string">"BigCorp"</span>, <span class="string">"New York"</span>, <span class="string">"GB"</span>)))</span><br></pre></td></tr></table></figure></p>
<p>这是MEGA_CORP发行的一张面值为1000美元的CommercialPaper，并在7日内到期。</p>
<p>我们添加一个CommercialPaper交易：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPDoesntCompile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledger &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CommercialPaper.CP_PROGRAM_ID) &#123; inState &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用transaction原语向账本添加交易。交易可以通过指定<code>input</code>-s，<code>output</code>-s，<code>command</code>-s和<code>attachment</code>-s 来定义。</p>
<p>上述<code>input</code>调用有点特别，交易实际上不包含输入状态，只是引用其他交易的输出状态。上面的<code>input</code>调用在分类账中创建了一个虚拟交易（不会被验证），它会输出指定的状态，并引用来自该交易的虚拟交易。</p>
<p>上面的代码不能编译：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">29</span>, <span class="number">17</span>) Kotlin: Type mismatch: inferred type <span class="keyword">is</span> <span class="built_in">Unit</span> but EnforceVerifyOrFail was expected</span><br></pre></td></tr></table></figure></p>
<p>这是故意的：DSL迫使我们在<code>transaction</code>最后一行指定<code>verifies()</code>或者：<code><code>fails with</code>(“some text”)</code><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example test will fail with this exception.</span></span><br><span class="line"><span class="meta">@Test(expected = IllegalStateException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看失败的交易。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example test will fail with this exception.</span></span><br><span class="line"><span class="meta">@Test(expected = TransactionVerificationException.ContractRejection::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPMove</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行时，该代码会产生以下错误：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.corda.core.contracts.TransactionVerificationException$ContractRejection: java.lang.IllegalArgumentException: Failed requirement: the state <span class="keyword">is</span> propagated</span><br></pre></td></tr></table></figure></p>
<p>交易验证失败，因为我们想移动票据，但没有指定输出 - 但状态应该传播。但是，我们可以通过更改<code>verifies()</code>为<code><code>fails with</code>(“the state is propagated”)</code>以下内容来指定这是预期行为：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPMoveFails</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            `fails with`(<span class="string">"the state is propagated"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以继续构建交易，直到<code>verifies</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPMoveFailureAndSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            `fails with`(<span class="string">"the state is propagated"</span>)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, inState.withOwner(alice.party))</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>output</code>指定我们希望将输入状态传输到<code>ALICE</code>并且<code>command</code>添加由输入状态的当前所有者签名的<code>Move</code>命令本身<code>MEGA_CORP_PUBKEY</code>。</p>
<p>我们构建了完整的签名商业票据交易并对其进行验证。请注意我们遗漏了<code>fails with</code>这一行 - 这很好，失败将在部分构建的交易中进行测试。</p>
<p>如果我们想测试错误的Party签署交易时会发生什么，我们该怎么办？如果我们简单地添加<code>command</code>, 它将永久破坏交易…输入<code>tweak</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `simple issuance with tweak`<span class="params">()</span></span> &#123;</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper()) <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            tweak &#123;</span><br><span class="line">                <span class="comment">// The wrong pubkey.</span></span><br><span class="line">                command(bigCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">                timeWindow(TEST_TX_TIME)</span><br><span class="line">                `fails with`(<span class="string">"output states are issued by a command signer"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tweak</code>创建交易的本地副本。这使得本地“破坏”交易成为可能，同时不修改原来的交易，允许测试不同的错误情况。</p>
<p>我们现在有一个测试单个交易的简单测试。这已经很有用了，事实上，以这种方式测试单个交易是非常普遍的。甚至还有一个简单的顶级<code>transaction</code>元，它可以用一个交易创建一个分类帐：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `simple issuance with tweak and top level transaction`<span class="params">()</span></span> &#123;</span><br><span class="line">    ledgerServices.transaction(dummyNotary.party) &#123;</span><br><span class="line">        output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper()) <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        attachments(CP_PROGRAM_ID)</span><br><span class="line">        tweak &#123;</span><br><span class="line">            <span class="comment">// The wrong pubkey.</span></span><br><span class="line">            command(bigCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            `fails with`(<span class="string">"output states are issued by a command signer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">        timeWindow(TEST_TX_TIME)</span><br><span class="line">        verifies()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链接交易"><a href="#链接交易" class="headerlink" title="链接交易"></a>链接交易</h2><p>现在我们知道如何定义单个交易了，我们来看看如何定义它们的链：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `chain commercial paper`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> issuer = megaCorp.party.ref(<span class="number">123</span>)</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        unverifiedTransaction &#123;</span><br><span class="line">            attachments(Cash.PROGRAM_ID)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"alice's $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy alice.party)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        transaction(<span class="string">"Issuance"</span>) &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        transaction(<span class="string">"Trade"</span>) &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            input(<span class="string">"alice's $900"</span>)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"borrowed $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy megaCorp.party)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</span><br><span class="line">            command(alice.publicKey, Cash.Commands.Move())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们声明<code>ALICE</code>有900美元，但我们不关心从哪里开始。为此我们可以使用 <code>unverifiedTransaction</code>。请注意我们不需要指定<code>verifies()</code>。</p>
<p>请注意，我们使用<code>&quot;alice&#39;s $900&quot;</code>标记了输出，同样在命名为<code>&quot;Issuance&quot;</code>的交易中，我们使用<code>&quot;paper&quot;</code>标记了一个商业票据。现在我们可以随后在其他交易中引用它们，例如通过<code>input(&quot;alice&#39;s $900&quot;)</code>或<code>&quot;paper&quot;.output&lt;ICommercialPaperState&gt;()</code>。</p>
<p>最后一笔命名为<code>&quot;Trade&quot;</code>的交易举例说明了向爱丽丝卖出900美元<code>CommercialPaper</code>的简单事实，仅仅在7天后以10％的利率面值减价100美元。</p>
<p>我们也可以测试整个分类帐调用<code>verifies()</code>和<code>fails()</code>分类账级别。为此，我们创建一个使用相同输入两次的简单示例：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `chain commercial paper double spend`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> issuer = megaCorp.party.ref(<span class="number">123</span>)</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        unverifiedTransaction &#123;</span><br><span class="line">            attachments(Cash.PROGRAM_ID)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"alice's $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy alice.party)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        transaction(<span class="string">"Issuance"</span>) &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction(<span class="string">"Trade"</span>) &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            input(<span class="string">"alice's $900"</span>)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"borrowed $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy megaCorp.party)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</span><br><span class="line">            command(alice.publicKey, Cash.Commands.Move())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            <span class="comment">// We moved a paper to another pubkey.</span></span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"bob's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(bob.party))</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fails()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>交易单独<code>verifies()</code>，但状态花了两次！这就是为什么我们需要全球总账验证（<code>fails()</code>最后）。和前面的例子一样，我们可以用<code>tweak</code>来创建整个分类账的本地副本：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `chain commercial tweak`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> issuer = megaCorp.party.ref(<span class="number">123</span>)</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        unverifiedTransaction &#123;</span><br><span class="line">            attachments(Cash.PROGRAM_ID)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"alice's $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy alice.party)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        transaction(<span class="string">"Issuance"</span>) &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction(<span class="string">"Trade"</span>) &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            input(<span class="string">"alice's $900"</span>)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"borrowed $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy megaCorp.party)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</span><br><span class="line">            command(alice.publicKey, Cash.Commands.Move())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tweak &#123;</span><br><span class="line">            transaction &#123;</span><br><span class="line">                input(<span class="string">"paper"</span>)</span><br><span class="line">                <span class="comment">// We moved a paper to another pubkey.</span></span><br><span class="line">                output(CP_PROGRAM_ID, <span class="string">"bob's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(bob.party))</span><br><span class="line">                command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">                verifies()</span><br><span class="line">            &#125;</span><br><span class="line">            fails()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        verifies()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="升级合同"><a href="#升级合同" class="headerlink" title="升级合同"></a>升级合同</h1><p><b style="color:blue">虽然在开发合同代码时需要谨慎对待，但不可避免地需要进行升级以修复错误（无论是在设计还是实施中）。升级可能涉及将合同代码的一个版本替换为另一个版本或更改为了解如何迁移现有状态对象的不同合同。当状态对象作为输出添加到交易中时，它们通过<code>StateAndContract</code>类型链接到它们打算提供的合同代码 。改变一个状态的合同只需要一个<code>ContractClassName</code>换另一个。</b></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>以下是合约升级的工作流程：</p>
<ol>
<li>银行A和B在非平台上进行交易谈判</li>
<li>银行A和B执行流程以使用合约X构建代表交易的状态对象，并将其包含在交易中（然后签署并发送到共识服务）</li>
<li>时间流逝</li>
<li>合同X的开发人员发现了合同代码中的一个错误，并且发布了一个新版本，合同Y.开发人员然后会通知所有现有用户（例如通过邮件列表或CorDapp Store），以阻止他们的节点使用合同发布更多状态X</li>
<li>银行A和B通过标准变更控制流程审查新合同，并确定他们同意升级的合同状态（他们可能会决定不升级某些合同状态，因为这些合同状态可能需要履行其他义务合同）</li>
<li>银行A和B指示他们的Corda节点（通过RPC）愿意使用约定X升级状态对象以使用约定的升级路径来表示具有合同Y的对象</li>
<li>其中一方（Initiator）启动一个流程，用引用合同Y的新状态对象来替换引用合同X的状态对象</li>
<li>提议的交易（the Proposal），以旧状态作为输入并且重新发布状态作为输出，被创建并且用节点的私钥签名</li>
<li>该Initiator节点将拟议中的交易，与它提出的新合同升级路径的细节一起，给状态对象的所有参与者</li>
<li>每个对方（Acceptors）验证提案，相应地签署或拒绝状态重新发布，并将签名或拒绝通知发回给发起节点</li>
<li>如果从各方收到签名，则Initiator组装完整的签名交易并将其发送给公证处</li>
</ol>
<h2 id="授权升级"><a href="#授权升级" class="headerlink" title="授权升级"></a>授权升级</h2><p>每个正在升级合同的状态的参与者都必须指示他们的节点在升级发生之前同意升级。<code>ContractUpgradeFlow</code>用于管理授权过程。每个节点管理员都可以使用RPC 为相关状态触发一个<code>Authorise</code>或一个<code>Deauthorise</code>流。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authorise</span></span>(</span><br><span class="line">        <span class="keyword">val</span> stateAndRef: StateAndRef&lt;*&gt;,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> upgradedContractClass: Class&lt;<span class="keyword">out</span> UpgradedContract&lt;*, *&gt;&gt;</span><br><span class="line">) : FlowLogic&lt;<span class="built_in">Void</span>?&gt;() &#123;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deauthorise</span></span>(<span class="keyword">val</span> stateRef: StateRef) : FlowLogic&lt;<span class="built_in">Void</span>?&gt;() &#123;</span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span>: <span class="built_in">Void</span>? &#123;</span><br></pre></td></tr></table></figure>
<h2 id="提议升级"><a href="#提议升级" class="headerlink" title="提议升级"></a>提议升级</h2><p>在各方授权合同升级之后，合同参与方之一可以通过触发<code>ContractUpgradeFlow.Initiate</code>流程启动升级流程。<code>Initiate</code>创建包括旧状态和更新状态的交易，并将其发送给每个参与者。每个参与者将验证交易，在其上创建签名，并将签名发送回发起人。一旦收集完所有签名，交易将会公证并保存到每个参与者的保险库中。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设银行A与银行B签订了一项协议，银行B由状态目标<code>DummyContractState</code>代表并受合约代码<code>DummyContract</code>的约束。合约交换几天后，合约代码的开发者发现了合约代码中的一个错误。</p>
<p>银行A和银行B决定将合同升级为<code>DummyContractV2</code>：</p>
<ol>
<li><p>开发人员创建一个<code>DummyContractV2</code>扩展<code>UpgradedContract</code>该类的新合同，以及一个<code>DummyContractV2.State</code>引用新合同的新状态对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyContractV2</span> : <span class="type">UpgradedContractWithLegacyConstraint</span>&lt;<span class="type">DummyContract.State, DummyContractV2.State</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        const <span class="keyword">val</span> PROGRAM_ID: ContractClassName = <span class="string">"net.corda.testing.contracts.DummyContractV2"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legacyContract: String = DummyContract::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">name</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legacyContractConstraint: AttachmentConstraint = AlwaysAcceptAttachmentConstraint</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">val</span> magicNumber: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">val</span> owners: List&lt;AbstractParty&gt;) : ContractState &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> participants: List&lt;AbstractParty&gt; = owners</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Commands</span> : <span class="type">CommandData &#123;</span></span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Create</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Move</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">upgrade</span><span class="params">(state: <span class="type">DummyContract</span>.<span class="type">State</span>)</span></span>: State &#123;</span><br><span class="line">        <span class="keyword">return</span> State(state.magicNumber, state.participants)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Other verifications.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>银行A指示其节点接受合同升级到<code>DummyContractV2</code>合同状态。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rpcClient : CordaRPCClient = &lt;&lt; Bank A<span class="string">'s Corda RPC Client &gt;&gt;</span></span><br><span class="line"><span class="string">val rpcA = rpcClient.proxy()</span></span><br><span class="line"><span class="string">rpcA.startFlow(ContractUpgradeFlow.Authorise(&lt;&lt;StateAndRef of the contract state&gt;&gt;, DummyContractV2::class.java))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>银行B启动升级流程，该流程将向所有合同参与者发送升级提议。合同状态的每个参与者在签署并返回合同状态升级提议后，都将验证并同意升级。升级后的交易将按流量记录在每个参与者的节点中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rpcClient : CordaRPCClient = &lt;&lt; Bank B<span class="string">'s Corda RPC Client &gt;&gt;</span></span><br><span class="line"><span class="string">val rpcB = rpcClient.proxy()</span></span><br><span class="line"><span class="string">rpcB.startFlow(&#123; stateAndRef, upgrade -&gt; ContractUpgradeFlow(stateAndRef, upgrade) &#125;,</span></span><br><span class="line"><span class="string">    &lt;&lt;StateAndRef of the contract state&gt;&gt;,</span></span><br><span class="line"><span class="string">    DummyContractV2::class.java)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意: 查看<code>ContractUpgradeFlowTest</code>更详细的代码示例。</p>
<h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><p>集成测试包括在本地引入节点并通过启动流程并检查其状态来测试它们的不变量。</p>
<p><b style="color:blue">在本教程中，我们将展示三个节点 - Alice，Bob和公证人。Alice将向Bob发放现金，然后Bob将这笔现金返还给Alice。我们将看到如何在此期间测试一些简单的确定性和非确定性不变量。</b></p>
<p><b style="color:red">为了产生节点，我们将使用驱动程序DSL。这个DSL允许从代码启动节点进程。它管理网络map服务并在后台安全地关闭节点。</b></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">driver(DriverParameters(startNodesInProcess = <span class="keyword">true</span>,</span><br><span class="line">        extraCordappPackagesToScan = listOf(<span class="string">"net.corda.finance.contracts.asset"</span>))) &#123;</span><br><span class="line">    val aliceUser = User(<span class="string">"aliceUser"</span>, <span class="string">"testPassword1"</span>, permissions = setOf(</span><br><span class="line">            startFlow&lt;CashIssueFlow&gt;(),</span><br><span class="line">            startFlow&lt;CashPaymentFlow&gt;(),</span><br><span class="line">            invokeRpc(<span class="string">"vaultTrackBy"</span>),</span><br><span class="line">            invokeRpc(CordaRPCOps::notaryIdentities),</span><br><span class="line">            invokeRpc(CordaRPCOps::networkMapFeed)</span><br><span class="line">    ))</span><br><span class="line">    val bobUser = User(<span class="string">"bobUser"</span>, <span class="string">"testPassword2"</span>, permissions = setOf(</span><br><span class="line">            startFlow&lt;CashPaymentFlow&gt;(),</span><br><span class="line">            invokeRpc(<span class="string">"vaultTrackBy"</span>),</span><br><span class="line">            invokeRpc(CordaRPCOps::networkMapFeed)</span><br><span class="line">    ))</span><br><span class="line">    val (alice, bob) = listOf(</span><br><span class="line">            startNode(providedName = ALICE_NAME, rpcUsers = listOf(aliceUser)),</span><br><span class="line">            startNode(providedName = BOB_NAME, rpcUsers = listOf(bobUser))</span><br><span class="line">    ).transpose().getOrThrow()</span><br></pre></td></tr></table></figure>
<p>上面的代码启动三个节点：</p>
<ul>
<li>Alice，拥有用户权限来启动<code>CashIssueFlow</code>和 <code>CashPaymentFlow</code>流程。</li>
<li>Bob，只有拥有用户权限才能启动<code>CashPaymentFlow</code></li>
<li>公证人提供了一份<code>ValidatingNotaryService</code>。我们不会直接连接到公证人，所以没有必要提供<code>User</code></li>
</ul>
<p><code>startNode</code>函数一旦节点完全启动完成就返回<code>future</code>。这允许节点的启动是平行的。我们等待这些<code>futures</code>，因为我们需要返回的信息; 他们各自的<code>NodeHandles</code>s。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aliceClient = CordaRPCClient(alice.rpcAddress)</span><br><span class="line"><span class="keyword">val</span> aliceProxy = aliceClient.start(<span class="string">"aliceUser"</span>, <span class="string">"testPassword1"</span>).proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bobClient = CordaRPCClient(bob.rpcAddress)</span><br><span class="line"><span class="keyword">val</span> bobProxy = bobClient.start(<span class="string">"bobUser"</span>, <span class="string">"testPassword2"</span>).proxy</span><br></pre></td></tr></table></figure></p>
<p>获得句柄后，我们等待双方向网络map注册，以确保我们没有网络map注册的竞争条件。接下来我们使用我们创建的测试用户从测试过程分别连接到Alice和Bob。然后我们建立RPC链接，使我们能够启动流程和查询状态。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bobVaultUpdates = bobProxy.vaultTrackBy&lt;Cash.State&gt;().updates</span><br><span class="line"><span class="keyword">val</span> aliceVaultUpdates = aliceProxy.vaultTrackBy&lt;Cash.State&gt;().updates</span><br></pre></td></tr></table></figure></p>
<p>我们会对Alice和Bob的保险库(Vault)发生更改感兴趣，因此我们会查询每个保险库(Vault)的更新流。</p>
<p>现在我们都已经建立起来了，我们终于可以获得一些现金行动了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">val issueRef = OpaqueBytes.of(0)</span><br><span class="line">val notaryParty = aliceProxy.notaryIdentities().first()</span><br><span class="line">(1..10).map &#123; i -&gt;</span><br><span class="line">    aliceProxy.startFlow(::CashIssueFlow,</span><br><span class="line">            i.DOLLARS,</span><br><span class="line">            issueRef,</span><br><span class="line">            notaryParty</span><br><span class="line">    ).returnValue</span><br><span class="line">&#125;.transpose().getOrThrow()</span><br><span class="line">// We wait for all of the issuances to run before we start making payments</span><br><span class="line">(1..10).map &#123; i -&gt;</span><br><span class="line">    aliceProxy.startFlow(::CashPaymentFlow,</span><br><span class="line">            i.DOLLARS,</span><br><span class="line">            bob.nodeInfo.singleIdentity(),</span><br><span class="line">            true</span><br><span class="line">    ).returnValue</span><br><span class="line">&#125;.transpose().getOrThrow()</span><br><span class="line"></span><br><span class="line">bobVaultUpdates.expectEvents &#123;</span><br><span class="line">    parallel(</span><br><span class="line">            (1..10).map &#123; i -&gt;</span><br><span class="line">                expect(</span><br><span class="line">                        match = &#123; update: Vault.Update&lt;Cash.State&gt; -&gt;</span><br><span class="line">                            update.produced.first().state.data.amount.quantity == i * 100L</span><br><span class="line">                        &#125;</span><br><span class="line">                ) &#123; update -&gt;</span><br><span class="line">                    println(&quot;Bob vault update of $update&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个循环创建10个线程，每个线程在Alice节点上启动一个<code>CashFlow</code>流。我们指定我们要向鲍勃发放<code>i</code>美元，并将公证人设置为负责公证所创建状态的公证人。请注意，由于我们没有花费任何状态，只会在分类帐上创建新的状态，所以不会发生公证。</p>
<p>为了本教程的目的，我们从不同的线程开始流程，演示如何测试非确定性，这是<code>expectEvents</code>块的功能。</p>
<p>Expect DSL允许在事件流上检查排序约束。上面的代码指定我们期望10个更新以<code>bobVaultUpdates</code>未指定的顺序在流上发出（这是<code>parallel</code>构造的作用）。我们指定一个（否则可选）<code>match</code>谓词来标识我们感兴趣的特定更新，然后我们将打印这些更新。</p>
<p>如果我们运行迄今为止编写的代码，我们应该看到4个节点启动（<code>Alice</code>，<code>Bob</code>，<code>公证</code>和<code>一个隐含的网络map服务</code>），然后Bob的10个日志从Alice接收1,2，… 10美元，以某种未指定的顺序。</p>
<p>接下来，我们希望Bob将这笔现金退还给Alice。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    bobProxy.startFlow(::CashPaymentFlow, i.DOLLARS, alice.nodeInfo.singleIdentity()).returnValue.getOrThrow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aliceVaultUpdates.expectEvents &#123;</span><br><span class="line">    sequence(</span><br><span class="line">            (<span class="number">1.</span><span class="number">.10</span>).map &#123; i -&gt;</span><br><span class="line">                expect &#123; update: Vault.Update&lt;Cash.State&gt; -&gt;</span><br><span class="line">                    println(<span class="string">"Alice got vault update of <span class="variable">$update</span>"</span>)</span><br><span class="line">                    assertEquals(update.produced.first().state.<span class="keyword">data</span>.amount.quantity, i * <span class="number">100</span>L)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一次，我们会按顺序进行。我们让Bob按顺序向Alice付10美元。我们确保一个在<code>CashFlow</code>已经等待完成<code>startFlow</code>的<code>returnValue</code>。</p>
<p>然后，我们再次使用Expect DSL，这次使用<code>sequence</code>用于测试按照我们预期的顺序到达的更新。</p>
<p>请注意，<code>parallel</code>和<code>sequence</code>可以被嵌套到彼此任意地来测试更复杂的场景。</p>
<p>这就是这些！我们看到了如何在本地启动几个corda节点，如何连接它们以及如何测试一些简单的关于<code>CashFlow</code>的不变量。</p>
<p><b style="color:red">要运行完整的测试，您可以从IntelliJ 打开<code>example-code/src/integration-test/kotlin/net/corda/docs/IntegrationTestingTutorial.kt</code>  并运行测试，或者使用gradle：</b><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Run example-code integration tests</span><br><span class="line">./gradlew docs/source/example-code:integrationTest -i</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/08/密码学/数字证书基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/密码学/数字证书基础知识/" itemprop="url">数字证书基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T10:29:18+08:00">2018-06-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/密码学/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于数字证书，一定会想起Https，其实Https是基于<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">SSL/TLS</a>的。SSL/TLS其实不止可以用于HTTP，任何采用TCP协议的数据通信都可以采用SSL/TLS进行传输，比如FTP。只是就当前而言，SSL/TLS最为广泛的应用在于HTTPS。当然想起SSL，大家一定还会想起RSA，接着就是SSH了。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>这里需要提到公私钥的密码体制了，这个网上的资料有很多就不多说明了。</p>
<h2 id="关于HTTPS"><a href="#关于HTTPS" class="headerlink" title="关于HTTPS"></a>关于HTTPS</h2><p>其实客户机加密数据发送给服务器，由于只有服务器才有私钥，所以这个过程是没有任何问题的。但是反过来服务器加密数据发送给客户机，由于公钥是公开的这个过程就有问题了，因为大家都可以看到内容。</p>
<p>另外如果有人冒充服务器，让用户替换了自己的公钥，这样也会遭受中间人攻击。所以用户也需要验证公钥是不是相应服务器的公钥，所以就出现了数据证书。</p>
<p>服务器向客户端发送信息的时候要加上签名，还要加上数字证书，这样客户端既可以验证内容和公钥是否正确了。</p>
<p>以上的过程只是用于服务器和客户端约定以后的通信加密密串，一旦约定成功就可以使用对称加密进行后续的通信了。<br>如下：</p>
<ol>
<li>client -&gt; server: 你好，以后使用这个密串通信吧！（公钥加密）</li>
<li>server -&gt; client: 好的！（数字签名，证书）</li>
</ol>
<p>你看整个过程还是比较简洁的。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>经过上面的说明之后，我们来理解什么是数字证书。数字证书就是对网站生成的公钥进行签名的第三方服务机构。证书里面包含：</p>
<ul>
<li>Issuer (证书的发布机构)</li>
<li>Valid from , Valid to (证书的有效期)</li>
<li>Public key (公钥)</li>
<li>Subject (主题)： 这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 对于这里的证书来说，证书的所有者是Trustwave这个公司。</li>
<li>Signature algorithm (签名所使用的算法)</li>
<li>Thumbprint, Thumbprint algorithm (指纹以及指纹算法)</li>
</ul>
<p>当然这里我们不得不提到根证书，一般系统都是信任根证书，否则就不存在数字证书的合法性了。我们都知道CA机构是分层级的，包括根证书(Root Certificate)、中间证书(Intermediate Certificate)以及最底层的网站证书。其中根证书签署中间证书，中间证书在签署最底层的网站证书，由此组成一个证书链(Certificate Chain)。整个对证书的颁发、管理、认证组成了一整套基础设施——<a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="noopener">PKI</a>。</p>
<p>其实这样的分层是通过公钥的嵌套签名实现的层级关系。</p>
<h2 id="关于如何发布证书"><a href="#关于如何发布证书" class="headerlink" title="关于如何发布证书"></a>关于如何发布证书</h2><p>使用java的keytool工具可以生成相应的公私钥，还可以向CA机构购买证书服务。当然我们也可以自建自己的证书机构，只是不会有人承认而已，而且还要用户将我们的证书放入操作系统的信任列表中，这样实现起来比较麻烦。这里就不做更多说明了。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.cnblogs.com/davenkin/p/digital-certificate.html" target="_blank" rel="noopener">数字证书学习笔记</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a> 阮一峰的博客一般都是清晰好懂的。<br><a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="noopener">数字证书原理</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/blockchain/corda/Corda教程-hello world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/blockchain/corda/Corda教程-hello world/" itemprop="url">Corda教程 - hello world</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T17:20:35+08:00">2018-06-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>CorDapps是安装在一个或多个Corda节点上的插件，并使节点的所有者能够使节点执行一些新的过程 - 从发行债券工具到做餐馆预订。</p>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>我们的CorDapp将对账单进行模拟。IOU–“IO（我们）（YO）U”的简称 - 记录了一个人欠给他人一笔钱的事实。很明显，这是我们只想在贷款人和借款人之间需要知道的基础上进行沟通的敏感信息。幸运的是，这是Corda擅长的领域之一。由于区块链平台的规范，Corda可以轻松地让一小组人员就共享事实达成一致，而无需与网络上的其他人分享这一事实。</p>
<p>为了提供任何有用的功能，我们的CorDapp至少需要两个东西：</p>
<ul>
<li>状态，Corda节点达成共识的共同事实，然后存储在分类账上</li>
<li>流程，封装了执行特定分类帐更新的过程</li>
</ul>
<p>我们的IOU CorDapp也不例外。它将定义一个状态和一个流程：</p>
<h3 id="IOUState"><a href="#IOUState" class="headerlink" title="IOUState"></a>IOUState</h3><p>我们的状态将是<code>IOUState</code>。它将存储借条的价值，以及贷款人和借款人的身份。我们可以想象<code>IOUState</code>如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/tutorial-state.png" alt=""></p>
<h3 id="IOUFlow"><a href="#IOUFlow" class="headerlink" title="IOUFlow"></a>IOUFlow</h3><p>我们的流程将是<code>IOUFlow</code>。此流程将完全自动化将新IOU发放到分类账的过程。它由以下步骤组成：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/simple-tutorial-flow.png" alt=""></p>
<p>在传统的分布式账本系统中，所有数据都被广播给每个网络参与者，您不需要考虑数据流 - 只需打包分类账更新并将其发送给网络上的其他人即可。但在Corda，隐私是核心焦点，流程使我们能够在同意分类账更新的过程中仔细控制谁看到了什么。</p>
<h3 id="CorDapp模板"><a href="#CorDapp模板" class="headerlink" title="CorDapp模板"></a>CorDapp模板</h3><p>编写新的CorDapp时，通常需要将其基于标准模板：</p>
<ul>
<li><a href="https://github.com/corda/cordapp-template-java" target="_blank" rel="noopener">Java的Cordapp模板</a></li>
<li><a href="https://github.com/corda/cordapp-template-kotlin" target="_blank" rel="noopener">kotlin的Cordapp模板</a></li>
</ul>
<p>Cordapp模板为开发CorDapp提供了必需的样板，并允许您将CorDapp快速部署到虚拟节点的本地测试网络上，以测试其功能。</p>
<p>CorDapps可以用Java和Kotlin编写，并且将在本教程中以两种语言提供代码。</p>
<p>请注意，不需要下载和安装Corda本身。Corda V1.0所需的库将从一个在线Maven仓库自动下载。</p>
<h4 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h4><p>要下载模板，请在要下载CorDapp模板的目录中打开终端窗口，然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/corda/cordapp-template-java.git ;  cd cordapp-template-java</span><br></pre></td></tr></table></figure></p>
<p><em>要么</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/corda/cordapp-template-kotlin.git ;  cd cordapp-template-kotlin</span><br></pre></td></tr></table></figure></p>
<h4 id="在IntelliJ中打开模板"><a href="#在IntelliJ中打开模板" class="headerlink" title="在IntelliJ中打开模板"></a>在IntelliJ中打开模板</h4><p>下载模板后，按照以下说明在IntelliJ中打开它：<a href="https://docs.corda.net/tutorial-cordapp.html#opening-the-example-cordapp-in-intellij。" target="_blank" rel="noopener">https://docs.corda.net/tutorial-cordapp.html#opening-the-example-cordapp-in-intellij。</a></p>
<h4 id="模板结构"><a href="#模板结构" class="headerlink" title="模板结构"></a>模板结构</h4><p>该模板有许多文件，但我们可以忽略其中的大部分。我们只会修改以下文件：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于kotlin</span></span><br><span class="line"><span class="comment">// 1. The state</span></span><br><span class="line">cordapp-contracts-states/src/main/kotlin/com/template/StatesAndContracts.kt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The flow</span></span><br><span class="line">cordapp/src/main/kotlin/com/template/App.kt</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于java</span></span><br><span class="line"><span class="comment">// 1. The state</span></span><br><span class="line">cordapp-contracts-states/src/main/java/com/template/TemplateState.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The flow</span></span><br><span class="line">cordapp/src/main/java/com/template/TemplateFlow.java</span><br></pre></td></tr></table></figure>
<h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>为了防止以后出现构建错误，我们应该在开始之前删除以下文件：</p>
<ul>
<li>Java的： <code>cordapp/src/main/java/com/template/TemplateClient.java</code></li>
<li>kotlin： <code>cordapp/src/main/kotlin/com/template/Client.kt</code><h4 id="迄今取得进展"><a href="#迄今取得进展" class="headerlink" title="迄今取得进展"></a>迄今取得进展</h4>我们现在有一个模板，可以用来定义我们的IOU CorDapp。我们先来定义一下<code>IOUState</code>。<h3 id="编写状态"><a href="#编写状态" class="headerlink" title="编写状态"></a>编写状态</h3>在Corda，分类帐上的共享事实以状态表示。我们的第一个任务是定义一个新的状态类型来表示IOU。<h4 id="ContractState接口"><a href="#ContractState接口" class="headerlink" title="ContractState接口"></a>ContractState接口</h4>Corda状态是实现ContractState接口的类的任何实例。<code>ContractState</code>接口被定义为如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The list of entities considered to have a stake in this state.</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们可以看到<code>ContractState</code>接口只有一个字段<code>participants</code>。<code>participants</code>是这个状态相关的实体列表。</p>
<p>除此之外，我们的状态可以自由定义它需要的任何字段，方法，帮助者或内部类，以准确地表示分类账上给定类型的共享事实。</p>
<h4 id="建模IOUs"><a href="#建模IOUs" class="headerlink" title="建模IOUs"></a>建模IOUs</h4><p>我们应该如何在账本上定义代表借据？除了实现ContractState 接口之外，我们<code>IOUState</code>还需要属性来跟踪IOU的相关特性：</p>
<ul>
<li>IOU的价值</li>
<li>借条的贷方</li>
<li>借条的借款人</li>
</ul>
<p>还有更多可以包含的领域，比如IOU的货币，但现在让我们忽略它们。稍后添加它们通常就像为您的类定义添加附加属性一样简单。</p>
<h4 id="定义IOUState"><a href="#定义IOUState" class="headerlink" title="定义IOUState"></a>定义IOUState</h4><p>让我们开始打开<code>TemplateState.java</code>（对于Java）或<code>StatesAndContracts.kt</code>（对于Kotlin）并更新 <code>TemplateState</code>以定义<code>IOUState</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace TemplateState's definition with:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUState</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>,</span><br><span class="line">               <span class="keyword">val</span> lender: Party,</span><br><span class="line">               <span class="keyword">val</span> borrower: Party) : ContractState &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> participants <span class="keyword">get</span>() = listOf(lender, borrower)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Java，你还需要重命名<code>TemplateState.java</code>为<code>IOUState.java</code>。</p>
<p>为了定义IOUState，我们做了以下更改：</p>
<ul>
<li>我们已将<code>TemplateState</code>类重新命名为<code>IOUState</code></li>
<li>我们已经为Java 添加了属性<code>value</code>，<code>lender</code>以及<code>borrower</code>, Java中所需的getter和setter。<ul>
<li><code>value</code>是类型的<code>int</code>（在Java中）/ <code>Int</code>（在Kotlin中）</li>
<li><code>lender</code>并且<code>borrower</code>是类型<code>Party</code><ul>
<li><code>Party</code>是一种内置的Corda类型，表示网络上的实体</li>
</ul>
</li>
</ul>
</li>
<li>我们已经覆盖<code>participants</code>返回<code>lender</code>和<code>borrower</code>的列表<ul>
<li><code>participants</code> 是应该被通知创建或消费这个状态的所有各方的名单</li>
</ul>
</li>
</ul>
<p>我们发放到分类账上的借条只是这个类的实例。</p>
<h4 id="合同怎么处理？"><a href="#合同怎么处理？" class="headerlink" title="合同怎么处理？"></a>合同怎么处理？</h4><p>如果您已阅读白皮书或重要概念部分，您会知道每个州都有一个关联合同，该合同会对状态随着时间的推移而产生不变量。包括合同对于我们的第一个CorDapp并不重要，所以我们现在只使用由模板定义的空白<code>TemplateContract</code>和<code>TemplateContract.Commands.Action</code>命令。在下一个教程中，我们将实施我们自己的合约和命令。</p>
<h3 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h3><p>流程会对节点可以执行的一系列步骤进行编码，以实现特定的分类帐更新。通过在节点上安装新的流程，我们允许节点处理新的业务流程。我们定义的流程将允许节点发放 IOUState到分类帐上。</p>
<h4 id="流程轮廓"><a href="#流程轮廓" class="headerlink" title="流程轮廓"></a>流程轮廓</h4><p>我们的流程目标是协调一项借条发行交易。Corda中的交易是更新分类账的变更的原子单位。每笔交易都是将零个或多个现有状态标记为历史（输入），同时创建零个或多个新状态（输出）的建议。</p>
<p>创建这个交易并将其应用于分类帐的过程将由IOU的贷方进行，并且需要执行以下步骤：</p>
<ol>
<li>将发行新IOU的交易提案建立在分类帐上</li>
<li>签署交易提案</li>
<li>记录交易</li>
<li>将交易发送给借条人，以便他们也可以记录</li>
</ol>
<p>在此阶段，我们不要求借款人批准和签署IOU发行交易。当我们在下一个教程中查看合约时，我们将能够施加这个要求。</p>
<h5 id="支流"><a href="#支流" class="headerlink" title="支流"></a>支流</h5><p>Corda中很常见诸如记录交易或向交易对手发送交易等任务。Corda不是强迫每个开发人员重新实现自己的逻辑来处理这些任务，而是提供了许多库流程来处理这些任务。我们将这些流程调用到较大流程的上下文中，以处理可重复的任务子流程 。</p>
<p>在我们的案例中，我们可以使用IOU发行流程的步骤3和步骤4自动化<code>FinalityFlow</code>。</p>
<h4 id="FlowLogic"><a href="#FlowLogic" class="headerlink" title="FlowLogic"></a>FlowLogic</h4><p>所有的流程都必须继承<code>FlowLogic</code>。然后通过重写<code>FlowLogic.call</code>来定义流程采取的步骤。</p>
<p>让我们在<code>TemplateFlow.java</code>或<code>App.kt</code>中定义我们的<code>IOUFlow</code>。删除模板（<code>Initiator</code>和<code>Responder</code>）中的两个现有流程，并将其替换为以下内容：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace TemplateFlow's definition with:</span></span><br><span class="line"><span class="meta">@InitiatingFlow</span></span><br><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUFlow</span></span>(<span class="keyword">val</span> iouValue: <span class="built_in">Int</span>,</span><br><span class="line">              <span class="keyword">val</span> otherParty: Party) : FlowLogic&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The progress tracker provides checkpoints indicating the progress of the flow to observers. */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> progressTracker = ProgressTracker()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The flow logic is encapsulated within the call() method. */</span></span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// We retrieve the notary identity from the network map.</span></span><br><span class="line">        <span class="keyword">val</span> notary = serviceHub.networkMapCache.notaryIdentities[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create the transaction components.</span></span><br><span class="line">        <span class="keyword">val</span> outputState = IOUState(iouValue, ourIdentity, otherParty)</span><br><span class="line">        <span class="keyword">val</span> cmd = Command(TemplateContract.Commands.Action(), ourIdentity.owningKey)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create a transaction builder and add the components.</span></span><br><span class="line">        <span class="keyword">val</span> txBuilder = TransactionBuilder(notary = notary)</span><br><span class="line">                .addOutputState(outputState, TEMPLATE_CONTRACT_ID)</span><br><span class="line">                .addCommand(cmd)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We sign the transaction.</span></span><br><span class="line">        <span class="keyword">val</span> signedTx = serviceHub.signInitialTransaction(txBuilder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We finalise the transaction.</span></span><br><span class="line">        subFlow(FinalityFlow(signedTx))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Java，你还需要重命名<code>TemplateFlow.java</code>为<code>IOUFlow.java</code>。我们一步一步浏览这段代码。</p>
<p>我们已经定义了自己的<code>FlowLogic</code>重写了<code>FlowLogic.call</code>。<code>FlowLogic.call</code>有一个返回类型，必须匹配传递给它的类型参数<code>FlowLogic</code>- 这是通过运行流程返回的类型。</p>
<p><code>FlowLogic</code>子类可以有选择地使用构造函数参数，这些参数可以用作<code>FlowLogic.call</code>的参数。在我们的案例中，我们有两个：</p>
<ul>
<li><code>iouValue</code>，这是发行借据的价值</li>
<li><code>otherParty</code>，借条的借款人（运行该流程的节点是贷方）</li>
</ul>
<p><code>FlowLogic.call</code>被注解<code>@Suspendable</code> - <b style="color:Red">这可以让流程在遇到长时间运行的操作时被检查并指向并序列化到磁盘，从而允许您的节点继续运行其他流程。忘记这个注解将导致一些非常奇怪的错误信息！</b></p>
<p>在<code>FlowLogic</code>子类本身上还有更多的注释：</p>
<ul>
<li><code>@InitiatingFlow</code> 意味着该流程可以由节点直接启动</li>
<li><code>@StartableByRPC</code> 允许节点所有者通过RPC调用启动此流程</li>
</ul>
<p>我们来看看<code>FlowLogic.call</code>它自己的步骤。这是我们实际描述发行<code>IOUState</code>到分类账的程序的地方。</p>
<h5 id="选择一个公证人"><a href="#选择一个公证人" class="headerlink" title="选择一个公证人"></a>选择一个公证人</h5><p>每笔交易都需要一名公证人来防止双重花费，并担任时间戳管理机构。我们在流程中做的第一件事是从节点的<code>ServiceHub</code>检索一个公证人。<code>ServiceHub.networkMapCache</code>提供有关网络上其他节点以及它们提供的服务的信息。</p>
<p>注意: 无论何时我们需要流程中的信息 - 无论是关于我们自己的节点的身份，节点的本地存储还是网络的其余部分，我们通常都会通过节点的<code>ServiceHub</code>获取它。</p>
<h5 id="建立交易"><a href="#建立交易" class="headerlink" title="建立交易"></a>建立交易</h5><p>我们将分两步建立交易提案：</p>
<ul>
<li>创建交易的组件</li>
<li>将这些组件添加到交易生成器</li>
</ul>
<h5 id="交易项目"><a href="#交易项目" class="headerlink" title="交易项目"></a>交易项目</h5><p>我们的交易将具有以下结构：<br><img src="https://docs.corda.net/head/_images/simple-tutorial-transaction.png" alt=""></p>
<ul>
<li>输出<code>IOUState</code>的右侧表示我们将添加到分类账的状态。如您所见，没有任何输入 - 我们在创建IOU时不会消耗任何现有账本状态</li>
<li><code>Action</code>是将借条人列为签署人的命令</li>
</ul>
<p>我们已经讨论过了<code>IOUState</code>，但我们还没有看过命令。命令有两个功能：</p>
<ul>
<li>它们表明交易的意图 - 发行，转让，赎回，撤销。当我们在下一个教程中讨论合同时，这将是至关重要的</li>
<li>它们允许我们为交易定义所需的签名者。例如，IOU的创建可能只需要贷方的签名，而IOU的转移可能需要IOU的借款人和贷方的签名</li>
</ul>
<p>每个<code>Command</code>包含一个命令类型和一个公钥列表。现在，我们使用预先定义的<code>TemplateContract.Action</code>作为命令类型，并将贷方列为唯一的公钥。这意味着为使交易有效，贷款人必须签署交易。</p>
<h5 id="创建一个事务生成器"><a href="#创建一个事务生成器" class="headerlink" title="创建一个事务生成器"></a>创建一个事务生成器</h5><p>要真正建立拟议的交易，我们需要一个<code>TransactionBuilder</code>。这是一个可变的交易类，我们可以在其中添加输入，输出，命令以及交易所需的任何其他项目。我们创建一个<code>TransactionBuilder</code>使用我们早先检索的公证人。</p>
<p>一旦我们有了<code>TransactionBuilder</code>，我们添加我们的组件：</p>
<ul>
<li>该命令直接使用<code>TransactionBuilder.addCommand</code>添加 </li>
<li>输出<code>IOUState</code>使用<code>TransactionBuilder.addOutputState</code>添加。除了输出状态本身外，这种方法还要参考管理状态演变随时间推移的合约。在这里，我们传递了一个对其没有限制的<code>TemplateContract</code>引用。我们将在下一个教程中定义一个强制约束的合约</li>
</ul>
<h5 id="签署交易"><a href="#签署交易" class="headerlink" title="签署交易"></a>签署交易</h5><p>现在我们有一个有效的交易提案，我们需要签署它。交易一旦签署，任何人都无法修改交易而不会使此签名无效。这有效地使交易不可变。</p>
<p>我们用<code>ServiceHub.toSignedTransaction</code>签名交易，它返回一个<code>SignedTransaction</code>。<code>SignedTransaction</code>是将交易与该交易上的签名列表配对的对象。</p>
<h5 id="完成交易"><a href="#完成交易" class="headerlink" title="完成交易"></a>完成交易</h5><p>我们现在有一个有效的签名交易。剩下要做的就是让所有相关方都记录下来。通过这样做，它将成为分类账的永久部分。如上所述，我们将使用一个内置的<code>FinalityFlow</code>流程自动处理这个过程。<code>FinalityFlow</code>完全自动化的过程：</p>
<ul>
<li>如果需要，公证交易（即如果交易包含输入 和/或 时间窗口）</li>
<li>将它记录在我们的Vault中</li>
<li>将它发送给其他参与者（即贷方）以供他们进行记录</li>
</ul>
<h3 id="运行我们的CorDapp"><a href="#运行我们的CorDapp" class="headerlink" title="运行我们的CorDapp"></a>运行我们的CorDapp</h3><p>现在我们已经编写了一个CorDapp，现在是通过在一些真正的Corda节点上运行它来测试它的时候了。</p>
<h4 id="部署我们的CorDapp"><a href="#部署我们的CorDapp" class="headerlink" title="部署我们的CorDapp"></a>部署我们的CorDapp</h4><p>我们来看看我们要部署的节点。打开项目的build.gradle文件并向下滚动到<code>task deployNodes</code>部分。本节定义了三个节点。有两个标准节点（<code>PartyA</code>和<code>PartyB</code> ），<b style="color:red">以及运行网络map服务并公布验证公证服务的特殊网络map/公证节点。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">task deployNodes(type: net.corda.plugins.Cordform, dependsOn: [&apos;jar&apos;]) &#123;</span><br><span class="line">    directory &quot;./build/nodes&quot;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=Notary,L=London,C=GB&quot;</span><br><span class="line">        notary = [validating : true]</span><br><span class="line">        p2pPort 10002</span><br><span class="line">        rpcPort 10003</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=PartyA,L=London,C=GB&quot;</span><br><span class="line">        p2pPort 10005</span><br><span class="line">        rpcPort 10006</span><br><span class="line">        webPort 10007</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">        rpcUsers = [[ user: &quot;user1&quot;, &quot;password&quot;: &quot;test&quot;, &quot;permissions&quot;: [&quot;ALL]]]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=PartyB,L=New York,C=US&quot;</span><br><span class="line">        p2pPort 10008</span><br><span class="line">        rpcPort 10009</span><br><span class="line">        webPort 10010</span><br><span class="line">        sshdPort 10024</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">        rpcUsers = [[ user: &quot;user1&quot;, &quot;password&quot;: &quot;test&quot;, &quot;permissions&quot;: [&quot;ALL&quot;]]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用Gradle 来运行<code>deployNodes</code>任务。对于每个节点定义，Gradle将：</p>
<ul>
<li>将项目的源文件打包到一个CorDapp jar中</li>
<li><code>build/nodes</code>使用我们已安装的CorDapp创建一个新节点</li>
</ul>
<p>我们现在可以通过从项目的根目录运行以下命令来完成此操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean deployNodes</span><br></pre></td></tr></table></figure></p>
<h4 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a>运行节点</h4><p>运行<code>deployNodes</code>将构建<code>build/nodes</code>下的节点。如果我们导航到其中一个文件夹，我们将看到三个节点文件夹。每个节点文件夹具有以下结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|____corda.jar                     // The runnable node</span><br><span class="line">|____corda-webserver.jar           // The node&apos;s webserver</span><br><span class="line">|____node.conf                     // The node&apos;s configuration file</span><br><span class="line">|____cordapps</span><br><span class="line">|____java/kotlin-source-0.1.jar  // Our IOU CorDapp</span><br></pre></td></tr></table></figure></p>
<p>我们通过从项目的根目录运行以下命令来启动节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/nodes/runnodes</span><br></pre></td></tr></table></figure></p>
<h4 id="与节点交互"><a href="#与节点交互" class="headerlink" title="与节点交互"></a>与节点交互</h4><p>现在我们的节点正在运行，让我们命令其中一个通过开启我们的<code>IOUFlow</code>创建一个借条。在更大的应用程序中，我们通常会提供一个位于节点顶部的Web API。在这里，为了简单起见，我们将通过其内置的CRaSH shell与节点进行交互。</p>
<p>转到显示<code>PartyA</code>的CRaSH shell的终端窗口。键入<code>help</code>将显示可用命令的列表。</p>
<p>注意: 本地终端shell只能在开发模式下使用。在生产环境中，可以启用SSH服务器。有关SSH和如何连接的更多信息，请参阅<a href="https://docs.corda.net/head/shell.html" target="_blank" rel="noopener">Shell</a>页面。</p>
<p>我们想用PartyB创建一个99的欠条。我们开始<code>IOUFlow</code>输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin</span><br><span class="line">start IOUFlow iouValue: 99, otherParty: "O=PartyB,L=New York,C=US"</span><br><span class="line">// Java</span><br><span class="line">start IOUFlow arg0: 99, arg1: "O=PartyB,L=New York,C=US"</span><br></pre></td></tr></table></figure></p>
<p>这个单一命令将导致PartyA和PartyB自动同意一个借条。这是流程框架的一大优势 - 它允许您将复杂的协商和更新过程减少为单个函数调用。</p>
<p>如果这个流程奏效了，它应该在PartyA和PartyB的Vault里记录一条新的借条。让我们检查。</p>
<p>我们可以运行以下命令来检查每个节点的vault的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vaultQuery contractStateType: com.template.IOUState</span><br></pre></td></tr></table></figure></p>
<p>PartyA和PartyB的保险库都应显示以下输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">states:</span><br><span class="line">- state:</span><br><span class="line">    data:</span><br><span class="line">      value: 99</span><br><span class="line">      lender: "C=GB,L=London,O=PartyA"</span><br><span class="line">      borrower: "C=US,L=New York,O=PartyB"</span><br><span class="line">      participants:</span><br><span class="line">      - "C=GB,L=London,O=PartyA"</span><br><span class="line">      - "C=US,L=New York,O=PartyB"</span><br><span class="line">    contract: "com.template.contract.IOUContract"</span><br><span class="line">    notary: "C=GB,L=London,O=Notary"</span><br><span class="line">    encumbrance: null</span><br><span class="line">    constraint:</span><br><span class="line">      attachmentId: "F578320232CAB87BB1E919F3E5DB9D81B7346F9D7EA6D9155DC0F7BA8E472552"</span><br><span class="line">  ref:</span><br><span class="line">    txhash: "5CED068E790A347B0DD1C6BB5B2B463406807F95E080037208627565E6A2103B"</span><br><span class="line">    index: 0</span><br><span class="line">statesMetadata:</span><br><span class="line">- ref:</span><br><span class="line">    txhash: "5CED068E790A347B0DD1C6BB5B2B463406807F95E080037208627565E6A2103B"</span><br><span class="line">    index: 0</span><br><span class="line">  contractStateClassName: "com.template.state.IOUState"</span><br><span class="line">  recordedTime: 1506415268.875000000</span><br><span class="line">  consumedTime: null</span><br><span class="line">  status: "UNCONSUMED"</span><br><span class="line">  notary: "C=GB,L=London,O=Notary"</span><br><span class="line">  lockId: null</span><br><span class="line">  lockUpdateTime: 1506415269.548000000</span><br><span class="line">totalStatesAvailable: -1</span><br><span class="line">stateTypes: "UNCONSUMED"</span><br><span class="line">otherResults: []</span><br></pre></td></tr></table></figure></p>
<p>这是发放IOUState到分类帐上的交易。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>我们已经编写了一个简单的CorDapp，允许将欠款发放到账本上。我们的CorDapp由两个关键部分组成：</p>
<ul>
<li>IOUState在账本上代表欠条</li>
<li>IOUFlow，编排商定分类帐一张欠条的创作过程</li>
</ul>
<p>完成本教程后，您的CorDapp应该如下所示：</p>
<ul>
<li>Java：<a href="https://github.com/corda/corda-tut1-solution-java" target="_blank" rel="noopener">https://github.com/corda/corda-tut1-solution-java</a></li>
<li>Kotlin：<a href="https://github.com/corda/corda-tut1-solution-kotlin" target="_blank" rel="noopener">https://github.com/corda/corda-tut1-solution-kotlin</a></li>
</ul>
<h4 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h4><p>我们可以对这个CorDapp进行一些改进：</p>
<ul>
<li>我们应该使用合同测试和流程测试框架添加单元测试</li>
<li>我们应该IOUState.value从一个整数变为适当的一种货币</li>
<li>我们可以添加一个API，以便与CorDapp进行交互</li>
</ul>
<p>但现在，最大的优先事项是<code>IOUContract</code>在每个<code>IOUState</code>时间段的演变中增加强加的限制 。这将是我们下一篇教程的重点。</p>
<h2 id="Hello-World-V2-合约约束"><a href="#Hello-World-V2-合约约束" class="headerlink" title="Hello World V2 - 合约约束"></a>Hello World V2 - 合约约束</h2><p>注意： 本教程扩展了上一篇的Hello，World教程中构建的CorDapp 。</p>
<p>在Hello，World教程中，我们构建了一个CorDapp，允许我们在账本上对IOU进行建模。我们的CorDapp由两个元素组成：</p>
<ul>
<li><code>IOUState</code>在账本上代表欠条</li>
<li><code>IOUFlow</code>，编排商定分类帐一张欠条的创作过程</li>
</ul>
<p>然而，我们的CorDapp并未对随着时间的推移对账簿上的借条发展施加任何限制。任何人都可以自由地在任何一方之间创造任何价值的欠条。</p>
<p>在本教程中，我们将编写一份合约，对IOUState可能随时间变化的规则制定规则。反过来，这将需要对前一教程中定义的流程进行一些小的更改。</p>
<h3 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h3><p>很容易想象大多数CorDapps会想要对它们的状态随着时间的推移施加一些限制：</p>
<ul>
<li>现金类的CorDapp不会希望允许用户无限制地创建生成资金的交易（至少在没有中央银行或商业银行参与的情况下）</li>
<li>贷款类的CorDapp可能不希望允许创建负值贷款</li>
<li>资产交易的CorDapp不会允许用户在没有交易对手同意的情况下完成交易</li>
</ul>
<p>在Corda，我们对各状态如何使用合约进行限制。</p>
<p>注意：Corda的合约与其他分布式账本平台的智能合约有很大不同。它们不是表示当前世界状态的有状态对象。相反，像真实世界的合约一样，他们只是对允许的交易类型施加规则。</p>
<p>每个状态都有相关的合约。如果交易不符合交易中每个输入和输出状态的合约，则交易无效。</p>
<h3 id="合约接口"><a href="#合约接口" class="headerlink" title="合约接口"></a>合约接口</h3><p>就像每个Corda状态必须实现<code>ContractState</code>接口一样，每个合约都必须实现 <code>Contract</code>接口：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implements the contract constraints in code.</span></span><br><span class="line">    <span class="meta">@Throws(IllegalArgumentException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，Contract它通过一个verify将交易作为输入的函数来表达它的约束，并且：</p>
<ul>
<li>抛出一个，IllegalArgumentException如果它拒绝交易提议</li>
<li>如果它接受交易提议，则无提示返回</li>
</ul>
<h4 id="控制IOU演变"><a href="#控制IOU演变" class="headerlink" title="控制IOU演变"></a>控制IOU演变</h4><p><code>IOUState</code>一个好的合约会是什么样子？没有正确或错误的答案 - 这取决于你希望你的CorDapp如何表现。</p>
<p>对于我们的CorDapp，让我们强加一下我们只想允许创建IOU的限制。我们不希望节点转让它们或将它们兑换为现金。强制执行此行为的一种方法是强加以下限制：</p>
<ul>
<li>涉及IOU的交易必须消耗零输入，并创建一个类型<code>IOUState</code>的输出 </li>
<li>交易还应该包括一个<code>Create</code>命令，表明交易的意图（更多的命令很快）</li>
</ul>
<p>我们可能还想对发布<code>IOUState</code>的属性施加一些限制：</p>
<ul>
<li>其价值必须是非负的</li>
<li>贷款人和借款人不能是同一个实体</li>
</ul>
<p>最后，我们要强制限制谁需要签署交易：</p>
<ul>
<li>借条的放款人必须签字</li>
<li>借条的借款人必须签字</li>
</ul>
<p>我们可以将这一交易描述如下：<br><img src="https://docs.corda.net/head/_images/simple-tutorial-transaction-2.png" alt=""></p>
<h4 id="定义IOUContract"><a href="#定义IOUContract" class="headerlink" title="定义IOUContract"></a>定义IOUContract</h4><p>我们来写一个强制执行这些约束的合约。我们将通过修改<code>TemplateContract.java</code>或 <code>StatesAndContracts.kt</code>更新<code>TemplateContract</code>来定义一个<code>IOUContract</code>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace IOUContract's contract ID and definition with:</span></span><br><span class="line">const <span class="keyword">val</span> IOU_CONTRACT_ID = <span class="string">"com.template.IOUContract"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUContract</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    <span class="comment">// Our Create command.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Create</span> : <span class="type">CommandData</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> command = tx.commands.requireSingleCommand&lt;Create&gt;()</span><br><span class="line"></span><br><span class="line">        requireThat &#123;</span><br><span class="line">            <span class="comment">// Constraints on the shape of the transaction.</span></span><br><span class="line">            <span class="string">"No inputs should be consumed when issuing an IOU."</span> using (tx.inputs.isEmpty())</span><br><span class="line">            <span class="string">"There should be one output state of type IOUState."</span> using (tx.outputs.size == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IOU-specific constraints.</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">out</span> = tx.outputsOfType&lt;IOUState&gt;().single()</span><br><span class="line">            <span class="string">"The IOU's value must be non-negative."</span> using (<span class="keyword">out</span>.value &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="string">"The lender and the borrower cannot be the same entity."</span> using (<span class="keyword">out</span>.lender != <span class="keyword">out</span>.borrower)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Constraints on the signers.</span></span><br><span class="line">            <span class="string">"There must be two signers."</span> using (command.signers.toSet().size == <span class="number">2</span>)</span><br><span class="line">            <span class="string">"The borrower and lender must be signers."</span> using (command.signers.containsAll(listOf(</span><br><span class="line">                    <span class="keyword">out</span>.borrower.owningKey, <span class="keyword">out</span>.lender.owningKey)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用Java，你还需要重命名<code>TemplateContract.java</code>为<code>IOUContract.java</code>。</p>
<h4 id="Create命令"><a href="#Create命令" class="headerlink" title="Create命令"></a>Create命令</h4><p>我们添加到合同中的第一件事是一个命令。命令有两个功能：</p>
<ul>
<li>它们表明交易的意图，使我们能够对不同类型的交易进行不同的验证。例如，建议设立借条的交易可能必须满足兑换欠条的不同约束</li>
<li>它们允许我们为交易定义所需的签名者。例如，IOU的创建可能只需要贷方的签名，而IOU的转移可能需要IOU的借款人和贷方的签名</li>
</ul>
<p>我们的合约有一个命令，一个<code>Create</code>命令。<b style="color:red">所有命令都必须实现该<code>CommandData</code>接口。</b></p>
<p>该<code>CommandData</code>接口是命令的简单标记接口。实际上，它的声明只有两个单词（Kotlin接口不需要body）：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CommandData</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="验证逻辑"><a href="#验证逻辑" class="headerlink" title="验证逻辑"></a>验证逻辑</h4><p>我们的合约还需要通过实现<code>verify</code>来定义实际的合同约束。我们写这个verify函数的目标 是编写一个函数，给定一个交易：</p>
<ul>
<li>如果交易被认为是无效的，则抛出异常<code>IllegalArgumentException</code></li>
<li>如果该交易被认为是有效就不要抛出一个异常</li>
</ul>
<p>在决定交易是否有效时，该<code>verify</code>方法只能访问交易的内容：</p>
<ul>
<li><code>tx.inputs</code>，其中列出了输入</li>
<li><code>tx.outputs</code>，其中列出了输出</li>
<li><code>tx.commands</code>，其中列出了命令及其相关的签名者</li>
</ul>
<p>以及交易的附件和时间窗口，我们不会在这里使用。</p>
<p>基于上面列举的约束条件，<code>verify</code>如果满足以下任一条件，我们需要编写一个拒绝交易的函数：</p>
<ul>
<li><b style="color:red">该交易不包含<code>Create</code>命令</b></li>
<li>交易有输入</li>
<li>交易没有确切的一个输出</li>
<li>借据本身是无效的</li>
<li>交易不需要贷方的签名</li>
</ul>
<h4 id="命令约束"><a href="#命令约束" class="headerlink" title="命令约束"></a>命令约束</h4><p>我们的第一个约束是围绕交易的命令。我们使用Corda的<code>requireSingleCommand</code>功能来测试单个<code>Create</code>命令的存在。</p>
<p>如果该<code>Create</code>命令不存在，或者该交易有多个<code>Create</code>命令，则将抛出异常并且合同验证将失败。</p>
<h4 id="交易限制"><a href="#交易限制" class="headerlink" title="交易限制"></a>交易限制</h4><p>我们还希望我们的交易没有输入，只有单一输出 - 发行交易。</p>
<p>为了施加这个以及随后的限制，我们使用了<code>Corda</code>的内置<code>requireThat</code>模块。<code>requireThat</code>提供了一种简洁的方式来编写以下内容：</p>
<ul>
<li>如果右侧的条件不计算为真…</li>
<li>… IllegalArgumentException在左侧抛出消息</li>
</ul>
<p>像以前一样，抛出此异常的行为会导致交易被视为无效。</p>
<h4 id="借条限制"><a href="#借条限制" class="headerlink" title="借条限制"></a>借条限制</h4><p>我们想要对其IOUState本身施加两个约束：</p>
<ul>
<li>其价值必须是非负的</li>
<li>贷款人和借款人不能是同一个实体</li>
</ul>
<p>我们将这些约束与以前一样强加在同一个<code>requireThat</code>块中。</p>
<p>你可以看到，我们不仅限于在<code>requireThat</code>块中编写约束。我们也可以编写其他语句 - 在这种情况下，提取交易的单个<code>IOUState</code>元素并将其分配给一个变量。</p>
<h4 id="签名者约束"><a href="#签名者约束" class="headerlink" title="签名者约束"></a>签名者约束</h4><p>最后，我们要求贷款人和借款人都是交易中必需的签名人。交易所需的签名者等于命令中列出的所有签名者的联合。因此，我们从<code>Create</code>早先检索的命令中提取签名者。</p>
<p>这是一个绝对必要的约束 - 它确保在没有<code>IOUState</code>贷方和借方节点的明确同意的情况下在账本上不能创建账户。</p>
<h4 id="目前取得进展"><a href="#目前取得进展" class="headerlink" title="目前取得进展"></a>目前取得进展</h4><p>我们现在已经写了一个<code>IOUContract</code>限制每个<code>IOUState</code>时间的演变：</p>
<ul>
<li>一个<code>IOUState</code>只能被创建，不转移或赎回</li>
<li>创建一个<code>IOUState</code>无需输入，一个<code>IOUState</code>输出和一个 <code>Create</code>命令的发布事务</li>
<li>将<code>IOUState</code>通过发行交易创建必须有一个非负值，贷款人与借款人必须是不同的实体</li>
</ul>
<p>接下来，我们将更新IOUFlow它，以便在发放IOUState到分类账时遵守这些合同约束。</p>
<h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>我们现在需要更新我们的流程来实现三件事情：</p>
<ul>
<li>验证我们构建的交易提案是否满足<code>IOUContract</code>约束条件</li>
<li>更新贷款方的流程以请求借款人的签名</li>
<li>为响应贷方签名请求的借款人创建一个响应流程</li>
</ul>
<p>我们将通过修改我们在前一教程中编写的流程来实现这一点。</p>
<h4 id="验证交易"><a href="#验证交易" class="headerlink" title="验证交易"></a>验证交易</h4><p>在<code>IOUFlow.java</code>或者<code>App.kt中</code>，将imports块更改为以下内容：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Suspendable</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.StateAndContract</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.CollectSignaturesFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.FinalityFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.FlowLogic</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.InitiatingFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.StartableByRPC</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker</span><br></pre></td></tr></table></figure></p>
<p>在从网络中检索公证人的身份之后，通过更改代码进行更新<code>IOUFlow.call</code>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We create a transaction builder.</span></span><br><span class="line"><span class="keyword">val</span> txBuilder = TransactionBuilder(notary = notary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We create the transaction components.</span></span><br><span class="line"><span class="keyword">val</span> outputState = IOUState(iouValue, ourIdentity, otherParty)</span><br><span class="line"><span class="keyword">val</span> outputContractAndState = StateAndContract(outputState, IOU_CONTRACT_ID)</span><br><span class="line"><span class="keyword">val</span> cmd = Command(IOUContract.Create(), listOf(ourIdentity.owningKey, otherParty.owningKey))</span><br><span class="line"></span><br><span class="line"><span class="comment">// We add the items to the builder.</span></span><br><span class="line">txBuilder.withItems(outputContractAndState, cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verifying the transaction.</span></span><br><span class="line">txBuilder.verify(serviceHub)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signing the transaction.</span></span><br><span class="line"><span class="keyword">val</span> signedTx = serviceHub.signInitialTransaction(txBuilder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a session with the other party.</span></span><br><span class="line"><span class="keyword">val</span> otherpartySession = initiateFlow(otherParty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtaining the counterparty's signature.</span></span><br><span class="line"><span class="keyword">val</span> fullySignedTx = subFlow(CollectSignaturesFlow(signedTx, listOf(otherpartySession), CollectSignaturesFlow.tracker()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finalising the transaction.</span></span><br><span class="line">subFlow(FinalityFlow(fullySignedTx))</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">在原始的CorDapp中，我们通过调用一个称为<code>FinalityFlow</code>子流程的内置流来自动化对交易进行公证处理并将其记录到每个参与者的库中</b>。我们将使用另一个预定义的流程<code>CollectSignaturesFlow</code>来收集借款人的签名。</p>
<p>首先，我们需要更新命令。我们现在正在使用<code>IOUContract.Create</code>，而不是 <code>TemplateContract.Commands.Action</code>。我们也希望根据合同约束将借款人变成必需的签名人。这与将借款人的公钥添加到交易的命令一样简单。</p>
<p>我们还需要使用对旧的<code>IOUContract</code>的引用将输出状态添加到交易中，而不是旧的<code>TemplateContract</code>。</p>
<p>现在我们的状态是由一个真实的合约来管理的，我们希望在开始签署过程之前检查我们的交易提案是否满足这些要求。我们通过调用<code>TransactionBuilder.verify</code>我们的交易建议来完成此工作，然后再添加我们的签名来完成。</p>
<h4 id="请求借款人的签名"><a href="#请求借款人的签名" class="headerlink" title="请求借款人的签名"></a>请求借款人的签名</h4><p>我们现在需要与借款人沟通，要求他们签署交易。无论何时您想在流程环境中与另一方进行交流，您首先需要与他们建立流程会话。如果交易对手已经注册<code>FlowLogic</code>以响应<code>FlowLogic</code>发起会话，则将建立会话。这两个<code>FlowLogic</code>实例之间的所有通信都将作为本次会话的一部分。</p>
<p>一旦我们与借款人建立会话，我们就会使用<code>CollectSignaturesFlow</code>收集借款人的签名，这需要：</p>
<ul>
<li>由流程发起人签署的交易</li>
<li>流程发起人与所需签署人之间的流程会话列表</li>
</ul>
<p>并返回由所有必填签名者签署的交易。</p>
<p>然后，我们可以将这个完全签署的交易传递给<code>FinalityFlow</code>。</p>
<h4 id="创建借款人的流程"><a href="#创建借款人的流程" class="headerlink" title="创建借款人的流程"></a>创建借款人的流程</h4><p>在出借方方面，我们使用的<code>CollectSignaturesFlow</code>自动收集签名。为了让贷款人作出回应，我们还需要编写一个回应流程。在Java中的<code>IOUFlowResponder.java</code>新文件或Kotlin中的<code>App.kt</code>文件中，添加以下类：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.requireThat</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.SignedTransaction</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define IOUFlowResponder:</span></span><br><span class="line"><span class="meta">@InitiatedBy(IOUFlow::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUFlowResponder</span></span>(<span class="keyword">val</span> otherPartySession: FlowSession) : FlowLogic&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> signTransactionFlow = <span class="keyword">object</span> : SignTransactionFlow(otherPartySession, SignTransactionFlow.tracker()) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkTransaction</span><span class="params">(stx: <span class="type">SignedTransaction</span>)</span></span> = requireThat &#123;</span><br><span class="line">                <span class="keyword">val</span> output = stx.tx.outputs.single().<span class="keyword">data</span></span><br><span class="line">                <span class="string">"This must be an IOU transaction."</span> using (output <span class="keyword">is</span> IOUState)</span><br><span class="line">                <span class="keyword">val</span> iou = output <span class="keyword">as</span> IOUState</span><br><span class="line">                <span class="string">"The IOU's value can't be too high."</span> using (iou.value &lt; <span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subFlow(signTransactionFlow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>IOUFlow</code>一样，我们的<code>IOUFlowResponder</code>流程是一个<code>FlowLogic</code>子类, 重写了<code>FlowLogic.call</code>。</p>
<p>该流程使用<code>InitiatedBy</code>(<code>IOUFlow.class</code>)注解，这意味着您的节点将在从<code>Initiator</code>另一个节点上运行的实例接收到消息时调用<code>IOUFlowResponder.call</code> 。<code>IOUFlow</code>的这条消息会是什么？如果我们看一下<code>CollectSignaturesFlow</code>定义，我们可以看到我们将被发送一个<code>SignedTransaction</code>，并且预计将通过该交易发回我们的签名。</p>
<p>我们可以编写自己的流程来处理这个过程。但是，也有一个预定义的流程<code>SignTransactionFlow</code>可以自动处理流程。唯一的问题是<code>SignTransactionFlow</code>是一个抽象类 - 我们必须继承它并重写<code>SignTransactionFlow.checkTransaction</code>。</p>
<h4 id="CheckTransactions"><a href="#CheckTransactions" class="headerlink" title="CheckTransactions"></a>CheckTransactions</h4><p><code>SignTransactionFlow</code>将在签署之前自动验证交易及其签名。但是，仅仅因为交易在合同中有效并不意味着我们一定要签名。如果我们不想处理有问题的交易对手，或者价值太高，或者我们对交易结构不满意，该怎么办？</p>
<p>重写<code>SignTransactionFlow.checkTransaction</code>允许我们定义这些额外的检查。在我们的案例中，我们正在检查：</p>
<ul>
<li>交易涉及的<code>IOUState</code> - 确保<code>IOUContract</code>将运行以验证交易</li>
<li>借条的价值低于一定数额（在这种情况下为100）</li>
</ul>
<p>如果这些条件中的任何一个都不符合，我们将不签署交易 - 即使交易及其签名在合同中有效。</p>
<p>一旦我们定义了<code>SignTransactionFlow</code>子类，我们就会调用<code>FlowLogic.subFlow</code>，并且与借方和贷方的流程自动进行通信。</p>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>我们现在已经更新了流程，以验证交易并收集贷方签名，符合中定义的<code>IOUContract</code>约束条件。我们现在可以使用与之前相同的说明重新运行我们更新的CorDapp 。</p>
<p>我们的CorDapp现在对发行IOU进行限制。最重要的是，借款发行现在需要借款人和借款人达成协议，然后才能在账本上创建借条。这样可以防止贷款人或借款人以一种只有利于自己的方式单方面更新分类账。</p>
<p>完成本教程后，您的CorDapp应该如下所示：</p>
<ul>
<li>Java：<a href="https://github.com/corda/corda-tut2-solution-java" target="_blank" rel="noopener">https://github.com/corda/corda-tut2-solution-java</a></li>
<li>Kotlin：<a href="https://github.com/corda/corda-tut2-solution-kotlin" target="_blank" rel="noopener">https://github.com/corda/corda-tut2-solution-kotlin</a></li>
</ul>
<p>你现在应该准备开发你自己的CorDapps。您也可以在这里找到样品CorDapps的列表 。在编写CorDapps时，您还需要了解有关Corda API的更多信息 。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://docs.corda.net/head/hello-world-introduction.html" target="_blank" rel="noopener">Hello, World!</a><br><a href="https://docs.corda.net/head/tut-two-party-introduction.html" target="_blank" rel="noopener">Hello, World! Pt.2 - Contract constraints</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/blockchain/corda/Corda-networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/blockchain/corda/Corda-networks/" itemprop="url">Corda networks</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T15:47:02+08:00">2018-06-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="设置Corda网络"><a href="#设置Corda网络" class="headerlink" title="设置Corda网络"></a>设置Corda网络</h2><p>Corda网络由多台运行节点的机器组成。这些节点使用持久协议进行通信，以创建和验证交易。</p>
<p>这种节点可能具有三种更广泛的功能类别。这些功能块是作为服务提供的，一个节点可以运行其中几个。</p>
<ul>
<li>公证人：运行公证服务见证人状态的节点花费并最终决定交易是否是双重花费</li>
<li>Oracle：通过提供影响交易有效性的事实将账本与外部世界链接起来的网络服务</li>
<li>常规节点：所有节点都有一个Vault，并且可能开始与其他节点，公证人和神谕（Oracle）进行通信的协议，并发展他们的私人分类账</li>
</ul>
<h3 id="建立你自己的网络"><a href="#建立你自己的网络" class="headerlink" title="建立你自己的网络"></a>建立你自己的网络</h3><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>给定Corda网络中的每个节点都必须具有由网络根CA签署的身份证书。有关更多信息，请参阅<a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>节点可以通过在节点的目录中添加/编辑<code>node.conf</code>进行配置。有关详情请参阅<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>。</p>
<p>一个示例配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">dataSourceProperties : &#123;</span><br><span class="line">    dataSourceClassName : org.h2.jdbcx.JdbcDataSource</span><br><span class="line">    &quot;dataSource.url&quot; : &quot;jdbc:h2:file:&quot;$&#123;baseDirectory&#125;&quot;/persistence&quot;</span><br><span class="line">    &quot;dataSource.user&quot; : sa</span><br><span class="line">    &quot;dataSource.password&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:10004&quot;</span><br><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user1, password=letmein, permissions=[ StartFlow.net.corda.protocols.CashProtocol ] &#125;</span><br><span class="line">]</span><br><span class="line">devMode : true</span><br></pre></td></tr></table></figure></p>
<p>有关网络配置的最重要的配置是：</p>
<ul>
<li><code>p2pAddress</code>：这指定了Artemis将与其他节点进行消息传递绑定的主机和端口。需要注意的是绑定的地址将不是<code>my-corda-node</code>，而是<code>::</code>（所有网络接口上的所有地址）。指定的主机名是必须由网络中的其他节点在外部解析的主机名。在上述配置中，这是VPN中机器的可解析名称。</li>
<li><code>rpcAddress</code>：Artemis将为RPC调用绑定的地址。</li>
<li><code>webAddress</code>：网络服务器应该绑定的地址。需要注意的是端口必须是来自截然不同p2pAddress并且rpcAddress如果他们是在同一台机器上。</li>
</ul>
<h4 id="引导网络"><a href="#引导网络" class="headerlink" title="引导网络"></a>引导网络</h4><p>节点使用网络图互相看到。这是一个静态签名的节点信息文件的集合，每个节点在网络中都有一个文件。大多数生产部署将通过HTTP使用高度可用，安全的网络映射分布。</p>
<p>对于节点（至少最初）驻留在同一个文件系统中的测试部署，可以将这些节点信息文件直接放置在节点的<code>additional-node-infos</code>目录中，节点将从该目录中选择并将它们存储在本地网络映射缓存中。节点在启动时生成自己的节点信息文件。</p>
<p>除了网络映射之外，网络中的所有节点都必须使用相同的一组网络参数。这些是一组保证节点间互操作性的常量。HTTP网络图分发节点自动下载的网络参数。在没有这个的情况下，网络参数必须在本地生成。这可以通过网络引导程序完成。这是一个工具，用于扫描公共目录中的所有节点配置，以生成复制到节点目录的网络参数文件。它还将每个节点的节点信息文件复制到每个其他节点，以便它们可以互相交换。</p>
<p>引导程序工具可以从<a href="http://downloads.corda.net/network-bootstrapper-corda-X.Y.jar" target="_blank" rel="noopener">http://downloads.corda.net/network-bootstrapper-corda-X.Y.jar</a> 下载，其中<code>X</code>是主要的Corda版本，并且<code>Y</code>是次要的Corda版本。</p>
<p>要使用它，请为要创建的每个节点创建一个包含<code>node.conf</code>文件的目录。然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar network-bootstrapper.jar &lt;nodes-root-dir&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如，在包含这些文件的目录上运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├──notary.conf //公证人的node.conf文件</span><br><span class="line">├──partya.conf // Party A的node.conf文件</span><br><span class="line">└──partyb.conf //乙方的node.conf文件</span><br></pre></td></tr></table></figure></p>
<p>会生成包含三个节点的目录：公证人，partya和partyb。</p>
<p>该工具仅引导网络。如果新节点需要加入网络，或者现有节点已经改变节点信息中的某些内容，例如P2P地址，它就不能动态更新。为此，新的节点信息文件将需要放置在其他节点的<code>additional-node-infos</code>目录中。一个简单的方法是使用rsync。但是，如果事先知道节点集合，最终节点文件夹可以在引导程序中预生成并且只在需要时启动。</p>
<h4 id="白名单合同"><a href="#白名单合同" class="headerlink" title="白名单合同"></a>白名单合同</h4><p>如果您想创建区域白名单（请参阅<a href="https://docs.corda.net/releases/release-V3.1/setting-up-a-corda-network.html" target="_blank" rel="noopener">API：合同约束</a>），则可以传入CorDapp jar列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar network-bootstrapper.jar &lt;nodes-root-dir&gt; &lt;path-to-first-corDapp&gt; &lt;path-to-second-corDapp&gt; ..</span><br></pre></td></tr></table></figure></p>
<p>CorDapp jars将被散列并扫描Contract类。默认情况下，该工具将生成一个名为<code>whitelist.txt</code>包含每个包含该jar散列项的合约的条目的文件。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.corda.finance.contracts.asset.Obligation：decd098666b9657314870e192ced0c3519c2c9d395507a238338f8d003929de8</span><br><span class="line">net.corda.finance.contracts.asset.Cash:decd098666b9657314870e192ced0c3519c2c9d395507a238338f8d003929de9</span><br></pre></td></tr></table></figure></p>
<p>这些将被添加到<code>NetworkParameters.whitelistedContractImplementations</code>。请参阅<a href="https://docs.corda.net/releases/release-V3.1/network-map.html" target="_blank" rel="noopener">网络映射</a>。</p>
<p>这意味着默认情况下，网络引导程序工具会将所有通过的CorDapps中的所有合约列入白名单。</p>
<p>如果根目录中有一个文件<code>whitelist.txt</code>，工具会将新的jar散列或合约附加到它。</p>
<p>区域操作员将维护这个白名单文件，并使用该工具将新版本的CorDapps添加到它。</p>
<p>警告:</p>
<ul>
<li>区域操作员必须确保该文件仅被附加。</li>
<li>如果操作员从列表中删除哈希值，则指向该版本的所有交易将突然失败约束验证，并且整个链会受到影响。</li>
<li>如果合同从白名单中删除，那么从此时开始创建的所有状态将受到HashAttachmentConstraint约束。</li>
</ul>
<p>注意：在未来的版本中，我们将提供维护合约白名单的防篡改方式。</p>
<p>对于约束的细粒度控制，如果多个合约存在于同一个jar中，则该工具从另一个文件中读取： <code>exclude_whitelist.txt</code>，其中包含不应列入白名单的合约列表，因此默认为严格限制： <code>HashAttachmentConstraint</code></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.corda.finance.contracts.asset.Cash</span><br><span class="line">net.corda.finance.contracts.asset.CommercialPaper</span><br></pre></td></tr></table></figure></p>
<h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>您现在可以按任何顺序启动节点。您应该看到一条横幅，一些日志行，并最终显示该节点已完全启动。<code>Node started up and registered</code></p>
<p>在流程管理方面，没有规定的方法。您可以手动启动jars，也可以使用systemd。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>只有少数重要的线条打印在控制台上。有关详细信息/诊断问题，请检查日志。</p>
<p>日志记录是标准的log4j2，可以进行相应配置。日志默认被重定向到<code>NODE_DIRECTORY/logs/</code>中的文件。</p>
<h4 id="连接到节点"><a href="#连接到节点" class="headerlink" title="连接到节点"></a>连接到节点</h4><p>一旦节点启动成功，您可以连接到它作为客户端来启动协议/查询状态等。根据您的网络设置，您可能需要通过管道远程执行此操作。</p>
<p>请参阅<a href="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html" target="_blank" rel="noopener">使用客户端RPC API</a>了解如何建立RPC链接。</p>
<p>旁注：客户始终与具有单一身份的单个节点相关联，该身份只能看到其分类账的一部分。</p>
<h2 id="网络许可"><a href="#网络许可" class="headerlink" title="网络许可"></a>网络许可</h2><p>Corda网络获得许可。要连接到网络，节点需要在其<code>&lt;workspace&gt;/certificates/</code>文件夹中有三个密钥库 ：</p>
<ul>
<li><code>truststore.jks</code>，它存储可信的公钥和证书（在我们的例子中是网络根CA的证书）</li>
<li><code>nodekeystore.jks</code>，它存储节点的身份密钥对和证书</li>
<li><code>sslkeystore.jks</code>，它存储节点的TLS密钥对和证书</li>
</ul>
<p><b style="color:red">生产部署需要安全的证书颁发机构。大多数生产部署将使用现有的证书颁发机构或使用将在未来几个月内提供的软件构建一个。在此之前，以下文档可用于创建您自己的认证中心。</b></p>
<p>注意: 如果您正在查找有关如何连接到现有兼容区域的信息，请转至章节：<a href="https://docs.corda.net/releases/release-V3.1/permissioning.html#connecting-to-a-compatibility-zone" target="_blank" rel="noopener">连接到兼容区域</a></p>
<h3 id="证书层级"><a href="#证书层级" class="headerlink" title="证书层级"></a>证书层级</h3><p>Corda网络有四种类型的证书颁发机构（CA）：</p>
<ul>
<li>根CA网络</li>
<li><b style="color:red">门卫CA</b><ul>
<li><b style="color:red">使用门卫CA代替根网络CA进行日常密钥签名以降低根网络CA的私钥被泄露的风险</b></li>
</ul>
</li>
<li>节点自己的CA<ul>
<li>每个节点在发布用于签署其身份密钥和TLS证书的子证书时充当自己的CA.</li>
</ul>
</li>
<li>合法身份的CA<ul>
<li>除签署交易外，Node的着名合法身份也可以颁发机密合法身份证书</li>
</ul>
</li>
</ul>
<p>以下约束也是强制性的：</p>
<ul>
<li>门卫证书由网络根发出，证书不包含扩展名</li>
<li><b style="color:red">知名服务身份证书由具有门卫证书的实体颁发</b></li>
<li>节点CA证书由具有门卫证书的实体颁发</li>
<li>众所周知的合法身份/TLS证书由标记为节点CA的证书颁发</li>
<li>保密合法身份证书由标记为众所周知的合法身份的证书颁发</li>
<li>Party的证书被标记为知名身份或机密身份</li>
<li>高于门卫/网络map的证书结构有意保留，因为它们与身份服务无关，因此在这些证书上实施特定结构没有优势。证书层次结构一致性检查是必需的，因为节点可以颁发自己的证书，并可以在证书上设置自己的角色标志，验证这些证书是否与证书层次结构设计一致，这一点很重要。作为副作用，这也作为对颁发证书的二级深度限制.</li>
</ul>
<p>所有证书必须与自定义角色扩展一起发布（见下文）。</p>
<p>我们可以将权限结构可视化如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/certificate_structure.png" alt=""></p>
<h3 id="密钥对和证书格式"><a href="#密钥对和证书格式" class="headerlink" title="密钥对和证书格式"></a>密钥对和证书格式</h3><p>您可以使用任何标准关键工具或Corda<code>X509Utilities</code>（使用Bouncy Castle）来创建所需的公钥/私钥对和证书。密钥对和证书应遵守以下限制：</p>
<ul>
<li>证书必须遵循X.509标准<ul>
<li>我们推荐X.509 v3用于向前兼容</li>
</ul>
</li>
<li>TLS证书必须遵循TLS v1.2标准</li>
<li>根网络CA，门卫CA和节点CA密钥以及节点TLS密钥必须遵循以下方案之一：<ul>
<li>ECDSA使用NIST P-256曲线（secp256r1）</li>
<li>具有3072位密钥大小的RSA</li>
</ul>
</li>
</ul>
<h3 id="证书角色扩展"><a href="#证书角色扩展" class="headerlink" title="证书角色扩展"></a>证书角色扩展</h3><p>Corda证书具有自定义的X.509 v3扩展名，用于指定证书所涉及的角色。该扩展具有OID <code>1.3.6.1.4.1.50530.1.1</code>并且不重要，因此Corda节点之外的实现可以安全地忽略它。该扩展包含一个ASN.1整数，用于标识证书的身份类型：</p>
<ol>
<li>门卫 doorman</li>
<li>网络map （Network Map）</li>
<li>服务标识 Service identity（目前仅用作分布式公证中的共享标识）</li>
<li>节点证书颁发机构 Node certificate authority （从中发布TLS和知名身份证书）</li>
<li>传输层安全 Transport layer security</li>
<li>众所周知的合法身份 Well-known legal identity</li>
<li>保密的法律身份 Confidential legal identity</li>
</ol>
<p>在典型的安装中，节点管理员不需要知道这些。但是，当节点证书由外部工具（例如组织内部署的现有PKI解决方案）管理时，了解这些约束非常重要。</p>
<p>证书路径验证被扩展，以便证书必须包含扩展名（如果扩展名存在于发行者的证书中）。</p>
<h3 id="创建根和门卫CA"><a href="#创建根和门卫CA" class="headerlink" title="创建根和门卫CA"></a>创建根和门卫CA</h3><h4 id="创建根网络CA的密钥库（keyStore）和信任库（trustStore）"><a href="#创建根网络CA的密钥库（keyStore）和信任库（trustStore）" class="headerlink" title="创建根网络CA的密钥库（keyStore）和信任库（trustStore）"></a>创建根网络CA的密钥库（keyStore）和信任库（trustStore）</h4><ol>
<li>创建一个新的密钥对<ul>
<li>这将用作根网络CA的密钥对</li>
</ul>
</li>
<li>为密钥对创建一个自签名证书。基本约束扩展必须设置为true<ul>
<li>这将被用作根网络CA的证书</li>
</ul>
</li>
<li>创建一个新的密钥库，并将根网络CA的密钥对和证书存储在其中以供以后使用<ul>
<li>此根密钥库将被根网络CA用于签署门卫CA的证书</li>
</ul>
</li>
<li>使用别名<code>cordarootca</code>创建一个名为<code>truststore.jks</code>并存储根网络CA证书的新Java密钥库<ul>
<li>随后必须将该密钥库供应给各个节点，以便它们可以将其存储在其<code>certificates</code>文件夹中</li>
</ul>
</li>
</ol>
<p><b style="color:Red">警告: 根网络CA的私钥应该受到保护并保持安全。</b></p>
<h4 id="创建门卫CA的密钥库"><a href="#创建门卫CA的密钥库" class="headerlink" title="创建门卫CA的密钥库"></a>创建门卫CA的密钥库</h4><ol>
<li>创建一个新的密钥对<ul>
<li>这将被用作门卫CA的密钥对</li>
</ul>
</li>
<li>获取使用根网络CA密钥签名的密钥对的证书。基本约束扩展必须设置为true<ul>
<li>这将被用作门卫CA的证书</li>
</ul>
</li>
<li>创建一个新的密钥库，并将门卫CA的密钥对和证书链（即门卫CA证书和根网络CA证书）存储在其中以备后用<ul>
<li>这个密钥库将被门卫CA用来签署节点的身份证书</li>
</ul>
</li>
</ol>
<h3 id="创建节点CA密钥库和TLS密钥库"><a href="#创建节点CA密钥库和TLS密钥库" class="headerlink" title="创建节点CA密钥库和TLS密钥库"></a>创建节点CA密钥库和TLS密钥库</h3><h4 id="创建节点CA密钥库"><a href="#创建节点CA密钥库" class="headerlink" title="创建节点CA密钥库"></a>创建节点CA密钥库</h4><ol>
<li>对于每个节点，创建一个新的密钥对</li>
<li>获取使用门卫CA密钥签名的密钥对的证书。基本约束扩展必须设置为true</li>
<li>使用别名<code>cordaclientca</code>创建一个名为<code>nodekeystore.jks</code>并存储密钥对的新Java密钥库<ul>
<li>节点将在本地存储此密钥库以签署其身份密钥和匿名密钥</li>
</ul>
</li>
</ol>
<h4 id="创建节点TLS密钥库"><a href="#创建节点TLS密钥库" class="headerlink" title="创建节点TLS密钥库"></a>创建节点TLS密钥库</h4><ol>
<li>对于每个节点，创建一个新的密钥对</li>
<li>为使用节点CA密钥签名的密钥对创建证书。基本约束扩展必须设置为 false</li>
<li>使用别名<code>cordaclienttls</code>创建一个名为<code>sslkeystore.jks</code>并存储密钥和证书的新Java密钥库<ul>
<li>节点将在本地存储此密钥库以签署其TLS证书</li>
</ul>
</li>
</ol>
<h3 id="在节点上安装证书"><a href="#在节点上安装证书" class="headerlink" title="在节点上安装证书"></a>在节点上安装证书</h3><p>对于每个节点，将以下文件复制到节点的证书目录（<code>&lt;workspace&gt;/certificates/</code>）中：</p>
<ol>
<li>节点的nodekeystore.jks密钥库</li>
<li>节点的sslkeystore.jks密钥库</li>
<li>根网络CA的truststore.jks密钥库</li>
</ol>
<h3 id="连接到兼容区域"><a href="#连接到兼容区域" class="headerlink" title="连接到兼容区域"></a>连接到兼容区域</h3><p><b style="color:red">要连接到兼容区域，您需要提交证书签名请求（CSR）以获取该区域的有效标识，从而向其证书签名授权（门卫）注册。</b></p>
<p>在您注册之前，您必须首先收到包含来自区域操作员的根证书的信任存储文件。然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar --initial-registration --network-root-truststore-password &lt;trust store password&gt;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，它会期望信任存储文件位于该位置<code>certificates/network-root-truststore.jks</code>。这可以用附加<code>--network-root-truststore</code>标志覆盖。</p>
<p>将根据从节点配置中获取的节点信息创建证书签名请求。生成请求需要来自节点配置文件的以下信息。</p>
<ul>
<li>myLegalName：    您公司的法定名称为X.500字符串。X.500允许区分具有相同名称的实体，因为合法名称在网络上必须是唯一的。如果另一个节点已经被许可使用该名称，则许可服务器将自动拒绝该请求。如果违反合法名称规则，请求也将被拒绝，请参阅<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html#node-naming" target="_blank" rel="noopener">节点命名</a>以获取更多信息。</li>
<li>电子邮件地址：    例如“<a href="mailto:admin@company.com" target="_blank" rel="noopener">admin@company.com</a>“</li>
<li>DEVMODE：    必须设置为false</li>
<li>compatibilityZoneURL：<br>Corda兼容区域网络管理服务根URL。<br>由Corda节点生成的一对新的私钥和公钥将用于创建请求。<br>该实用程序将向门卫服务器提交请求并定期轮询结果以检索证书。一旦请求被批准并且从服务器下载证书，节点将使用证书和生成的私钥创建密钥库和信任库。</li>
</ul>
<p>注意: 如果批准过程花费的时间比预期的长，您可以随时退出。请求过程将在重新启动时恢复。</p>
<p>只有在节点首次连接到网络或证书过期时，才需要此过程。</p>
<h2 id="Network-Map"><a href="#Network-Map" class="headerlink" title="Network Map"></a>Network Map</h2><p>网络map是已签名的NodeInfo对象的集合。每个NodeInfo都由其节点签名代表，因此不能被篡改。它在兼容区域中形成一组可达节点。节点可以从两个来源接收这些对象：</p>
<ul>
<li>一个讲述简单的基于HTTP的协议的网络映射服务器。</li>
<li>节点的目录中的<code>additional-node-infos</code>目录。</li>
</ul>
<p>网络映射服务器还分配参数文件，该参数文件为所有节点需要同意保持同步的各种设置定义值。</p>
<p>注意:在Corda 3中没有提供HTTP网络映射服务器的实现。这是因为兼容性区域管理其成员资格（数据库，票务工作流程，HSM硬件等）的细节预计会因运营商而异，所以我们提供了一个简单的基于REST的协议，用于上载/下载NodeInfos并管理网络参数。未来版本的Corda可能会为运行测试区提供一个简单的“存根”实现。在Corda 3中，运行测试网络的正确方法是通过您自己的机制分发相关文件。我们提供了一个工具来自动完成这项任务的大部分（见下文）。</p>
<h3 id="HTTP网络map协议"><a href="#HTTP网络map协议" class="headerlink" title="HTTP网络map协议"></a>HTTP网络map协议</h3><p>如果节点配置了<code>compatibilityZoneURL</code>配置，那么它首先将其自己的签名上传<code>NodeInfo</code> 到服务器（<b style="color:Red">并且每次启动时都会更改</b>），然后继续下载整个网络map。网络map由一个<code>NodeInfo</code>哈希列表组成。节点定期轮询网络映射（基于HTTP缓存有效头），并且下载和缓存任何新条目。不再存在的条目将从节点的缓存中删除。</p>
<p>网络地图服务的一组REST端点如下。</p>
<table>
<thead>
<tr>
<th style="text-align:center">请求方法</th>
<th style="text-align:center">路径</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">/network-map/publish</td>
<td style="text-align:center">让节点将其签名NodeInfo对象上传到网络地图。</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">/network-map/ack-parameters</td>
<td style="text-align:center">为了节点操作员确认网络图，新参数被接受以供将来更新。</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">/network-map</td>
<td style="text-align:center">检索当前签名的网络地图对象。整个对象用附加的网络映射证书进行签名。</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">/network-map/node-info/{hash}</td>
<td style="text-align:center">检索NodeInfo网络地图对象中指定的签名。</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">/network-map/network-parameters/{hash}</td>
<td style="text-align:center">检索签名的网络参数（见下文）。整个对象用附加的网络映射证书进行签名。</td>
</tr>
</tbody>
</table>
<p>HTTP用于网络map服务，而不是Corda自己的基于AMQP的对等消息传递协议，以便将服务器置于缓存内容交付网络后面，如Cloudflare，Akamai，Amazon Cloudfront等。通过使用工业HTTP缓存网络，map服务器可以更有效地屏蔽DoS攻击。另外，对于分发很少变化的小文件的情况，HTTP是一个很好理解和优化的协议。Corda自己的协议设计用于使用签名的二进制消息分离为并行和嵌套流的身份验证身份之间的复杂多方会话，这对于网络映射分发不是必需的。</p>
<h3 id="additional-node-infos目录"><a href="#additional-node-infos目录" class="headerlink" title="additional-node-infos目录"></a><code>additional-node-infos</code>目录</h3><p>除了HTTP网络map服务外，或者如果节点没有连接到一个节点，节点将轮询位于其基本目录中的<code>additional-node-infos</code>目录的内容。预计每个文件都是网络地图服务发布的相同签名<code>NodeInfo</code>对象。这些会自动添加到节点的缓存中，并可用于补充或替换HTTP网络图。如果同一节点通过这两种机制进行广告，则采用最新的节点。</p>
<p>启动时，节点会生成自己的签名节点信息文件，格式的文件名nodeInfo-${hash}。它也可以使用–just-generate-node-info命令行标志生成而不需要启动节点。要创建一个没有HTTP网络映射服务的简单网络，只需将该文件放置在该网络中每个节点的<code>additional-node-infos</code>目录中即可。例如，一个简单的方法是使用rsync。</p>
<p>通常，测试网络具有提前知晓的结构。为了创建这样的网络，我们提供了一个 <code>network-bootstrapper</code>工具。如果给定网络中每台机器的IP地址/域名，此工具会预先生成节点配置目录。生成的节点目录包含网络中每个其他节点的NodeInfos以及网络参数文件和身份证书。生成的节点不需要一次全部在线 - 一个未与之交互的离线节点不会以任何方式影响网络。因此，像这样生成的测试集群可以按照您可能需要的最大大小来确定大小，然后根据需要进行放大和缩小。</p>
<p>更多信息可以在<a href="https://docs.corda.net/releases/release-V3.1/setting-up-a-corda-network.html" target="_blank" rel="noopener">设置Corda网络</a>中找到。</p>
<h3 id="网络参数"><a href="#网络参数" class="headerlink" title="网络参数"></a>网络参数</h3><p>网络参数是一组值，参与该区域的每个节点需要达成一致并用于正确互操作。它们可以被认为是Corda部署的各个方面的封装，理性人可能会不同意。虽然其他区块链/DLT系统通常需要源代码fork以改变各种常量（如加密货币中的硬币总数，使用的端口号等），但在Corda中，我们将这些决策重构为单独的文件，并允许“区域运营商”对其进行决策。操作员签署一个包含这些值的数据结构，并将它们与网络map一起分发。提供工具以获得用户选择同意新版本参数的权限，并确保每个人同时切换到它们。</p>
<p>如果节点正在使用HTTP网络map服务，那么在首次启动时，它将下载已签名的网络参数，将其缓存在<code>network-parameters</code>文件中并将其应用到节点上。</p>
<p>警告: 如果<code>network-parameters</code>文件发生更改并且不再与网络map服务所发布的内容相匹配，则该节点将自动关闭。解决方法是删除不正确的文件并重新启动节点，以便可以再次下载参数。</p>
<p>如果节点没有使用HTTP网络map服务，那么预计签名文件是通过其他方式提供的。对于这种情况，网络引导程序工具除了生成网络参数文件之外，还会将节点信息文件分发到节点目录。</p>
<p>当前的一组网络参数：</p>
<ul>
<li>minimumPlatformVersion：节点必须运行的最低平台版本。低于此值的任何节点都不会启动。</li>
<li>notaries：    在兼容区域中允许的公证人的身份和验证类型（验证或不验证）的列表。</li>
<li>maxMessageSize：    （目前这被忽略，但它将在未来的版本中发布。）</li>
<li>maxTransactionSize：交易的最大允许字节数。这是交易对象及其附件的大小。</li>
<li>modifiedTime：    网络参数上次由兼容性区域运算符修改的时间。</li>
<li>epoch：    网络参数的版本号。从1开始，只要有任何参数改变，它就会一直增加。</li>
<li>whitelistedContractImplementations：合同代码的白名单版本列表。对于每个合同类，都有包含该合同的已批准CorDapp jar版本的散列列表。点击此处了解更多关于区域限制的信息<a href="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html" target="_blank" rel="noopener">API：合同限制</a></li>
</ul>
<p>更多参数将在未来版本中添加，以管理诸如允许的端口号，节点在从区域被逐出之前可以离线多久，区域成员是否需要IPv6连接，所需的加密算法和部署时间表（例如用于后期量子密码学），与SGX有关的参数等等。</p>
<h3 id="网络参数更新过程"><a href="#网络参数更新过程" class="headerlink" title="网络参数更新过程"></a>网络参数更新过程</h3><p>如果需要更改网络参数，Corda区域操作员将开始更新过程。有很多原因可能导致这一决定：例如，添加公证人，设置添加的新字段以实现平滑的网络互操作性，或者需要更改现有的兼容性常量。</p>
<p>注意: 未来版本可能支持分阶段推出网络参数更改的概念。</p>
<p>要同步兼容区域中的所有节点以使用新的一组网络参数，将提供两种RPC方法。该流程需要人员交互和对变更的批准，因此节点操作员可以在同意之前查看差异。</p>
<p>当更新即将发生时，网络map服务开始用通常的网络map数据通告附加信息。它包括新的网络参数哈希，更改说明和更新截止日期。节点向网络映射服务器查询新的一组参数。</p>
<p>新的参数集被公布的事实显示在节点日志中，并带有“下载的新网络参数”消息，并且通过RPC连接的程序可以通过使用该<code>CordaRPCOps.networkParametersFeed</code>方法接收<code>ParametersUpdateInfo</code>。通常，区域操作员还会通过电子邮件向节点操作员发送电子邮件，让他们了解即将发生的更改的详细信息，以及理由，如何提交对象，截止日期等。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Data class containing information about the scheduled network parameters update. The info is emitted every time node</span></span><br><span class="line"><span class="comment"> * receives network map with [ParametersUpdate] which wasn't seen before. For more information see: [CordaRPCOps.networkParametersFeed] and [CordaRPCOps.acceptNewNetworkParameters].</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> hash new [NetworkParameters] hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> parameters new [NetworkParameters] data structure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> description description of the update</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> updateDeadline deadline for accepting this update using [CordaRPCOps.acceptNewNetworkParameters]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ParametersUpdateInfo</span></span>(</span><br><span class="line">        <span class="keyword">val</span> hash: SecureHash,</span><br><span class="line">        <span class="keyword">val</span> parameters: NetworkParameters,</span><br><span class="line">        <span class="keyword">val</span> description: String,</span><br><span class="line">        <span class="keyword">val</span> updateDeadline: Instant</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>节点管理员可以检查更改并决定是否要接受它。在更新截止日期之前应该进行批准。在截止日期前不批准的节点可能会被区域运营商从网络地图中删除，但这是由运营商决定的决定。例如，运营商也可能会选择更改截止日期。</p>
<p>如果网络运营商开始通告一组不同的新参数，那么该新的组将覆盖前一组。只有最新的更新才能被接受。</p>
<p>要将参数批准发送回区域操作员， 必须使用更新来调用RPC方法<code>fun acceptNewNetworkParameters(parametersHash: SecureHash)</code>。请注意，批准不能撤消。您可以通过Corda shell执行<code>parametersHash</code>操作（请参阅Shell）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run acceptNewNetworkParameters parametersHash: &quot;ba19fc1b9e9c1c7cbea712efda5f78b53ae4e5d123c89d02c9da44ec50e9c17d&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果管理员不接受更新，则下一次该节点在截止日期后轮询网络映射，则通告的网络参数将为更新后的网络参数。前一组参数将不再有效。此时节点将自动关闭，并要求节点操作员再次将其恢复。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>随着Corda平台的不断发展和新功能的增加，拥有版本控制系统变得非常重要，它允许用户轻松比较版本并了解可用功能。每个Corda发行版都使用标准的语义版本方案<code>major.minor.patch</code>。这在公开域中发布时非常有用，但对于在平台上工作的开发人员不友好。它首先必须被解析，然后他们有三个独立的部分来确定API差异。发布版本仍然有用，节点发送的每个MQ消息都将其附加到标题属性<code>release-version</code>以进行调试。</p>
<p>使用单个增量整数值来表示Corda平台的API版本（称为平台版本）要容易得多。它类似于Android的API级别。它从1开始，每增加一个版本，就会增加1，这会改变整个平台上任何公开暴露的API。这包括节点本身的公共API，RPC系统，消息传递，序列化等。API始终保持向后兼容性，并且使用弃用从旧API迁移。在极少数情况下，API可能不得不被删除，例如由于安全问题。平台版本和发布版本之间没有任何关系 - 主要，次要或补丁值的更改可能会或可能不会增加平台版本。</p>
<p>平台版本是节点<code>NodeInfo</code>对象的一部分，可以从中获得<code>ServiceHub</code>。这使得CorDapp能够找出正在运行的版本并确定是否有可用的功能。当一个节点向网络映射服务注册时，它将使用该节点的平台版本来强制执行网络的最低​​版本要求。</p>
<p>注意: 未来版本可能会引入目标平台版本的概念，这与Android的<code>targetSdkVersion</code>类似，并且会为平台行为发生变化的情况提供维护行为兼容性的手段。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/linux/Systemd添加自定义系统服务设置自定义开机启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/linux/Systemd添加自定义系统服务设置自定义开机启动/" itemprop="url">【转】Systemd添加自定义系统服务设置自定义开机启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T10:35:10+08:00">2018-06-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务权限"><a href="#服务权限" class="headerlink" title="服务权限"></a>服务权限</h2><p>systemd有系统和用户区分；系统（<code>/user/lib/systemd/system/</code>）、用户（<code>/etc/lib/systemd/user/</code>）.一般系统管理员手工创建的单元文件建议存放在<code>/etc/systemd/system/</code>目录下面。</p>
<h2 id="创建服务文件"><a href="#创建服务文件" class="headerlink" title="创建服务文件"></a>创建服务文件</h2><p>一般是放在<code>/etc/systemd/system/</code>目录下面，命名都是<code>xxx.service</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=kibana</span><br><span class="line">Group=kibana</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">EnvironmentFile=-/etc/default/kibana</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kibana</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">Restart=always</span><br><span class="line">WorkingDirectory=/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>下面是具体字段的说明：</p>
<p><code>[Unit]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Description</td>
<td style="text-align:center">服务的简单描述</td>
</tr>
<tr>
<td style="text-align:center">Documentation</td>
<td style="text-align:center">服务文档</td>
</tr>
<tr>
<td style="text-align:center">Before、After</td>
<td style="text-align:center">定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。</td>
</tr>
<tr>
<td style="text-align:center">Requires</td>
<td style="text-align:center">这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。</td>
</tr>
<tr>
<td style="text-align:center">Wants</td>
<td style="text-align:center">推荐使用。这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</td>
</tr>
</tbody>
</table>
<p><code>[Service]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type=simple（默认值）</td>
<td style="text-align:center">systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。</td>
</tr>
<tr>
<td style="text-align:center">Type=forking</td>
<td style="text-align:center">systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。</td>
</tr>
<tr>
<td style="text-align:center">Type=oneshot</td>
<td style="text-align:center">这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。</td>
</tr>
<tr>
<td style="text-align:center">Type=notify</td>
<td style="text-align:center">与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。</td>
</tr>
<tr>
<td style="text-align:center">Type=dbus</td>
<td style="text-align:center">若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。</td>
</tr>
<tr>
<td style="text-align:center">Type=idle</td>
<td style="text-align:center">systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。</td>
</tr>
<tr>
<td style="text-align:center">PIDFile</td>
<td style="text-align:center">pid文件路径</td>
</tr>
<tr>
<td style="text-align:center">ExecStart</td>
<td style="text-align:center">指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。</td>
</tr>
<tr>
<td style="text-align:center">ExecReload</td>
<td style="text-align:center">指定单元停止时执行的命令或者脚本。</td>
</tr>
<tr>
<td style="text-align:center">ExecStop</td>
<td style="text-align:center">指定单元停止时执行的命令或者脚本。</td>
</tr>
<tr>
<td style="text-align:center">PrivateTmp</td>
<td style="text-align:center">True表示给服务分配独立的临时空间</td>
</tr>
<tr>
<td style="text-align:center">Restart</td>
<td style="text-align:center">这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。</td>
</tr>
<tr>
<td style="text-align:center">RemainAfterExit</td>
<td style="text-align:center">如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</td>
</tr>
</tbody>
</table>
<p><code>[Install]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Alias</td>
<td style="text-align:center">为单元提供一个空间分离的附加名字。</td>
</tr>
<tr>
<td style="text-align:center">RequiredBy</td>
<td style="text-align:center">单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。</td>
</tr>
<tr>
<td style="text-align:center">WantBy</td>
<td style="text-align:center">单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。</td>
</tr>
<tr>
<td style="text-align:center">Also</td>
<td style="text-align:center">指出和单元一起安装或者被协助的单元。</td>
</tr>
<tr>
<td style="text-align:center">DefaultInstance</td>
<td style="text-align:center">实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</td>
</tr>
</tbody>
</table>
<h2 id="重载服务"><a href="#重载服务" class="headerlink" title="重载服务"></a>重载服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure>
<p>就会在<code>/etc/systemd/system/multi-user.target.wants/</code>目录下新建一个<code>/usr/lib/systemd/system/nginx.service</code> 文件的链接。</p>
<h2 id="操作服务"><a href="#操作服务" class="headerlink" title="操作服务"></a>操作服务</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo journalctl -f -u nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure>
<h2 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h2><p><a href="http://blog.51cto.com/wjb10000/1788364" target="_blank" rel="noopener">systemd添加自定义系统服务设置自定义开机启动</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">108</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">101</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
