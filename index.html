<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/07/linux/Systemd添加自定义系统服务设置自定义开机启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/linux/Systemd添加自定义系统服务设置自定义开机启动/" itemprop="url">【转】Systemd添加自定义系统服务设置自定义开机启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T10:35:10+08:00">2018-06-07</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="服务权限"><a href="#服务权限" class="headerlink" title="服务权限"></a>服务权限</h2><p>systemd有系统和用户区分；系统（<code>/user/lib/systemd/system/</code>）、用户（<code>/etc/lib/systemd/user/</code>）.一般系统管理员手工创建的单元文件建议存放在<code>/etc/systemd/system/</code>目录下面。</p>
<h2 id="创建服务文件"><a href="#创建服务文件" class="headerlink" title="创建服务文件"></a>创建服务文件</h2><p>一般是放在<code>/etc/systemd/system/</code>目录下面，命名都是<code>xxx.service</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=kibana</span><br><span class="line">Group=kibana</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">EnvironmentFile=-/etc/default/kibana</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kibana</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">Restart=always</span><br><span class="line">WorkingDirectory=/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>下面是具体字段的说明：</p>
<p><code>[Unit]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Description</td>
<td style="text-align:center">服务的简单描述</td>
</tr>
<tr>
<td style="text-align:center">Documentation</td>
<td style="text-align:center">服务文档</td>
</tr>
<tr>
<td style="text-align:center">Before、After</td>
<td style="text-align:center">定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。</td>
</tr>
<tr>
<td style="text-align:center">Requires</td>
<td style="text-align:center">这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。</td>
</tr>
<tr>
<td style="text-align:center">Wants</td>
<td style="text-align:center">推荐使用。这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</td>
</tr>
</tbody>
</table>
<p><code>[Service]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type=simple（默认值）</td>
<td style="text-align:center">systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。</td>
</tr>
<tr>
<td style="text-align:center">Type=forking</td>
<td style="text-align:center">systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。</td>
</tr>
<tr>
<td style="text-align:center">Type=oneshot</td>
<td style="text-align:center">这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。</td>
</tr>
<tr>
<td style="text-align:center">Type=notify</td>
<td style="text-align:center">与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。</td>
</tr>
<tr>
<td style="text-align:center">Type=dbus</td>
<td style="text-align:center">若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。</td>
</tr>
<tr>
<td style="text-align:center">Type=idle</td>
<td style="text-align:center">systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。</td>
</tr>
<tr>
<td style="text-align:center">PIDFile</td>
<td style="text-align:center">pid文件路径</td>
</tr>
<tr>
<td style="text-align:center">ExecStart</td>
<td style="text-align:center">指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。</td>
</tr>
<tr>
<td style="text-align:center">ExecReload</td>
<td style="text-align:center">指定单元停止时执行的命令或者脚本。</td>
</tr>
<tr>
<td style="text-align:center">ExecStop</td>
<td style="text-align:center">指定单元停止时执行的命令或者脚本。</td>
</tr>
<tr>
<td style="text-align:center">PrivateTmp</td>
<td style="text-align:center">True表示给服务分配独立的临时空间</td>
</tr>
<tr>
<td style="text-align:center">Restart</td>
<td style="text-align:center">这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。</td>
</tr>
<tr>
<td style="text-align:center">RemainAfterExit</td>
<td style="text-align:center">如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</td>
</tr>
</tbody>
</table>
<p><code>[Install]</code>单元的说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Alias</td>
<td style="text-align:center">为单元提供一个空间分离的附加名字。</td>
</tr>
<tr>
<td style="text-align:center">RequiredBy</td>
<td style="text-align:center">单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。</td>
</tr>
<tr>
<td style="text-align:center">WantBy</td>
<td style="text-align:center">单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。</td>
</tr>
<tr>
<td style="text-align:center">Also</td>
<td style="text-align:center">指出和单元一起安装或者被协助的单元。</td>
</tr>
<tr>
<td style="text-align:center">DefaultInstance</td>
<td style="text-align:center">实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</td>
</tr>
</tbody>
</table>
<h2 id="重载服务"><a href="#重载服务" class="headerlink" title="重载服务"></a>重载服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure>
<p>就会在<code>/etc/systemd/system/multi-user.target.wants/</code>目录下新建一个<code>/usr/lib/systemd/system/nginx.service</code> 文件的链接。</p>
<h2 id="操作服务"><a href="#操作服务" class="headerlink" title="操作服务"></a>操作服务</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo journalctl -f -u nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx.service</span><br></pre></td></tr></table></figure>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure>
<h2 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h2><p><a href="http://blog.51cto.com/wjb10000/1788364" target="_blank" rel="noopener">systemd添加自定义系统服务设置自定义开机启动</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/06/blockchain/corda/Corda-Nodes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/blockchain/corda/Corda-Nodes/" itemprop="url">Corda Nodes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T17:39:49+08:00">2018-06-06</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建本地节点"><a href="#创建本地节点" class="headerlink" title="创建本地节点"></a>创建本地节点</h2><p>每个Corda节点都有以下的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── certificates            // The node&apos;s certificates</span><br><span class="line">├── corda-webserver.jar     // The built-in node webserver</span><br><span class="line">├── corda.jar               // The core Corda libraries</span><br><span class="line">├── logs                    // The node logs</span><br><span class="line">├── node.conf               // The node&apos;s configuration files</span><br><span class="line">├── persistence.mv.db       // The node&apos;s database</span><br><span class="line">└── cordapps                // The CorDapps jars installed on the node</span><br></pre></td></tr></table></figure></p>
<p>该节点通过编辑其<code>node.conf</code>文件进行配置。通过将CorDapp JAR放入该<code>cordapps</code>文件夹中来在节点上安装CorDapps 。</p>
<p>在开发模式下（即何时<code>devMode = true</code>，请参阅<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>以获取更多信息）， 如果所需的密钥库不存在，则<code>certificates</code>目录中将填充预先配置的密钥库。这可以确保开发人员能够尽快获得节点的工作。但是，这些预配置的密钥库不安全。要了解更多信息，请参阅<a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>。</p>
<h2 id="节点命名"><a href="#节点命名" class="headerlink" title="节点命名"></a>节点命名</h2><p>节点的名称必须是有效的X.500专有名称。为了与其他实现（特别是TLS实现）兼容，我们将允许的X.500名称属性类型约束为X.509证书（在RFC 3280中指定）的最小支持集的子集以及locality属性：</p>
<ul>
<li>组织（O）</li>
<li>州（ST）</li>
<li>地点（L）</li>
<li>国家（C）</li>
<li>组织单元（OU）</li>
<li>通用名称（CN）</li>
</ul>
<p>更多信息参考<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html#node-naming" target="_blank" rel="noopener">这个网址</a>！</p>
<h2 id="Cordform任务"><a href="#Cordform任务" class="headerlink" title="Cordform任务"></a>Cordform任务</h2><p>Corda提供了一个名为的gradle插件<code>Cordform</code>，允许您自动生成和配置一组用于测试和演示的节点。这是一个<code>Cordform</code>调用的示例任务<code>deployNodes</code>，它创建三个节点，在<a href="https://github.com/corda/cordapp-template-kotlin/blob/release-V3/build.gradle#L100" target="_blank" rel="noopener">Kotlin CorDapp模板</a>中定义：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> deployNodes(type: net.corda.plugins.Cordform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line">    directory <span class="string">"./build/nodes"</span></span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Notary,L=London,C=GB"</span></span><br><span class="line">        <span class="comment">// The notary will offer a validating notary service.</span></span><br><span class="line">        notary = [validating : <span class="keyword">true</span>]</span><br><span class="line">        p2pPort  <span class="number">10002</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10003</span></span><br><span class="line">            adminPort <span class="number">10023</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No webport property, so no webserver will be created.</span></span><br><span class="line">        h2Port   <span class="number">10004</span></span><br><span class="line">        <span class="comment">// Includes the corda-finance CorDapp on our node.</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyA,L=London,C=GB"</span></span><br><span class="line">        p2pPort  <span class="number">10005</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10006</span></span><br><span class="line">            adminPort <span class="number">10026</span></span><br><span class="line">        &#125;</span><br><span class="line">        webPort  <span class="number">10007</span></span><br><span class="line">        h2Port   <span class="number">10008</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">        <span class="comment">// Grants user1 all RPC permissions.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"ALL"</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyB,L=New York,C=US"</span></span><br><span class="line">        p2pPort  <span class="number">10009</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10010</span></span><br><span class="line">            adminPort <span class="number">10030</span></span><br><span class="line">        &#125;</span><br><span class="line">        webPort  <span class="number">10011</span></span><br><span class="line">        h2Port   <span class="number">10012</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">        <span class="comment">// Grants user1 the ability to start the MyFlow flow.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"StartFlow.net.corda.flows.MyFlow"</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要将节点配置扩展到<code>deployNodes</code>任务中定义的属性之外，请使用<code>configFile</code>路径（相对或绝对）设置为其他配置文件的属性。根据node.conf，该文件应该遵循标准的<a href="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html" target="_blank" rel="noopener">节点配置</a>格式。该文件的属性将被附加到生成的节点配置中。通过<code>-PconfigFile</code>命令行选项运行Gradle任务时，也可以添加文件的路径。但是，相同的文件将应用于所有节点。在前面的示例<code>PartyB</code>节点之后，将有一个从文件添加的额外配置选项<code>none-b.conf</code>：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> deployNodes(type: net.corda.plugins.Cordform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line">    [...]</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyB,L=New York,C=US"</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// Grants user1 the ability to start the MyFlow flow.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"StartFlow.net.corda.flows.MyFlow"</span>]]]</span><br><span class="line">        configFile = <span class="string">"samples/trader-demo/src/main/resources/none-b.conf"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行此任务将在<code>build/nodes</code>文件夹中创建三个节点：</p>
<ul>
<li>一个<code>Notary</code>节点：<ul>
<li>提供验证公证服务</li>
<li>没有网络服务器（因为<code>webPort</code>没有定义）</li>
<li>正在运行<code>corda-finance</code>CorDapp</li>
</ul>
</li>
<li><code>PartyA</code>和<code>PartyB</code>节点：<ul>
<li>不提供任何服务</li>
<li>将有一个网络服务器（因为<code>webPort</code>已定义）</li>
<li>正在运行<code>corda-finance</code> CorDapp</li>
<li>有一个RPC用户，<code>user1</code>可以用来通过RPC登录到节点</li>
</ul>
</li>
</ul>
<p>此外，所有三个节点都将包含项目源文件夹中定义的所有CorDapps，即使这些CorDapps未列入每个节点的<code>cordapps</code>条目中。这意味着<code>deployNodes</code>，例如从模板CorDapp，运行任务会自动构建模板CorDapp并将其添加到每个节点。</p>
<p><b style="color:red">您可以扩展<code>deployNodes</code>以生成其他节点。</b></p>
<p>这<code>Dockerform</code>是一个<code>Cordform</code>的姐姐任务。它具有几乎相同的语法，并产生非常相似的结果 - 通过使用<code>docker-compose</code>增加一个额外的文件来增强节点的易用性。您可以在下面<code>IRS Demo&lt;https://github.com/corda/corda/blob/release-V3.0/samples/irs-demo/cordapp/build.gradle#L111&gt;</code> 的主Corda GitHub存储库的samples目录中找到示例任务：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> rpcUsersList = [</span><br><span class="line">    [<span class="string">'username'</span> : <span class="string">"user"</span>,</span><br><span class="line">     <span class="string">'password'</span> : <span class="string">"password"</span>,</span><br><span class="line">     <span class="string">'permissions'</span> : [</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.flows.AutoOfferFlow\$Requester"</span>,</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.flows.UpdateBusinessDayFlow\$Broadcast"</span>,</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.api.NodeInterestRates\$UploadFixesFlow"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.vaultQueryBy"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.networkMapSnapshot"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.currentNodeTime"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.wellKnownPartyFromX500Name"</span></span><br><span class="line">     ]]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// (...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> prepareDockerNodes(type: net.corda.plugins.Dockerform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Notary Service,L=Zurich,C=CH"</span></span><br><span class="line">        notary = [validating : <span class="keyword">true</span>]</span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Bank A,L=London,C=GB"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Bank B,L=New York,C=US"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Regulator,L=Moscow,C=RU"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project.group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不需要指定端口，因为每个节点都是独立的容器，所以不会发生端口冲突。运行该任务将创建与“Cordform任务”中所述的相同的文件夹结构<code>Dockerfile</code>，并<code>docker-compose.yml</code>在每个节点目录中和<code>build/nodes</code>目录中添加一个附加文件夹结构。默认情况下，每个节点都公开端口<code>10003</code>，这是RPC连接的默认端口。</p>
<p>要创建我们<code>deployNodes</code>任务中定义的节点，请在定义任务的项目根目录的终端窗口中运行以下命令<code>deployNodes</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew deployNodes</span><br></pre></td></tr></table></figure></p>
<p>这将在<code>build/nodes</code>文件夹中创建节点。将为该deployNodes任务中定义的每个节点生成一个节点文件夹，以及runnodes用于同时运行所有节点以进行测试和开发的shell脚本（或Windows上的批处理文件）。如果您对CorDapp源代码或deployNodes任务进行了任何更改，则需要重新运行该任务以查看更改才能生效。</p>
<p>现在可以按照运行节点中的说明<a href="https://docs.corda.net/releases/release-V3.1/running-a-node.html" target="_blank" rel="noopener">运行节点</a>。</p>
<h2 id="本地运行节点"><a href="#本地运行节点" class="headerlink" title="本地运行节点"></a>本地运行节点</h2><p>出于测试目的，本地运行Corda节点有几种方法。</p>
<h3 id="一次启动所有节点"><a href="#一次启动所有节点" class="headerlink" title="一次启动所有节点"></a>一次启动所有节点</h3><p><code>runnodes</code>是一个shell脚本（或Windows上的批处理文件），<code>deployNodes</code>可以让您快速启动所有节点及其Web服务器。<code>runnodes</code>只能用于测试目的。</p>
<p><code>runnodes</code>通过从项目的根目录运行以下命令来启动节点：命令：<code>build/nodes/runnodes</code>.</p>
<p>如果<code>OutOfMemoryError</code>在与节点进行交互时收到异常，则需要增加可供其使用的Java堆内存量，这可以在单独运行时执行。</p>
<h3 id="启动单个Corda节点"><a href="#启动单个Corda节点" class="headerlink" title="启动单个Corda节点"></a>启动单个Corda节点</h3><p>通过打开节点文件夹中的终端窗口并运行以下命令来运行节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，节点将查找调用的配置文件<code>node.conf</code>和在当前工作目录中调用的CorDapps <code>cordapps</code>文件夹。您可以在命令行上覆盖配置文件和工作区路径（例如 <code>./corda.jar --config-file=test.conf --base-directory=/opt/corda/nodes/test</code>）。</p>
<p>您可以使用<code>-Xmx</code>命令行参数来增加节点可用的Java堆内存量。例如，以下内容将以2048MB的堆大小运行节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx2048m -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>也可以通过在节点的文件夹中打开终端窗口并运行以下命令来运行节点的Web服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda-webserver.jar</span><br></pre></td></tr></table></figure></p>
<h3 id="启动启用远程调试的节点"><a href="#启动启用远程调试的节点" class="headerlink" title="启动启用远程调试的节点"></a>启动启用远程调试的节点</h3><p><b style="color:red">要启用节点的远程调试，请从终端窗口运行以下命令：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dcapsule.jvm.args=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005&quot; -jar corda.jar</span><br></pre></td></tr></table></figure></p>
<p>该命令行将在端口5005上启动调试器并暂停进程，等待调试器附件。</p>
<h2 id="部署节点"><a href="#部署节点" class="headerlink" title="部署节点"></a>部署节点</h2><p>这些说明适用于想要将Corda节点部署到服务器的人员，无论他们是按照<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">本地创建节点</a>中的指示信息开发并测试了CorDapp 还是正在部署第三方CorDapp。</p>
<h3 id="Linux：作为系统服务安装并运行Corda"><a href="#Linux：作为系统服务安装并运行Corda" class="headerlink" title="Linux：作为系统服务安装并运行Corda"></a>Linux：作为系统服务安装并运行Corda</h3><p>我们建议创建系统服务来运行节点和可选的Web服务器。这提供日志记录和服务处理，并确保Corda服务在启动时运行。</p>
<p>具体细节查看<a href="https://docs.corda.net/releases/release-V3.1/deploying-a-node.html" target="_blank" rel="noopener">这里</a>！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/01/blockchain/corda/Cordapp基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/blockchain/corda/Cordapp基础知识/" itemprop="url">Cordapp基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T10:17:22+08:00">2018-06-01</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CorDapps（Corda分布式应用程序）是在Corda平台上运行的分布式应用程序。CorDapp的目标是允许节点就分类账更新达成一致。他们通过定义Corda节点所有者可以通过RPC调用调用的流程来实现此目标：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/node-diagram.png" alt=""></p>
<p>Cordapps由以下关键组件组成：</p>
<ul>
<li>状态： 达成协议的事实</li>
<li>合约： 定义构成有效分类账更新的内容</li>
<li>服务： 在节点内提供长寿命的工具</li>
<li>序列化白名单： 限制节点从网络线路接收的类型</li>
</ul>
<p>每个Cordapp安装在单节点级别，而不是网络本身。例如，节点所有者可以选择安装Bond Trading CorDapp，并具有以下组件：</p>
<ul>
<li><code>BondState</code>: 用来代表债券，作为账本上的事实</li>
<li><code>BondContract</code>: 用来管理账本有效更新包括<code>BondState</code>状态</li>
<li>三个流程：<ul>
<li><code>IssueBondFlow</code>: 允许新的<code>BondState</code>状态发布到账本上</li>
<li><code>TradeBondFlow</code>: 允许存在的<code>BondState</code>状态在账本上进行买进和卖出。</li>
<li><code>ExitBondFlow</code>: 允许存在的<code>BondState</code>状态从账本上退出</li>
</ul>
</li>
</ul>
<p>安装此CorDapp后，节点所有者将能够使用CorDapp定义的流程来允许与发行，出售，购买和退出债券有关的分类帐更新。</p>
<h2 id="编写一个CorDapp"><a href="#编写一个CorDapp" class="headerlink" title="编写一个CorDapp"></a>编写一个CorDapp</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>每个CorDapp组件都采用JVM类的形式，该JVM类子类或实现Corda库类型：</p>
<ul>
<li>流程子类<code>FlowLogic</code></li>
<li>状态实现 <code>ContractState</code></li>
<li>合约实现 <code>Contract</code></li>
<li>服务子类 <code>SingletonSerializationToken</code></li>
<li>序列化白名单实现：<code>SerializationWhitelist</code></li>
</ul>
<h3 id="Web内容和RPC客户端"><a href="#Web内容和RPC客户端" class="headerlink" title="Web内容和RPC客户端"></a>Web内容和RPC客户端</h3><p>出于测试目的，CorDapps还可能包括：</p>
<ul>
<li>API和静态网页内容：由Corda内置的网络服务器提供。这个网络服务器不是生产就绪的，只能用于测试目的</li>
<li>RPC客户端：这些程序可以自动执行通过RPC与节点进行交互的过程</li>
</ul>
<p>在生产环境中，应该使用生产就绪的网络服务器，这些文件应该移到不同的模块或项目中，以便在构建时不会膨胀CorDapp。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>您应该将项目的结构基于Java或Kotlin模板：</p>
<ul>
<li><a href="https://github.com/corda/cordapp-template-java" target="_blank" rel="noopener">Java模板CorDapp</a></li>
<li><a href="https://github.com/corda/cordapp-template-kotlin" target="_blank" rel="noopener">Kotlin模板CorDapp</a></li>
</ul>
<p>该项目应该分为两个模块：</p>
<ul>
<li><code>cordapp-contracts-states</code>包含合约和状态等类的模块，将作为流程的一部分通过线路发送</li>
<li><code>cordapp</code>含有剩余的类模块</li>
</ul>
<p>每个模块将被编译到它自己的CorDapp中。当节点同意分类帐更新时，这可以最小化必须通过网络发送的JAR的大小。</p>
<h3 id="模块1-cordapp-contracts-states"><a href="#模块1-cordapp-contracts-states" class="headerlink" title="模块1 - cordapp-contracts-states"></a>模块1 - cordapp-contracts-states</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── main</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                ├── TemplateContract.java</span><br><span class="line">                └── TemplateState.java</span><br></pre></td></tr></table></figure>
<h3 id="模块2-cordapp"><a href="#模块2-cordapp" class="headerlink" title="模块2 - cordapp"></a>模块2 - cordapp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── template</span><br><span class="line">│   │           ├── TemplateApi.java</span><br><span class="line">│   │           ├── TemplateClient.java</span><br><span class="line">│   │           ├── TemplateFlow.java</span><br><span class="line">│   │           ├── TemplateSerializationWhitelist.java</span><br><span class="line">│   │           └── TemplateWebPlugin.java</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── META-INF</span><br><span class="line">│       │   └── services</span><br><span class="line">│       │       ├── net.corda.core.serialization.SerializationWhitelist</span><br><span class="line">│       │       └── net.corda.webserver.services.WebServerPluginRegistry</span><br><span class="line">│       ├── certificates</span><br><span class="line">│       └── templateWeb</span><br><span class="line">├── test</span><br><span class="line">│   └── java</span><br><span class="line">│       └── com</span><br><span class="line">│           └── template</span><br><span class="line">│               ├── ContractTests.java</span><br><span class="line">│               ├── FlowTests.java</span><br><span class="line">│               └── NodeDriver.java</span><br><span class="line">└── integrationTest</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                └── DriverBasedTest.java</span><br></pre></td></tr></table></figure>
<p>这里面需要注意的是<code>test</code>是包含示例单元测试，以及用于从IntelliJ运行CorDapp的节点驱动程序. <code>integrationTest</code>是包含一个示例集成测试。这里需要注意两者的区别。</p>
<p>在<code>main</code>中，有以下的几个目录：</p>
<ul>
<li><code>resources/META-INF/services</code> 包含CorDapp的序列化白名单和网页插件的注册管理机构</li>
<li><code>resources/certificates</code> 包含用于测试目的的虚拟证书</li>
<li><code>resources/templateWeb</code> 包含一个虚拟的前端</li>
<li><code>java</code>（或<code>kotlin</code>在Kotlin模板中），其中包括我们的CorDapp的源代码</li>
</ul>
<p>我们的CorDapp的源代码分解如下：</p>
<ul>
<li><code>TemplateFlow.java</code>，其中包含一个虚拟<code>FlowLogic</code>子类</li>
<li><code>TemplateState.java</code>，其中包含一个虚拟<code>ContractState</code>实现</li>
<li><code>TemplateContract.java</code>，其中包含一个虚拟<code>Contract</code>实现</li>
<li><code>TemplateSerializationWhitelist.java</code>，其中包含一个虚拟<code>SerializationWhitelist</code>实现</li>
</ul>
<p>在开发你的CorDapp时，你应该首先修改这些类来定义你的CorDapp的组件。一个单一的CorDapp可以定义多个流程，状态和合同。</p>
<p><b style="color:red">该模板还包含一个Web API和RPC客户端：</b></p>
<ul>
<li><code>TemplateApi.java</code></li>
<li><code>TemplateClient.java</code></li>
<li><code>TemplateWebPlugin.java</code></li>
</ul>
<p>这些用于测试目的，并将在生产CorDapp中删除。</p>
<h3 id="学习的资源"><a href="#学习的资源" class="headerlink" title="学习的资源"></a>学习的资源</h3><p>在编写CorDapp时，您应该查阅以下资源：</p>
<ul>
<li><a href="https://docs.corda.net/releases/release-V3.1/getting-set-up.html" target="_blank" rel="noopener">快速设置</a>来设置你的开发环境</li>
<li>你好，世界！教程来编写你的第一个CorDapp</li>
<li><a href="https://docs.corda.net/releases/release-V3.1/cordapp-build-systems.html" target="_blank" rel="noopener">构建一个CorDapp</a>来构建和运行您的CorDapp</li>
<li>该API文档阅读有关开发CorDapps可用的API<ul>
<li>还有一个<a href="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html" target="_blank" rel="noopener">cheatsheet</a>重新说明关键类型</li>
</ul>
</li>
<li>该<a href="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html" target="_blank" rel="noopener">流程指南</a>看如何执行常见任务流的代码示例</li>
<li><a href="https://www.corda.net/samples/" target="_blank" rel="noopener">CorDapps实例程序</a>显示Corda功能的各个部分</li>
</ul>
<h2 id="构建一个Cordapp"><a href="#构建一个Cordapp" class="headerlink" title="构建一个Cordapp"></a>构建一个Cordapp</h2><h3 id="CorDapp格式"><a href="#CorDapp格式" class="headerlink" title="CorDapp格式"></a>CorDapp格式</h3><p>Cordapp是一个semi-fat的jar包，它包含除 Corda核心库和其它依赖的任何其他CorDapps 之外的所有CorDapp依赖项。</p>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>在下面的说明中，我们假设你正在使用<code>gradle</code>和<code>cordformation</code>插件来构建你的CorDapp。</p>
<h3 id="设置依赖关系"><a href="#设置依赖关系" class="headerlink" title="设置依赖关系"></a>设置依赖关系</h3><h4 id="选择你的Corda，Quasar和Kotlin版本"><a href="#选择你的Corda，Quasar和Kotlin版本" class="headerlink" title="选择你的Corda，Quasar和Kotlin版本"></a>选择你的Corda，Quasar和Kotlin版本</h4><p>CorDapp的build.gradle文件中使用了几个变量来定义用于构建您的CorDapp的版本：</p>
<ul>
<li><code>ext.corda_release_version</code> 定义了Corda的版本</li>
<li><code>ext.corda_gradle_plugins_version</code> 定义了Corda Gradle插件的版本</li>
<li><code>ext.quasar_version</code> 定义了Quasar的版本</li>
<li><code>ext.kotlin_version</code> 定义Kotlin的版本（如果使用Kotlin编写您的CorDapp）</li>
</ul>
<h4 id="Corda依赖"><a href="#Corda依赖" class="headerlink" title="Corda依赖"></a>Corda依赖</h4><p><code>cordformation</code>和<code>cordapp</code>插件添加了两个新的gradle这个配置：</p>
<ul>
<li><code>cordaCompile</code>，这扩展了 <code>compile</code></li>
<li><code>cordaRuntime</code>，这扩展了 <code>runtime</code></li>
</ul>
<p><code>cordaCompile</code>和<code>cordaRuntime</code>指出不应包含在CorDapp JAR中的依赖关系。这些配置应该用于任何Corda依赖（例如corda-core，corda-node），以防止依赖包含两次（一次在CorDapp JAR中，一次在Corda JAR中）。</p>
<p>要针对Corda构建，您必须将以下内容添加到您的build.gradle文件中：</p>
<p>Cordapp插件应该适用于任何将要构建cordapp的项目，并且cordformation插件应该适用于希望在本地创建小型测试网络的项目。</p>
<p>这样做后，确保： net.corda:corda:$corda_release_version被定义为cordaRuntime依赖项，并且所有其他net.corda编译依赖项（例如，net.corda：corda-core：$ corda_release_version）被设置为cordaCompile依赖项。</p>
<p>您可能还想添加：</p>
<ul>
<li><code>net.corda:corda-test-utils:$corda_release_version</code>作为<code>testCompile</code>依赖项，以便使用Corda的测试框架</li>
<li><code>net.corda:corda-webserver:$corda_release_version</code>作为<code>cordaRuntime</code>依赖项，以便使用Corda的内置开发Web服务器</li>
</ul>
<h4 id="依赖其他CorDapps"><a href="#依赖其他CorDapps" class="headerlink" title="依赖其他CorDapps"></a>依赖其他CorDapps</h4><p>您的CorDapp也可能依赖于另一个CorDapp中定义的类，例如状态，合约和流程。有两种方法可以在CorDapp的build.gradle文件中添加另一个CorDapp作为依赖项：</p>
<ul>
<li><code>cordapp project(&quot;:another-cordapp&quot;)</code>（如果在同一个项目中的模块中定义了另一个CorDapp，则使用此方法）</li>
<li><code>cordapp &quot;net.corda:another-cordapp:1.0&quot;</code> （否则使用这个）</li>
</ul>
<p>该cordappgradle这个配置有两个目的：</p>
<ul>
<li>当使用<code>cordformation</code> Gradle插件时，<code>cordapp</code>配置表明该JAR应该作为CorDapp包含在您的节点中</li>
<li>当使用<code>cordapp</code> Gradle插件时，<code>cordapp</code>配置可防止CorDapp JAR中包含依赖项</li>
</ul>
<p>请注意，<code>cordformation</code>和<code>cordapp</code> Gradle插件可以一起使用。</p>
<h4 id="其他依赖关系"><a href="#其他依赖关系" class="headerlink" title="其他依赖关系"></a>其他依赖关系</h4><p>如果您的CorDapps有任何额外的外部依赖关系，可以像Gradle中的正常Kotlin / Java依赖关系那样指定它们。看下面的例子，特别是<code>apache-commons</code>包含。</p>
<p>有关管理依赖关系的更多信息，请参阅<a href="https://docs.gradle.org/current/userguide/dependency_management.html" target="_blank" rel="noopener">Gradle文档</a>。</p>
<p>以下是CorDapp的Gradle依赖关系块的示例：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Corda integration dependencies</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-core:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-finance:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-jackson:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-rpc:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-node-api:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-webserver-impl:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda-webserver:$corda_release_version"</span></span><br><span class="line">    testCompile <span class="string">"net.corda:corda-test-utils:$corda_release_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corda Plugins: dependent flows and services</span></span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its module in the same project.</span></span><br><span class="line">    cordapp <span class="keyword">project</span>(<span class="string">":cordapp-contracts-states"</span>)</span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its fully-qualified name.</span></span><br><span class="line">    cordapp <span class="string">"net.corda:bank-of-corda-demo:1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some other dependencies</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"org.jetbrains.kotlin:kotlin-test:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"junit:junit:$junit_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.apache.commons:commons-lang3:3.6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建CorDapp-Jar"><a href="#创建CorDapp-Jar" class="headerlink" title="创建CorDapp Jar"></a>创建CorDapp Jar</h3><p>一旦您的依赖关系设置正确，您可以使用gradle <code>jar</code>任务来构建您的CorDapp JAR ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradlew jar</span><br></pre></td></tr></table></figure></p>
<p>CorDapp JAR将被输出到<code>build/libs</code>文件夹。</p>
<h3 id="安装CorDapp-JAR"><a href="#安装CorDapp-JAR" class="headerlink" title="安装CorDapp JAR"></a>安装CorDapp JAR</h3><p>在安装CorDapp之前，您必须创建一个或多个节点来安装它。有关说明，请参阅<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">本地创建节点</a>。</p>
<p>在运行时，节点将加载其<code>cordapps</code>文件夹中存在的任何CorDapps 。因此，为了在节点上安装CorDapp，必须将CorDapp JAR添加到该<code>&lt;node_dir&gt;/cordapps/</code>文件夹中，其中node_dir是存储节点的JAR和配置文件的文件夹。</p>
<h2 id="通过master分支编译"><a href="#通过master分支编译" class="headerlink" title="通过master分支编译"></a>通过master分支编译</h2><p>针对最新的Corda稳定版本开发CorDapps是明智的。但是，如果您使用的是最新功能，或者正在测试主代码库上的PR，则可能需要针对不稳定的Master分支进行构建。</p>
<h2 id="Corda-Api"><a href="#Corda-Api" class="headerlink" title="Corda Api"></a>Corda Api</h2><p>以下是用于开发CorDapps的核心API：</p>
<ul>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-states.html" target="_blank" rel="noopener">API：状态 States</a>  <a href="http://cncorda.com/doc/apis/api-states/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-persistence.html" target="_blank" rel="noopener">API：持久化 Persistence</a>  <a href="http://cncorda.com/doc/apis/api-persistence/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-contracts.html" target="_blank" rel="noopener">API：合约 Contracts</a>  <a href="http://cncorda.com/doc/apis/api-contracts/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html" target="_blank" rel="noopener">API：合约约束 Contract Constraints</a>  <a href="http://cncorda.com/doc/apis/api-contract-constrains/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-vault-query.html" target="_blank" rel="noopener">API：Vault查询</a>  <a href="https://docs.corda.net/releases/release-V3.1/api-vault-query.html" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-transactions.html" target="_blank" rel="noopener">API：交易 Transaction</a>  <a href="http://cncorda.com/doc/apis/api-transactions/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-flows.html" target="_blank" rel="noopener">API：流程 Flows</a>  <a href="http://cncorda.com/doc/apis/api-flows/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-identity.html" target="_blank" rel="noopener">API：身份 Identity</a>  <a href="http://cncorda.com/doc/apis/api-identity/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-service-hub.html" target="_blank" rel="noopener">API：ServiceHub</a> <a href="http://cncorda.com/doc/apis/api-servicehub/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">API：RPC操作 RPC operations</a> <a href="http://cncorda.com/doc/apis/api-rpc-operations/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-testing.html#flow-testing" target="_blank" rel="noopener">API：测试 Testing</a></li>
</ul>
<h3 id="内部API和稳定性保证"><a href="#内部API和稳定性保证" class="headerlink" title="内部API和稳定性保证"></a>内部API和稳定性保证</h3><p>Corda 3.0提供稳定的wire协议并支持数据库升级。因此，您应该能够将持久数据从3.0迁移到未来版本。但是，在我们开始提供ABI稳定性之前，有必要针对未来版本的API重新编译应用程序。</p>
<p>此外，请注意，Corda 3.0版本已经过基本级别的安全审核，为确保节点安全得到维护，应遵循以下最佳做法：</p>
<ul>
<li>应该使用安全密码生成器创建RPC用户、数据库连接和shell用户的凭证，最好从节点主机的命令行创建。</li>
<li>绝不应使用默认或开发模式凭证部署节点。</li>
<li>Corda节点应该使用其中一个受支持的数据库平台，而不是仅用于开发目的的默认H2数据库。Postgres是一个支持的平台。</li>
<li>应该在安全的网络（如DMZ）内操作节点，将入站和出站流量限制为仅需要的端口（就是限定端口做一些事）。具体而言，节点运营商应该致力于允许从互联网上访问点对点流量。RPC和数据库连接应该仅限于内部。</li>
<li>节点Web服务器模块已弃用，因此不应将其部署到生产环境中，因为它不是与Corda节点相同的安全标准。</li>
</ul>
<p>可以从Java 9 Jigsaw模块中获得Corda工件。从<code>module-info.java</code>中可以引用其中一个模块，例如<code>requires net.corda.core;</code>。</p>
<h3 id="Corda稳定的模块"><a href="#Corda稳定的模块" class="headerlink" title="Corda稳定的模块"></a>Corda稳定的模块</h3><p>以下模块具有稳定的API，我们承诺不会在以下版本中中断，除非出于安全原因需要进行不兼容的更改：</p>
<ul>
<li>核心（net.corda.core）：核心Corda函数库，如加密函数、Corda构建模块的类型：状态，合约，交易，附件等，以及用于节点和协议的一些接口</li>
<li>客户端RPC（net.corda.client.rpc）：客户端RPC</li>
<li>客户端Jackson（net.corda.client.jackson）：对客户端应用程序的JSON支持</li>
<li>测试实用程序（net.corda.testing.core）：通用测试实用程序</li>
<li>测试节点驱动程序（net.corda.testing.node，net.corda.testing.driver）：测试实用程序以编程方式运行节点</li>
<li>Http Test Utils（net.corda.testing.http）：一组用于制作HttpCalls的实用程序，旨在演示和测试。</li>
<li>DSL Test Utils（net.corda.testing.dsl）：用于测试目的的用于构建伪交易（与有线协议不同）的简单DSL。</li>
<li>虚拟合约 Dummy Contracts（net.corda.testing.contracts）：用于测试目的的虚拟状态和合约</li>
<li>模拟服务 Mock Services（net.corda.testing.services）：用于测试目的的模拟服务实现</li>
</ul>
<h3 id="Corda孵化模块"><a href="#Corda孵化模块" class="headerlink" title="Corda孵化模块"></a>Corda孵化模块</h3><p>以下模块还没有完全稳定的API，但我们会尽最大努力最大限度地减少开发人员使用它们的中断，直到我们能够将其应用到公共API中：</p>
<ul>
<li>net.corda.confidential.identities：实验性支持分类账上的机密身份</li>
<li>net.corda.finance：一系列基本合同（及相关模式）和协议，如抽象可替代资产，现金，义务和商业票据</li>
<li>net.corda.client.jfx：支持Java FX UI</li>
<li>net.corda.client.mock：客户端模拟实用程序</li>
<li>Cordformation：Gradle集成插件</li>
</ul>
<h3 id="Corda不稳定模块"><a href="#Corda不稳定模块" class="headerlink" title="Corda不稳定模块"></a>Corda不稳定模块</h3><p>以下模块可用，但我们不承诺任何意义上的稳定性或延续性：</p>
<ul>
<li>net.corda.buildSrc：必要的gradle插件来构建Corda</li>
<li>net.corda.node：Corda节点的核心代码（例如节点驱动程序，节点服务，消息传递，持久性）</li>
<li>net.corda.node.api：节点和客户端模块之间共享的数据结构，例如通过RPC发送的类型</li>
<li>net.corda.samples.network.visualiser：一个网络可视化工具，它使用仿真来显示Corda网络上节点之间的交互和消息</li>
<li>net.corda.samples.demos.attachment：演示如何使用附件从一个节点发送一个事务到另一个节点，并且接收节点访问附件</li>
<li>net.corda.samples.demos.bankofcorda：模拟资产发行机构的角色（例如中央银行的现金）</li>
<li>net.corda.samples.demos.irs：展示两家银行之间的利率互换协议</li>
<li>net.corda.samples.demos.notary：一个节点获得多个事务的简单演示，由分布式（Raft或BFT SMaRt）公证人公证</li>
<li>net.corda.samples.demos.simmvaluation：SIMM评估和分布式账本协议的演示</li>
<li>net.corda.samples.demos.trader：演示了四个节点：公证人，现金发行人（Corda银行）和两个彼此进行交易的人，用现金交换商业票据</li>
<li>net.corda.node.smoke.test.utils：测试烟雾测试实用程序</li>
<li>net.corda.node.test.common：通用测试功能</li>
<li>net.corda.tools.demobench：一个GUI工具，允许在本地运行Corda节点进行演示</li>
<li>net.corda.tools.explorer：Corda的GUI前端</li>
<li>net.corda.tools.graphs：用于推断项目依赖性的实用程序</li>
<li>net.corda.tools.loadtest：Corda负载测试</li>
<li>net.corda.verifier：允许节点外交易验证，允许验证水平扩展</li>
<li>net.corda.webserver：是一个用于导出HTTP端点的CorDapps的servlet容器。该服务器是节点的RPC客户端</li>
<li>net.corda.sandbox-creator：沙箱实用程序</li>
<li>net.corda.quasar.hook：代理钩入Quasar并提供类型排除列表</li>
</ul>
<p><b style="color:#6ab0de"><code>net.corda</code>名称空间中包含<code>.internal</code>或<code>net.corda.node</code>仅供内部使用的任何软件包内的代码。未来版本将拒绝任何CorDapps使用这些包中的类型。</b></p>
<h3 id="DoNotImplement-注解"><a href="#DoNotImplement-注解" class="headerlink" title="@DoNotImplement 注解"></a><code>@DoNotImplement</code> 注解</h3><p>Corda API中的某些接口和抽象类已被标注为@DoNotImplement。虽然我们承诺不删除或修改任何这些类的现有功能，但注释是我们可能需要在将来版本的Corda中扩展它们的警告。因此，Cordapp开发人员应该“按原样”使用这些类，而不是试图扩展或实现它们中的任何一个。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Corda普遍使用一种自定义形式的安全二进制序列化。这样做的目的是：</p>
<ul>
<li>希望有一个模式（schema）描述与实际数据一起被序列化的内容<ul>
<li>版本控制（以前的序列化数据也能被识别）</li>
<li>为了更容易编写泛型代码，例如可以导航序列化数据形式的用户接口。</li>
<li>支持跨平台（非JVM）交互，其中类文件的格式不容易解释。</li>
</ul>
</li>
<li>希望使用独立于平台并且不受第三方库升级等影响的文档化和静态线路格式。</li>
<li>希望支持开放式多态，其中超类的子类的数量可以随时间扩展并且子类不需要在模式中预先定义。这是很多Corda概念的关键，例如状态。</li>
<li>通过支持的构造函数构造反序列化对象来提高安全性，而不是直接将数据插入到其字段中，而没有机会验证一致性或拦截尝试操纵假定的不变量。</li>
<li>二进制格式比数字签名更适用于基于文本的格式，因为修改语法的范围要小得多，而不是语义。</li>
</ul>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>经典的Java序列化，JVM类路径上的任何类都可以反序列化。通过利用类路径上的大量第三方库作为JVM应用程序依赖关系和精心设计的反序列字节流的一部分，这已被证明是漏洞利用和漏洞的来源。在Corda中，我们通过坚持每个对象的类属于允许的类的白名单中，阻止任何类被反序列化（并在序列化过程中主动）。</p>
<p>类通过三种机制之一进入白名单：</p>
<ul>
<li>通过<code>@CordaSerializable</code>注解。这个注解可能存在接口和超类的注解上。</li>
<li>通过实现<code>SerializationWhitelist</code>接口并指定白名单类别的列表。</li>
<li>通过内置的Corda白名单（见<code>DefaultWhitelist</code>类）。虽然这不是用户可编辑的，但它列出了为方便您而列入白名单的常见JDK类。</li>
</ul>
<p>注解的方式是加入白名单的首选方式。<a href="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html" target="_blank" rel="noopener">Using the client RPC API</a>是一个实例。</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>目前，基于Kryo的格式仍然被客户端和服务器端的RPC框架所使用。但是，计划很快RPC框架将转向AMQP框架。</p>
<p>将序列化方案分离到不同的上下文中使我们能够为该上下文使用最合适的框架，而不是试图强制采取一刀切的方法。Kryo更适合于程序堆栈框架的序列化，因为它比我们的AMQP框架在构建和序列化方面更加灵活。但是，这种灵活性使得安全性变得异常困难。相反，我们的AMQP框架允许我们专注于可以推理的安全框架，从而使安全性更低，安全漏洞更少。</p>
<h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><p>本节介绍AMQP序列化格式支持的类和接口。</p>
<ul>
<li>集合类型</li>
<li>JVM原始类型</li>
<li>数组</li>
<li>JDK类型：支持的类型可以查阅原文</li>
<li>第三方的类型</li>
<li>Corda类型：<code>@CordaSerializable</code>注解的类和接口</li>
</ul>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>您自己的类型必须遵守以下支持的规则：</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h5><ol>
<li>该类必须使用包含在<code>.class</code>文件中的参数名称进行编译。这是Kotlin中的默认设置，但必须使用<code>javac</code>的<code>-parameters</code>命令行选项打开。</li>
<li>这个类必须要用<code>@CordaSerializable</code>注解</li>
<li>必须支持构造函数参数，getter和setter的声明类型，并且在使用泛型时，泛型参数必须是受支持的类型，开放式通配符（*）或有界通配符，该通配符目前被扩展为开放式通配符</li>
<li>任何超类都必须遵守相同的规则，但可以是抽象的</li>
<li>对象引用循环不受支持，因此对象无法直接或间接引用自身</li>
</ol>
<h4 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h4><p>Corda的AMQP序列化框架实例化对象的主要方式是通过指定的构造函数。这用于首先确定对象的哪些属性将被序列化，然后在反序列化时用于使用序列化值实例化对象。</p>
<p>建议Corda中的可序列化对象遵守以下规则，因为它们允许不可变状态对象被反序列化：</p>
<ol>
<li>一个Java Bean getter，用于构造函数中的每个属性，并具有表单的名称<code>getX</code>。</li>
<li>一个构造函数，它采用您希望以序列化形式记录的所有属性。这是序列化框架重建类的一个实例所必需的.</li>
<li>如果提供了多个构造函数，则序列化框架需要知道使用哪一个。<code>@ConstructorForDeserialization</code> 注释可以被用来指示哪一个。对于没有<code>@ConstructorForDeserialization</code>注解的Kotlin类，将选择主构造函数</li>
</ol>
<h4 id="Setter实例化"><a href="#Setter实例化" class="headerlink" title="Setter实例化"></a>Setter实例化</h4><p>作为基于构造函数初始化的替代，Corda还可以通过检查类中存在的getter和setter方法来确定对象的重要元素。如果一个类只有一个默认的构造函数和属性，那么可序列化的属性将由该属性的getter和setter的存在来确定，这些属性都是公开可见的（即该类遵守可变JavaBean 的经典成语）。</p>
<p>在反序列化中，首先会创建一个默认实例，然后调用该对象以使用正确的值填充它。</p>
<h4 id="无法访问的私有属性"><a href="#无法访问的私有属性" class="headerlink" title="无法访问的私有属性"></a>无法访问的私有属性</h4><p>虽然Corda AMQP序列化框架支持私有对象属性，但没有可公开访问的getter方法，但强烈建议不要使用此开发习惯用法。</p>
<h4 id="不匹配的类属性-构造函数参数"><a href="#不匹配的类属性-构造函数参数" class="headerlink" title="不匹配的类属性/构造函数参数"></a>不匹配的类属性/构造函数参数</h4><p>考虑一个例子，您希望确保类型为某种形式容器的类的属性总是按照某些特定条件进行排序，但您希望保持该类的不变性。</p>
<h4 id="可变容器"><a href="#可变容器" class="headerlink" title="可变容器"></a>可变容器</h4><p>因为Java从根本上不提供可以确定类的可变性的机制，所以这给序列化框架带来了问题。当用容器属性（列表，地图等）重新构建对象时，我们必须选择是创建可变对象还是不可变对象。考虑到这些限制，我们决定保留不可变对象的不变性更好，而不是强制推断不可变对象的可变性。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>所有的枚举都支持，只要它们被<code>@CordaSerializable</code>注解。Corda支持枚举类型版本的互操作性。这允许这样的类型随时间改变而不破坏反向（或向前）兼容性。<a href="https://docs.corda.net/releases/release-V3.1/serialization-enum-evolution.html" target="_blank" rel="noopener">Enum Evolution</a>讨论了这样做的规则和机制。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>以下规则适用于受支持的<code>Throwable</code>实现。</p>
<ol>
<li>如果你希望你的异常是可序列化和安全传输的，它应该继承自<code>CordaException</code>或者<code>CordaRuntimeException</code></li>
<li>如果不是，该<code>Throwable</code>遗嘱将反序列化为一个<code>CordaRuntimeException</code>包含其中的原件的详细信息 <code>Throwable</code>，包括原始的类名称<code>Throwable</code></li>
</ol>
<h4 id="Kotlin对象"><a href="#Kotlin对象" class="headerlink" title="Kotlin对象"></a>Kotlin对象</h4><p>略</p>
<h3 id="类合成"><a href="#类合成" class="headerlink" title="类合成"></a>类合成</h3><p>Corda序列化支持在反序列化时从提供的模式动态合成类，而不在类路径中存在支持类。在通用代码可能希望能够对反序列化的数据，在JVM上运行的脚本语言以及确保不在类路径上的类可以反序列化而不加载潜在的恶意代码的情况下，这可能是有用的。</p>
<p>未来可能的增强包括：</p>
<ol>
<li>Java单例支持。我们将添加支持以识别单身人士的类别，并确定负责返回单身人士实例的静态方法</li>
<li>实例内化支持。我们将添加对确定应根据实例映射解析的类的支持，以避免创建许多相同（类似于String.intern()）的重复实例，</li>
</ol>
<h3 id="类型演变"><a href="#类型演变" class="headerlink" title="类型演变"></a>类型演变</h3><p>类型演化是类可以随时间改变的机制，但仍然可以在所有类型的版本中保持序列化和反序列化。这确保了一个对象的序列化，它具有旧类型的“看起来像”类可以被反序列化的版本以及实例化类的当前状态的版本。</p>
<p>更多细节可以在<a href="https://docs.corda.net/releases/release-V3.1/serialization-default-evolution.html" target="_blank" rel="noopener">Default Class Evolution</a>中找到。</p>
<h2 id="安全的编码准则"><a href="#安全的编码准则" class="headerlink" title="安全的编码准则"></a>安全的编码准则</h2><p>该平台通过默认设计确保安全。不幸的是，该平台无法防止各种安全错误。本文档描述了在编写应用程序以阻止各种攻击时需要考虑的问题。尽管假设没有合理的交易对手试图用流程级别的攻击来颠覆您的交易可能会很诱人，但是依靠信任来提高软件安全性会使您很难在稍后想要快速添加对手方并且没有广泛审查的情况下扩展您的业务。</p>
<h3 id="流动"><a href="#流动" class="headerlink" title="流动"></a>流动</h3><p><a href="https://docs.corda.net/releases/release-V3.1/flow-state-machines.html" target="_blank" rel="noopener">编写流程</a>是您的应用程序与网络上的其他各方进行通信的方式。因此，它们是恶意数据进入您应用程序的典型切入点，必须小心处理。</p>
<p>这些<code>receive</code>方法返回包装在<code>UntrustworthyData&lt;T&gt;</code>标记类型中的数据。这种类型不会添加任何功能，它只是提醒您正确验证从网络获得的所有内容。请记住，另一方可能没有运行您提供的用于参与流程的代码：他们被允许执行任何操作！需要注意的事项：</p>
<ul>
<li>例如，如果您建议为资产交易价值100美元的现金状态，并且签署的交易从另一方返回，则该交易与流程中较早建立或建议的部分交易不匹配，您必须检查它指向您实际请求的状态。否则，攻击者可以让你签署一项交易，如果他们知道一个ID的话，那么这笔交易将花费更多的时间给你。</li>
<li>一个不正确类型的交易。有两种交易类型：普通和公证变更。如果您希望获得一种类型，但获得另一种类型，则可能会发现自己签署了一项交易，将您的资产转移到敌对公证人的控制之下。</li>
<li>交易中各状态的意外更改。如果您有权访问所有需要的数据，则可以重新运行构建器逻辑并对结果状态进行比较，以确保它符合您的预期。例如，如果构建下一个状态所需的数据对双方都可用，则计算您想要相互同意的交易的函数可以在实现流程的两端的两个类之间共享。</li>
</ul>
<p>主题应该清楚：签名是一项非常敏感的操作，因此您需要确保您知道您要签名的是什么，并且输出没有任何变化！一旦您通过交易向交易对手提供了您的签名，就不再有任何事情可以阻止他们将其交付给分类账。</p>
<h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><p>合同是JVM沙箱内的任意函数，因此它们有很大的自由度。需要注意的事项：</p>
<ul>
<li>当前状态转换不应允许的状态更改。你会想要检查没有领域正在改变，除了预期的领域！</li>
<li>意外捕获并丢弃可能由验证逻辑抛出的异常。</li>
<li>如果您不知道其他合约是做什么或可能做什么，则通过虚拟方法调用其他合约。</li>
</ul>
<h2 id="流程cookbook"><a href="#流程cookbook" class="headerlink" title="流程cookbook"></a>流程cookbook</h2><p><a href="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html" target="_blank" rel="noopener">该流程</a>展示了如何在Java和Kotlin中使用Corda的API。</p>
<h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><p><a href="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html" target="_blank" rel="noopener">这个网页</a>是Corda知识的备忘单。</p>
<h2 id="Cordapp示例"><a href="#Cordapp示例" class="headerlink" title="Cordapp示例"></a>Cordapp示例</h2><p><a href="https://docs.corda.net/releases/release-V3.1/building-a-cordapp-samples.html" target="_blank" rel="noopener">CorDapp samples</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/31/blockchain/corda/Corda基础学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/blockchain/corda/Corda基础学习/" itemprop="url">Corda基础学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T17:40:02+08:00">2018-05-31</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇的博客中，我提到了Corda的一些基础的知识，但是那个版本是比较旧的，这次针对新的版本，写一些笔记来完成相应的更新。</p>
<h2 id="Corda-Network"><a href="#Corda-Network" class="headerlink" title="Corda Network"></a>Corda Network</h2><p>关于Corda的网络，有以下几点：</p>
<ol>
<li>这个网络由运行Corda和CorDapps的节点组成。</li>
<li>网络是授权的，通过doorman控制权限</li>
<li>节点之间的通信是点对点的，不依赖全局广播。</li>
</ol>
<h3 id="Network结构"><a href="#Network结构" class="headerlink" title="Network结构"></a>Network结构</h3><p>主要的组成就是Corda Service和Cordapps。</p>
<p>节点之间的通信是直接的，通过AMQP发送TLS加密的信息。是点对点的，不采用广播的方式。</p>
<p>每个网络存在网络映射服务，可以发布网络上每个节点都可以访问的IP地址，以及这些节点的身份证书和它们提供的服务。</p>
<h3 id="doorman"><a href="#doorman" class="headerlink" title="doorman"></a>doorman</h3><p>Corda网络是半私人的。每个网络都有一个门卫服务，用于执行关于节点必须提供的信息的规则以及他们在被允许进入网络之前必须完成的了解您的客户流程。</p>
<p>要加入网络，节点必须联系门卫并提供所需的信息。如果门卫感到满意，该节点将从网络的许可服务接收根权威机构签署的TLS证书。此证书在与网络上的其他参与者通信时验证节点的身份。</p>
<p><b style="color:red">注：在源码中发现就是发送http请求，而且还要设置一个URL。详细的信息可以参阅源码部分。</b></p>
<p>我们可以将网络可视化如下：</p>
<p><img src="https://docs.corda.net/head/_images/network.png" alt=""></p>
<h3 id="Network中的服务"><a href="#Network中的服务" class="headerlink" title="Network中的服务"></a>Network中的服务</h3><p>节点可以提供几种类型的服务：</p>
<ul>
<li>一个或多个可插式公证服务。公证人保证分类账更新的唯一性和可能性。每个公证服务可以在单个节点上运行，也可以在一组节点上运行。</li>
<li>零个或更多的Oracle服务。Oracle是一个众所周知的服务，如果他们陈述事实并且事实被认为是真实的，那么它就会签署交易。</li>
</ul>
<h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><p>概要</p>
<ul>
<li>分类账从每个同行的角度来看都是主观的</li>
<li>两位同行总是保证看到他们分享的任何分类账事实完全相同的版本</li>
</ul>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在Corda，没有单一的中央数据存储。相反，每个节点都维护一个已知事实的单独数据库。因此，每个同行只能看到分类帐上的一小部分事实，并且没有同行完全知道分类账。</p>
<p>例如，想象一个具有五个节点的网络，其中每个彩色圆圈表示一个共享事实：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/ledger-venn.png" alt=""></p>
<h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><p>概要</p>
<ul>
<li>Corda中的身份可以代表合法身份或服务身份</li>
<li>身份证明由门卫签署的X.509证书或公认的身份证明</li>
<li>众所周知的身份发布在网络地图中（NetworkMapService，这个在源码中我们也可以看到）</li>
<li>机密身份仅在需要了解基础时共享</li>
</ul>
<p>Corda中的身份可以表示：</p>
<ul>
<li>一个组织的法律身份</li>
<li>网络服务的服务标识（该节点只是提供服务而已）</li>
</ul>
<p>法律身份用于交易中的各方，例如现金状态的所有者。服务标识用于提供与交易相关的服务的人员，例如公证人员或oracle。服务身份与合法身份不同，因此分布式服务可以存在于不同组织所拥有的节点上。这种分布式服务身份是基于的<code>CompositeKeys</code>，它描述了服务签名的有效签名者集合。有关CompositeKeys的更多技术细节，请参阅<a href="https://docs.corda.net/releases/release-V3.1/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a>。</p>
<p><b style="color:red">身份是众所周知的还是保密的，取决于他们的X.509证书（和对应的证书路径是否可信的根证书）已发布：</b>.</p>
<ul>
<li>众所周知的身份是法律实体或服务的一般可识别的公钥，这使得它们不适用于需要参与者保密的交易。此证书已发布在网络地图服务中供任何人访问。</li>
<li>机密身份只发布给参与交易身份的人员。公钥可能暴露给第三方（例如公证服务），但名称和X.509证书的分发是有限的。</li>
</ul>
<p>虽然Corda交易隐私模式有几个要素，包括确保交易只与需要查看它们的用户共享以及有计划地使用英特尔SGX，但重要的是要提供深入的防御隐私攻击。机密身份用于确保即使第三方访问未加密的交易，他们也无法在没有附加信息的情况下识别参与者。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>节点必须能够验证使用X.509证书实现的公钥所有者的身份。<b style="color:red">首次运行时，节点生成密钥对并向网络门卫服务提交证书签名请求</b>（请参阅 <a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>）。Doorman服务应用适当的身份检查，然后向用作节点认证中心（CA）的节点发放证书。从该初始CA证书中，节点自动创建并签署两个其他证书，一个TLS证书(sslKeyStore)和一个用于该节点众所周知的身份的签名证书(nodeKeyStore)。最后，节点建立包含其地址和众所周知的身份的节点信息记录，并将其注册到网络地图服务。</p>
<p>组织可以从签署证书创建公开和机密身份。众所周知的身份的用例包括代表用于冗余目的的单个身份的节点集群，或者为组织单位创建身份。</p>
<p>组织需要决定他们希望在网络地图服务中发布哪些身份，使其广为人知，并且出于隐私原因（通常是为了避免暴露商业敏感的交易细节），他们希望将其保留为机密身份。在某些情况下，出于操作原因，除了主网络地图服务之外，节点还可能使用专用网络地图服务。使用此类网络地图注册的身份必须被认为是众所周知的，并且将机密身份存储在中央目录中，而不在记录级别应用控制，以确保只有需要访问身份的人才能检索其证书。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>概要：</p>
<ul>
<li>状态代表了分类账事实</li>
<li>通过将当前状态标记为历史并创建更新状态来进行状态演变</li>
<li>每个节点都有一个保管库（Vault，可以是放入数据库中，有相应接口，默认是放在内存中），它在其中存储任何相关的状态</li>
</ul>
<h3 id="概观-1"><a href="#概观-1" class="headerlink" title="概观"></a>概观</h3><p>状态可以包含任意数据，允许它们表示任何种类的事实（例如股票，债券，贷款，KYC数据，身份信息……）。例如，以下状态代表IOU - 爱丽丝欠Bob的协议金额X：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/state.png" alt=""></p>
<p>除了关于事实本身的任何信息外，状态还包含对管理状态演变随时间推移的合约的引用。</p>
<h3 id="状态序列"><a href="#状态序列" class="headerlink" title="状态序列"></a>状态序列</h3><p>共享事实随时间的生命周期由状态序列表示。当一个状态需要更新时，我们创建代表世界新状态的新版本状态，并将现有状态标记为历史状态。</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/state-sequence.png" alt=""></p>
<h3 id="金库-Vault"><a href="#金库-Vault" class="headerlink" title="金库(Vault)"></a>金库(Vault)</h3><p>网络上的每个节点都有一个保管库 - 一个数据库，用于追踪所有当前和历史状态，以及它认为与自身相关的所有当前状态和历史状态.</p>
<h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>概要</p>
<ul>
<li>每个输入和输出状态的合约都必须接受有效的交易</li>
<li>合约是用JVM编程语言（如Java或Kotlin）编写的，</li>
<li>合约执行是确定性的，其对交易的接受仅基于交易的内容</li>
</ul>
<h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><p>回想一下，交易只有在所有必需的签名者都进行了数字签名的情况下才有效。但是，即使交易收集了所有必需的签名，它也仅在合约有效的情况下才有效。</p>
<p>合约有效性定义如下：</p>
<ul>
<li>每个状态都指向一份合约</li>
<li>一个合约需要一个交易作为输入，并指出根据合约的规则的交易是否被认为是有效的</li>
<li>只有当每个输入状态和每个输出状态的合约认为其有效时，交易才有效</li>
</ul>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/tx-validation.png" alt=""></p>
<p>合约代码可以用任何JVM语言编写，并且可以使用该语言的全部功能，包括：</p>
<ul>
<li>检查输入，输出，命令，时间戳和/或附件的数量</li>
<li>检查这些组件的内容</li>
<li>循环构造，变量赋值，函数调用，辅助方法等</li>
<li>将类似的状态分组以验证它们是否为一组（例如，对所有现金状态的总价值施加一个规则）</li>
</ul>
<p>非契约有效的交易不是更新分类帐的有效提案，因此不能提交给分类账。通过这种方式，合约对状态随时间推移的演变规定了独立于所需签名人签署给定交易的意愿的规则。</p>
<h3 id="合约沙箱"><a href="#合约沙箱" class="headerlink" title="合约沙箱"></a>合约沙箱</h3><p>交易验证必须是确定性的 - 合约应始终接受或始终拒绝给定的交易。例如，交易有效性不能取决于进行验证的时间，也不取决于合作伙伴运行合约的信息量。这是确保网络上的所有同行对特定分类帐更新的有效性达成共识的必要条件。</p>
<p><b style="color:red">为了达到这个目的，合约评估确定性沙箱中的交易。沙盒有一个白名单（这就是在源码看到的WhiteList的作用了吧，不过这个白名单是针对附件的），可以防止合约导入可能成为非确定性来源的库</b>。这包括提供当前时间的库，随机数生成器，提供文件系统访问的库或网络库等。最终，验证交易时可用于合约的唯一信息是交易本身中包含的信息。</p>
<h3 id="合约限制"><a href="#合约限制" class="headerlink" title="合约限制"></a>合约限制</h3><p>由于合约无法获得外部信息，它只能检查交易的内部有效性。例如，它不能检查交易是否与最初与交易对手达成一致。</p>
<p>因此，同事在签署交易之前应检查交易内容，即使交易合约有效，以查看他们是否同意提议的分类帐更新。同行没有义务签署一项交易，只是因为它在合约中有效。例如，他们可能不愿意承担过大的贷款，或可能不同意为资产提供的现金数额。</p>
<h3 id="神谕（Oracle）"><a href="#神谕（Oracle）" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h3><p>有时，交易有效性将取决于一些外部信息，例如汇率。在这些情况下，需要一个oracle。有关更多详细信息，请参阅Oracles。</p>
<h3 id="法律散文（legal-prose）"><a href="#法律散文（legal-prose）" class="headerlink" title="法律散文（legal prose）"></a>法律散文（legal prose）</h3><p>每份合约还涉及法律散文文件，其中规定了与传统法律体系兼容的随时间推移的状态演变规则。在法律纠纷的情况下，可以依靠这份文件。</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>概要</p>
<ul>
<li>交易是更新分类账的建议</li>
<li>交易提案承诺以下情况：<ul>
<li>它不包含双重花费</li>
<li>这是合约有效的</li>
<li>它由所需方签署</li>
</ul>
</li>
</ul>
<p>Corda使用UTXO（未使用的交易输出）模型。</p>
<h3 id="交易链"><a href="#交易链" class="headerlink" title="交易链"></a>交易链</h3><p>这些输入状态引用（StateRef）将交易连接在一起，形成所谓的交易链。</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/tx-chain.png" alt=""></p>
<h3 id="提交交易"><a href="#提交交易" class="headerlink" title="提交交易"></a>提交交易</h3><p>最初，交易只是更新分类帐的建议.<br><img src="https://docs.corda.net/releases/release-V3.1/_images/uncommitted_tx.png" alt=""></p>
<p>要成为现实，交易必须接收所有必需的签名者的签名（参见下面的命令）。每位必需的签名者将其签名附加到交易中以表明他们批准该提案：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/tx_with_sigs.png" alt=""></p>
<p>如果所有必需的签名都被收集起来，交易将变为承诺：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/committed_tx.png" alt=""></p>
<p>这意味着：</p>
<ul>
<li>交易的输入被标记为历史性的，并且不能用于任何未来的交易</li>
<li>交易的产出成为分类账当前状态的一部分</li>
</ul>
<h3 id="交易有效性"><a href="#交易有效性" class="headerlink" title="交易有效性"></a>交易有效性</h3><p>如果以下两个条件成立，每个必需的签名者只应签署交易：</p>
<ul>
<li>交易有效性：对于提议的交易以及创建当前提议的交易输入的交易链中的每个交易：<ul>
<li>交易由所有必要方进行数字签名</li>
<li>合约验证交易有效</li>
</ul>
</li>
<li>交易唯一性：没有其他交易已经消耗了我们建议交易的任何投入</li>
</ul>
<h3 id="其他交易组件"><a href="#其他交易组件" class="headerlink" title="其他交易组件"></a>其他交易组件</h3><p>除输入状态和输出状态外，交易可能包含：</p>
<ul>
<li>命令</li>
<li>附件</li>
<li>时间戳</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>假设我们有一个以现金状态和债券状态作为输入的交易，以现金状态和债券状态作为输出。该交易可能代表两种不同的情况：</p>
<ul>
<li>债券购买</li>
<li>债券上的息票支付</li>
</ul>
<p>我们可以想象，我们希望对构成有效交易的内容施加不同的规则，具体取决于这是购买还是优惠券付款。例如，在购买的情况下，我们需要改变债券的当前所有者，而在支付息票的情况下，我们会要求债券的所有权不变。</p>
<p>为此，我们有命令。在交易中包含命令可以让我们指出交易的意图，从而影响我们如何检查交易的有效性。</p>
<p>每个命令还与一个或多个签名者列表关联。通过将命令中列出的所有公钥的联合，我们得到交易所需的签名者列表。在我们的例子中，我们可以想象：</p>
<ul>
<li>在债券的息票付款中，只有债券所有者需要签署</li>
<li>在现金支付中，只需要现金的所有者签字</li>
</ul>
<p>我们可以看到这种情况如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/commands.png" alt=""></p>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>有时，我们有大量的数据可以在许多不同的交易中重用。一些例子：</p>
<ul>
<li>公众假期日历</li>
<li>支持法律文件</li>
<li>货币代码表</li>
</ul>
<p>对于这个用例，我们有附件。每个交易可以通过哈希引用零个或多个附件。这些附件是包含任意内容的ZIP/JAR文件。这些文件中的信息可以在检查交易的有效性时使用。</p>
<h3 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h3><p>在某些情况下，我们希望建议的交易只能在特定时间段内批准。例如：</p>
<ul>
<li>期权只能在特定日期后执行</li>
<li>债券只能在到期日前赎回</li>
</ul>
<p>在这种情况下，我们可以为交易添加一个时间窗口。时间窗口指定了可以提交事务的时间窗口。我们讨论时间窗口部分的时间窗口。</p>
<h2 id="流程（Flow）"><a href="#流程（Flow）" class="headerlink" title="流程（Flow）"></a>流程（Flow）</h2><p>概要</p>
<ul>
<li>流程自动化了同意分类帐更新的过程</li>
<li>节点之间的通信只发生在这些流程的上下文中，并且是点对点的</li>
<li>提供了内置流程来自动化常见任务</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>Corda网络使用点对点消息而不是全局广播。这意味着协调分类帐更新需要网络参与者准确指定需要发送的信息，交易对手以及以何种顺序。</p>
<p>以下是在Alice和Bob之间就简单分类账更新达成一致的过程的可视化：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/flow.gif" alt=""></p>
<h3 id="流程框架"><a href="#流程框架" class="headerlink" title="流程框架"></a>流程框架</h3><p>Corda不需要手动指定这些步骤，而是使用流程自动化流程。流程是一系列步骤，告诉节点如何实现特定的分类帐更新，例如发放资产或结算交易。</p>
<p>以下是上述简单分类账更新中涉及的流程步骤顺序：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/flow-sequence.png" alt=""></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>一旦给定的业务流程被封装在流中并作为CorDapp的一部分安装在节点上，节点的所有者就可以指示节点随时使用RPC调用启动该业务流程。该流程将所有网络，I / O和并发问题从节点所有者中抽象出来。</p>
<p>节点上的所有活动都发生在这些流程的上下文中。与合约不同，流程不在沙箱中执行，这意味着节点可以执行诸如网络，I/O等操作，并在流程执行过程中使用随机源。</p>
<h4 id="节点间通信"><a href="#节点间通信" class="headerlink" title="节点间通信"></a>节点间通信</h4><p>节点通过在流之间传递消息进行通信。每个节点具有零个或多个流类，它们被注册为响应来自单个其他流的消息。</p>
<p>假设Alice是网络上的一个节点，并希望与另一个网络节点Bob同意分类帐更新。为了与Bob沟通，Alice必须：</p>
<ul>
<li>开始注册Bob回应的流程</li>
<li>在该流程的上下文中向Bob发送消息</li>
<li>鲍勃将开始注册的交易对手流程</li>
</ul>
<p>现在建立了一个连接，Alice和Bob可以通过传递一系列来回传递的消息来同意分类账更新，如流程步骤中所规定的那样。</p>
<h4 id="子流程"><a href="#子流程" class="headerlink" title="子流程"></a>子流程</h4><p>可以通过在另一个流程的上下文中将流程作为子流程启动来组成流程。作为子流程开始的流程称为子流程。父流程将一直等到子流程返回。</p>
<h4 id="流程库"><a href="#流程库" class="headerlink" title="流程库"></a>流程库</h4><p>Corda提供了一个处理常见任务的流程库，这意味着开发人员不必重新定义常见流程背后的逻辑，例如：</p>
<ul>
<li>公证和记录交易</li>
<li>从对手方节点收集签名</li>
<li>验证一系列交易</li>
</ul>
<p>有关可用内置流程的更多信息，请参见<a href="https://docs.corda.net/releases/release-V3.1/flow-library.html" target="_blank" rel="noopener">Flow库</a>。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>流程框架允许节点一次有多个活动流。这些流量可能持续数天，跨节点重启甚至升级。</p>
<p>这是通过将数据流序列化到磁盘来实现的，只要它们进入阻塞状态（例如，当它们正在等待I / O或网络呼叫时）。与其等待流程畅通无阻，节点立即开始处理任何其他计划流程，仅在以后返回到原始流程。</p>
<h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>概要</p>
<ul>
<li>承诺，交易必须达到有效性和唯一性共识</li>
<li>有效性共识需要交易及其所有依赖关系的合约有效性</li>
<li>唯一性共识可以防止双重花费</li>
</ul>
<h3 id="两种共识"><a href="#两种共识" class="headerlink" title="两种共识"></a>两种共识</h3><p>确定提议的交易是否是有效的分类帐更新涉及达成两种类型的共识：</p>
<ul>
<li>有效性共识 - 在签署交易前由每个必需签署者检查</li>
<li>唯一性共识 - 只有公证服务才能检查</li>
</ul>
<p>有效性共识是检查以下条件是否适用于拟议交易以及交易链中为交易提议交易产生输入的每个交易的过程：</p>
<ul>
<li>交易被每个输入和输出状态的合约所接受</li>
<li>交易拥有所有必需的签名</li>
</ul>
<p>验证提议的交易本身是不够的。我们还必须核实导致建立交易建议输入的交易链中的每一笔交易。</p>
<p>这就是所谓的走链。例如，假设网络上的一方提出将我们的国债转让给我们的交易。在下列情况下，我们只能确保债券转移有效：</p>
<ul>
<li>国债是由中央银行在有效的发行交易中发行的</li>
<li>债券交易后的每一次交易都是有效的</li>
</ul>
<h3 id="唯一性共识"><a href="#唯一性共识" class="headerlink" title="唯一性共识"></a>唯一性共识</h3><p>唯一性共识是要求所提议的交易的投入没有一个在另一笔交易中已经消耗。</p>
<p>如果一个或多个输入已经在另一个交易中被使用，这就是所谓的双重支出，并且交易提议被认为是无效的。</p>
<p>公证人提供了唯一性共识。请参阅公证人了解更多详情。</p>
<h2 id="公证人（Notary）"><a href="#公证人（Notary）" class="headerlink" title="公证人（Notary）"></a>公证人（Notary）</h2><p>概要</p>
<ul>
<li>公证人防止“双花”</li>
<li>公证员也可以选择验证交易</li>
<li>一个网络可以有几个公证人，每个公证人都运行不同的共识算法</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个公证是一种网络服务，它提供了独特的共识被证明的是，对于一个给定的交易，它尚未签署消耗任何拟议中的交易的输入状态的其他交易。</p>
<p>在被要求公证交易时，公证人可以：</p>
<ul>
<li>如果交易尚未签署其他消耗建议交易输入状态的交易，请签署交易</li>
<li>拒绝该交易并标记双重支出尝试已经发生</li>
</ul>
<p>这样做，公证人提供了系统中的终点。在获得公证人的签名之前，各方不能确定同等有效但冲突的交易不会被视为花费给定输入状态的“有效”尝试。但是，在获得公证人的签名后，我们可以确定提议的交易的输入状态尚未被先前的交易消耗。因此，公证是系统中的终点。</p>
<p>每个状态都有一个指定的公证人，如果公证人是所有交易输入状态的指定公证人，公证人只会公证一项交易。</p>
<h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>Corda具有“可插入”的共识，允许公证人根据隐私，可扩展性，法律系统兼容性和算法敏捷性的要求选择一致的算法。</p>
<p>特别是，公证人在以下方面可能会有所不同：</p>
<ul>
<li>结构 - 公证可能是单个网络节点，相互信任的节点群或相互不信任的节点群</li>
<li>共识算法 - 公证服务可以选择运行高速，高可信度算法，如RAFT，低速低信任算法（如BFT），或者其他任何其他共识算法</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>公证服务还必须在提交之前通过确认每笔交易来决定是否提供有效性共识。在作出这个决定时，他们面临以下的交易：</p>
<ul>
<li><b style="color:red">如果一个交易没有被检查有效性，它会产生“拒绝状态”攻击的风险，在这种情况下，一个节点明知地建立一个无效的事务，消耗一些现有状态并将其发送给公证人，导致这些状态被标记为已消耗。（这是攻击风险，需要验证交易合法性以抵制这种攻击）</b>.</li>
<li>如果交易被检查的有效性，公证员将需要看到交易及其依赖的全部内容。这泄露了可能的私人数据给公证人</li>
</ul>
<p>在评估这种折衷时，还有几点需要注意。在非验证模型的情况下，Corda的受控数据分布模型意味着关于未消费状态的信息并未广泛共享。此外，Corda的许可网络意味着公证人可以存储创建“拒绝状态”交易的一方的身份，从而使得攻击能够逐个解决。</p>
<p>在验证模型的情况下，使用匿名的，新近生成的公钥而不是法定身份来识别交易中的当事方会限制公证人看到的信息。</p>
<h3 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h3><p>每个Corda网络可以有多个公证员，每个公证员可能运行不同的共识算法。这提供了几个好处：</p>
<ul>
<li>隐私 - 我们可以在同一网络上同时具有验证和非验证公证服务，每个都运行不同的算法。这使得节点能够按照每个交易选择首选公证人</li>
<li>负载平衡 - 通过多个公证处理交易负载可以为整个平台提供更高的交易吞吐量</li>
<li>低等待时间 - 等待时间可以通过选择与交易双方身体接近的公证员来最小化</li>
</ul>
<h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>请记住，如果公证人是所有交易输入状态的指定公证人，则公证人只会签署交易。但是，有些情况下我们可能需要更换状态的指定公证人。这些包括：</p>
<ul>
<li>当单个交易需要消耗具有不同指定公证人的多个状态时</li>
<li>由于隐私或效率问题，节点宁愿为给定的交易使用不同的公证人</li>
</ul>
<p>在这些交易可以创建之前，必须首先将各状态重新命名为全部具有相同的公证人。这是通过使用特殊的公证人更改交易来实现的，该交易需要：</p>
<ul>
<li>单个输入状态</li>
<li><b style="color:red">与输入状态相同的输出状态，但指定的公证人已更改（将输入的公证人更改掉作为输入即可）</b></li>
</ul>
<p>输入状态的指定公证人将签署交易，如果它不构成双重花费，此时一个状态将进入具有旧状态所有财产的存在，但具有不同的指定公证人。</p>
<h2 id="时间窗口-1"><a href="#时间窗口-1" class="headerlink" title="时间窗口"></a>时间窗口</h2><p>概要</p>
<ul>
<li>如果交易包含时间窗口，则只能在该窗口期间提交</li>
<li>公证人是时间戳管理机构，拒绝在该窗口之外提交交易</li>
<li>时间窗口可以有开始和结束时间，也可以在任何一端打开</li>
</ul>
<h3 id="在分布式系统中的时间"><a href="#在分布式系统中的时间" class="headerlink" title="在分布式系统中的时间"></a>在分布式系统中的时间</h3><p>公证人还充当时间戳的权力，验证在公证之前在特定时间窗口发生的交易。</p>
<p>创建交易的一方和公证人之间永远不会有精确的时钟同步。这不仅仅是由于物理和网络延迟的问题，而且还因为在插入命令和获得公证签名之间可能有许多其他步骤（例如将交易发送给交易中涉及的其他方，请求人签字…）。因此交易发送给公证人的时间可能与交易创建时间大不相同。</p>
<p>假设公证人的时间馈送是由美国海军天文台的原子钟定义的GPS / NaviStar时间。这个是非常准确的，全球免费提供。</p>
<h2 id="神谕（Oracle）-1"><a href="#神谕（Oracle）-1" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h2><p>概要</p>
<ul>
<li>事实可以作为命令的一部分包含在交易中</li>
<li>如果包含的事实是真实的，则oracle是一种仅签署交易的服务</li>
</ul>
<h3 id="概观-2"><a href="#概观-2" class="headerlink" title="概观"></a>概观</h3><p>在很多情况下，交易的合约效力取决于一些外部数据，例如当前的汇率。但是，如果我们要让每个参与者根据他们自己对当前汇率的看法来评估交易的有效性，那么合同的执行将是非确定性的：一些签名者会认为交易是有效的，而另一些则认为它是无效的。因此，会在分类账的真实状态上产生分歧。</p>
<p>Corda使用oracles解决了这个问题。神谕（Oracle）是网络服务，根据请求提供封装特定事实（例如，时间x时的汇率）的命令，并将神谕列为必需的签名者。</p>
<p><b style="color:red">如果一个节点希望在交易中使用某个事实，他们会请求一个命令，从oracle中断言这个事实。如果oracle认为事实是真的，他们会发回所需的命令。然后节点将这个命令包含在他们的交易中，并且oracle将签署该交易来断言事实是真实的。</b></p>
<p>如果他们希望将他们的服务货币化，神谕可以选择只签署一笔交易，并证明其收取的费用是有效的。</p>
<h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p><a href="/2018/05/30/blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E4%BA%A4%E6%98%93%E6%8B%86%E5%88%86">交易拆分</a></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>概要</p>
<ul>
<li>节点是JVM运行时间，具有运行Corda软件的唯一网络标识</li>
<li>该节点有两个与外界的接口：<ul>
<li>网络层，用于与其他节点交互</li>
<li>RPC，用于与节点的所有者进行交互</li>
</ul>
</li>
<li>通过在插件注册表中安装CorDapps来扩展节点的功能</li>
</ul>
<h3 id="节点架构"><a href="#节点架构" class="headerlink" title="节点架构"></a>节点架构</h3><p>Corda节点是一个JVM运行时环境，在网络上具有唯一身份，用于承载Corda服务和CorDapps。</p>
<p>我们可以将节点的内部架构可视化如下：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/node-architecture.png" alt=""></p>
<p>该体系结构的核心要素是：</p>
<ul>
<li>用于存储数据的持久层</li>
<li>用于与其他节点交互的网络接口</li>
<li>用于与节点所有者进行交互的RPC接口</li>
<li>一个服务中心（ServiceHub），用于允许节点的流程调用节点的其他服务</li>
<li>通过安装CorDapps扩展节点的cordapp界面和提供程序</li>
</ul>
<h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p>持久层有两部分：</p>
<ul>
<li>Vault，其中节点存储任何相关的当前和历史状态</li>
<li>存储服务（StorageService），它存储数据，附件和流程检查点（checkpoints）</li>
</ul>
<p>节点的所有者可以使用RPC接口查询节点的存储（见下文）。</p>
<h3 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h3><p>作为运行流程的一部分，与网络中其他节点的所有通信都由节点本身处理。节点的所有者不直接与其他网络节点交互。</p>
<h3 id="RPC接口"><a href="#RPC接口" class="headerlink" title="RPC接口"></a>RPC接口</h3><p>节点的所有者通过远程过程调用（RPC）与节点交互。<a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">API：RPC操作</a>记录了节点公开的关键<a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">RPC操作</a>。</p>
<h3 id="服务中心（ServiceHub）"><a href="#服务中心（ServiceHub）" class="headerlink" title="服务中心（ServiceHub）"></a>服务中心（ServiceHub）</h3><p>在内部，节点可以访问在流程执行期间使用的一组丰富的服务，以协调分类帐更新。提供的主要服务是：</p>
<ul>
<li>有关网络上其他节点及其提供的服务的信息</li>
<li>访问保管库（Vault）内容和存储（Storage）服务</li>
<li>访问和生成节点的公钥 - 私钥对</li>
<li>关于节点本身的信息</li>
<li>当前时间，由节点跟踪</li>
</ul>
<h3 id="CorDapp提供商"><a href="#CorDapp提供商" class="headerlink" title="CorDapp提供商"></a>CorDapp提供商</h3><p>CorDapp提供程序是安装新的CorDapps以扩展节点行为的地方。</p>
<p>该节点还默认安装了几个CorDapps来处理常见任务，例如：</p>
<ul>
<li>检索交易对方的交易和附件</li>
<li>升级合同</li>
<li>广播商定的分类账更新以供对手方记录</li>
</ul>
<h4 id="排水模式（Draining-mode）"><a href="#排水模式（Draining-mode）" class="headerlink" title="排水模式（Draining mode）"></a>排水模式（Draining mode）</h4><p>为了使节点能够干净关闭，重要的是没有流程正在运行中，这意味着不应该坚持检查点。该节点能够处于流程排放模式，在此期间：</p>
<ul>
<li>需要通过RPC启动新流程的命令将被拒绝。</li>
<li>预计将要执行将被忽略。（那么这些流程应该如何进行处理呢？）</li>
<li>最初的P2P会话消息将不会被处理，这意味着对等方将无法发起涉及该节点的新流程。</li>
<li>所有其他活动将照常进行，确保机内流程的数量将严格减少。</li>
</ul>
<p>由于它们的数量（可以通过RPC进行监控）达到零，所以关闭节点是安全的。该属性是持久的，这意味着重新启动节点不会将其重置为默认值，并且需要RPC命令。</p>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>概要</p>
<ul>
<li>权限的网络更适合财务用例</li>
<li>点对点通信允许共享需要知道的信息</li>
<li>UTXO模型允许每秒更多的交易处理</li>
</ul>
<h3 id="Permissioned-vs-permissionless"><a href="#Permissioned-vs-permissionless" class="headerlink" title="Permissioned vs. permissionless"></a>Permissioned vs. permissionless</h3><p>传统blockchain网络是permissionless。网络上的各方都是匿名的，可以随意加入和离开。</p>
<p>相比之下，Corda网络获得许可。网络上的每一方都有一个已知的身份，他们在与交易对手进行交流时使用，网络访问由门卫控制。这有几个好处：</p>
<ul>
<li>对于涉及受监管金融机构的大多数情况，匿名方不适用</li>
<li>了解您的交易对手的身份可以使用现有的法律体系，以分类方式解决冲突</li>
<li>如果没有使用诸如工作证明等昂贵的机制，Sybil攻击就可以避免</li>
</ul>
<h3 id="点对点与全球广播"><a href="#点对点与全球广播" class="headerlink" title="点对点与全球广播"></a>点对点与全球广播</h3><p>传统的区块链网络向每个参与者传播每一条消息。其原因有两方面：</p>
<ul>
<li>交易对手身份未知，因此必须将消息发送给每位参与者以确保其到达其预期接收者</li>
<li>让每个参与者意识到每一笔交易都可以让网络防止双重花费</li>
</ul>
<p>缺点是所有参与者都能看到其他人的数据。这在许多使用情况下是不可接受的。</p>
<p>在Corda中，每条消息都会发送给特定的对方，并且不会被任何无关的第三方看到。开发人员可以完全控制发送什么消息，向谁发送消息，以及按照什么顺序。因此，数据仅在需要知道的基础上共享。为了防止这种制度出现双重花费，我们聘请公证人作为工作证明的替代方案。</p>
<p>Corda还使用其他几种技术来最大化网络上的隐私：</p>
<ul>
<li>交易拆分：交易的结构方式允许他们在不公开交易内容的情况下进行数字签名。这是通过使用名为Merkle树的数据结构实现的。你可以在merkle-trees中阅读关于这种技术的更多信息。</li>
<li>密钥随机化：交易双方仅通过其公钥识别，并为每个交易生成新密钥对。因此，旁观者无法确定哪一方参与了某个交易。（公钥大家都可以看到，但是不会公布私钥，但是如何保证通信的安全是个问题）</li>
</ul>
<h3 id="UTXO与账户模式"><a href="#UTXO与账户模式" class="headerlink" title="UTXO与账户模式"></a>UTXO与账户模式</h3><p>Corda使用UTXO（未使用的交易输出）模型。每个交易消耗一组现有状态来产生一组新状态。</p>
<p>替代方案将是一个账户模型。在账户模型中，有状态对象存储在分类账上，事务采取请求的形式来更新这些对象的当前状态。</p>
<p>UTXO模型的主要优点是可以并行应用具有不同输入的交易，极大地增加了网络每秒潜在的交易量。在账户模型中，每秒交易数量受限于对给定对象的更新必须按顺序应用的事实。</p>
<h3 id="Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）"><a href="#Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）" class="headerlink" title="Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）"></a>Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）</h3><p>金融机构需要有能力利用传统的法律制度解决冲突。Corda旨在通过以下方式使其成为可能：</p>
<ul>
<li>拥有许可的网络，意味着参与者知道他们在每次交易中处理的是谁</li>
<li>所有的代码合约都有一份法律文件的支持，这些文件描述了可以依靠解决冲突的合约的预期行为</li>
</ul>
<h3 id="构建与重用"><a href="#构建与重用" class="headerlink" title="构建与重用"></a>构建与重用</h3><p>只要有可能，Corda就会重新使用现有技术，使整个平台更加强健。例如，Corda重复使用：</p>
<ul>
<li>用于开发CorDapps的标准JVM编程语言</li>
<li>现有的SQL数据库</li>
<li>现有的消息队列实现</li>
</ul>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://docs.corda.net/releases/release-V3.1/key-concepts.html" target="_blank" rel="noopener">https://docs.corda.net/releases/release-V3.1/key-concepts.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/blockchain/corda/Corda基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/blockchain/corda/Corda基础知识/" itemprop="url">Corda基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T16:28:29+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>corda是分布式账本技术的一种，另一种大家已经熟知的就是HyperLedger的Fabric。当然这种插件化的开发也有公共链上的石墨烯技术，这种技术也是插件化的挖矿节点的实现，但是石墨烯技术是C++语言的实现，这里我就不做更多的说明了，关于石墨烯更多的介绍可以点击<a href="https://github.com/cryptonomex/graphenes" target="_blank" rel="noopener">这里</a>。<a href="https://steemit.com/blockchain/@robinwen/bts-steem-eos" target="_blank" rel="noopener">这篇文章</a>也做了详细的介绍。</p>
<p>Corda与Fabric的区别，官网的说法是Corda专注于金融这块，而Fabric是基于组织联盟的，但是不管怎样分布式账本技术都是借鉴了区块链的设计思想的；Fabric是插件化的，而Corda是模块化的，我觉得这点在软件设计上有很大的区别。Corda是基于Kotlin开发的，而Fabric主力语言是Python，但是也可以使用其他语言，并不限制。</p>
<p>如果你想了解更多的Corda知识，可以参阅官网的<a href="https://docs.corda.net/releases/release-M7.0/_static/corda-introductory-whitepaper.pdf" target="_blank" rel="noopener">技术白皮书</a>。这个白皮书介绍了，这个系统最终的方案，现在还有很多未实现，正在实现中，当然在实现中可能会有与白皮书不一样的地方。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="包含的实现"><a href="#包含的实现" class="headerlink" title="包含的实现"></a>包含的实现</h3><p>Corda原型机目前包括：</p>
<ul>
<li>具有消息持久性和递送重试的对等网络。</li>
<li>用于定义合同和状态的关键数据结构。</li>
<li>智能合约，您可以在合约目录中找到。</li>
<li>与它们一起工作的算法，如序列化，散列，签名和签名验证。</li>
<li>API文档和教程（您正在阅读的内容）。</li>
<li>业务流程编排框架。</li>
<li>公证基础设施用于精确时间戳，并且在没有区块链的情况下消除双重花费。</li>
<li>一个简单的REST API和一个Web应用程序演示，用它来呈现IRS交易的前端。</li>
</ul>
<p>现在不包括，但是后面会进行实现的部分：</p>
<ul>
<li>沙盒，分销或发布智能合同代码</li>
<li>用于管理的用户界面</li>
</ul>
<p>现在的Corda版本仍然是创意的快速探索，所以为了提高开发的速度，会采取一些捷径，注意以下的一些事项：</p>
<ul>
<li>它使用一个对象映射序列化框架，而不是一个明确的，供应商中立的协议。</li>
<li>目前没有权限框架。（shiro或者Spring auth）</li>
<li>一些隐私技术尚未实施</li>
<li>它使用嵌入式SQL数据库，但尚未支持主流SQL供应商（Oracle，Postgres，MySQL，SQL Server等）的连接。</li>
</ul>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>在corda项目下定义了一些示例程序，这些程序在samples目录下，运行的命令如官网的命令，这里就不做更多说明了。</p>
<p><a href="https://docs.corda.net/releases/release-M7.0/running-the-demos.html" target="_blank" rel="noopener">运行演示</a></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>这里需要介绍状态（State）、交易（Transaction）和合约（Contract），以及它们之间的交互关系。</p>
<p>首先，交易消费的是状态（State），交易的作用就是将一个状态变换为一个新的状态。分类账被定义为一组不可变状态，由数字签名的交易创建和销毁。每个事务指向一组将要消耗/销毁的状态，这些状态称为输入，并且包含一组将会创建的新状态，这些状态称为 输出。</p>
<p>其次，合约定义了一个验证函数，这是一个纯函数，以交易为输入。要被视为有效，交易必须被输入和输出状态所指向的每个合约的验证功能所接受。</p>
<p>除了输入和输出之外，交易还可能包括命令，小数据包，平台不会自行解释，但可以参数化执行合约。<b style="color:blue">它们可以被认为是验证函数的参数。每个命令都有一个与之关联的公钥列表。该平台确保交易在合约开始执行之前由命令中列出的每个密钥签署。该平台确保交易在合同开始执行之前由命令中列出的每个密钥签署。因此，验证功能可以相信所有列出的密钥都签名了交易，但是负责验证交易从验证功能角度看是否有效所需的任何密钥都包含在列表中.</b></p>
<p><b style="color:red">命令总是嵌入在交易中。有时候，有很多数据可以在许多不同的交易中重复使用。这种使用的例子就是我们的附件。每个交易可以通过哈希引用0个或多个附件。附件始终都是ZIP/JAR文件，可能包含任何内容。这里可以看出命令与附件相关。</b></p>
<p><b style="color:red">请注意交易中可以有输入、输出、命令（Command）和附件（Attachment）。但是这些东西可能有也可能没有。交易中的数据需要合约来进行解释，并确保它们正确地结合在一起。</b></p>
<p><b style="color:red">交易有时可能需要提供带有外界数据的合约。可能包括以下的列子：股票价格、关于事件的事实或者法律实体的状态（例如破产）等等。这些事实的提供者称为神谕（oracles），他们通过签署包含他们已知的命令的交易或通过创建签名附件来为账本提供事实。这些命令包含事实和签名来彰显对此事实的一致。</b></p>
<p>时间也被建模为一个事实，并且有一种称为公证的特殊服务的签名。公证人是一种很有可能的分散式服务，它履行矿工在其他区块链系统中的作用：公证人确保只有一项交易可以消耗任何给定的输出。此外，他们可以验证放置在交易中的时间戳命令，该命令指定交易被认为对公证有效的时间窗口。时间窗口可以是开放式的（即开始但不结束或反之亦然）。通过这种方式，交易可以与公证人的时钟相关联。</p>
<p>一个Corda网络可能有多个竞争公证人。每个状态（State）都指向控制它的公证人。虽然单个交易只有在全部由同一公证人控制的情况下才会消耗状态，但是提供了将一个状态（或一组状态）从一个公证转移到另一个的特殊类型的交易。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Amount"><a href="#Amount" class="headerlink" title="Amount"></a>Amount</h4><p>Amount类是用来表示一些可替代的资产的量。它是一个通用类，它包装用于定义基础产品的类型，称为Token。它可以是JDK的Currency类型，或者Issued，或者是更复杂的类型（例如义务合同签发定义（其中包含用于解决义务的标记定义）。）</p>
<p>使用示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// A quantity of some specific currency like pounds, euros, dollars etc.</span><br><span class="line">Amount&lt;Currency&gt;</span><br><span class="line">// A quantity of currency that is issued by a specific issuer, for instance central bank vs other bank dollars</span><br><span class="line">Amount&lt;Issued&lt;Currency&gt;&gt;</span><br><span class="line">// A quantity of obligations to deliver currency of any issuer.</span><br><span class="line">Amount&lt;Obligation.State&lt;Currency&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>Corda合约由三部分组成; 代表特定交易或资产细节的可执行代码、法律散文（legal prose）和状态对象。<b style="color:red">在关系数据库术语中，状态就像数据库中的一行。</b>分类帐中的状态参考（无论是否已消费）用<code>StateRef</code>对象表示。如果状态引用（state ref）已经能从存储中找到，你将有一个<code>StateAndRef</code>，这是一个简单的<code>StateRef</code>加上数据。</p>
<p><code>ContractState</code>类是所有状态必须实现的接口。<code>TransactionState</code>是一个简单的<code>ContractState</code>容器（一个合约程序使用的自定义数据）和附加的平台级别的状态信息，比如notary指针。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A _participant_ is any party that is able to consume this state in a valid transaction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The list of participants is required for certain types of transactions. For example, when changing the notary</span></span><br><span class="line"><span class="comment">     * for this state, every participant has to be involved and approve the transaction</span></span><br><span class="line"><span class="comment">     * so that they receive the updated state, and don't end up in a situation where they can no longer use a state</span></span><br><span class="line"><span class="comment">     * they possess, since someone consumed that state during the notary change process.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The participants list should normally be derived from the contents of the state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些接口继承了<code>ContractState</code>，代表常见状态的标准化功能：</p>
<ul>
<li><p><code>OwnableState</code><br>拥有所有者的状态（表示为一个<code>PublicKey</code>，就是状态里面包含拥有者的<code>PublicKey</code>）。公开所有者和用于替换所有者的功能，例如当资产被出售时。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OwnableState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/** There must be a MoveCommand signed by this key to claim the amount. */</span></span><br><span class="line">    <span class="keyword">val</span> owner: AbstractParty</span><br><span class="line">    <span class="comment">/** Copies the underlying data structure, replacing the owner field with this new value and leaving the rest alone. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwner</span><span class="params">(newOwner: <span class="type">AbstractParty</span>)</span></span>: CommandAndState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearState</code><br>一种链接回到其先前状态的状态，随着时间的推移创建一个状态线程。对特定交易或不可拆分资产（如罕见艺术品）进行建模时，线性状态非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LinearState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unique id shared by all LinearState states throughout history within the vaults of all parties.</span></span><br><span class="line"><span class="comment">     * Verify methods should check that one input and one output share the id in a transaction,</span></span><br><span class="line"><span class="comment">     * except at issuance/termination.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> linearId: UniqueIdentifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DealState</code><br>一个<code>LinearState</code>(通过继承实现)表示两方或多方之间的协议。旨在简化实施操纵许多协议类型的通用流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface DealState : LinearState &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Generate a partial transaction representing an agreement (command) to this deal, allowing a general</span><br><span class="line">     * deal/agreement flow to generate the necessary transaction for potential implementations.</span><br><span class="line">     *</span><br><span class="line">     * TODO: Currently this is the &quot;inception&quot; transaction but in future an offer of some description might be an input state ref</span><br><span class="line">     *</span><br><span class="line">     * TODO: This should more likely be a method on the Contract (on a common interface) and the changes to reference a</span><br><span class="line">     * Contract instance from a ContractState are imminent, at which point we can move this out of here.</span><br><span class="line">     */</span><br><span class="line">    fun generateAgreement(notary: Party): TransactionBuilder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FixableDealState</code><br>一个交易状态，进一步的功能暴露以支持固定利率。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FixableDealState</span> : <span class="type">DealState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When is the next fixing and what is the fixing for?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextFixingOf</span><span class="params">()</span></span>: FixOf?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * What oracle service to use for the fixing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> oracle: Party</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a fixing command for this deal and fix.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> This would also likely move to methods on the Contract once the changes to reference</span></span><br><span class="line"><span class="comment">     * the Contract from the ContractState are in.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generateFix</span><span class="params">(ptx: <span class="type">TransactionBuilder</span>, oldState: <span class="type">StateAndRef</span>&lt;*&gt;, fix: <span class="type">Fix</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="NamedByHash和UniqueIdentifier"><a href="#NamedByHash和UniqueIdentifier" class="headerlink" title="NamedByHash和UniqueIdentifier"></a>NamedByHash和UniqueIdentifier</h4><p>散列作为标识的事物（如交易和附件）应该实现<code>NamedByHash</code>接口，这个接口标准化提取ID的操作。请注意，散列不是全局唯一标识符：它总是对基础数据内容的派生摘要。<b style="color:red">有时候这不是你想要的：两个具有完全相同参数并且同时生成但是在逻辑上不同的交易不能通过散列识别，因为它们的内容将是相同的。相反，你会使用<code>UniqueIdentifier</code>。</b> 这是一个（Java）UUID表示一个全球唯一的128位随机数，以及一个可与之配对的任意字符串。例如，为了方便起见，该字符串可以代表现有的“weak”（不保证唯一）标识符。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamedByHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: SecureHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueIdentifier</span></span>(<span class="keyword">val</span> externalId: String? = <span class="literal">null</span>, <span class="keyword">val</span> id: UUID = UUID.randomUUID()) : Comparable&lt;UniqueIdentifier&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用UUID标识，但是可以使用配对的字符串进行拼接</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (externalId != <span class="literal">null</span>) <span class="string">"<span class="subst">$&#123;externalId&#125;</span>_<span class="variable">$id</span>"</span> <span class="keyword">else</span> id.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/** Helper function for unit tests where the UUID needs to be manually initialised for consistency. */</span></span><br><span class="line">        <span class="meta">@VisibleForTesting</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromString</span><span class="params">(name: <span class="type">String</span>)</span></span>: UniqueIdentifier = UniqueIdentifier(<span class="literal">null</span>, UUID.fromString(name))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UniqueIdentifier</span>)</span></span>: <span class="built_in">Int</span> = id.compareTo(other.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (other <span class="keyword">is</span> UniqueIdentifier)</span><br><span class="line">            id == other.id</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = id.hashCode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="FungibleAssets-and-Cash"><a href="#FungibleAssets-and-Cash" class="headerlink" title="FungibleAssets and Cash"></a>FungibleAssets and Cash</h4><p><code>FungibleAsset</code>(可替代资产)是可模拟可替代资产的合约的一个共同的超类，它也为其子类的状态对象提供了一个标准接口来实现。将典型的用例就是<code>Cash</code>，然而<code>FungibleAsset</code>意图是容易扩展到覆盖其它资产，例如商品可以根据需要通过使用一个子类，其状态的对象包括进一步的细节（商品，产地，等级的位置等）进行建模。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FungibleAsset</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">OwnableState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount represents a positive quantity of some issued product which can be cash, tokens, assets, or generally</span></span><br><span class="line"><span class="comment">     * anything else that's quantifiable with integer quantities. See [Issued] and [Amount] for more details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> amount: Amount&lt;Issued&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * There must be an ExitCommand signed by these keys to destroy the amount. While all states require their</span></span><br><span class="line"><span class="comment">     * owner to sign, some (i.e. cash) also require the issuer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> exitKeys: Collection&lt;PublicKey&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies the underlying data structure, replacing the amount and owner fields with the new values and leaving the</span></span><br><span class="line"><span class="comment">     * rest (exitKeys) alone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwnerAndAmount</span><span class="params">(newAmount: <span class="type">Amount</span>&lt;<span class="type">Issued</span>&lt;<span class="type">T</span>&gt;&gt;, newOwner: <span class="type">AbstractParty</span>)</span></span>: FungibleAsset&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里<code>Cash</code>其实是一个<code>Contract</code>，里面包含<code>FungibleAssets</code>的状态子类，由于代码比较长，这里就不展示了。</p>
<h4 id="Transaction-生命周期类型"><a href="#Transaction-生命周期类型" class="headerlink" title="Transaction 生命周期类型"></a>Transaction 生命周期类型</h4><p><code>WireTransaction</code>类包含一个没有签名交易的核心，并带有附件的引用以代表附件本身。一旦对交易签名就封装成<code>SignedTransaction</code>类。为了处理交易（即验证它），它首先被转换为<code>LedgerTransaction</code>，这涉及到验证签名并将它们关联到相关命令，并对附件的引用进行附件解析。具有有效签名的命令被封装在<code>AuthenticatedObject</code>类中(新版中，这个类被重命名为<code>CommandWithParties</code>)。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WireTransaction</span></span>(componentGroups: List&lt;ComponentGroup&gt;, <span class="keyword">val</span> privacySalt: PrivacySalt = PrivacySalt()) : TraversableTransaction(componentGroups) &#123;</span><br><span class="line">    <span class="meta">@Deprecated(<span class="meta-string">"Required only in some unit-tests and for backwards compatibility purposes."</span>, ReplaceWith(<span class="meta-string">"WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)"</span>)</span>, DeprecationLevel.WARNING)</span><br><span class="line">    <span class="keyword">constructor</span>(inputs: List&lt;StateRef&gt;, <span class="comment">// 输入</span></span><br><span class="line">                attachments: List&lt;SecureHash&gt;, <span class="comment">// 附件hash集合</span></span><br><span class="line">                outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, <span class="comment">// 输出，这里我们可以看到TransactionState的意义了</span></span><br><span class="line">                commands: List&lt;Command&lt;*&gt;&gt;, <span class="comment">// 命令集合</span></span><br><span class="line">                notary: Party?,   <span class="comment">// 见证者</span></span><br><span class="line">                timeWindow: TimeWindow?, <span class="comment">// 时间窗口</span></span><br><span class="line">                privacySalt: PrivacySalt = PrivacySalt() <span class="comment">// 私钥密码</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看一下<code>SignedTransaction</code>的定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SignedTransaction</span></span>(<span class="keyword">val</span> txBits: SerializedBytes&lt;CoreTransaction&gt;,</span><br><span class="line">                             <span class="keyword">override</span> <span class="keyword">val</span> sigs: List&lt;TransactionSignature&gt;</span><br><span class="line">) : TransactionWithSignatures &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一下LedgerTransaction的定义。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LedgerTransaction</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="comment">/** The resolved input states which will be consumed/invalidated by the execution of this transaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;,           <span class="comment">// 输入</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;,     <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">/** Arbitrary data passed to the program of each input state. */</span></span><br><span class="line">        <span class="keyword">val</span> commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;,             <span class="comment">// 命令（具有有效签名的命令）</span></span><br><span class="line">        <span class="comment">/** A list of [Attachment] objects identified by the transaction that are needed for this transaction to verify. */</span></span><br><span class="line">        <span class="keyword">val</span> attachments: List&lt;Attachment&gt;,                               <span class="comment">// 解析好的附件</span></span><br><span class="line">        <span class="comment">/** The hash of the original serialised WireTransaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> id: SecureHash,                                     <span class="comment">// id，交易的hash</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> notary: Party?,                                     <span class="comment">// 见证者</span></span><br><span class="line">        <span class="keyword">val</span> timeWindow: TimeWindow?,                                     <span class="comment">// 时间窗口</span></span><br><span class="line">        <span class="keyword">val</span> privacySalt: PrivacySalt,                                    <span class="comment">// 密码盐，这个是不是太暴露了</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> networkParameters: NetworkParameters? = <span class="literal">null</span>         <span class="comment">// 网络配置参数</span></span><br><span class="line">) : FullTransaction() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AuthenticatedObject</code>类被重命名为<code>CommandWithParties</code>，这个类比较简单，具体的内容如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandWithParties</span>&lt;<span class="type">out T : CommandData</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> signers: List&lt;PublicKey&gt;,   <span class="comment">// 签署人，其实就是公钥</span></span><br><span class="line">        <span class="comment">/** If any public keys were recognised, the looked up institutions are available here */</span></span><br><span class="line">        <span class="keyword">val</span> signingParties: List&lt;Party&gt;, <span class="comment">// 找到签署人所属的Party</span></span><br><span class="line">        <span class="keyword">val</span> value: T</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#6ab0de">注意：<code>LedgerTransaction</code>没有必要运行它的合约，因此合约可以是无效的（但不是签名无效的）。您可以使用如下所示的verify方法运行合约。</b></p>
<p>可以使用<code>TransactionBuilder</code>构建新的交易，这是一个可修改的交易，一旦内部修改完成，就可以对其进行签名。合约类通常会暴露帮助方法，这些方法对<code>TransactionBuilder</code>会有所帮助。</p>
<p>以下是一个构建交易的例子，该交易创建了bananas的发行（请注意，bananas不是库中真正的合约类型）：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notaryToUse: Party = ... <span class="comment">// 见证者Party</span></span><br><span class="line"><span class="comment">// 创建交易，加入了State</span></span><br><span class="line"><span class="keyword">val</span> txb = TransactionBuilder(notary = notaryToUse).withItems(BananaState(Amount(<span class="number">20</span>, Bananas), fromCountry = <span class="string">"Elbonia"</span>))</span><br><span class="line"><span class="comment">// 使用私钥进行交易签名</span></span><br><span class="line">txb.signWith(myKey)</span><br><span class="line"><span class="comment">// 设置时间窗口</span></span><br><span class="line">txb.setTime(Instant.now(), notaryToUse, <span class="number">30.</span>seconds)</span><br><span class="line"><span class="comment">// We must disable the check for sufficient signatures, because this transaction is not yet notarised.</span></span><br><span class="line"><span class="comment">// 转化为SignedTransaction</span></span><br><span class="line"><span class="keyword">val</span> stx = txb.toSignedTransaction(checkSufficientSignatures = <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// Alternatively, let's just check it verifies pretending it was fully signed. To do this, we get</span></span><br><span class="line"><span class="comment">// a WireTransaction, which is what the SignedTransaction wraps. Thus by verifying that directly we</span></span><br><span class="line"><span class="comment">// skip signature checking.</span></span><br><span class="line">txb.toWireTransaction().toLedgerTransaction(services).verify()</span><br></pre></td></tr></table></figure></p>
<h4 id="Party和PublicKey"><a href="#Party和PublicKey" class="headerlink" title="Party和PublicKey"></a>Party和PublicKey</h4><p>使用网络的实体称为参与方（Party）。各方可以使用密钥签署结构，并且一方可以在其控制下拥有许多密钥。</p>
<p>Party有时候可能被伪名识别，例如，作为监管链的一部分发送给你的节点的交易中，重要的是你可以说服你自己了解交易的有效性，但是同样重要的是，你不知道在那次交易中涉及的是谁。在这些情况下，公钥可能不存在关于谁拥有它的任何标识信息。</p>
<p>参与签署交易的参与方(Party)的身份可以简单地用<code>PublicKey</code>表示，或者通过使用Party类的更多信息（如姓名）来表示。<code>CommandWithParties</code>表示由一组参与方签署的对象（如命令）。</p>
<p><b style="color:#6ab0de">注意: 这些类型是临时的，将来随着身份框架变得更加充实而将发生重大变化。</b></p>
<h4 id="多签名支持"><a href="#多签名支持" class="headerlink" title="多签名支持"></a>多签名支持</h4><p>Corda支持需要多个密钥或参与方授权进行状态对象转换的情况，例如：“首席执行官或其中三分之一的助理都需要提供签名”。</p>
<h5 id="CompositeKey-复合键"><a href="#CompositeKey-复合键" class="headerlink" title="CompositeKey(复合键)"></a>CompositeKey(复合键)</h5><p>这是通过使用树结构的公钥组合来实现的<code>CompositeKey</code>。<code>CompositeKey</code>是一棵树，<b style="color:red">它将密码公钥基元存储在其树叶中，并在中间节点中存储组合逻辑。每个中间节点指定它需要多少个孩子签名的阈值。</b></p>
<p>“Alice和Bob或Charlie”组合键的例证：</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/composite-key.png" alt=""></p>
<p>为了提供更大的灵活性，每个子节点都可以有一个相关的自定义权重（默认值为1）。该阈值 然后指定所需的所有子节点的最小总权重。我们之前的例子也可以表示为：</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/composite-key-2.png" alt=""></p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>签名验证分两个阶段进行：</p>
<ol>
<li>给定一个签名列表，每个签名都会根据预期的内容进行验证。</li>
<li>将与签名相对应的公钥与所讨论的组合密钥树的树叶进行匹配，并且针对每个中间节点计算所有孩子的总组合权重。如果所有阈值都满足，则认为组合密钥要求得到满足。</li>
</ol>
<h4 id="日期支持"><a href="#日期支持" class="headerlink" title="日期支持"></a>日期支持</h4><p>有许多支持接口和类供合约处理日期（特别是在截止日期范围内）使用。由于合约谈判通常涉及诸如“overnight”，“T+3”等期限的最后期限，因此希望允许将这些条款转换为相应的截止日期。<code>Tenor</code>在截止日期之前（例如3天等）对间隔进行建模，同时<code>DateRollConvention</code>描述如何修改最后期限以考虑银行假期或修改正常工作日的其他事件。</p>
<p>根据工作日计算期限的延期需要有关所涉银行假期的信息（以及合同各方在不同的国家/地区，例如，这可能涉及多套不同的银行假期）。<code>BusinessCalendar</code>类模拟这些商业假期的日历; 目前它从磁盘上的文件加载这些文件，但将来这可能涉及参考数据库，以确保所用日期的一致性。</p>
<h4 id="加密和数学支持"><a href="#加密和数学支持" class="headerlink" title="加密和数学支持"></a>加密和数学支持</h4><p><code>SecureHash</code>类代表未知算法的安全散列。我们目前只定义一个子类，<code>SecureHash.SHA256</code>。有实用的方法来创建它们，解析它们等等。</p>
<p>我们还提供了一些数学实用工具，特别是一组插值器和用于样条线的类。这些可以在<a href="https://docs.corda.net/releases/release-M7.0/api/net.corda.core.math/index.html" target="_blank" rel="noopener">数学包</a>中找到。</p>
<h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p>我们平台的基本数据结构之一就是交易。它可以通过签名和验证，也可以由第三方进行验证。交易的构建假定它们构成一个具有输入和输出状态，命令和附件的完整实体。但是，所有敏感数据都不应该透露给参与验证级别交易创建的其他节点（这种情况的一个很好的例子是只验证嵌入式命令的Oracle）。如何以一种让对方信服他们获得签名数据的方式来实现这一点，确实构成了交易的一部分？</p>
<p>我们决定使用众所周知的密码方案来提供包含和数据完整性的证明。Merkle树广泛用于点对点网络，区块链系统和git。</p>
<h4 id="Corda的Merkle树"><a href="#Corda的Merkle树" class="headerlink" title="Corda的Merkle树"></a>Corda的Merkle树</h4><p>交易分为叶子，每个叶子都包含输入，输出，命令或附件。计算中不使用时间戳或签名者等其他字段。接下来，Merkle树以正常方式构建，方法是将当前节点下方的节点散列连接在一起。它在下面的示例图像中可见，其中<code>H</code>表示sha256函数，“+” – 级联。</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/merkleTree.png" alt=""></p>
<p>该交易有一个输入状态，一个输出和三个命令。如果树不是完整的二叉树，则在散列计算（虚线）中重复最右边的节点。</p>
<p><b style="color:blue">最后，根的散列是交易的标识符，它也用于数据完整性的签名和验证。每个叶级别的更改都会改变交易的标识符。</b></p>
<h4 id="隐藏数据"><a href="#隐藏数据" class="headerlink" title="隐藏数据"></a>隐藏数据</h4><p><b style="color:red">隐藏数据并提供它构成交易一部分的证据通过构建部分Merkle树（或Merkle分支）来完成。</b>Merkle分支是一组散列，根据叶子的数据来计算根的散列。然后将该散列与整个交易的散列进行比较，如果它们匹配，则意味着我们获得的数据属于该特定交易。</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/partialMerkle.png" alt=""></p>
<p>在上面的例子中，红色节点是持有Oracle服务签名数据的节点。蓝色节点的哈希形成部分梅克尔树，不包括虚线的哈希。有了应该在红色节点位置和分支中的命令，我们可以计算这棵树的根，并将它与原始交易标识符进行比较 - 我们证明此命令属于此交易。</p>
<h3 id="共识模型"><a href="#共识模型" class="headerlink" title="共识模型"></a>共识模型</h3><p>Corda的基本共识单位是状态。共识的概念可以分为两部分：</p>
<ol>
<li>对状态有效性达成共识 - 各方可以确定定义输出状态的交易被各状态指定的合约接受并具有所有必需的签名。这是通过各方独立运行相同的合约代码和验证逻辑来​​实现的。</li>
<li>关于状态唯一性的共识 - 各方可以确定交易中创建的输出状态是该交易消耗的输入状态的唯一继承者（换句话说 - 一个状态未被用作多个交易的输入）</li>
</ol>
<h4 id="公证人"><a href="#公证人" class="headerlink" title="公证人"></a>公证人</h4><p>我们介绍了公证人（notary）的概念，该公证人是负责证明对于给定的交易没有签署另一个消耗其任何输入状态的交易的机构。数据模型被扩展，以便每个状态都有一个指定的公证人：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class TransactionState&lt;out T : ContractState&gt;(</span><br><span class="line">        /** The custom contract state */</span><br><span class="line">        val data: T,</span><br><span class="line">        /** Identity of the notary that ensures the state is not used as an input to a transaction more than once */</span><br><span class="line">        val notary: Party) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有交易都必须由其输入状态公证人签名，以使输出状态有效（除了发行交易，不包含输入状态）。</p>
<p>当公证人被要求签署交易时，它要么签署交易，证明输出是输入的唯一后继者，要么提供已经被之前签署的另一个交易消耗的任何输入状态的冲突信息。这样做，公证人提供了系统中的终点。在获得公证人签名之前，各方不能确定同等有效但冲突的交易不会被视为确认。获得签名后，双方知道该交易的输入已被该交易独有消耗。因此，这是我们可以说终结发生的地步。</p>
<h4 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h4><p>网络中可以存在一个以上的公证人。这提供了以下好处：</p>
<ol>
<li>自定义行为。我们可以同时拥有验证和隐私保护公证人 - 各方可以根据他们的具体要求做出选择</li>
<li>负载平衡。将事务处理负载分摊到多个公证处将会在整个平台中实现更高的事务吞吐量</li>
<li>低延迟。通过选择公证员与交易方更接近，延迟时间可以缩短</li>
</ol>
<p><b style="color:blue">如果一个交易的所有输入状态指向一个交易，交易只能由公证人签名。在交易涉及由多个公证人控制的状态的情况下，各状态首先必须被重新委托给同一公证人。这是通过使用一种特殊类型的交易来实现的，该交易不会修改任何内容，而是修改状态的公证指针。确保所有投入状态都指向同一公证人是每个相关方的责任（这是交易输出状态有效的另一个条件）</b></p>
<h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>要更改输入状态的公证，请使用NotaryChangeFlow。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Suspendable</span><br><span class="line">fun changeNotary(originalState: StateAndRef&lt;ContractState&gt;,</span><br><span class="line">                 newNotary: Party): StateAndRef&lt;ContractState&gt; &#123;</span><br><span class="line">    val flow = NotaryChangeFlow.Instigator(originalState, newNotary)</span><br><span class="line">    return subFlow(flow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流程如下：</p>
<ol>
<li>将旧状态作为输入，将新状态作为输出进行构建</li>
<li>从所有参与者获取签名（参与者是能够在有效交易中消费此状态的任何一方，如由状态本身定义的那样）</li>
<li>获得旧的公证人签名</li>
<li>记录并向参与者分发最终交易，以便每个人都拥有新的状态</li>
</ol>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>公证人的设计决定之一是在提交输入状态之前是否验证交易。</p>
<p>如果一个交易没有被检查有效性，它会打开平台进行“拒绝状态”攻击，任何人都可以建立一个无效的交易，消耗其他人的状态并将其提交给公证员以使状态“被阻止”。但是，对交易的验证需要公证人能够看到有问题交易的全部内容及其依赖关系。这是一个明显的隐私泄露。</p>
<p>我们的平台非常灵活，目前我们支持验证和非验证公证实施 - 一方可以根据自己的隐私要求选择使用哪一个。</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>在这个模型中，公证人还充当时间戳机构，验证交易时间戳命令。</p>
<h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><h3 id="corda网站"><a href="#corda网站" class="headerlink" title="corda网站"></a>corda网站</h3><p>这里是corda的<a href="https://www.corda.net/zh-hant/" target="_blank" rel="noopener">官方网站</a>。<br><a href="https://github.com/corda" target="_blank" rel="noopener">这个网站</a>是corda的github主页，你可在里面找到我们的corda项目，入门的cordapp example也可以在这里找到，还是比较实用的。</p>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>最后这里列一下Kotlin的学习的一些资料。</p>
<p>最棒的就是<a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Strings/Task.kt" target="_blank" rel="noopener">这个网站</a>的在线练习，做的的确棒极了。</p>
<p>当然对于Kotlin，我们不得不研究一下它的<a href="http://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">官方指南</a>. 你可以在这里查询文档和Api的说明文档，另外里面还做了一个全局的搜索，不管是文档，博客还是Api文档，你都可以一键搜索，很是方便。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>这个是志愿者翻译的<a href="https://dongchuan.gitbooks.io/gradle-user-guide-/content/overview/features.html" target="_blank" rel="noopener">Gradle User Guide中文版</a></p>
<p>当然如果你想自定义Gradle插件的话，就不得不研究<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure" target="_blank" rel="noopener">Gradle的文档</a>)，里面有相关的Api和概念。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.corda.net/releases/release-M7.0/index.html" target="_blank" rel="noopener">Corda API reference</a><br><a href="https://medium.com/corda/peer-to-peer-enterprise-blockchain-networking-with-the-corda-firewall-4f6a427ebd97" target="_blank" rel="noopener">Peer-to-Peer Enterprise Blockchain Networking with the Corda Firewall.</a><br><a href="http://cncorda.com/" target="_blank" rel="noopener">Corda中文网</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/ProcessBuilder简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/ProcessBuilder简介/" itemprop="url">ProcessBuilder简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:54:47+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学过C语言的都知道如何开启一个新的进行。自从我们学习了java之后，很少会开启新的进程，因为我们绝大部分的使用都是开启线程，以至于线程池的知识成了现在java面试的宝典了。</p>
<p>最近在研究Corda的源码，发现里面的启动都是通过相应的ProcessBuilder，这个类开启了若干进程，当然进程都是执行的shell代码，这里就不做更多说明了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ProcessBuilder类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由Process类处理实现进程的控制管理。每个 ProcessBuilder 实例管理一个进程属性集。它的start() 方法利用这些属性创建一个新的 Process 实例。start() 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p>每个进程生成器（即ProcessBuilder对象）管理这些进程属性： </p>
<ul>
<li><p>命令 command<br>是一个字符串列表，它表示要调用的外部程序文件及其参数（如果有）。在此，表示有效的操作系统命令的字符串列表是依赖于系统的。例如，每一个总体变量，通常都要成为此列表中的元素，但有一些操作系统，希望程序能自己标记命令行字符串——在这种系统中，Java 实现可能需要命令确切地包含这两个元素。</p>
</li>
<li><p>环境 environment<br>是从变量 到值 的依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅 System.getenv()）。</p>
</li>
<li><p>工作目录 working directory<br>默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</p>
</li>
<li><p>redirectErrorStream属性<br>最初，此属性为 false，意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 Process.getInputStream() 和 Process.getErrorStream() 方法来访问。如果将值设置为 true，标准错误将与标准输出合并。这使得关联错误消息和相应的输出变得更容易。在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</p>
</li>
</ul>
<h2 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h2><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p>
<p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>
<p>Process抽象类有以下6个抽象方法： </p>
<ul>
<li>destroy()<br>杀掉子进程。 </li>
<li>exitValue()<br>返回子进程的出口值。 </li>
<li>InputStream getErrorStream()<br>获得子进程的错误流。 </li>
<li>InputStream getInputStream()<br>获得子进程的输入流。 </li>
<li>OutputStream getOutputStream()<br>获得子进程的输出流。 </li>
<li>waitFor()<br>导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止。</li>
</ul>
<h3 id="如何创建Process对象？"><a href="#如何创建Process对象？" class="headerlink" title="如何创建Process对象？"></a>如何创建Process对象？</h3><p>一般有两种方法：</p>
<ol>
<li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象。</li>
<li>Runtime.exec() 方法创建一个本机进程，并返回 Process 子类的一个实例。</li>
</ol>
<h2 id="Runtime-exec"><a href="#Runtime-exec" class="headerlink" title="Runtime.exec()"></a>Runtime.exec()</h2><p>ProcessBuilder与Runtime.exec()的区别? </p>
<p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。 </p>
<p>ProcessBuilder.start() 和 Runtime.exec()传递的参数有所不同，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u013256816/article/details/54603910" target="_blank" rel="noopener">浅析ProcessBuilder</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/java线程状态的分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/java线程状态的分析/" itemprop="url">java线程状态的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:35:06+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近阅读了《深入理解Linux内核》这本书，对于线程和进程的知识有了比较深入的理解，这里我就不做更多的介绍了，如果你想了解更多的知识可以阅读一下这本书，虽然阅读起来比较麻烦，但是确实是一本比较不错的书籍，里面的很多知识都是值得深入学习的。做好攻坚的准备就是了。</p>
<h2 id="关于线程的状态"><a href="#关于线程的状态" class="headerlink" title="关于线程的状态"></a>关于线程的状态</h2><p>以下是java的线程状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NEW</td>
<td style="text-align:center">初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td style="text-align:center">RUNNABLE</td>
<td style="text-align:center">运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td style="text-align:center">BLOCKED</td>
<td style="text-align:center">阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td style="text-align:center">WAITING</td>
<td style="text-align:center">等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td style="text-align:center">TIMED_WAITING</td>
<td style="text-align:center">超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<h2 id="改变线程状态"><a href="#改变线程状态" class="headerlink" title="改变线程状态"></a>改变线程状态</h2><p>大家都知道Thread类内部提供了几个方法可以改变线程的状态。</p>
<p>当然Future里面也有不少的改变线程状态的实现。</p>
<p>但是这些基础知识就不做更多的介绍了，这也不是我要说明的重点。</p>
<h2 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h2><p>今天主要是来说明这个类的作用的。这个类里面有很多的内容，今天就重点介绍里面的park方法。</p>
<p>因为park方法可以改变线程的状态，这种改变时操作系统级别的，这种调用一定是使用了系统调用，主要是你要明白这一点才能里面AQS里面的实现，这里就是简单的记录一下。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/缓存行与计算机缓存结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/缓存行与计算机缓存结构/" itemprop="url">缓存行与计算机缓存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:18:20+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/base/" itemprop="url" rel="index"><span itemprop="name">base</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在读《深入理解Linux内核》读了不少关于计算机缓存的体系结构设计，这里就不做更多的说明，下面我们来看看这里面的知识吧！</p>
<p>计算机分为多级缓存，但是主要的还是要从内存条说起。</p>
<p>其实系统会在系统内存上单独开一片cache，而且这片的cache和普通的内存管理策略不同。这应该算是第一级缓存，但是这种提升不是很大。下面我们来讲高速缓存块cache。</p>
<p>对于高速缓存块cache也是有多种分法。一是主板级别的高速cache，这种是多CPU共享的。再上面一层就是CPU专用的高速cache块了。再上一层就是每个CPU核共享的高速cache。再上面一层就是寄存器了。</p>
<p>这就是背景知识。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>高速缓存块不是按照每一个字节进行缓存，而是按照一个内存块进行缓存。可是一旦这块中任何一个内容改变，都会导致整个块的Refresh。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里主要是指程序的改进，比如说你定义一个对象。以前这个对象在一个缓存行中，但是对象中改变的字段就是一个两个频繁改变，这样每次refresh的块比较大。所以方法就是将可变的属性放入一个缓存块中，将不可变的放入另一个缓存块中，这样刷新的少了，速度自然提升了。这就是缓存块的具体说明，具体可以查看具体的引用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://geek.csdn.net/news/detail/114619" target="_blank" rel="noopener">认识CPU Cache</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/理解Java的AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/理解Java的AQS/" itemprop="url">理解Java的AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T19:48:46+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/aqs/" itemprop="url" rel="index"><span itemprop="name">aqs</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一提到java的锁机制，大家都会想到AQS（AbstractQueuedSynchronizer），意思就是抽象的同步队列，感觉就是使用队列来进行同步操作而已。（Java8版本）</p>
<h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>AbstractQueuedSynchronizer是继承自AbstractOwnableSynchronizer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 独占模式同步的当前所有者。</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个说明还是比较简单的，就是说这个同步独占这个线程而已。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>当然AbstractOwnableSynchronizer是队列，所以里面有内部类表示节点（Node），其实就是一个双向链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标记以指示节点正在以共享模式等待</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标记以指示节点正在以独占模式等待</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // 表示线程已取消的waitStatus值</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    // waitStatus值指示后继者的线程需要暂停</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    // waitStatus值指示线程正在等待状态</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    // waitStatus值指示下一个acquireShared应无条件传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Status field, taking on only the values:</span><br><span class="line">    *   SIGNAL: 值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="line">    *   CANCELLED:  值为1，表示当前的线程被取消；</span><br><span class="line">    *   CONDITION:  值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="line">    *   PROPAGATE:  值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="line">    *   0:        None of the above 表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter; // 存储condition队列中的后继节点。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Returns true if node is waiting in shared mode.</span><br><span class="line">    */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">首先这是一个双向链表，从这里我们可以看出AQS的功能可以分为两类：独占功能和共享功能</b>。另外，排队的节点有5中状态，就是<code>waitStatus</code>的值，Node需要记录排队的线程和下一个等待的节点（线程）。</p>
<p>## </p>
<p>未完待续！！！！！</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a><br><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a><br><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）</a><br><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/深入java类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/深入java类加载器/" itemprop="url">深入java类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T17:41:35+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>对于java的类加载机制，我想大家一定都知道双亲委派模型和JDK类中的加载器。主要有Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader和User Defined ClassLoader。这些基础知识就不多说了。</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)：<br>这个类加载器使用C++语言实现，并非ClassLoader的子类。主要负责加载存放在<code>JAVA_HOME/jre/lib/rt.jar</code>里面所有的class文件，或者被<code>-Xbootclasspath</code>参数所指定路径中以rt.jar命名的文件。</li>
<li>扩展类加载器(Extension ClassLoader)：<br>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>JAVA_HOME/lib/ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li>
<li>应用程序类加载器(Application ClassLoader)：<br>这个加载器由sun.misc.Launcher$AppClassLoader实现，它负责加载<code>classpath</code>对应的jar及目录。一般情况下这个就是程序中默认的类加载器。</li>
<li>自定义类加载器(User Defined ClassLoader)：<br>开发人员继承ClassLoader抽象类自行实现的类加载器，基于自行开发的ClassLoader可用于并非加载classpath中(例如从网络上下载的jar或二进制字节码)、还可以在加载class文件之前做些小动作 如：加密等。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>类加载器(ClassLoader)用来加载 class字节码到 Java 虚拟机中，并转换成 java.lang.Class 类的一个实例。当然class字节码的来源可能有多种，一种就是自己拼写class文件的内容。</p>
<p>Java中如何比较两个类相等呢？这里所指的“相等”包括代表类的Class对象的equal方法、isAssignableFrom()、isInstance()方法及instance关键字返回的结果。</p>
<p>其实在Java中，一个类是否是相同的，主要取决于类加载器和包名+类名，只有以上条件都满足了，我们才说这两个类是相等的。我并没有在class文件中发现equals方法，这说明类加载的去重完全是在definedClass方法中，调用了底层的一些C代码实现的。也就是说，我们无法自己实例化一个Class实例，这需要JVM底层帮我们处理，每个Class实例的去重，完全是JVM的底层代码帮忙处理的。但是我们可以在class类中发现一个ClassLoader类的成员。</p>
<h2 id="ParallelLoaders"><a href="#ParallelLoaders" class="headerlink" title="ParallelLoaders"></a>ParallelLoaders</h2><p>这是ClassLoader里面的一个内部类，用来封装一组并行能力的加载器类型。这个一般是用不到的，有兴趣可以先看一下。但是需要知道ClassLoader是支持并行加载的。</p>
<h2 id="类加载过程与双亲委派"><a href="#类加载过程与双亲委派" class="headerlink" title="类加载过程与双亲委派"></a>类加载过程与双亲委派</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123; // 获得要用的锁</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); // 检查这个类有没有被加载</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime(); // 时间</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123; // 如果父类加载器，就用父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 默认的父类加载器是启动类加载器</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123; // 如果最终没有加载到这个类</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime(); // 取得系统时间</span><br><span class="line">                c = findClass(name); // 如果没有父类加载器就自己加载</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很清楚，就不用过多解释了。双亲委派不是基于继承实现的，而是基于组合的方式实现的，默认使用启动类加载器作为父类加载器。如果类加器的父类加载器没有帮助我们加载到相应的类，那么就会调用findClass这个方法，所以为啥我们定义类加载器的时候需要重写findClass方法的原因就在这里。</p>
<p>默认的findClass实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，如果加载不了类就抛异常，我们进行重写的时候，也应该注意这点（这是典型的模板方法模式）。</p>
<p>其次我们发现loadClass不是final方法，也就是说我们可以打破双亲委派的模型，直接使用自己的类加载器，但这样会出现无法使用系统类的问题了，这个只是我的猜测，但是如果我想ClassLoader中会不会相应的信息，也许需要以后研究JVM底层的时候，才会有答案了。</p>
<h2 id="重写findClass"><a href="#重写findClass" class="headerlink" title="重写findClass"></a>重写findClass</h2><p>我们可以发现重写findClass完全达不到自己生成Class的目的。然后你会发现defineClass也是返回Class类型的，所以我们需要在方法中调用这个方法进行相应的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    // 从codeSource中获取类所在文件路径</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有趣发现这里也有模板方法模式，如果你想前后处理一些事情，可以重写preDefineClass、postDefineClass这两个方法，但是注意原来的方法时private的，你无法调用super里面的方法，这会带来很多的问题。</p>
<p>当然defineClass本省就是一个重载方法，所以详细的信息请查看源码，这里就不多说明了，其实用到才关注，一般的时候是不用管的。</p>
<h2 id="resolveClass方法"><a href="#resolveClass方法" class="headerlink" title="resolveClass方法"></a>resolveClass方法</h2><p>resolveClass 此方法负责完成Class对象的链接，如果链接过，则直接返回。</p>
<h2 id="findLibrary-loadLiberay"><a href="#findLibrary-loadLiberay" class="headerlink" title="findLibrary/loadLiberay"></a>findLibrary/loadLiberay</h2><p>这两个方法其实是为了加载动态链接库使用的，以前我也分析过里面的代码，有些印象，这里就不做更多的解释了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">99</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">95</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
