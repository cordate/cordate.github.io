<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/缓存行与计算机缓存结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/缓存行与计算机缓存结构/" itemprop="url">缓存行与计算机缓存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:18:20+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在读《深入理解Linux内核》读了不少关于计算机缓存的体系结构设计，这里就不做更多的说明，下面我们来看看这里面的知识吧！</p>
<p>计算机分为多级缓存，但是主要的还是要从内存条说起。</p>
<p>其实系统会在系统内存上单独开一片cache，而且这片的cache和普通的内存管理策略不同。这应该算是第一级缓存，但是这种提升不是很大。下面我们来讲高速缓存块cache。</p>
<p>对于高速缓存块cache也是有多种分法。一是主板级别的高速cache，这种是多CPU共享的。再上面一层就是CPU专用的高速cache块了。再上一层就是每个CPU核共享的高速cache。再上面一层就是寄存器了。</p>
<p>这就是背景知识。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>高速缓存块不是按照每一个字节进行缓存，而是按照一个内存块进行缓存。可是一旦这块中任何一个内容改变，都会导致整个块的Refresh。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里主要是指程序的改进，比如说你定义一个对象。以前这个对象在一个缓存行中，但是对象中改变的字段就是一个两个频繁改变，这样每次refresh的块比较大。所以方法就是将可变的属性放入一个缓存块中，将不可变的放入另一个缓存块中，这样刷新的少了，速度自然提升了。这就是缓存块的具体说明，具体可以查看具体的引用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://geek.csdn.net/news/detail/114619" target="_blank" rel="noopener">认识CPU Cache</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/理解Java的AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/理解Java的AQS/" itemprop="url">理解Java的AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T19:48:46+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一提到java的锁机制，大家都会想到AQS（AbstractQueuedSynchronizer），意思就是抽象的同步队列，感觉就是使用队列来进行同步操作而已。（Java8版本）</p>
<h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>AbstractQueuedSynchronizer是继承自AbstractOwnableSynchronizer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 独占模式同步的当前所有者。</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个说明还是比较简单的，就是说这个同步独占这个线程而已。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>当然AbstractOwnableSynchronizer是队列，所以里面有内部类表示节点（Node），其实就是一个双向链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标记以指示节点正在以共享模式等待</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标记以指示节点正在以独占模式等待</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // 表示线程已取消的waitStatus值</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    // waitStatus值指示后继者的线程需要暂停</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    // waitStatus值指示线程正在等待状态</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    // waitStatus值指示下一个acquireShared应无条件传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Status field, taking on only the values:</span><br><span class="line">    *   SIGNAL: 值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="line">    *   CANCELLED:  值为1，表示当前的线程被取消；</span><br><span class="line">    *   CONDITION:  值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="line">    *   PROPAGATE:  值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="line">    *   0:        None of the above 表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter; // 存储condition队列中的后继节点。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Returns true if node is waiting in shared mode.</span><br><span class="line">    */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">首先这是一个双向链表，从这里我们可以看出AQS的功能可以分为两类：独占功能和共享功能</b>。另外，排队的节点有5中状态，就是<code>waitStatus</code>的值，Node需要记录排队的线程和下一个等待的节点（线程）。</p>
<p>## </p>
<p>未完待续！！！！！</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a><br><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/深入java类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/深入java类加载器/" itemprop="url">深入java类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T17:41:35+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>对于java的类加载机制，我想大家一定都知道双亲委派模型和JDK类中的加载器。主要有Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader和User Defined ClassLoader。这些基础知识就不多说了。</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)：<br>这个类加载器使用C++语言实现，并非ClassLoader的子类。主要负责加载存放在<code>JAVA_HOME/jre/lib/rt.jar</code>里面所有的class文件，或者被<code>-Xbootclasspath</code>参数所指定路径中以rt.jar命名的文件。</li>
<li>扩展类加载器(Extension ClassLoader)：<br>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>JAVA_HOME/lib/ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li>
<li>应用程序类加载器(Application ClassLoader)：<br>这个加载器由sun.misc.Launcher$AppClassLoader实现，它负责加载<code>classpath</code>对应的jar及目录。一般情况下这个就是程序中默认的类加载器。</li>
<li>自定义类加载器(User Defined ClassLoader)：<br>开发人员继承ClassLoader抽象类自行实现的类加载器，基于自行开发的ClassLoader可用于并非加载classpath中(例如从网络上下载的jar或二进制字节码)、还可以在加载class文件之前做些小动作 如：加密等。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>类加载器(ClassLoader)用来加载 class字节码到 Java 虚拟机中，并转换成 java.lang.Class 类的一个实例。当然class字节码的来源可能有多种，一种就是自己拼写class文件的内容。</p>
<p>Java中如何比较两个类相等呢？这里所指的“相等”包括代表类的Class对象的equal方法、isAssignableFrom()、isInstance()方法及instance关键字返回的结果。</p>
<p>其实在Java中，一个类是否是相同的，主要取决于类加载器和包名+类名，只有以上条件都满足了，我们才说这两个类是相等的。我并没有在class文件中发现equals方法，这说明类加载的去重完全是在definedClass方法中，调用了底层的一些C代码实现的。也就是说，我们无法自己实例化一个Class实例，这需要JVM底层帮我们处理，每个Class实例的去重，完全是JVM的底层代码帮忙处理的。但是我们可以在class类中发现一个ClassLoader类的成员。</p>
<h2 id="ParallelLoaders"><a href="#ParallelLoaders" class="headerlink" title="ParallelLoaders"></a>ParallelLoaders</h2><p>这是ClassLoader里面的一个内部类，用来封装一组并行能力的加载器类型。这个一般是用不到的，有兴趣可以先看一下。但是需要知道ClassLoader是支持并行加载的。</p>
<h2 id="类加载过程与双亲委派"><a href="#类加载过程与双亲委派" class="headerlink" title="类加载过程与双亲委派"></a>类加载过程与双亲委派</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123; // 获得要用的锁</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); // 检查这个类有没有被加载</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime(); // 时间</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123; // 如果父类加载器，就用父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 默认的父类加载器是启动类加载器</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123; // 如果最终没有加载到这个类</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime(); // 取得系统时间</span><br><span class="line">                c = findClass(name); // 如果没有父类加载器就自己加载</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很清楚，就不用过多解释了。双亲委派不是基于继承实现的，而是基于组合的方式实现的，默认使用启动类加载器作为父类加载器。如果类加器的父类加载器没有帮助我们加载到相应的类，那么就会调用findClass这个方法，所以为啥我们定义类加载器的时候需要重写findClass方法的原因就在这里。</p>
<p>默认的findClass实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，如果加载不了类就抛异常，我们进行重写的时候，也应该注意这点（这是典型的模板方法模式）。</p>
<p>其次我们发现loadClass不是final方法，也就是说我们可以打破双亲委派的模型，直接使用自己的类加载器，但这样会出现无法使用系统类的问题了，这个只是我的猜测，但是如果我想ClassLoader中会不会相应的信息，也许需要以后研究JVM底层的时候，才会有答案了。</p>
<h2 id="重写findClass"><a href="#重写findClass" class="headerlink" title="重写findClass"></a>重写findClass</h2><p>我们可以发现重写findClass完全达不到自己生成Class的目的。然后你会发现defineClass也是返回Class类型的，所以我们需要在方法中调用这个方法进行相应的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    // 从codeSource中获取类所在文件路径</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有趣发现这里也有模板方法模式，如果你想前后处理一些事情，可以重写preDefineClass、postDefineClass这两个方法，但是注意原来的方法时private的，你无法调用super里面的方法，这会带来很多的问题。</p>
<p>当然defineClass本省就是一个重载方法，所以详细的信息请查看源码，这里就不多说明了，其实用到才关注，一般的时候是不用管的。</p>
<h2 id="resolveClass方法"><a href="#resolveClass方法" class="headerlink" title="resolveClass方法"></a>resolveClass方法</h2><p>resolveClass 此方法负责完成Class对象的链接，如果链接过，则直接返回。</p>
<h2 id="findLibrary-loadLiberay"><a href="#findLibrary-loadLiberay" class="headerlink" title="findLibrary/loadLiberay"></a>findLibrary/loadLiberay</h2><p>这两个方法其实是为了加载动态链接库使用的，以前我也分析过里面的代码，有些印象，这里就不做更多的解释了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/编译原理/LLVM语言参考手册(类型系统到其他值)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/编译原理/LLVM语言参考手册(类型系统到其他值)/" itemprop="url">LLVM语言参考手册(类型系统到其他值)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T12:34:05+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>LLVM类型系统是中间表示的最重要的特征之一。类型化使得可以直接对中间表示执行许多优化，而不必在转换之前在侧面进行额外的分析。强大的类型系统使读取生成的代码变得更加容易，并且支持新的分析和转换，这些分析和转换在普通的三个地址代码表示上不可行。</p>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>概述：void类型不代表任何值并且没有大小。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void</span><br></pre></td></tr></table></figure></p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>概述：    函数类型可以被认为是函数签名。它由一个返回类型和一个形式参数类型列表组成。函数类型的返回类型是void类型或第一类类型 - <a href="http://llvm.org/docs/LangRef.html#t-label" target="_blank" rel="noopener">标签</a>和<a href="http://llvm.org/docs/LangRef.html#t-metadata" target="_blank" rel="noopener">元数据</a>类型除外。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;returntype&gt; (&lt;parameter list&gt;)</span><br></pre></td></tr></table></figure></p>
<p>…其中<code>&lt;parameter list&gt;</code>是逗号分隔的类型说明符列表。可选地，参数列表可以包括类型…，该类型指示该函数采用可变数目的参数。变量参数函数可以通过<a href="http://llvm.org/docs/LangRef.html#int-varargs" target="_blank" rel="noopener">处理内部函数的变量参数</a>来访问它们的参数。<code>&lt;returntype&gt;</code>是除<a href="http://llvm.org/docs/LangRef.html#t-label" target="_blank" rel="noopener">标签</a>和<a href="http://llvm.org/docs/LangRef.html#t-metadata" target="_blank" rel="noopener">元数据</a>之外的任何类型。</p>
<p>例子：<br><code>i32 (i32)</code>    函数接受i32，返回一个i32<br><code>float (i16, i32 *) *</code>    指针，以接受一个函数i16和一个i32指针来返回float。<br><code>i32 (i8*, ...)</code>    可变参数函数，它有至少一个指针到i8（在C中是char），它返回一个整数。LLVM中这是printf的签名。<br><code>{i32, i32} (i32)</code>    一个函数i32，返回一个包含两个i32值的<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构</a></p>
<h2 id="第一类类型（First-Class-Types）"><a href="#第一类类型（First-Class-Types）" class="headerlink" title="第一类类型（First Class Types）"></a>第一类类型（First Class Types）</h2><p>第一类的类型可能是最重要的。这些类型的值是唯一可以通过指令产生的类型。</p>
<h3 id="单值类型"><a href="#单值类型" class="headerlink" title="单值类型"></a>单值类型</h3><p>这些是从CodeGen的角度来看在寄存器中有效的类型。</p>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>概述：    整数类型是一个非常简单的类型，它简单地为所需的整数类型指定一个任意的位宽。可以指定从1位到2<sup>23</sup>-1（约8百万）的任何位宽。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iN</span><br></pre></td></tr></table></figure></p>
<p>整数将占据的位数由该<code>N</code>值指定。</p>
<p>例子：<br><code>i1</code>    一个单位整数。<br><code>i32</code>    一个32位整数。<br><code>i1942652</code>    一个超过100万位的大整数。</p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>half</td>
<td>16位浮点值</td>
</tr>
<tr>
<td>float</td>
<td>32位浮点值</td>
</tr>
<tr>
<td>double</td>
<td>64位浮点值</td>
</tr>
<tr>
<td>fp128</td>
<td>128位浮点值（112位尾数）</td>
</tr>
<tr>
<td>x86_fp80</td>
<td>80位浮点值（X87）</td>
</tr>
<tr>
<td>ppc_fp128</td>
<td>128位浮点值（两个64位）</td>
</tr>
</tbody>
</table>
<p>half，float，double和fp128的二进制格式分别对应于binary16，binary32，binary64和binary128的IEEE-754-2008规范。</p>
<h4 id="X86-mmx类型"><a href="#X86-mmx类型" class="headerlink" title="X86_mmx类型"></a>X86_mmx类型</h4><p>概述：    x86_mmx类型表示在x86机器上的MMX寄存器中保存的值。允许的操作相当有限：参数和返回值，load和store以及bitcast。用户指定的<code>MMX</code>指令表示为具有参数<code>and/or</code>此类型结果的内部调用或asm调用。没有这种类型的数组、向量或常量。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_mmx</span><br></pre></td></tr></table></figure></p>
<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>概述：    指针类型用于指定内存位置。指针通常用于引用内存中的对象。</p>
<p>指针类型可能有一个可选的地址空间属性，用于定义指向对象所在的编号地址空间。默认地址空间是数字零。非零地址空间的语义是特定于目标的。</p>
<p>请注意，LLVM不允许指向<code>void（void*）</code>的指针，也不允许指向标签<code>（label*）</code>的指针。改为使用<code>i8*</code>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; *</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>[4 x i32]*</code>    4个的i32值数组的指针。<br><code>i32 (i32*) *</code>    函数指针，它接受一个<code>i32*</code>，并返回i32。<br><code>i32 addrspace(5)*</code>    i32值的指针，驻留在地址空间<code>#5</code>中的值。</p>
<h4 id="矢量类型"><a href="#矢量类型" class="headerlink" title="矢量类型"></a>矢量类型</h4><p>概述：    矢量类型是表示元素矢量的简单派生类型。当使用单个指令（SIMD）并行操作多个原始数据时，使用矢量类型。矢量类型需要大小（元素数量）和基础原始数据类型。矢量类型被认为是<a href="http://llvm.org/docs/LangRef.html#t-firstclass" target="_blank" rel="noopener">第一类</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; &lt;# elements&gt; x &lt;elementtype&gt; &gt;</span><br></pre></td></tr></table></figure></p>
<p>元素的数量是一个大于0的常数整数值; <code>elementtype</code>可以是任何整数、浮点或指针类型。大小为零的矢量是不允许的。</p>
<p>例子：<br><code>&lt;4 x i32&gt;</code>    4个32位整数值的向量。<br><code>&lt;8 x float&gt;</code>    8个32位浮点值的向量。<br><code>&lt;2 x i64&gt;</code>    2个64位整数值的向量。<br><code>&lt;4 x i64*&gt;</code>    4个64位整数值指针的向量。</p>
<h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><p>概述：    标签类型代表代码标签。<br>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label</span><br></pre></td></tr></table></figure></p>
<h3 id="令牌-token-类型"><a href="#令牌-token-类型" class="headerlink" title="令牌(token)类型"></a>令牌(token)类型</h3><p>概述：    当值与指令相关联时使用token类型，但该值的所有用法不得试图反思或模糊它。因此，具有<a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">phi</a>或<a href="http://llvm.org/docs/LangRef.html#i-select" target="_blank" rel="noopener">select</a>类型令牌是不合适的。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token</span><br></pre></td></tr></table></figure></p>
<h3 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h3><p>概述：    元数据类型表示嵌入的元数据。除函数参数外，不得从元数据创建派生类型。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metadata</span><br></pre></td></tr></table></figure></p>
<h3 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h3><p>聚合类型是派生类型的一个子集，可以包含多个成员类型。<a href="http://llvm.org/docs/LangRef.html#t-array" target="_blank" rel="noopener">数组</a>和<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构</a>是聚合类型。<a href="http://llvm.org/docs/LangRef.html#t-vector" target="_blank" rel="noopener">向量</a>不被视为聚合类型。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>概述：    数组类型是一种非常简单的派生类型，它将元素按顺序排列在内存中。数组类型需要大小（元素数量）和基础数据类型。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;# elements&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure></p>
<p>元素的数量是一个常数整数值; <code>elementtype</code>可以是任何尺寸的类型。</p>
<p>例子：<br><code>[40 x i32]</code>    包含40个32位整数值的数组。<br><code>[41 x i32]</code>    41个32位整数值的数组。<br><code>[4 x i8]</code>    包含4个8位整数值的数组。<br>以下是多维数组的一些示例：<br><code>[3 x [4 x i32]]</code>    3x4 32位整数值数组。<br><code>[12 x [10 x float]]</code>    单精度浮点值的12×10数组。<br><code>[2 x [3 x [4 x i16]]]</code>    2x3x4的16位整数值数组。</p>
<p>除了静态类型隐含的数组末尾之外，没有对索引的限制（尽管在某些情况下索引超出了分配对象的范围）。这意味着可以在零长度数组类型的LLVM中实现单维“可变大小数组”。例如，在LLVM中实现“pascal样式数组”可以使用类型“<code>{ i32, [0 x float]}</code>”。</p>
<h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>概述：    结构类型用于在内存中一起表示数据成员的集合。结构的元素可以是任何具有大小的类型。</p>
<p>使用’<code>load</code>‘和’<code>store</code>‘通过使用’<code>getelementptr</code>‘指令获取指向字段的指针来访问内存中的结构。使用’<code>extractvalue</code>‘和’<code>insertvalue</code>‘指令访问寄存器中的结构。</p>
<p>结构可以选择是“压缩”结构，其指示结构的对齐是一个字节，并且元素之间没有填充。在非压缩结构中，字段类型之间的填充按照DataLayout字符串在模块中定义的方式插入，该模块需要与基础代码生成器的预期匹配。</p>
<p>结构可以是“文字”或“识别符”。字面结构与其他类型（例如<code>{i32, i32}*</code>）内联定义，而标识类型始终在顶层使用名称定义。文字类型被其内容所独占，因为没有办法编写它们，所以永远不会递归或不透明。识别符的类型可以是递归的，可以是不透明的，并且永远不会被分离。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 = type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 = type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>{ i32, i32, i32 }</code>    三个i32值的结构<br><code>{ float, i32 (i32) * }</code>    一对，其中第一个元素是a float，第二个元素是一个指向函数的指针，该函数接受一个i32返回值i32。<br><code>&lt;{ i8, i32 }&gt;</code>    一个已知为5字节大小的打包结构。</p>
<h4 id="不透明结构类型"><a href="#不透明结构类型" class="headerlink" title="不透明结构类型"></a>不透明结构类型</h4><p>概述：    不透明结构类型用于表示没有指定主体的命名结构类型。这符合（例如）正向声明结构的C概念。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%X = type opaque</span><br><span class="line">%52 = type opaque</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>opaque</code>    一种不透明的类型。</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>LLVM有几种不同的基本类型的常量。本节介绍它们的全部和它们的语法。</p>
<h2 id="简单常量"><a href="#简单常量" class="headerlink" title="简单常量"></a>简单常量</h2><ul>
<li>布尔常量: 两个字符串’ true’和’ false’都是该i1类型的有效常量。</li>
<li>整型常量: 标准整数（如’4’）是整数类型的常量 。负数可能与整数类型一起使用。</li>
<li>浮点常量: 浮点常量使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e + 2）或更精确的十六进制表示法（请参见下文）。汇编器需要浮点常量的精确十进制值。例如，汇编程序接受1.25，但拒绝1.3，因为1.3是二进制中的重复小数。浮点常量必须具有 浮点类型。</li>
<li>空指针常量: 标识符’<code>null</code>‘被识别为空指针常量，并且必须是指针类型。</li>
<li>令牌(Token)常量: 标识符’none’被识别为空的标记常量，并且必须是标记类型。</li>
</ul>
<p>常量的一个非直观符号是浮点常量的十六进制形式。例如，形式为’<code>double    0x432ff973cafa8000</code>‘等同于（但难以阅读）’<code>double 4.5e+15</code>‘。唯一需要十六进制浮点常量（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能用合理数目的十进制浮点数表示的浮点常量数字。例如，<code>NaN&#39;s</code>，<code>infinities</code>和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位发生更改。</p>
<p>当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字形式表示（与IEEE754表示符合double）; 然而，half和float值必须分别精确表示为IEEE 754的半精度和单精度。十六进制格式总是用于长双，并有三种形式的长双。x86使用的80位格式表示0xK后跟20个十六进制数字。PowerPC使用的128位格式（两个相邻的双精度） 0xM由32个十六进制数字表示。IEEE 128位格式0xL由32个十六进制数字表示。长双打只有在你的目标上的长双重格式匹配时才有效。IEEE 16位格式（半精度）由表示0xH 后跟4个十六进制数字。所有的十六进制格式都是big-endian（左边的符号位）。</p>
<p>没有<code>x86_mmx</code>类型的常量。</p>
<h2 id="复杂（Complex）常量"><a href="#复杂（Complex）常量" class="headerlink" title="复杂（Complex）常量"></a>复杂（Complex）常量</h2><p>复杂常量是简单常量和较小复常量的（可能递归）组合。</p>
<h3 id="结构常数"><a href="#结构常数" class="headerlink" title="结构常数"></a>结构常数</h3><p>结构常量用类似于结构类型定义的符号表示（逗号分隔的元素列表，用大括号（{}）括起来）。例如：“<code>{ i32 4, float 17.0, i32* @G }</code>”，其中“<code>@G</code>”被声明为“<code>@G = external global i32</code>”。结构常量必须具有<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构类型</a>，并且元素的数量和类型必须与该类型指定的类型匹配。</p>
<h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号（[]）括起来）。例如：“<code>[ i32 42, i32 11, i32 74 ]</code>”。数组常量必须具有<a href="http://llvm.org/docs/LangRef.html#t-array" target="_blank" rel="noopener">数组类型</a>，并且元素的数量和类型必须与该类型指定的数量和类型相匹配。作为一种特殊情况，字符数组常量也可以用 前缀表示为双引号字符串。例如：“c<code>&quot;Hello World\0A\00&quot;</code>”。</p>
<h3 id="矢量-Vector-常量"><a href="#矢量-Vector-常量" class="headerlink" title="矢量(Vector)常量"></a>矢量(Vector)常量</h3><p>向量常量用类似于向量类型定义的符号表示（逗号分隔的元素列表，由小于/大于（（&lt;&gt;））围绕）。例如：“<code>&lt; i32 42, i32 11, i32 74, i32 100 &gt;</code>”。向量常量必须具有向量类型，并且元素的数量和类型必须与该类型指定的类型匹配。</p>
<h3 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h3><p>字符串“<code>zeroinitializer</code>‘可用于将零值初始化为任何类型的零，包括标量和<a href="http://llvm.org/docs/LangRef.html#t-aggregate" target="_blank" rel="noopener">聚合类型</a>。这通常用于避免必须打印大型零初始化器（例如，用于大型数组），并且始终完全等同于使用显式零初始化器。</p>
<h3 id="元数据节点"><a href="#元数据节点" class="headerlink" title="元数据节点"></a>元数据节点</h3><p>元数据节点是一个没有类型的常量元组。例如：“<code>!{!0, !{!2, !0}, !&quot;test&quot;}</code>”。元数据可以引用常量值，例如：“<code>!{!0, i32 0, i8* @global, i64 (i64)* @function, !&quot;str&quot;}</code>”。与其他类型化的常量不同，它们被解释为指令流的一部分，元数据是附加附加信息的地方，例如调试信息。</p>
<h2 id="全局变量和函数地址"><a href="#全局变量和函数地址" class="headerlink" title="全局变量和函数地址"></a>全局变量和函数地址</h2><p><a href="http://llvm.org/docs/LangRef.html#globalvars" target="_blank" rel="noopener">全局变量</a>和 <a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数</a>总是隐式有效（链接时间）常量。当使用<a href="http://llvm.org/docs/LangRef.html#identifiers" target="_blank" rel="noopener">全局标识符</a>并且总是有指针类型时，这些常量被明确引用。例如，以下是合法的LLVM文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@X = global i32 17</span><br><span class="line">@Y = global i32 42</span><br><span class="line">@Z = global [2 x i32*] [ i32* @X, i32* @Y ]</span><br></pre></td></tr></table></figure></p>
<h2 id="未定义的值"><a href="#未定义的值" class="headerlink" title="未定义的值"></a>未定义的值</h2><p>字符串’<code>undef</code>‘可以用于任何需要常量的地方，并且表示该值的用户可能会收到未指定的位模式。未定义的值可以是任何类型（除了’<code>label</code>‘或’<code>void</code>‘），并且可以在任何允许常量的地方使用。</p>
<p>未定义的值非常有用，因为它们向编译器指出，无论使用什么值，该程序都已定义良好。这为编译器提供了更多的优化自由度。下面是一些有效的（可能令人惊讶的）转换的例子（在伪IR中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  %A = add %X, undef</span><br><span class="line">  %B = sub %X, undef</span><br><span class="line">  %C = xor %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure></p>
<p>这是安全的，因为所有的输出位都受<code>undef</code>位的影响。任何输出位都可以有一个零或一个依赖的输入位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = or %X, undef</span><br><span class="line">  %B = and %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = -1</span><br><span class="line">  %B = 0</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X  ;; By choosing undef as 0</span><br><span class="line">  %B = %X  ;; By choosing undef as -1</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br></pre></td></tr></table></figure></p>
<p>这些逻辑操作的位不总是受输入的影响。例如，如果%X有一个零位，那么“<code>and</code>‘操作的输出将始终为该位的零，而不管”<code>undef</code>‘ 的相应位是什么。因此，优化或假设<code>and</code>的结果是<code>undef</code>是不安全的。但是，假设<code>undef</code>的所有位都可以是0，并且将’<code>and</code>‘优化为0是安全的。同样，假设可以设置<code>undef</code>的<code>or</code>操作的所有位是安全的，允许’<code>or</code>‘被折叠为-1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = select undef, %X, %Y</span><br><span class="line">  %B = select undef, 42, %Y</span><br><span class="line">  %C = select %X, %Y, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X     (or %Y)</span><br><span class="line">  %B = 42     (or %Y)</span><br><span class="line">  %C = %Y</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure></p>
<p>这组例子表明，未定义的’<code>select</code>‘（和条件分支）条件可以采取任何方式，但它们必须来自两个操作数中的一个。在<code>%A</code>例子中，如果<code>%X</code>和<code>%Y</code>是两个已知具有明显的低位，那么<code>%A</code>就必须有一个清除低位。然而，在这个<code>%C</code>例子中，优化器被允许假设’<code>undef</code>‘操作可以是和<code>%Y</code>相同的，允许整个’<code>select</code>‘被消除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  %A = xor undef, undef</span><br><span class="line"></span><br><span class="line">  %B = undef</span><br><span class="line">  %C = xor %B, %B</span><br><span class="line"></span><br><span class="line">  %D = undef</span><br><span class="line">  %E = icmp slt %D, 4</span><br><span class="line">  %F = icmp gte %D, 4</span><br><span class="line"></span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br><span class="line">  %D = undef</span><br><span class="line">  %E = undef</span><br><span class="line">  %F = undef</span><br></pre></td></tr></table></figure></p>
<p>这个例子指出两个<code>undef</code>操作不一定相同。这对于人们来说可能是令人惊讶的（并且也匹配C语义），他们认为“<code>X^X</code>”总是零，即使 X未定义也是如此。由于多种原因，这是不正确的，但简单的答案是，一个<code>undef</code>“变量”可以在其“生存范围”内随意改变它的值。这是真的，因为这个变量实际上并没有生存范围。相反，该值是从任意寄存器中逻辑读取的，这些寄存器恰好在需要时发生变化，因此该值不一定随时间变化。事实上，<code>%A</code>和<code>%C</code>需要有相同的语法或核心LLVM“全部替换与使用”的概念将不成立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = sdiv undef, %X</span><br><span class="line">  %B = sdiv %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = 0</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure></p>
<p>这些示例显示了未定义的值 和未定义的行为之间的关键区别。一个未定义的值（如’<code>undef</code>‘）允许有一个任意的位模式。这意味着<code>%A</code>操作可以不断折叠为’0’，因为’<code>undef</code>‘可能为零，并且零除以任何值为零。但是，在第二个例子中，我们可以做一个更积极的假设：因为<code>undef</code>允许它是一个任意值，我们可以假设它可能为零。由于被零除以具有未定义的行为，我们被允许假设该操作根本不执行。这允许我们删除分割和所有代码。由于未定义的操作“不可能发生”，因此优化器可以假定它发生在死代码中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:  store undef -&gt; %X</span><br><span class="line">b:  store %X -&gt; undef</span><br><span class="line">Safe:</span><br><span class="line">a: &lt;deleted&gt;</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure></p>
<p>存储的未定义的值可以被假设为不具有任何影响; 我们可以假设这个值被恰好与已经存在的相匹配的位覆盖。然而，一个存储到一个未定义的位置可能破坏任意的内存，因此，它具有未定义行为。</p>
<h2 id="毒药（Poison）值"><a href="#毒药（Poison）值" class="headerlink" title="毒药（Poison）值"></a>毒药（Poison）值</h2><p>毒性（Poison）值与undef值相似，但它们也表示这样的事实，即不能引起副作用的指令或常量表达式已经检测到导致未定义行为的条件。</p>
<p>目前在IR中无法表示毒物值; 它们只存在于某些操作的调用，如带有<code>nsw</code>标志的<code>add</code>操作。</p>
<p>毒药值行为是根据值依赖来定义的：</p>
<ul>
<li><a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">phi</a>节点以外的值取决于它们的操作数。</li>
<li><a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">Phi</a>节点取决于对应于其动态前驱基本块的操作数。</li>
<li>函数参数取决于其函数的动态调用者中相应的实际参数值。</li>
<li>调用(<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener">call</a>)指令取决于将控制动态传回给它们的<a href="http://llvm.org/docs/LangRef.html#i-ret" target="_blank" rel="noopener">ret</a>指令。</li>
<li>调用(<a href="http://llvm.org/docs/LangRef.html#i-invoke" target="_blank" rel="noopener">invoke</a>)指令取决于ret， <a href="http://llvm.org/docs/LangRef.html#i-resume" target="_blank" rel="noopener">resume</a>或异常抛出调用指令，动态地将控制权交还给它们。</li>
<li>非易失性加载和存储取决于所有引用的内存地址的最新存储，遵循IR中的命令（包括由<a href="mailto:`@llvm.memcpy" target="_blank" rel="noopener">`@llvm.memcpy</a>`等内在函数隐含的加载和存储）。</li>
<li>具有外部可见副作用的指令取决于最近的先前的指令，其具有外部可见的副作用，遵循IR中的顺序。（这包括易失性操作。）</li>
<li>指令控制依赖于一个终止指令，如果终止子指令有多个后继者和指令总是被执行时控制转移到后继的一个，并且当控制被转移到另一个可以不执行。</li>
<li>此外，指令也是控制 - 取决于终止指令，如果终止指令已将控制权转移给不同的后继者，则其所依赖的指令集将会不​​同。</li>
<li>依赖性是传递性的。</li>
</ul>
<p>Poison值具有与undef值相同的行为，另外的效果是任何依赖poison值的指令都具有未定义的行为。</p>
<p>这里有些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  %poison = sub nuw i32 0, 1           ; Results in a poison value.</span><br><span class="line">  %still_poison = and i32 %poison, 0   ; 0, but also poison.</span><br><span class="line">  %poison_yet_again = getelementptr i32, i32* @h, i32 %still_poison</span><br><span class="line">  store i32 0, i32* %poison_yet_again  ; memory at @h[0] is poisoned</span><br><span class="line"></span><br><span class="line">  store i32 %poison, i32* @g           ; Poison value stored to memory.</span><br><span class="line">  %poison2 = load i32, i32* @g         ; Poison value loaded back from memory.</span><br><span class="line"></span><br><span class="line">  store volatile i32 %poison, i32* @g  ; External observation; undefined behavior.</span><br><span class="line"></span><br><span class="line">  %narrowaddr = bitcast i32* @g to i16*</span><br><span class="line">  %wideaddr = bitcast i32* @g to i64*</span><br><span class="line">  %poison3 = load i16, i16* %narrowaddr ; Returns a poison value.</span><br><span class="line">  %poison4 = load i64, i64* %wideaddr  ; Returns a poison value.</span><br><span class="line"></span><br><span class="line">  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.</span><br><span class="line">  br i1 %cmp, label %true, label %end  ; Branch to either destination.</span><br><span class="line"></span><br><span class="line">true:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This is control-dependent on %cmp, so</span><br><span class="line">                                       ; it has undefined behavior.</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  %p = phi i32 [ 0, %entry ], [ 1, %true ]</span><br><span class="line">                                       ; Both edges into this PHI are</span><br><span class="line">                                       ; control-dependent on %cmp, so this</span><br><span class="line">                                       ; always results in a poison value.</span><br><span class="line"></span><br><span class="line">  store volatile i32 0, i32* @g        ; This would depend on the store in %true</span><br><span class="line">                                       ; if %cmp is true, or the store in %entry</span><br><span class="line">                                       ; otherwise, so this is undefined behavior.</span><br><span class="line"></span><br><span class="line">  br i1 %cmp, label %second_true, label %second_end</span><br><span class="line">                                       ; The same branch again, but this time the</span><br><span class="line">                                       ; true block doesn&apos;t have side effects.</span><br><span class="line"></span><br><span class="line">second_true:</span><br><span class="line">  ; No side effects!</span><br><span class="line">  ret void</span><br><span class="line"></span><br><span class="line">second_end:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This time, the instruction always depends</span><br><span class="line">                                       ; on the store in %end. Also, it is</span><br><span class="line">                                       ; control-equivalent to %end, so this is</span><br><span class="line">                                       ; well-defined (ignoring earlier undefined</span><br><span class="line">                                       ; behavior in this example).</span><br></pre></td></tr></table></figure></p>
<h2 id="基本块的地址"><a href="#基本块的地址" class="headerlink" title="基本块的地址"></a>基本块的地址</h2><p><code>blockaddress(@function, %block)</code></p>
<p>在“<code>blockaddress</code>”常数计算在指定函数指定的基本块的地址，并总是有一个<code>i8*</code>类型。取出输入块的地址是非法的。</p>
<p>当用作’<code>indirectbr</code>‘指令的操作指令时，或者用于与空值进行比较时，该值仅具有已定义的行为。标签地址之间的指针相等测试会导致未定义的行为 - 但是，再次，与null进行比较是可以的，并且没有标签等于空指针。只要这些位未被检查，这可以作为不透明的指针大小值传递。ptrtoint只要原始值在indirectbr 指令之前重新构成，就允许和计算这些值。</p>
<p>最后，有些目标可能会在使用该值作为内联程序集的操作数时提供定义的语义，但这是目标特定的。</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式用于允许涉及其他常量的表达式用作常量。常量表达式可以是任何<a href="http://llvm.org/docs/LangRef.html#t-firstclass" target="_blank" rel="noopener">第一类类型</a>，并且可能涉及没有副作用的任何LLVM操作（例如，不支持加载和调用）。以下是常量表达式的语法：</p>
<ul>
<li><code>trunc (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-trunc" target="_blank" rel="noopener">trunc操作</a>。</li>
<li><code>zext (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-zext" target="_blank" rel="noopener">zext操作</a>。</li>
<li><code>sext (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-sext" target="_blank" rel="noopener">sext操作</a>。</li>
<li><code>fptrunc (CST to TYPE)</code>: 将浮点常量截断为另一个浮点类型。CST的大小必须大于TYPE的大小。这两种类型都必须是浮点型。</li>
<li><code>fpext (CST to TYPE)</code>: 浮点将常量扩展为另一种类型。CST的大小必须小于或等于TYPE的大小。这两种类型都必须是浮点型。</li>
<li><code>fptoui (CST to TYPE)</code>: 将浮点常量转换为相应的无符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li>
<li><code>fptosi (CST to TYPE)</code>: 将浮点常量转换为相应的有符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li>
<li><code>uitofp (CST to TYPE)</code>: 将无符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li>
<li><code>sitofp (CST to TYPE)</code>: 将有符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li>
<li><code>ptrtoint (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-ptrtoint" target="_blank" rel="noopener">ptrtoint操作</a>。</li>
<li><code>inttoptr (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-inttoptr" target="_blank" rel="noopener">inttoptr操作</a>。这个真的很危险！</li>
<li><code>bitcast (CST to TYPE)</code>: 将常数CST转换为另一个TYPE。操作数的限制与<a href="http://llvm.org/docs/LangRef.html#i-bitcast" target="_blank" rel="noopener">bitcast指令</a>的限制相同 。</li>
<li><code>addrspacecast (CST to TYPE)</code>: 将指针CST的常量指针或常量向量转换为另一个地址空间中的另一个TYPE。操作数的约束与<a href="http://llvm.org/docs/LangRef.html#i-addrspacecast" target="_blank" rel="noopener">addrspacecast指令</a>的约束相同。</li>
<li><code>getelementptr (TY, CSTPTR, IDX0, IDX1, ...)， getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr操作</a>。与<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a> 指令一样，索引列表可能有一个或多个索引，这些索引对于“指向TY的指针”类型是有意义的。</li>
<li><code>select (COND, VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-select" target="_blank" rel="noopener">选择操作</a>。</li>
<li><code>icmp COND (VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-icmp" target="_blank" rel="noopener">icmp操作</a>。</li>
<li><code>fcmp COND (VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-fcmp" target="_blank" rel="noopener">fcmp操作</a>。</li>
<li><code>extractelement (VAL, IDX)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-extractelement" target="_blank" rel="noopener">extractelement操作</a>。</li>
<li><code>insertelement (VAL, ELT, IDX)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-insertelement" target="_blank" rel="noopener">insertelement操作</a>。</li>
<li><code>shufflevector (VEC1, VEC2, IDXMASK)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-shufflevector" target="_blank" rel="noopener">shufflevector操作</a>。</li>
<li><code>extractvalue (VAL, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-extractvalue" target="_blank" rel="noopener">extractvalue操作</a>。索引列表的解释方式与“<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a>”操作中的索引类似。至少必须指定一个索引值。</li>
<li><code>insertvalue (VAL, ELT, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-insertvalue" target="_blank" rel="noopener">insertvalue操作</a>。索引列表的解释方式与“<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a>”操作中的索引类似。至少必须指定一个索引值。</li>
<li><code>OPCODE (LHS, RHS)</code>: 执行LHS和RHS常量的指定操作。操作码可以是任何<a href="http://llvm.org/docs/LangRef.html#binaryops" target="_blank" rel="noopener">二进制</a>或<a href="http://llvm.org/docs/LangRef.html#bitwiseops" target="_blank" rel="noopener">按位二进制</a>操作。操作数的限制与相应指令的限制相同（例如，不允许对浮点值进行按位操作）。</li>
</ul>
<h1 id="其他值"><a href="#其他值" class="headerlink" title="其他值"></a>其他值</h1><h2 id="内嵌汇编表达式"><a href="#内嵌汇编表达式" class="headerlink" title="内嵌汇编表达式"></a>内嵌汇编表达式</h2><p>LLVM 通过使用特殊值支持内联汇编表达式（与模块级内联汇编相反）。该值表示内联汇编程序作为模板字符串（包含要发出的指令），操作数约束列表（存储为字符串），指示内联asm表达式是否具有副作用的标志以及指示是否包含asm的函数需要保守地调整堆栈。</p>
<p>模板字符串支持使用<code>$</code>后跟一个数字的参数替换，以指示由约束字符串指定的给定寄存器/内存位置的替换。“<code>${NUM:MODIFIER}</code>”也可以使用，其中MODIFIER是如何打印操作数的特定于目标的注释（请参阅<a href="http://llvm.org/docs/LangRef.html#inline-asm-modifiers" target="_blank" rel="noopener">Asm模板参数修饰符</a>）。</p>
<p>字符<code>$</code>可以在模板中使用“<code>$$</code>”。要在输出中包含其他特殊字符，可以使用通常的“<code>\XX</code>”转义符，就像在其他字符串中一样。请注意，在模板替换之后，生成的汇编字符串将由LLVM的集成汇编器进行分析，除非它被禁用 - 即使发出<code>.s</code>文件 - 也必须包含LLVM已知的汇编语法。</p>
<p>LLVM还支持一些有用的内联汇编代码：</p>
<ul>
<li><code>${:uid}</code>：扩展为这个内联汇编blob唯一的十进制整数。在声明本地标签时，这种替换很有用。许多标准的编译器优化（如内联）可能会复制内联asm blob。添加blob唯一标识符可确保这两个标签在装配过程中不会发生冲突。这用于实现<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">GCC的％=特殊格式字符串</a>。</li>
<li><code>${:comment}</code>：扩展为当前目标的汇编方言的注释字符。这通常是<code>#</code>，但很多指标使用其他字符串，例如<code>;</code>，<code>//</code>或<code>!</code>。</li>
<li><code>${:private}</code>：扩展为汇编器专用标签前缀。带有此前缀的标签不会出现在组装对象的符号表中。通常前缀是<code>L</code>，但目标可能使用其他字符串。<code>.L</code>是比较受欢迎的。</li>
</ul>
<p>LLVM对inline asm的支持与Clang的GCC兼容的inline-asm支持的要求紧密相关。因此，这里列出的特征集以及约束和修饰符代码与GCC内联asm支持中的代码类似或相同。然而，要清楚的是，这里描述的模板和约束字符串的语法与GCC和Clang所接受的语法并不相同，并且尽管大多数约束字母是通过Clang原样传递的，但当从C源代码转换为LLVM程序集时，有些字符会被转换为其他代码。</p>
<p>一个内联汇编表达式的例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i32 (i32) asm &quot;bswap $0&quot;, &quot;=r,r&quot;</span><br></pre></td></tr></table></figure></p>
<p>内联汇编程序表达式只能用作调用(call)或调用(invoke)指令的被调用者操作数。因此，通常我们有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%X = call i32 asm &quot;bswap $0&quot;, &quot;=r,r&quot;(i32 %Y)</span><br></pre></td></tr></table></figure></p>
<p>带有在约束列表中不可见的副作用的内联asms必须标记为具有副作用。这是通过使用’sideeffect’关键字完成的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下，内联asms将包含无法工作的代码，除非堆栈以某种方式对齐，例如x86上的调用或SSE指令，但不会包含在asm中执行对齐的代码。编译器应该对asm可能包含的内容做出保守的假设，并且如果’alignstack’关键字存在，应该在序言中生成其通常的堆栈对齐代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm alignstack &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>内联asms也支持使用非标准汇编方言。假定的方言是ATT。当’<code>inteldialect</code>‘关键字存在时，内联asm使用英特尔方言。目前，ATT和Intel是唯一支持的方言。一个例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm inteldialect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>如果出现多个关键字，则’<code>sideeffect</code>‘关键字必须首先出现，’<code>alignstack</code>‘关键字第二关键字和’<code>inteldialect</code>‘关键字最后出现。</p>
<h3 id="内联汇编约束字符串"><a href="#内联汇编约束字符串" class="headerlink" title="内联汇编约束字符串"></a>内联汇编约束字符串</h3><p>约束列表是逗号分隔的字符串，每个元素包含一个或多个约束代码。</p>
<p>对于约束列表中的每个元素，将选择一个适当的寄存器或内存操作数，并且将对<code>$0</code>列表中的第一个约束，<code>$1</code>第二个等将使其可用于组件模板字符串扩展。</p>
<p>有三种不同类型的约束，它们通过约束代码前面的前缀符号进行区分：输出，输入和Clobber。必须始终按照以下顺序给出约束：先输出，然后输入，然后是clobbers。他们不能混在一起。</p>
<p>还有三种不同类型的约束代码：</p>
<ul>
<li>注册约束。这是一个寄存器类，或者是一个固定的物理寄存器。这种约束将分配一个寄存器，并且如果必要的话，将该参数或结果进行bitcast到适当的类型。</li>
<li>内存约束。这种约束用于获取内存操作数的指令。不同的约束允许目标使用不同的寻址模式。</li>
<li>立即值限制。这种约束是针对整数或其他立即值的，它可以直接渲染到指令中。各种特定于目标的约束条件允许为您希望使用的指令选择合适范围内的值。</li>
</ul>
<h4 id="输出约束"><a href="#输出约束" class="headerlink" title="输出约束"></a>输出约束</h4><p>输出约束由“<code>=</code>”前缀（例如“<code>=r</code>”）指定。这表示程序集将写入此操作数，然后操作数将作为asm表达式的返回值提供。输出约束不会消耗调用指令中的参数。（除了下面关于间接输出的内容）。</p>
<p>通常，在读取所有输入之前，预计没有输出位置被汇编表达式写入。因此，LLVM可以将相同的寄存器分配给输出和输入。如果这不安全（例如，如果程序集包含两条指令，其中第一条写入一个输出，第二条读取输入并写入第二条输出），则必须使用“<code>&amp;</code>”修饰符（例如“<code>=&amp;r</code>”）来指定输出是“早期破坏”输出。将输出标记为“<code>early-clobber</code>”可确保LLVM不会对任何输入（除了与此输出关联的输入）使用相同的寄存器。</p>
<h4 id="输入约束"><a href="#输入约束" class="headerlink" title="输入约束"></a>输入约束</h4><p><b style="color:green">输入约束没有前缀 - 只是约束代码。每个输入约束将从调用指令中消耗一个参数。asm不允许写入任何输入寄存器或存储单元（除非该输入连接到输出）。还要注意，如果LLVM可以确定它们必然都包含相同的值，则可以将多个输入全部分配给相同的寄存器。</b></p>
<p>通过提供一个整数作为约束字符串，输入约束可以将它们自己绑定到输出约束，而不是提供约束代码。被绑定的输入仍然会从调用指令中消耗一个参数，并且按照通常的方式在asm模板编号中占据一个位置 - 它们将被简单地限制为始终使用与其绑定的输出相同的寄存器。例如，一个约束字符串“<code>=r,0</code>”表示为输出分配一个寄存器，并将该寄存器用作输入（它是第<code>0</code>个约束）。</p>
<p>允许将输入连接到“早期破坏(early-clobber)”输出。在这种情况下，没有 其他输入可能与连接到早期触发器的输入共享相同的寄存器（即使其他输入具有相同的值）。</p>
<p>您只能将输入绑定到具有寄存器约束但不受内存约束的输出。只有一个输入可能与输出相关联。</p>
<p>还有一个“有趣”的特性，值得一点解释：如果寄存器类约束分配的寄存器对于作为输入提供的值类型操作数来说太小，则输入值将被分成多个寄存器，并且所有寄存器传递给内联asm。</p>
<p>但是，此功能通常不如您想象的那么有用。</p>
<p>首先，寄存器不保证连续。因此，在那些具有多条连续指令操作指令的体系结构上，这不是支持它们的适当方式。（例如，32位SparcV8具有64位加载，该指令只需要一个32位寄存器，然后硬件将加载到指定的寄存器和下一个寄存器中。内联asm的此功能对于此的支持将不会有用。）</p>
<p>几个目标提供了一个模板字符串修改，允许两寄存器操作数的第二个寄存器明确的访问（例如MIPS L，M和 D）。在这样的体系结构中，您实际上可以访问第二个已分配的寄存器（但是，仍然没有任何后续的寄存器）。但是，在这种情况下，为了清晰起见，将这个值简化为两个独立的操作数仍然可能更好。（例如，请参阅AX86 上的约束描述，尽管该特性仅用于此功能，但使用并不是一个好主意）</p>
<h4 id="间接投入和产出"><a href="#间接投入和产出" class="headerlink" title="间接投入和产出"></a>间接投入和产出</h4><p>间接输出或输入约束可以由“<code>*</code>”修饰符（在输出的情况下在“<code>=</code>”之后）指定。这表明asm将写入或读取作为输入参数提供的地址的内容。（注意，在这种方式，间接输出更像一个输入而不是输出：只是像输入，它们消耗的调用表达式的参数，而不是产生一个返回值。间接输出约束是“输出”仅是希望在asm可以写入输入内存位置的内容，而不是从中读取）。</p>
<p><b style="color:green">这通常用于内存约束，例如“<code>=*m</code>”，以将变量的地址作为值传递。</b></p>
<p>也可以使用间接寄存器约束，但仅限于输出（例如“<code>=*r</code>”）。这会导致LLVM正常地为输出值分配一个寄存器，然后在提供的内联asm之后，单独发送一个存储到作为输入提供的地址。（与在asm语句后明确写入store相比，此功能提供了什么值尚不清楚，而且它只能生成更糟糕的代码，因为它绕过了许多优化过程，我建议不要使用它。）</p>
<h4 id="Clobber约束"><a href="#Clobber约束" class="headerlink" title="Clobber约束"></a>Clobber约束</h4><p>一个clobber约束由一个“<code>~</code>”前缀表示。clobber不会消耗输入操作数，也不会生成输出。Clobbers不能使用任何一般的约束代码字母 - 它们可能只使用明确的寄存器约束，例如“<code>~{eax}</code>”。一个例外是，“<code>~{memory}</code>” 的clobber字符串表示程序集写入任意未声明的内存位置 - 不仅是由声明的间接输出指向的内存。</p>
<p>请注意，输出约束中也存在的clobbering命名寄存器是不合法的。</p>
<h4 id="约束代码"><a href="#约束代码" class="headerlink" title="约束代码"></a>约束代码</h4><p>潜在的前缀来了约束代码或代码之后。</p>
<p>约束代码可以是单个字母（例如“<code>r</code>”），“<code>^</code>”字符后跟两个字母（例如“<code>^wc</code>”）或“<code>{”寄存器名称“ }</code>”（例如“<code>{eax}</code>”）。</p>
<p>通常选择单字母和双字母约束代码与GCC的约束代码相同。</p>
<p>一个约束可能包含一个或多个约束代码，而让LLVM选择使用哪一个约束代码。这主要包括与来自clang的GCC inline asm的翻译兼容。</p>
<p>有两种方式可以指定替代方案，并且可以在内联asm约束列表中使用其中之一或两者。</p>
<ol>
<li>相互追加代码，制作约束代码集。例如“<code>im</code>”或“ <code>{eax}m</code>”。这意味着“选择集合中的任何选项”。对约束列表中的每个约束独立进行约束的选择。</li>
<li>在约束代码集之间使用“<code>|</code>”，创建替代方案。约束列表中的每个约束都必须具有相同数量的备选集。使用这种语法，约束列表中所有项目中的相同备选项将一起选择。</li>
</ol>
<p>把它们放在一起，你可能会有两个操作数约束字符串,像”<code>rm|r,ri|rm</code>“。这表明如果操作数0是r或m，则操作数1可以是r或i。如果操作数0是r，则操作数1可以是r或m。但是，操作数0和1不能都是m类型。</p>
<p>但是，不推荐使用其中任何一种替代功能，因为LLVM无法对使用哪种替代功能做出明智选择。（在当前需要选择的时候，没有足够的信息可以用聪明的方式来实现。）因此，它只是试图做出最有可能编译的选择，而不是最优性能的选择。（例如，给定“rm”，它总是选择使用内存，而不是寄存器）。而且，如果给定多个寄存器或多个寄存器类，它将简单地选择第一个。（实际上，目前它甚至不确保明确指定的物理寄存器是唯一的，因此指定多个物理寄存器作为替代，例如 {r11}{r12},{r11}{r12}，将r11分配给两个操作数，而不是所有打算的。）</p>
<h4 id="支持的约束代码列表"><a href="#支持的约束代码列表" class="headerlink" title="支持的约束代码列表"></a>支持的约束代码列表</h4><p>一般来说，约束代码的行为与GCC中的一样。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p>
<p>所有目标通常都支持一些约束代码：</p>
<ul>
<li>r：目标通用寄存器类中的寄存器。</li>
<li>m：存储器地址操作数。它支持哪些寻址模式，典型的例子是寄存器，寄存器+寄存器偏移量，或寄存器+直接偏移量（某些目标特定的大小）。</li>
<li>i：一个整数常量（目标特定宽度）。允许简单的即时或可重定位的值。</li>
<li>n：一个整数常量 - 不包括可重定位值。</li>
<li>s：一个整数常量，但只允许重定位值。</li>
<li>X：允许任何类型的操作数，不受任何限制。通常用于为asm分支或call传递标签。</li>
<li>{register-name}：需要完整的指定物理寄存器。</li>
</ul>
<p>其他约束是针对具体目标的：</p>
<p>AArch64：</p>
<ul>
<li>z：一个立即数整数0.输出WZR或者XZR视情况而定。</li>
<li>I：对一个ADD或SUB指令有效的立即整数，即0到4095，可选的移位12。</li>
<li>J：一个立即数，取反时对一个ADD或 SUB指令有效，即-1到-4095，可选左移12。</li>
<li>K：一个直接整数，它是有效的“位掩码即时32”的逻辑指令等AND，EOR或ORR与32位寄存器。</li>
<li>L：一个直接整数，它是有效的“位掩码即时64”的逻辑指令等AND，EOR或ORR与64位寄存器。</li>
<li>M：与MOV32位寄存器上的程序集别名一起使用的立即整数。这是一个超集K：除了bitmask立即数，还允许立即可以装载单个MOVZ或MOVL指令的整数 。</li>
<li>N：用于MOV64位寄存器上的程序集别名的立即整数。这是一个超集L。</li>
<li>Q：存储器地址操作数必须位于单个寄存器中（无偏移量）。（但是，LLVM目前也为m约束做了这个。）</li>
<li>r：32位或64位整数寄存器（W <em>或X </em>）。</li>
<li>w：一个32,64或128位浮点/ SIMD寄存器。</li>
<li>x：较低的128位浮点/ SIMD寄存器（V0至V15）。</li>
</ul>
<p>AMDGPU：</p>
<ul>
<li>r：32位或64位整数寄存器。</li>
<li>[0-9]v：32位VGPR寄存器，编号0-9。</li>
<li>[0-9]s：32位SGPR寄存器，编号0-9。</li>
</ul>
<p>所有ARM模式：</p>
<ul>
<li>Q，Um，Un，Uq，Us，Ut，Uv，Uy：内存地址的操作数。目前处理方式与操作数相同m。</li>
</ul>
<p>ARM和ARM的Thumb2模式：</p>
<ul>
<li>j：0到65535之间的一个立即数（有效MOVW）</li>
<li>I：对数据处理指令有效的立即整数。</li>
<li>J：一个介于-4095和4095之间的直接整数。</li>
<li>K：一个立即数，它的位反转对数据处理指令有效。（可以与模板修饰符“ B”一起使用以打印反转的值）。</li>
<li>L：一个立即整数，其否定对数据处理指令有效。（可以与模板修饰符“ n”一起使用以打印否定值）。</li>
<li>M：2的幂或0到32之间的整数。</li>
<li>N：无效的即时约束。</li>
<li>O：无效的即时约束。</li>
<li>r：一个通用的32位整数寄存器（r0-r15）。</li>
<li>l：在Thumb2模式下，低32位GPR寄存器（r0-r7）。在ARM模式下，与r。</li>
<li>h：在Thumb2模式下，一个高32位的GPR寄存器（r8-r15）。在ARM模式下，无效。</li>
<li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li>
<li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li>
<li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li>
</ul>
<p>ARM的Thumb1模式：</p>
<ul>
<li>I：0到255之间的立即数。</li>
<li>J：-255和-1之间的立即数。</li>
<li>K：0到255之间的直接整数，可选左移一定数量。</li>
<li>L：-7和7之间的立即数。</li>
<li>M：0到1020之间的整数，是4的倍数。</li>
<li>N：0到31之间的立即数。</li>
<li>O：在-508和508之间的立即数，是4的倍数。</li>
<li>r：一个低32位的GPR寄存器（r0-r7）。</li>
<li>l：一个低32位的GPR寄存器（r0-r7）。</li>
<li>h：高GPR寄存器（r0-r7）。</li>
<li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li>
<li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li>
<li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li>
</ul>
<p>Hexagon：</p>
<ul>
<li>o，v：此时存储器地址操作数，与约束一样对待m。</li>
<li>r：一个32位或64位寄存器。</li>
</ul>
<p>MSP430：</p>
<ul>
<li>r：一个8位或16位寄存器。</li>
</ul>
<p>MIPS：</p>
<ul>
<li>I：一个直接带符号的16位整数。</li>
<li>J：一个立即整数零。</li>
<li>K：一个直接无符号的16位整数。</li>
<li>L：一个直接的32位整数，其中低16位是0。</li>
<li>N：-65535和-1之间的立即数。</li>
<li>O：一个立即有符号的15位整数。</li>
<li>P：1到65535之间的立即数。</li>
<li>m：存储器地址操作数。在MIPS-SE模式下，允许一个基址寄存器加上16位立即数偏移量。在MIPS模式下，只需一个基址寄存器。</li>
<li>R：存储器地址操作数。在MIPS-SE模式下，允许一个基地址寄存器加上一个9位有符号偏移量。在MIPS模式下，与约束相同 m。</li>
<li>ZC：一个存储器地址操作数，适用于使用pref，ll或 sc在给定的子目标指令（细节有所不同）。</li>
<li>r，d， y：一个32位或64位GPR寄存器。</li>
<li>f：一个32位或64位FPU寄存器（F0-F31）或一个128位MSA寄存器（W0-W31）。在MSA寄存器的情况下，建议使用w 参数修饰符与GCC兼容。</li>
<li>c：适用于间接跳转（始终25）的32位或64位GPR寄存器 。</li>
<li>l：lo寄存器，32或64位。</li>
<li>x：无效。</li>
</ul>
<p>NVPTX：</p>
<ul>
<li>b：1位整数寄存器。</li>
<li>c或者h：一个16位整数寄存器。</li>
<li>r：一个32位整数寄存器。</li>
<li>l或者N：一个64位整数寄存器。</li>
<li>f：一个32位浮点寄存器。</li>
<li>d：一个64位的浮点寄存器。</li>
</ul>
<p>PowerPC的：</p>
<ul>
<li>I：一个直接带符号的16位整数。</li>
<li>J：直接无符号的16位整数，左移16位。</li>
<li>K：一个直接无符号的16位整数。</li>
<li>L：立即带符号的16位整数，左移16位。</li>
<li>M：大于31的立即数。</li>
<li>N：是2的精确幂的立即数。</li>
<li>O：立即整数常量0。</li>
<li>P：一个立即整型常量，其否定是一个有符号的16位常量。</li>
<li>es，o，Q，Z，Zy：一个存储器地址操作数，目前一样对待m。</li>
<li>r：32位或64位整数寄存器。</li>
<li>b：32位或64位整数寄存器，不包括R0（即 ：）R1-R31。</li>
<li>f：32位或64位浮点寄存器（F0-F31）或QPX使能时，128位或256位QPX寄存器（Q0-Q31;用于别名F寄存器）。</li>
<li>v：对于或类型，当启用QPX时，为128或256位QPX寄存器（），否则为128位altivec向量寄存器（）。4 x f324 x f64Q0-Q31V0-V31</li>
<li>y：条件寄存器（CR0-CR7）。</li>
<li>wc：CR寄存器中的单独CR位。</li>
<li>wa，wd，wf：任何128位VSX向量寄存器，从全VSX寄存器组（重叠两个浮点和向量寄存器文件）。</li>
<li>ws：来自完整的VSX寄存器组的32位或64位浮点寄存器。</li>
</ul>
<p>SPARC：</p>
<ul>
<li>I：一个立即的13位有符号整数。</li>
<li>r：一个32位整数寄存器。</li>
<li>f：SparcV8上的任何浮点寄存器或SparcV9上“低”一半寄存器中的浮点寄存器。</li>
<li>e：任何浮点寄存器。（与fSparcV8 相同。）</li>
</ul>
<p>SystemZ：</p>
<ul>
<li>I：直接无符号的8位整数。</li>
<li>J：直接无符号的12位整数。</li>
<li>K：一个直接带符号的16位整数。</li>
<li>L：一个直接签名的20位整数。</li>
<li>M：立即整数0x7fffffff。</li>
<li>Q：具有基地址和12位立即无符号位移的存储器地址操作数。</li>
<li>R：一个带有基地址的内存地址操作数，一个12位立即无符号位移和一个索引寄存器。</li>
<li>S：一个内存地址操作数，带有一个基址和一个20位立即带符号的位移。</li>
<li>T：一个带有基地址的内存地址操作数，一个20位立即带符号位移和一个索引寄存器。</li>
<li>r或者d：一个32位，64位或128位整数寄存器。</li>
<li>a：32,64或128位整数地址寄存器（不包括地址上下文中评估为0的R0）。</li>
<li>h：64位数据寄存器高位部分的32位值（LLVM专用）</li>
<li>f：一个32,64或128位浮点寄存器。</li>
</ul>
<p>X86：</p>
<ul>
<li>I：0到31之间的立即数。</li>
<li>J：0到64之间的立即数。</li>
<li>K：一个立即有符号的8位整数。</li>
<li>L：立即整数，0xff或0xffff或（仅在64位模式下）0xffffffff。</li>
<li>M：0到3之间的立即数。</li>
<li>N：直接无符号的8位整数。</li>
<li>O：0到127之间的立即数。</li>
<li>e：一个立即的32位有符号整数。</li>
<li>Z：一个立即的32位无符号整数。</li>
<li>o，v：目前处理方式与此相同m。</li>
<li>q：一个8,16,32或64位寄存器，可以作为8位 l整数寄存器访问。在X86-32，这是a，b，c，和d 寄存器，以及X86-64，它是所有的整数寄存器。</li>
<li>Q：一个8,16,32或64位寄存器，可以作为8位 h整数寄存器访问。这是a，b，c，和d寄存器。</li>
<li>r或者l：8,16,32或64位整数寄存器。</li>
<li>R：8,16,32或64位“传统”整数寄存器 - 自i386以来一直存在，并且可以在没有REX前缀的情况下访问。</li>
<li>f：一个32,64或80位’387 FPU堆栈伪寄存器。</li>
<li>y：如果启用MMX，则为64位MMX寄存器。</li>
<li>x：如果启用SSE：SSE寄存器中的32位或64位标量操作数或128位向量操作数。如果AVX也被使能，也可以是AVX寄存器中的256位向量操作数。如果AVX-512也被使能，也可以是AVX512寄存器中的512位向量操作数，否则会出错。</li>
<li>Y：同x，如果SSE2被启用，否则会出现错误。</li>
<li>A：特殊情况：首先为EAX分配EAX，然后再为EDX分配单个操作数（在32位模式下，64位整数操作数将分成两个寄存器）。不建议使用此约束，因为在64位模式下，64位操作数只会分配给RAX - 如果需要两个32位操作数，则最好在将其分配给它之前自行分割asm声明。</li>
</ul>
<p>XCore：</p>
<ul>
<li>r：一个32位整数寄存器。</li>
</ul>
<h3 id="Asm模板参数修饰符"><a href="#Asm模板参数修饰符" class="headerlink" title="Asm模板参数修饰符"></a>Asm模板参数修饰符</h3><p>在asm模板字符串中，可以在操作数引用上使用修饰符，如“<code>${0:n}</code>”。</p>
<p>一般来说，修饰符的行为与GCC中的相同。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p>
<p>目标无关的：</p>
<ul>
<li>c：不带目标特定的直接标点符号（例如无$前缀）打印一个立即的整数常量。</li>
<li>n：取消并打印立即数整数常量，不带目标特定的直接标点符号（例如无$前缀）。</li>
<li>l：打印为无标签的标签，没有特定于目标的标签标点（例如无$前缀）。</li>
</ul>
<p>AArch64：</p>
<ul>
<li>w：用w<em>名称而不是x</em>名称打印GPR寄存器。例如，而不是x30打印w30。</li>
<li>x：用x*名称打印GPR寄存器。（无论如何，这是默认的）。</li>
<li>b，h，s，d，q：打印浮点/ SIMD寄存器有 b<em>，h</em>，s<em>，d</em>，或q<em>名称，而不是默认的 v</em>。</li>
</ul>
<p>AMDGPU：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>ARM：</p>
<ul>
<li>a：打印操作数作为一个地址（[和]周围的寄存器）。</li>
<li>P： 没有效果。</li>
<li>q： 没有效果。</li>
<li>y：将VFP单精度寄存器作为索引双精度打印（例如打印d4[1]而不是s9）</li>
<li>B：按位反转并打印不带# 前缀的立即整数常量。</li>
<li>L：打印立即整数常量的低16位。</li>
<li>M：打印为适合ldm / stm的寄存器组。同时打印 指定的一个（！）后面的所有寄存器操作数，请谨慎使用。</li>
<li>Q：打印寄存器对的低位寄存器或双寄存器操作数的低位寄存器。</li>
<li>R：打印寄存器对的高位寄存器或双寄存器操作数的高位寄存器。</li>
<li>H：打印寄存器对的第二个寄存器。（在大端系统上， H相当于Q小端系统，H相当于R。）</li>
<li>e：打印NEON四路寄存器的低双字寄存器。</li>
<li>f：打印NEON四路寄存器的高位双字寄存器。</li>
<li>m：打印没有[和] 装饰的内存操作数的基址寄存器。</li>
</ul>
<p>Hexagon：</p>
<ul>
<li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li>
<li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li>
</ul>
<p>MSP430：</p>
<ul>
<li>没有额外的修饰符。</li>
</ul>
<p>MIPS：</p>
<ul>
<li>X：以十六进制形式打印一个立即数</li>
<li>x：以十六进制形式打印立即数的低16位。</li>
<li>d：以小数形式打印一个立即数。</li>
<li>m：减去一个并以十进制形式打印一个立即数。</li>
<li>z：如果立即为零，则打印$ 0，否则正常打印。</li>
<li>L：打印双寄存器操作数的低位寄存器，或打印双字存储器操作数的低位字的地址。</li>
<li>M：打印双寄存器操作数的高位寄存器，或者打印双字存储器操作数的高位字的地址。</li>
<li>D：打印双寄存器操作数的第二个寄存器，或打印双字存储器操作数的第二个字。（在大端系统上，D相当于L小端系统，D相当于 M。）</li>
<li>w： 没有效果。为了与需要此修饰符的GCC兼容才能打印W0-W31具有f 约束条件的MSA寄存器（）。</li>
</ul>
<p>NVPTX：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>PowerPC的：</p>
<ul>
<li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li>
<li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li>
<li>y：对于内存操作数，打印双寄存器X-form指令的格式化程序。（目前始终打印r0,OPERAND）。</li>
<li>U：如果内存操作数是更新形式，则打印’u’，否则不打印。（注意：LLVM不支持更新表单，所以它现在总是不会打印任何内容）</li>
<li>X：如果内存操作数是索引形式，则打印’x’。（注意：LLVM不支持索引形式，所以目前这总是不会打印任何东西）</li>
</ul>
<p>SPARC：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>SystemZ：</p>
<ul>
<li>SystemZ仅实现n，并且也不会支持任何其他目标无关的改性剂。</li>
</ul>
<p>X86：</p>
<ul>
<li>c：打印一个无用的整数或符号名称。（后者是这个典型的与目标无关的修饰符的目标特定行为）。</li>
<li>A：*在它之前用一个“ ‘ 打印一个注册名称。</li>
<li>b：打印一个8位寄存器名称（例如al）; 内存操作数不做任何事情。</li>
<li>h：打印上面的8位寄存器名称（例如ah）; 内存操作数不做任何事情。</li>
<li>w：打印16位寄存器名称（例如ax）; 内存操作数不做任何事情。</li>
<li>k：打印32位寄存器名称（例如eax）; 内存操作数不做任何事情。</li>
<li>q：打印64位寄存器名称（例如rax），如果64位寄存器可用，则返回32位寄存器名称; 内存操作数不做任何事情。</li>
<li>n：取反并打印一个未修饰的整数，或者，对于非立即整数的操作数（例如可重定位符号表达式），在操作数前面打印一个’ - ‘。（可重定位符号表达式的行为是针对此通常与目标无关的修饰符的目标特定行为）</li>
<li>H：用额外的偏移量+8打印存储器引用。</li>
<li>P：打印内存引用或操作数以用作调用指令的参数。（例如(rip)，即使它是PC相对的，也省略。）</li>
</ul>
<p>XCore：</p>
<ul>
<li>没有额外的修饰符。</li>
</ul>
<h3 id="内联Asm元数据"><a href="#内联Asm元数据" class="headerlink" title="内联Asm元数据"></a>内联Asm元数据</h3><p>包装内联asm节点的调用指令可能会附加一个“<code>!srcloc</code>”MDNode，它包含一个常量整数列表。如果存在，则当通过LLVMContext 错误报告机制报告错误时，代码生成器将使用该整数作为位置cookie值。这允许前端将内联asm中发生的后端错误与产生它的源代码关联起来。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;something bad&quot;, &quot;&quot;(), !srcloc !42</span><br><span class="line">...</span><br><span class="line">!42 = !&#123; i32 1234567 &#125;</span><br></pre></td></tr></table></figure></p>
<p>直到前端才能理解它在IR中的神奇数字。如果MDNode包含多个常量，则代码生成器将使用与发生错误的asm行相对应的那个常量。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/12/编译原理/LLVM语言参考手册(开始至高级结构)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/编译原理/LLVM语言参考手册(开始至高级结构)/" itemprop="url">LLVM语言参考手册(开始至高级结构)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T17:38:40+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文档是LLVM汇编语言的参考手册。LLVM是一种基于<a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener">静态单赋值</a>（SSA）的表现形式的语言。它提供类型安全、底层指令、灵活性以及干净地表示“所有”高级语言的能力。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><b style="color:green">LLVM代码表示被设计为以三种不同的形式使用：作为内存中编译器IR（中间码），作为磁盘上的位代码表示（适用于即时编译器进行快速加载）以及作为人可读汇编语言表达。这允许LLVM为有效的编译器的转换和分析提供强大的中间表示，同时提供调试和可视化转换的自然方式。LLVM的三种不同形式都是等价的。本文档描述了人类可读的表示形式和符号。</b></p>
<p>LLVM表示旨在轻量级和低级别，同时具有表现力，类型化和可扩展性。它的目标是成为一种“通用的IR”，通过处于足够低的水平，可以将高层次的想法清晰地映射到它（类似于微处理器是“通用IR”），允许将许多源语言映射到它们）。通过提供类型信息，LLVM可以用作优化的目标：例如，通过指针分析，可以证明C自动变量从不在当前函数之外访问，从而允许将它提升为简单的SSA值而不是一个内存位置。</p>
<h2 id="良好的格式"><a href="#良好的格式" class="headerlink" title="良好的格式"></a>良好的格式</h2><p>重要的是要注意，本文档描述了“良好格式”的LLVM汇编语言。 解析器接受什么和被认为是“良好格式”之间是有区别。例如，下面的指令在语法上没问题，但不是良好形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%x = add i32 1, %x</span><br></pre></td></tr></table></figure></p>
<p>因为<code>％x</code>的定义并不控制它的所有用途。 LLVM基础架构提供了一个验证过程，可用于验证LLVM模块是否格式良好。在解析输入的汇编程序之后和优化程序在输出bitcode之前，该过程由解析器自动运行。验证程序验证过程中指出的违规暗示转换过程中的错误或输入到解析器中的错误。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>LLVM标识符有两种基本类型：全局和本地。全局标识符（函数，全局变量）以<code>&#39;@&#39;</code>字符开头。本地标识符（寄存器名称，类型）以<code>&#39;%&#39;</code>字符开头 。此外，有三种不同的标识符格式，用于不同的目的：</p>
<ol>
<li>命名值用一串字符和前缀表示。例如<code>%foo</code>，<code>@DivisionByZero</code>， <code>%a.really.long.identifier</code>。实际使用的正则表达式是 <code>&#39;[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*&#39;</code>。在名称中需要其他字符的标识符可以用引号包裹起来。通过使用<code>&quot;\xx&quot;</code>，特殊字符可以被转义，<code>xx</code>是ASCII代码的十六进制字符的表示。这样，任何字符都可以用于名称值，甚至可以引用它们自己。全局变量可以使用前缀”\01”来阻止截断。</li>
<li>未命名的值用前缀表示为无符号数值。例如<code>%12</code>，<code>@2</code>，<code>%44</code>。</li>
<li>常量，在下面的<a href="http://llvm.org/docs/LangRef.html#constants" target="_blank" rel="noopener">常量</a>章节中进行了介绍。</li>
</ol>
<p>LLVM要求值以一个前缀开始，原因有两个：编译器不需要担心名称与保留字的冲突，并且保留字的集合可能在将来被扩展而不会产生什么不利。此外，未命名标识符允许编译器快速创建临时变量，而不必设法避免符号表冲突。</p>
<p>LLVM中的保留字与其他语言中的保留字非常相似。对于不同的操作码（<code>&#39;add&#39;</code>，<code>&#39;bitcast&#39;</code>，<code>&#39;ret&#39;</code>等等），对于原始类型名称（<code>&#39;void&#39;</code>，<code>&#39;i32&#39;</code>等等），以及其他的关键字。这些保留字不能与变量名冲突，因为它们都没有以前缀字符（<code>&#39;%&#39;</code>或<code>&#39;@&#39;</code>）开始。</p>
<p>以下是将整数变量“%X’乘以8的LLVM代码示例：<br>简单的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = mul i32 %X, 8</span><br></pre></td></tr></table></figure></p>
<p>减少强度之后（也是最推荐的方式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = shl i32 %X, 3</span><br></pre></td></tr></table></figure></p>
<p>最复杂的方式是(很有意思)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = add i32 %X, %X           ; yields i32:%0</span><br><span class="line">%1 = add i32 %0, %0           ; yields i32:%1</span><br><span class="line">%result = add i32 %1, %1</span><br></pre></td></tr></table></figure></p>
<p><code>%X</code>乘以8的最后一种方式说明了LLVM的几个重要的词法特征：</p>
<ol>
<li>注释用分号<code>&#39;;&#39;</code>分隔，直到行尾。</li>
<li>当计算结果未分配给指定命名值时，将创建未命名的临时对象。</li>
<li>未命名的临时对象按序号进行编号（使用预处理函数递增计数器，从0开始）。<b style="color:green">请注意，此编号中包含基本块和未命名的函数参数。例如，如果基本块入口没有给出标签名称并且所有函数参数都被命名，则它将得到编号0。</b></li>
</ol>
<p>它也显示了我们在本文件中遵循的惯例。在展示说明时，我们将按照说明书的注释来说明所产生值的类型和名称。</p>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>LLVM程序由<code>Module&#39;s</code>组成，每个模块都是输入程序的翻译单元。每个模块由函数，全局变量和符号表入口（symbol table entries）组成。模块可以与LLVM链接器组合在一起，LLVM链接器合并函数（和全局变量）定义，解析前置声明并合并符号表入口。以下是“hello world”模块的示例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Declare the string constant as a global constant.</span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; External declaration of the puts function</span></span><br><span class="line"><span class="comment">declare i32 @puts(i8* nocapture) nounwind</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Definition of main function</span></span><br><span class="line"><span class="comment">define i32 @main() &#123;   ; i32()*</span></span><br><span class="line"><span class="comment">  ; Convert [13 x i8]* to i8*...</span></span><br><span class="line"><span class="comment">  %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ; Call puts function to write out the string to stdout.</span></span><br><span class="line"><span class="comment">  call i32 @puts(i8* %cast210)</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Named metadata</span></span><br><span class="line"><span class="comment">!0 = !&#123;i32 42, null, !"string"&#125;</span></span><br><span class="line"><span class="comment">!foo = !&#123;!0&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子由一个名为<code>.str</code>的<a href="http://llvm.org/docs/LangRef.html#globalvars" target="_blank" rel="noopener">全局变量</a>，<code>“puts”</code>函数的外部声明，<code>&quot;main&quot;</code>的<a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数定义</a>和<code>”foo“</code>的<a href="http://llvm.org/docs/LangRef.html#namedmetadatastructure" target="_blank" rel="noopener">命名元数据</a>组成。</p>
<p><b style="color:green">通常，模块由全局值列表组成（其中函数和全局变量都是全局值）。全局值由指向内存位置的指针表示（在本例中，指向char数组的指针和指向函数的指针），并且具有以下<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>之一。</b></p>
<h3 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a><a href="https://msdn.microsoft.com/zh-cn/library/0yw6at8e.aspx" target="_blank" rel="noopener">链接类型</a></h3><p>所有全局变量和函数都具有以下链接类型之一：</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>具有<code>“private”</code>连接的全局值只能由当前模块中的对象直接访问。特别是，将代码链接到具有private全局值的模块中可能会导致private变量重新命名以避免冲突。由于符号对模块是私有的，因此所有引用都可以更新。这不会在对象文件的任何符号表中显示。</p>
<h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>与私有类似，但该值在对象文件中显示为本地符号（STB_LOCAL在ELF的情况下）。这就像<code>C</code>中的<code>&#39;static&#39;</code>关键字。</p>
<h4 id="available-externally"><a href="#available-externally" class="headerlink" title="available_externally"></a>available_externally</h4><p>具有<code>“available_externally”</code>链接的全局程序永远不会被发送到对应于LLVM模块的目标文件中。从链接器的角度来看，<code>available_externally</code>全局相当于external声明。它们的存在是为了允许内联和其他优化在知道全局变量（函数或语句块）的定义的情况下发生，这被称为模块之外的某个地方。具有<code>available_externally</code>链接的全局值可以随意丢弃，并允许内联和其他优化。这种连接类型只允许定义，而不允许声明。</p>
<h4 id="linkonce"><a href="#linkonce" class="headerlink" title="linkonce"></a>linkonce</h4><p><code>linkonce</code>连接的全局值在链接发生时，可以与其他同名的全局值合。这可以用来实现某些形式的内联函数，模板（templates）或其他代码，这些代码必须在使用它的每个翻译单元中生成，但是稍后可能会在更明确的定义中覆盖正文。未引用的<code>linkonce</code>全局变量允许被丢弃。请注意，<code>linkonce</code>链接实际上并不允许优化器将此函数的主体内联到调用者中，因为它不知道该函数的定义是否是程序中的权威定义，或者是否会被更强的定义覆盖。要启用内联和其他优化器，请使用<code>“linkonce_odr”</code>链接。</p>
<h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><p><code>“weak”</code>链接具有与<code>linkonce</code>链接相同的合并语义，除了未引用<code>weak</code>链接的全局可能不会被丢弃。这用于在C源代码中声明为<a href="http://www.cnblogs.com/hgfrzh/p/4064098.html" target="_blank" rel="noopener"><code>weak</code></a>的全局变量。</p>
<h4 id="common"><a href="#common" class="headerlink" title="common"></a>common</h4><p><code>common</code>连接与<code>weak</code>连接最为相似，但它们用于C中的临时定义，例如：全局作用域的<code>int x</code>。带有<code>common</code>连接的符号与<code>weak</code>是相同的方式合并；如果未引用<code>common</code>符号，它们可能不会被删除。<code>common</code>符号可能没有明确的部分，必须具有零初始化器，并且可能未被标记为“<code>constant</code>”。函数和别名可能没有共同的连接。</p>
<h4 id="appending"><a href="#appending" class="headerlink" title="appending"></a>appending</h4><p>“<code>appending</code>”链接可能只适用于指向数组类型的全局变量。当两个具有appending链接的全局变量链接在一起时，这两个全局数组被附加在一起。这是LLVM类型安全的，当<code>.o</code>文件被链接时，系统链接器将具有相同的名称的<code>“sections”</code>附加在一起。</p>
<p>不幸的是，这不符合<code>.o</code>文件中的任何特性，所以它只能用于像<code>llvm.global_ctors</code>的变量，<code>llvm</code>专门解释这样的变量。</p>
<h4 id="extern-weak"><a href="#extern-weak" class="headerlink" title="extern_weak"></a>extern_weak</h4><p>这个链接的语义遵循<code>ELF</code>目标文件模型：符号在链接之前是弱的，如果不链接，符号变为空，而不是未定义的引用。</p>
<h4 id="linkonce-odr，-weak-odr"><a href="#linkonce-odr，-weak-odr" class="headerlink" title="linkonce_odr， weak_odr"></a><code>linkonce_odr</code>， <code>weak_odr</code></h4><p>有些语言允许合并不同的全局变量，比如两个具有不同语义的函数。其他语言，例如C++，确保只有等效的全局变量被合并（“一个定义规则(one definition rule)” - “ODR”）。这些语言可以使用<code>linkonce_odr</code>和<code>weak_odr</code>连接类型来表示全局将仅与等效的全局变量合并。对于其他不支持<code>ODR</code>的语言，这些链接类型与其<code>非odr</code>的链接相同。</p>
<h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>如果没有使用上述标识符，则全局变量是外部可见的，这意味着它参与链接并可用于解析外部符号引用。</p>
<p><b style="color:red">对于函数声明，除<code>external</code>或<code>extern_weak</code>之外的任何链接类型都是非法的。</b></p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">调用约定</a></h3><p>LLVM<a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数(functions)</a>，<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener">调用(calls)</a>和 <a href="http://llvm.org/docs/LangRef.html#i-invoke" target="_blank" rel="noopener">调用(invokes)</a>都可以为该调用指定一个可选的调用约定。任何一对动态<code>调用者(caller)/被调用者(callee)</code>的调用约定都必须匹配，否则程序的行为是未定义的。<b style="color:green">LLVM支持以下调用约定，未来还可能添加更多调用约定：</b></p>
<h4 id="ccc-C调用约定"><a href="#ccc-C调用约定" class="headerlink" title="ccc - C调用约定"></a><code>ccc</code> - <a href="https://blog.csdn.net/fly2k5/article/details/544112" target="_blank" rel="noopener">C调用约定</a></h4><p>这个调用约定（如果没有指定其他调用约定，则默认是这个调用约定）匹配目标C调用约定。这个调用约定支持可变参数函数调用，并且允许在声明的原型和实现的函数声明中存在一些不匹配（就像普通的C一样）。</p>
<h4 id="“fastcc”-快速调用约定"><a href="#“fastcc”-快速调用约定" class="headerlink" title="“fastcc” - 快速调用约定"></a>“<code>fastcc</code>” - 快速调用约定</h4><p>这个调用约定试图尽可能快地进行调用（例如通过在寄存器中传递参数）。这个调用约定允许目标使用任何想要为目标生成快速代码的技巧，而不必遵守外部指定的<code>ABI</code>（应用程序二进制接口）。<a href="http://llvm.org/docs/CodeGenerator.html#id80" target="_blank" rel="noopener">只有在使用此调用约定、<code>GHC</code>调用约定或<code>HiPE</code>调用约定时，才能<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener"><b style="color:red">优化尾部调用</b></a></a>。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。</p>
<h4 id="“coldcc”-冷调用约定"><a href="#“coldcc”-冷调用约定" class="headerlink" title="“coldcc” - 冷调用约定"></a>“<code>coldcc</code>” - 冷调用约定</h4><p>这个调用约定尝试在调用不是共同执行的条件下尽可能高效地在调用者中编写代码。因此，这些调用通常会保留所有的寄存器，以便调用不会破坏调用方的任何实时范围（live range）。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。此外，内联器不考虑这种内联函数调用。</p>
<h4 id="“cc-10”-GHC约定"><a href="#“cc-10”-GHC约定" class="headerlink" title="“cc 10” - GHC约定"></a>“<code>cc 10</code>” - <code>GHC</code>约定</h4><p>这个调用约定专门供<a href="http://www.haskell.org/ghc" target="_blank" rel="noopener">格拉斯哥Haskell编译器（GHC）</a>使用。它在寄存器中的传递所有内容，通过禁用被调用者保存寄存器来达到极限。这种调用约定不应该被轻率使用，而只能用于特定情况下，例如替代实现函数式编程语言时经常使用的寄存器锁定性能技术。目前只有X86支持这种约定，它有以下限制：</p>
<ul>
<li>在X86-32上最多只支持4位类型参数。不支持浮点类型。</li>
<li>在X86-64上最多只支持10位类型参数和6个浮点参数。</li>
</ul>
<p>这种调用约定支持<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾部调用优化</a>，但要求主调方和被调方都在使用它。</p>
<h4 id="“cc-11”-HiPE调用约定"><a href="#“cc-11”-HiPE调用约定" class="headerlink" title="“cc 11” - HiPE调用约定"></a>“<code>cc 11</code>” - <code>HiPE</code>调用约定</h4><p>该调用约定专门用于<a href="http://www.it.uu.se/research/group/hipe/" target="_blank" rel="noopener">高性能Erlang（HiPE）</a>编译器，即<a href="http://www.erlang.org/download.shtml" target="_blank" rel="noopener">爱立信开源Erlang/OTP系统</a>的本地代码编译器。它比通常的C调用约定使用更多的寄存器进行参数传递，并且不定义被调者使用的保存寄存器。调用约定正确支持<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾部调用优化</a>，但要求调用者和被调用者都使用它。它使用寄存器固定机制，与<code>GHC</code>调用约定类似，用于将频繁访问的运行时组件固定到特定的硬件寄存器。目前只有X86支持这种约定（32位和64位）。</p>
<h4 id="“webkit-jscc”-WebKit的JavaScript调用约定"><a href="#“webkit-jscc”-WebKit的JavaScript调用约定" class="headerlink" title="“webkit_jscc” - WebKit的JavaScript调用约定"></a>“<code>webkit_jscc</code>” - WebKit的JavaScript调用约定</h4><p>此调用约定已针对<a href="https://trac.webkit.org/wiki/FTLJIT" target="_blank" rel="noopener">WebKit FTL JIT</a>实施。它将堆栈上的参数从右向左传递（如<code>cdecl</code>那样），并在平台的惯用返回寄存器中返回一个值。</p>
<h4 id="“anyregcc”-代码修补的动态调用约定"><a href="#“anyregcc”-代码修补的动态调用约定" class="headerlink" title="“anyregcc” - 代码修补的动态调用约定"></a>“<code>anyregcc</code>” - 代码修补的动态调用约定</h4><p>这是一个特殊的约定，它支持在调用点增补任意代码序列。这个约定强制调用参数进入寄存器，但允许它们动态分配。目前只能用于调用<code>llvm.experimental.patchpoint</code>，因为只有这个内部函数将其参数的位置记录在旁边表中。请参阅<a href="http://llvm.org/docs/StackMaps.html" target="_blank" rel="noopener">LLVM中的堆栈映射和修补程序点</a>。</p>
<h4 id="“preserve-mostcc”-PreserveMost调用约定"><a href="#“preserve-mostcc”-PreserveMost调用约定" class="headerlink" title="“preserve_mostcc” - PreserveMost调用约定"></a>“<code>preserve_mostcc</code>” - <code>PreserveMost</code>调用约定</h4><p>此调用约定会尽可能使调用方中的代码尽可能是非侵入性的。该约定的行为与C 调用约定的参数和返回值的传递方式相同，但它使用了一组不同的调用方/被调用方保存的寄存器。<b style="color:green">这减轻了在调用者调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</b></p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。浮点寄存器（<code>XMMs/YMMs</code>）不会保留，需要由调用者保存。</li>
</ul>
<p>这个约定背后的想法是支持对具有热路径和冷路径的运行时（Runtime）函数调用。<b style="color:green">热路径通常是一小段不使用多个寄存器的代码。冷路径可能需要调用另一个函数，因此只需要保留调用者保存的寄存器，这些寄存器还未被调用者保存</b>。就调用者/被调用者保存的寄存器方面，<code>PreserveMost</code>调用约定是与冷（cold）调用约定非常相似的，但它们用于不同类型的函数调用。<code>coldcc</code>适用于很少执行的函数调用，而<code>preserve_mostcc</code>函数调用旨在处于热路径上，并且相对执行更多一些。此外<code>preserve_mostcc</code>不会阻止内联器的内联函数调用。</p>
<p>这个调用约定将被未来版本的ObjectiveC运行时使用，因此此时应该仍被认为是实验性的。虽然此惯例是为了优化对ObjectiveC运行时的某些运行时调用而创建的，但它并不局限于此运行时，并且在将来也可能会被其他运行时使用。目前的实现只支持X86-64，但其目的是在未来支持更多架构。</p>
<h4 id="“preserve-allcc”-PreserveAll调用约定"><a href="#“preserve-allcc”-PreserveAll调用约定" class="headerlink" title="“preserve_allcc” - PreserveAll调用约定"></a>“<code>preserve_allcc</code>” - <code>PreserveAll</code>调用约定</h4><p>此调用约定会尝试使调用方中的代码比<code>PreserveMost</code>调用约定更不具侵入性。此调用约定的行为与C调用约定的参数和返回值的传递方式相同，但它使用一组不同的调用方/被调用方保存的寄存器。这消除了在调用者的调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。此外，它还保留所有浮点寄存器（<code>XMM/YMM</code>）。</li>
</ul>
<p>这个约定背后的想法是支持对不需要调用任何其他函数的运行时(Runtime)函数的调用。</p>
<p>此调用约定与<code>PreserveMost</code>调用约定一样，将被未来版本的ObjectiveC运行时使用，此时应视为实验性的。</p>
<h4 id="“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定"><a href="#“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定" class="headerlink" title="“cxx_fast_tlscc” - 访问函数的CXX_FAST_TLS调用约定"></a>“<code>cxx_fast_tlscc</code>” - 访问函数的<code>CXX_FAST_TLS</code>调用约定</h4><p>Clang生成一个访问函数来访问C++风格的TLS。访问函数通常有一个入口块，一个出口块和一个初次运行的初始化块。入口和出口块可以访问一些TLS IR变量，每个访问将被降低到平台特定的序列。</p>
<p>此调用约定旨在通过保留尽可能多的寄存器（所有寄存器保存在快速路径中，由入口和出口块组成）来尽量减少调用者的开销。</p>
<p>这个调用约定的行为与C调用约定在参数和返回值的传递方式上是一样的，但它使用了一组不同的调用者/被调用者保存的寄存器。</p>
<p>鉴于每个平台都有自己的降序序列，因此它有自己的一组保存的寄存器，所以我们不能使用现有的<code>PreserveMost</code>。</p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>RDI</code>和<code>RAX</code>除外。</li>
</ul>
<h4 id="“swiftcc”-这个调用约定用于Swift语言。"><a href="#“swiftcc”-这个调用约定用于Swift语言。" class="headerlink" title="“swiftcc” - 这个调用约定用于Swift语言。"></a>“<code>swiftcc</code>” - 这个调用约定用于Swift语言。</h4><ul>
<li>在X86-64上，<code>RCX</code>和<code>R8</code>可用于额外的整数返回，并且<code>XMM2</code>和<code>XMM3</code>可用于其他<code>FP/vector</code>返回。</li>
<li>在iOS平台上，我们使用<code>AAPCS-VFP</code>调用约定。<br>“<code>cc &lt;n&gt;</code>” - 编号调用约定<br>任何调用约定都可以用数字指定，从而允许使用特定于目标的调用约定。目标特定调用约定从64开始。</li>
</ul>
<p>可以根据需要添加/定义更多调用约定，以支持<code>Pascal</code>约定或任何其他众所周知的目标独立的调用约定。</p>
<h3 id="可见性风格"><a href="#可见性风格" class="headerlink" title="可见性风格"></a>可见性风格</h3><p>所有全局变量和函数都具有以下可见性样式之一：</p>
<h4 id="“default”-默认风格"><a href="#“default”-默认风格" class="headerlink" title="“default” - 默认风格"></a>“<code>default</code>” - 默认风格</h4><p>在使用<a href="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html" target="_blank" rel="noopener">ELF（Executable and Linking Format,可执行文件）</a>对象文件格式的目标上，默认可见性意味着该声明对其他模块可见，并且在共享库中，意味着声明的实体可能被覆盖。在Darwin上，default可见性意味着该声明对其他模块可见。default可见性对应于语言中的“外部链接”。</p>
<h4 id="“hidden”-隐藏的风格"><a href="#“hidden”-隐藏的风格" class="headerlink" title="“hidden” - 隐藏的风格"></a>“<code>hidden</code>” - 隐藏的风格</h4><p>具有隐藏可见性的对象的两个声明指向同一个对象，如果它们在同一个共享对象中。通常，隐藏的可见性表示该符号不会被放入动态符号表中，因此其他模块（可执行文件或共享库）不能直接引用它。</p>
<h4 id="“protected”-受保护的风格"><a href="#“protected”-受保护的风格" class="headerlink" title="“protected” - 受保护的风格"></a>“<code>protected</code>” - 受保护的风格</h4><p>在<a href="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html" target="_blank" rel="noopener">ELF</a>上，protected可见性表示该符号将被放置在动态符号表中，但定义的模块内的引用将绑定到本地符号。也就是说，该符号不能被另一个模块覆盖。</p>
<p>带有<code>internal</code>或<code>private</code>链接类型的符号必须具有<code>default</code>可见性。</p>
<h3 id="DLL存储类"><a href="#DLL存储类" class="headerlink" title="DLL存储类"></a>DLL<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B1%BB/10420072" target="_blank" rel="noopener">存储类</a></h3><p>所有全局变量，函数和别名都可以具有以下DLL存储类之一：</p>
<h4 id="dllimport"><a href="#dllimport" class="headerlink" title="dllimport"></a><a href="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx" target="_blank" rel="noopener"><code>dllimport</code></a></h4><p>“<code>dllimport</code>”会导致编译器通过全局指针引用函数或变量，该全局指针指向由导出符号的DLL设置的指针。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。</p>
<h4 id="dllexport"><a href="#dllexport" class="headerlink" title="dllexport"></a><a href="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx" target="_blank" rel="noopener"><code>dllexport</code></a></h4><p>“<code>dllexport</code>”会导致编译器提供一个指向DLL中的指针的全局指针，以便它可以引用<code>dllimport</code>属性。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。由于这个存储类是为了定义dll接口而存在，因此编译器，汇编器和链接器知道它是从外部引用的，并且不会删除该符号。</p>
<p>其实这个指令是用来加载动态链接库，相关的信息可以查看：<a href="https://stackoverflow.com/questions/3586023/dllimport-doesnt-work-as-advertised-in-mono-linux-c" target="_blank" rel="noopener">DllImport doesn’t work as advertised in Mono (Linux, C#)</a></p>
<h3 id="线程局部存储-TLS-模型"><a href="#线程局部存储-TLS-模型" class="headerlink" title="线程局部存储(TLS)模型"></a>线程局部存储(TLS)模型</h3><p><b style="color:green">一个变量可以被定义为<a href="http://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener"><code>thread_local</code></a>，这意味着它不会被线程共享（每个线程将有一个变量的分离副本）</b>。并非所有的目标机都支持线程局部变量。可选地，可以指定<a href="https://docs.oracle.com/cd/E19253-01/819-7050/6n918j8o0/index.html" target="_blank" rel="noopener">TLS模型</a>：</p>
<ul>
<li><code>localdynamic</code>: 对于仅在当前共享库中使用的变量。</li>
<li><code>initialexec</code>: 对于模块中不会动态加载的变量。</li>
<li><code>localexec</code>: 对于在可执行文件中定义的变量，只能在其中使用。</li>
</ul>
<p>如果没有给出显式模型，则使用“general dynamic”模型。</p>
<p>这些模型对应于ELF TLS模型; 请参阅<a href="http://people.redhat.com/drepper/tls.pdf" target="_blank" rel="noopener">ELF对thread_local存储的处理</a>获取更多信息，在这篇文章中提到的不同的场景下可能使用不同的模型。如果指定的TLS模型不受支持，或者可以选择一个更好的模型，则目标机可能会选择不同的TLS模型。</p>
<p>模型也可以在别名中指定，但它只能控制别名的访问方式。这对使用别名的地方不会有任何影响。</p>
<p>对于没有ELF TLS模型链接器支持的平台，<code>-femulated-tls</code>标志可用于生成GCC兼容的模拟TLS代码。</p>
<h3 id="运行时抢占说明"><a href="#运行时抢占说明" class="headerlink" title="运行时抢占说明"></a>运行时抢占说明</h3><p>全局变量，函数和别名可以有一个可选的运行时抢占说明符。如果没有明确给出抢先说明符，则假定符号是<code>dso_preemptable</code>。</p>
<h4 id="dso-preemptable"><a href="#dso-preemptable" class="headerlink" title="dso_preemptable"></a><code>dso_preemptable</code></h4><p>表示在运行时，可以用链接单元外部的符号替换该函数或变量。</p>
<h4 id="dso-local"><a href="#dso-local" class="headerlink" title="dso_local"></a><code>dso_local</code></h4><p>编译器可以假定标记为<code>dso_local</code>的函数或变量将解析为相同链接单元中的符号。即使定义不在此编译单元中，也会生成直接访问。</p>
<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>LLVM IR（中间码）允许您指定“可识别（identified）”和“文字（Literal）”<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构类型</a>。文字类型在结构上是独一无二的，但是identified类型从来都不是独一无二的。一个<a href="http://llvm.org/docs/LangRef.html#t-opaque" target="_blank" rel="noopener">不透明的结构类型</a>也可以用来向前声明一个还不能使用的类型。</p>
<p>identified（可识别的）结构规范的一个例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mytype = type &#123; %mytype*, i32 &#125;</span><br></pre></td></tr></table></figure></p>
<p>在LLVM 3.0发布之前，identified类型在结构上是独一无二的。在最新版本的LLVM中，只有文字类型是唯一的。</p>
<h3 id="非整型指针类型"><a href="#非整型指针类型" class="headerlink" title="非整型指针类型"></a>非整型指针类型</h3><p>注意：非整型指针类型是正在进行的工作，并且此时它们应该被认为是实验性的。</p>
<p>LLVM IR可选地允许前端通过<a href="http://llvm.org/docs/LangRef.html#langref-datalayout" target="_blank" rel="noopener">数据布局字符串</a>将某些地址空间中的指针表示为“非整数” 。非整型指针类型表示具有未指定的按位表示的指针; 也就是说，完整性表示可能是目标机相关的或不稳定（不由固定整数支持）。</p>
<p><code>inttoptr</code>指令将整数转换为非整型指针类型的ptrtoint指令是错误类型(ill-typed)的，<code>ptrtoint</code>指令将非整型指针类型的值转换为整数。所述指令的矢量版本也是不正确的(ill-typed)。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量定义了编译时分配的内存区域，而不是运行期。</p>
<p>全局变量定义必须被初始化。</p>
<p>其他编译单元中的全局变量也可以声明，在这种情况下，它们没有初始化程序。</p>
<p>无论是全局变量定义还是声明都可以有一个显式的部分放在里面，并且可以有一个可选的显式对齐。如果变量声明的显式或推断区段信息与其定义之间存在不匹配，则结果行为未定义。</p>
<p>一个变量可以被定义为一个全局<code>constant</code>，它表示变量的内容永远不会被修改（开启更好的优化，允许全局数据被放置在可执行文件的只读部分等）。请注意，需要运行时初始化的变量不能标记<code>constant</code>,因为变量在存储区中。</p>
<p>LLVM明确允许将全局变量的声明标记为常量，即使全局变量的定义中没有指定。此功能可用于对程序进行稍微更好的优化，但需要语言定义以保证基于“constantness”的优化对于在定义中不包含<code>constant</code>的编译单元有效。</p>
<p>作为SSA（静态单赋值）值，全局变量定义了程序中所有基本块的范围内的指针值（即它们是可控的）。全局变量总是定义一个指向其“内容”类型的指针，因为它们描述了一个内存区域，并且LLVM中的所有内存对象都是通过指针访问的。</p>
<p>全局变量可以用<code>unnamed_addr</code>来标记，表示地址不重要，只有内容。如果它们具有相同的初始化程序，标记为<code>unnamed_addr</code>的常量可以与其他常量合并。请注意，一个具有显着地址的常量可以与一个<code>unnamed_addr</code>常量合并，结果是一个地址明确的(significant)常量。</p>
<p>如果给出<code>local_unnamed_addr</code>属性，则这个属性的地址在模块内是不明确的。</p>
<p>全局变量可能被声明为驻留在特定目标机的编号地址空间中。对于支持它们的目标机，地址空间可能会影响优化的执行方式，可能也会影响使用什么目标机指令访问变量。默认地址空间为零。地址空间限定符必须在任何其他属性之前。</p>
<p>LLVM允许为全局指定显式部分（section）。如果目标机支持它，它会将globals发送到指定的section。此外，如果目标机有必要的支持，全局变量可以放在一个comdat中。</p>
<p>外部声明可能有明确的section指定。对于使用此信息的目标机器，section信息保留在LLVM IR中。将section信息附加到外部声明是一个断言，其定义位于指定的section。如果定义位于不同的section，则行为是未定义的。</p>
<p>默认情况下，全局初始化器通过假设在全局初始化器开始之前在模块内定义的全局变量未从其初始值修改而得到优化。即使对于可能从模块外部访问的变量（包括具有外部链接的或者出现在<code>@llvm.used</code>或<code>dllexported</code>中的变量）也是如此。这个假设可以通过将变量标记为<code>externally_initialized</code>来消除。</p>
<p>可以为全局变量指定明确的<a href="http://www.cnblogs.com/bakari/archive/2012/10/23/2734772.html" target="_blank" rel="noopener">对齐方式</a>，它必须是2的幂。如果不存在，或者如果对齐方式设置为零，则全局对齐由目标机器设置为任何方便的方式。如果指定了明确的对齐，则全局被强制完全按照指定的对齐方式。如果全局变量具有分配的section，则不允许目标机和优化器过度对齐（over-align）全局变量。在这种情况下，额外的对齐方式可以被观察到：例如，代码可以假定全局变量被密集包装在它们的section中，并尝试将它们作为数组进行迭代，对齐填充将会破坏这个迭代。最大对齐是<code>1 &lt;&lt; 29</code>.</p>
<p>全局变量还可以具有<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时抢占说明符</a>，可选的<a href="http://llvm.org/docs/LangRef.html#glattrs" target="_blank" rel="noopener">全局属性</a>和可选的附加<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>列表。</p>
<p>变量和别名可以有一个<a href="http://llvm.org/docs/LangRef.html#tls-model" target="_blank" rel="noopener">线程本地存储模型</a>。</p>
<p><b style="color:red">句法(这个例子要好好学习，也包含了上面的知识)：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@&lt;GlobalVarName&gt; = [Linkage] [PreemptionSpecifier] [Visibility]</span><br><span class="line">                   [DLLStorageClass] [ThreadLocal]</span><br><span class="line">                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]</span><br><span class="line">                   [ExternallyInitialized]</span><br><span class="line">                   &lt;global | constant&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]</span><br><span class="line">                   [, section &quot;name&quot;] [, comdat [($name)]]</span><br><span class="line">                   [, align &lt;Alignment&gt;] (, !name !N)*</span><br></pre></td></tr></table></figure></p>
<p>例如，下面在带有初始值设定项，节(section)和对齐的编号地址空间中定义全局变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = addrspace(5) constant float 1.0, section &quot;foo&quot;, align 4</span><br></pre></td></tr></table></figure></p>
<p>以下示例仅声明一个全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = external global i32</span><br></pre></td></tr></table></figure></p>
<p><b style="color:green">以下示例使用<code>initialexec</code>TLS模型定义了一个thread-local全局变量：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = thread_local(initialexec) global i32 0, align 4</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>LLVM函数定义包括了“的define”关键字，可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时间抢占标识符</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见风格</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#callingconv" target="_blank" rel="noopener">调用约定</a>，一个可选的<code>unnamed_addr</code>属性，返回类型，可选的返回类型<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>，函数名称，（可能为空的）参数列表（每个参数都带有可选的<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>），可选的<a href="http://llvm.org/docs/LangRef.html#fnattrs" target="_blank" rel="noopener">函数属性</a>，可选的section(节)，可选的对齐，可选的<a href="http://llvm.org/docs/LangRef.html#langref-comdats" target="_blank" rel="noopener">comdat</a>，可选的<a href="http://llvm.org/docs/LangRef.html#gc" target="_blank" rel="noopener">垃圾收集器名称</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prefixdata" target="_blank" rel="noopener">前缀</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prologuedata" target="_blank" rel="noopener">序言</a>，可选的<a href="http://llvm.org/docs/LangRef.html#personalityfn" target="_blank" rel="noopener">个性</a>，附加<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>的可选列表，开启大括号，基本块列表以及关闭大括号。</p>
<p>LLVM函数声明由“<code>declare</code>”关键字，可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#callingconv" target="_blank" rel="noopener">调用约定</a>，可选的<code>unnamed_addr</code>或<code>local_unnamed_addr</code>属性，返回类型，返回类型的可选<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>，函数名称，可能为空的参数列表，可选的对齐方式，可选的<a href="http://llvm.org/docs/LangRef.html#gc" target="_blank" rel="noopener">垃圾收集器名称</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prefixdata" target="_blank" rel="noopener">前缀</a>以及可选的<a href="http://llvm.org/docs/LangRef.html#prologuedata" target="_blank" rel="noopener">序言</a>。</p>
<p>一个函数定义包含一个基本块列表，形成该函数的<code>CFG</code>（控制流图）。每个基本块可以有选择地以一个标签开始（赋予基本块一个符号表入口），包含指令列表，并以<a href="http://llvm.org/docs/LangRef.html#terminators" target="_blank" rel="noopener">终止</a>指令（如分支或函数返回）结束。如果未提供显式标签，一个块被赋值给一个隐含的编号标签，编号使用从计数器中返回下一个值，就像用于未命名的临时对象那样（<a href="http://llvm.org/docs/LangRef.html#identifiers" target="_blank" rel="noopener">参见上文</a>）。例如，如果函数入口块没有明确的标签，则会分配标签“<code>％0</code>”，那么该块中的第一个未命名的临时块将为“<code>％1</code>”，以此类推。</p>
<p>函数中的第一个基本块在两个方面是特殊的：在函数入口时立即执行，并且不允许有祖先基本块（即不能有任何分支到函数的入口块）。由于该块可以没有前驱，它也不能有任何<a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">PHI节点</a>。</p>
<p>LLVM允许为函数指定显式section。如果目标机支持它，它将函数发送给指定的section。另外，该函数可以放置在COMDAT中。</p>
<p>可以为函数指定明确的对齐方式。如果不存在，或者如果对齐方式设置为零，则函数的对齐由目标机设置为任何感觉方便的方式。如果指定了明确的对齐方式，则该函数被强制至少具有那么多的对齐。所有对齐必须是2的幂。</p>
<p>如果<code>unnamed_addr</code>给出该属性，则知道该地址不重要，并且可以合并两个相同的函数。</p>
<p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内是不明显的。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [fn Attrs] [section &quot;name&quot;]</span><br><span class="line">       [comdat [($name)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>参数列表是逗号分隔的参数序列，其中每个参数具有以下形式：</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; [parameter Attrs] [name]</span><br></pre></td></tr></table></figure></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>与函数或变量不同，别名不会创建任何新数据。它们只是现有位置的新符号和元数据。</p>
<p>别名有一个名称和别名，可以是全局值或常量表达式。</p>
<p>别名可能具有可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时抢占说明符</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>和可选的<a href="http://llvm.org/docs/LangRef.html#tls-model" target="_blank" rel="noopener">tls模型</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias &lt;AliaseeTy&gt;, &lt;AliaseeTy&gt;* @&lt;Aliasee&gt;</span><br></pre></td></tr></table></figure></p>
<p>链接必须是一个<code>private</code>，<code>internal</code>，<code>linkonce</code>，<code>weak</code>，<code>linkonce_odr</code>，<code>weak_odr</code>，<code>external</code>。请注意，某些系统链接器可能无法正确处理丢弃具有别名的弱符号(就是内存溢出的问题)。</p>
<p>不是<code>unnamed_addr</code>的别名保证具有与别名表达式相同的地址。<code>unnamed_addr</code>只保证指向相同的内容。</p>
<p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内不显著。</p>
<p>由于别名只是第二个名称，因此有些限制适用，其中一些只能在生成对象文件时进行检查：</p>
<ul>
<li>定义别名的表达式必须在汇编时可计算。因为它只是一个名字，不能使用重定位。</li>
<li>表达式中的别名不会很弱，因为中间别名被覆盖的可能性无法在对象文件中表示。</li>
<li>表达式中的全局值不能是一个声明，因为这需要重定位，这是不可能的。</li>
</ul>
<h3 id="IFuncs"><a href="#IFuncs" class="headerlink" title="IFuncs"></a>IFuncs</h3><p>IFuncs就像别名一样，不会创建任何新的数据或func。它们只是动态链接器通过调用解析器函数在运行时解析的一个新符号。</p>
<p>IFuncs有一个名称和一个解析器，它是动态链接器调用的函数，它返回与该名称关联的另一个函数的地址。</p>
<p>IFunc可能具有可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>和可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [Visibility] ifunc &lt;IFuncTy&gt;, &lt;ResolverTy&gt;* @&lt;Resolver&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Comdats"><a href="#Comdats" class="headerlink" title="Comdats"></a>Comdats</h3><p>Comdat IR提供对COFF和ELF目标文件COMDAT功能的访问。</p>
<p><b style="color:red">关于什么是COMDAT，在<a href="https://zhuanlan.kanxue.com/article-4299.htm" target="_blank" rel="noopener">这篇文章</a>中提到<code>COMDAT</code>，即<code>common data</code>. 编译器将一些函数（具体是哪些函数，编译器自行决定）打包放到单独的section中，这有个专有名词叫COMDAT,即common data，意思是打包的函数或者打包的数据。按微软大拿Raymond Chen的说法，COMDAT这个概念最早来自FORTRAN语言。gcc和llvm对COMDAT都有对应的支持。链接器在链接阶段，可以对COMDAT中重复的函数进行消重（folding，折叠）。如果编译器不把函数打包成COMDAT项，链接器是不敢贸然优化掉对应的函数的，因为缺少这些函数的引用信息。</b></p>
<p>Comdats有一个代表COMDAT键的名称。如果链接器选择了某个其他键的键，则指定的这个键的所有全局对象只会在最终的对象文件中结束。如果有别名，别名将放置在相同的COMDAT中以及进行别名计算。</p>
<p>Comdats有一种选择类型来提供关于链接器如何在两个不同对象文件中的键之间进行选择的输入。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&lt;Name&gt; = comdat SelectionKind</span><br></pre></td></tr></table></figure></p>
<p>选择种类必须是以下之一：</p>
<ul>
<li><code>any</code>: 链接器可以选择任何COMDAT键，选择是任意的。</li>
<li><code>exactmatch</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同的数据。</li>
<li><code>largest</code>: 链接器将选择包含最大值COMDAT键的section。</li>
<li><code>noduplicates</code>: 链接器要求只有具有此COMDAT密钥的section存在。</li>
<li><code>samesize</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同数量的数据。</li>
</ul>
<p>请注意，Mach-O平台不支持COMDAT key，而ELF和WebAssembly仅支持<code>any</code>作为选择类型。</p>
<p><b style="color:green">这里是<code>COMDAT</code>组的一个例子，其中只有当COMDAT键的section最大时才会选择一个函数：</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat largest</span><br><span class="line">@foo = global i32 2, comdat($foo)</span><br><span class="line"></span><br><span class="line">define void @bar() comdat($foo) &#123;</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为一个语法糖，$name如果名称与全局名称相同，则可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">@foo = global i32 2, comdat</span><br></pre></td></tr></table></figure></p>
<p>在COFF对象文件中，这将创建一个COMDAT section，它的选择类型是<code>IMAGE_COMDAT_SELECT_LARGEST</code>，包含<code>@foo</code>符号的内容和另一个COMDAT section；这个section的选择类型是<code>IMAGE_COMDAT_SELECT_ASSOCIATIVE</code>,这个选择类型与第一个COMDAT section相关并包含在<code>@bar</code>符号的内容。</p>
<p>全局对象的属性有一些限制。它或它的别名在定位COFF时必须与COMDAT组具有相同的名称。COFF对象的内容和大小可以在链接期间使用，根据选择种类确定选择哪个COMDAT组。因为对象的名称必须与COMDAT组的名称相匹配，所以全局对象的链接不能是本地的; 如果符号表中发生冲突，则可以重命名本地符号。</p>
<p>组合使用COMDATS和段(section)属性可能会产生令人惊讶的结果。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">$bar = comdat any</span><br><span class="line">@g1 = global i32 42, section &quot;sec&quot;, comdat($foo)</span><br><span class="line">@g2 = global i32 42, section &quot;sec&quot;, comdat($bar)</span><br></pre></td></tr></table></figure></p>
<p>从对象文件的角度来看，这需要创建具有相同名称的两个段（section）。这是必要的，因为全局变量属于不同的COMDAT组，在对象文件级别，COMDAT由段（section）表示。</p>
<p>请注意，除了使用COMDAT IR指定的内容之外，某些IR结构（如全局变量和函数）可能会在对象文件中创建COMDAT。当代码生成器配置为在各个段（section）中发出全局变量时（例如， 向llc提供<code>-data-sections</code>或<code>-function-sections</code>选项时），就会出现这种情况。</p>
<h3 id="命名元数据"><a href="#命名元数据" class="headerlink" title="命名元数据"></a>命名元数据</h3><p>命名的元数据是元数据的集合。<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据节点</a>（但不是元数据字符串）是命名元数据的唯一有效操作数。</p>
<ol>
<li>命名的元数据被表示为一个带有元数据前缀的字符串。元数据名称的规则与标识符相同，但引用的名称不被允许。”\xx”类型转义仍然有效，它允许任何字符成为名称的一部分。</li>
</ol>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; Some unnamed metadata nodes, which are referenced by the named metadata.</span><br><span class="line">!0 = !&#123;!&quot;zero&quot;&#125;</span><br><span class="line">!1 = !&#123;!&quot;one&quot;&#125;</span><br><span class="line">!2 = !&#123;!&quot;two&quot;&#125;</span><br><span class="line">; A named metadata.</span><br><span class="line">!name = !&#123;!0, !1, !2&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>返回类型和函数类型的每个参数都可能具有一组与其关联的参数属性。参数属性用于传递有关函数结果或参数的附加信息。参数属性被认为是函数的一部分，而不是函数类型，所以具有不同参数属性的函数可以具有相同的函数类型。</p>
<p>参数属性是遵循指定类型的简单关键字。如果需要多个参数属性，则它们是空格分隔的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @printf(i8* noalias nocapture, ...)</span><br><span class="line">declare i32 @atoi(i8 zeroext)</span><br><span class="line">declare signext i8 @returns_signed_char()</span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>function result (nounwind, readonly)</code>的任何属性都会立即出现在参数列表之后。</p>
<p>目前，仅定义了以下参数属性：</p>
<ul>
<li><code>zeroext</code>: 这向代码生成器指示参数或返回值应该被调用者（对于参数）或被调用者（对于返回值）被零扩展到目标机ABI所需的范围。</li>
<li><code>signext</code>: 这向代码生成器指示参数或返回值应该由调用方（对于参数）或被调用方（对于返回值）进行符号扩展到目标机的ABI（通常为32位）所需的范围内。</li>
<li><code>inreg</code>: 这表明这个参数或返回值应该以特定的与目标机相关的方式处理，同时为函数调用或返回发送代码（通常通过将其放入寄存器而不是内存中，尽管有些目标机使用它来区分两个不同类型的寄存器）。使用此属性是特定于目标机的。</li>
<li><code>byval</code>: 这表明指针参数应该真的按值传递给函数。该属性意味着指向者的隐藏拷贝在调用者和被调用者之间建立，所以被调用者无法修改调用者中的值。该属性仅对LLVM指针参数有效。它通常用于按值传递结构和数组，但在指向标量的指针上也是有效的。复制被认为属于调用者而不是被调用者（例如，readonly函数不应写入byval参数）。这不是返回值的有效属性。<br>byval属性还支持使用align属性指定对齐方式。它指示要形成的堆栈槽的对齐以及指定给调用点的指针的已知对齐。如果未指定对齐，则代码生成器会进行特定于目标机的假设。</li>
<li><code>inalloca</code>: inalloca参数属性允许调用者采取传出栈参数的地址。一个inalloca参数必须是堆栈内存指针，<code>alloca</code>指令生成堆栈内存。alloca或参数分配也必须使用<code>inalloca</code>关键字进行标记。只有最后一个参数可能具有该<code>inalloca</code>属性，并且该参数保证在内存中传递。<br>参数分配最多可以由一个调用使用一次，因为调用可能会释放它。影响参数存储的属性，象<code>inreg</code>，<code>nest</code>，<code>sret</code>，或<code>byval</code>，<code>inalloca</code>属性不能结合这些属性一起使用。<code>inalloca</code>属性还禁止LLVM隐式降低大型聚合返回值，这意味着前端作者必须用<code>sret</code>指针降低它们(意思就是不要直接返回大型的值，改用返回指针)。<br>到达呼叫点时，参数分配必须是最新的还存活的堆栈分配，否则结果未定义。可以在参数分配之后、其调用点之前分配额外的堆栈空间，但必须使用<code>[llvm.stackrestore](http://llvm.org/docs/LangRef.html#int-stackrestore)</code>清除它。<br>有关如何使用此属性的更多信息，请参阅<a href="http://llvm.org/docs/InAlloca.html" target="_blank" rel="noopener">InAlloca属性的设计和使用</a>。</li>
<li><code>sret</code>: 这表明指针参数指定了作为源程序中函数返回值的结构地址。该指针必须由调用者保证是有效的：加载和存储到结构可以由被调用者假定不要陷入并且被正确对齐。这不是返回值的有效属性。</li>
<li><code>align &lt;n&gt;</code>: 这表明优化器可能会假定指针值具有指定的对齐方式。<br>请注意，该属性在与<code>byval</code>属性组合时具有额外的语义 。</li>
<li><code>noalias</code>: 这表明，通过<a href="http://llvm.org/docs/LangRef.html#pointeraliasing" target="_blank" rel="noopener">基于</a>所述参数或返回值的指针值访问的对象不可以访问，该函数的执行过程中，通过不基于所述参数或返回值的指针值。返回值的属性也具有下面描述的附加语义。调用方与被调用方分担责任，确保满足这些要求。有关更多详细信息，请参阅<a href="http://llvm.org/docs/AliasAnalysis.html#must-may-or-no" target="_blank" rel="noopener">别名分析</a>中 NoAlias回应的讨论。<br>请注意，这个<code>noalias</code>定义有意地类似于C99中用于函数参数的<a href="https://www.zhihu.com/question/41653775" target="_blank" rel="noopener"><code>restrict</code></a>定义。<br>对于函数返回值，C99的restrict意义不大，而对LLVM的<code>noalias</code>是有意义的。此外，在函数参数上使用时，返回值上的<code>noalias</code>属性的语义强于该属性的语义。在函数返回值上，<code>noalias</code>属性指示该函数的作用类似于系统内存分配函数，它返回一个指针，指向调用者可访问的任何其他对象的存储器的已分配存储空间。</li>
<li><code>nocapture</code>: 这表明被调用者不会创建超出被调用者本身的指针的任何副本。这不是返回值的有效属性。在易变的操作中使用的地址被认为是被捕获的。</li>
<li><code>nest</code>: 这表明指针参数可以使用弹性（trampoline）内联函数删除 。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>returned</code>: 这表明函数总是返回参数作为其返回值。这是在生成调用者时使用的优​​化器和代码生成器的提示，允许值传播，尾部调用优化以及在某些情况下省略寄存器保存和恢复; 在生成被调用者时不检查或强制执行。该参数和函数返回类型必须是<a href="http://llvm.org/docs/LangRef.html#i-bitcast" target="_blank" rel="noopener">bitcast指令</a>的有效操作数 。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>nonnull</code>: 这表明参数或返回指针不为null。该属性可能只适用于指针型参数。这不是LLVM检查或执行的，调用者必须确保传入的指针非空，或者被调用者必须确保返回的指针非空。</li>
<li><code>dereferenceable(&lt;n&gt;)</code>: 这表明参数或返回指针是可逆向引用的(dereferenceable，就是用*pr引用值)。该属性可能只适用于指针型参数。一个可逆向引用的指针可以从投机加载而没有陷入的风险。已知可逆向引用的字节数必须在括号中提供。字节数小于指点人类型的大小是合法的。该nonnull属性并不意味着可引用性（考虑一个指向数组末尾的一个元素的指针），但是<code>dereferenceable(&lt;n&gt;)</code>暗含<code>nonnull</code>在 <code>addrspace(0)</code>中（这是默认地址空间）。</li>
<li><code>dereferenceable_or_null(&lt;n&gt;)</code>: 这表明参数或返回值不能同时为非空和不可逆向引用(达到<code>&lt;n&gt;</code>字节）。标记为<code>dereferenceable_or_null(&lt;n&gt;)</code>的所有非空指针是<code>dereferenceable(&lt;n&gt;)</code>。对于地址空间0 <code>dereferenceable_or_null(&lt;n&gt;)</code>意味着一个指针是正好一个<code>dereferenceable(&lt;n&gt;)</code>或null; 在其它的地址空间<code>dereferenceable_or_null(&lt;n&gt;)</code> 意味着一个指针中的至少一个<code>dereferenceable(&lt;n&gt;)</code>或<code>null</code>（它也可以是<code>null</code>和<code>dereferenceable(&lt;n&gt;)</code>）。该属性可能只适用于指针型参数。</li>
<li><code>swiftself</code>: 这表明该参数是<code>self/context</code>参数。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>swifterror</code>: 这个属性被激发来模拟和优化Swift错误处理。它可以应用于指针指向指针类型或指针大小的alloca的参数。在调用点，与参数相对应的实际<code>swifterror</code>参数必须来自<code>swifterroralloca</code>或<code>swifterror</code>调用者的参数。甲swifterror值（参数或ALLOCA）只能加载和存储的，或用作一个swifterror参数。这不是返回值的有效属性，只能应用于一个参数。<br>这些约束允许调用约定swifterror通过将它们与在调用边界的特定寄存器相关联来优化对变量的访问， 而不是将它们放置在内存中。由于这确实改变了调用约定，所以swifterror在参数上使用属性的函数不是ABI兼容的。<br>这些约束条件还允许LLVM假定swifterror参数不会在函数swifterror中使其他内存可见，并且作为参数传递的 alloca不会转义。</li>
</ul>
<h3 id="垃圾收集器策略的名称"><a href="#垃圾收集器策略的名称" class="headerlink" title="垃圾收集器策略的名称"></a>垃圾收集器策略的名称</h3><p>每个函数都可以指定一个垃圾收集器策略名称，它只是一个字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() gc &quot;name&quot; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>名称的支持值包括<a href="http://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies" target="_blank" rel="noopener">LLVM内置的</a>值以及由加载的插件提供的值。指定GC策略将导致编译器更改其输出以支持指定的垃圾回收算法。请注意，LLVM本身不包含垃圾收集器，此功能仅限于生成可与外部提供的收集器互操作的机器代码。</p>
<h3 id="前缀数据"><a href="#前缀数据" class="headerlink" title="前缀数据"></a>前缀数据</h3><p>前缀数据是与函数关联的数据，代码生成器在函数入口点之前立即发出的。此功能的目的是允许前端（frontends）将语言特定的运行时元数据与特定函数相关联，并通过函数指针使其可用，同时仍允许调用函数指针。</p>
<p>要访问给定函数的数据，程序可以将函数指针bitcast到指向常量类型和取消逆向引用索引(dereference index，可能是指内容-1处的索引)-1的指针。这意味着IR符号刚刚超过前缀数据的末尾。例如，以单个<code>i32</code>注释的函数为例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prefix i32 123 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>前缀数据可以被引用为，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = bitcast void* () @f to i32*</span><br><span class="line">%a = getelementptr inbounds i32, i32* %0, i32 -1</span><br><span class="line">%b = load i32, i32* %a</span><br></pre></td></tr></table></figure></p>
<p>前缀数据的布局就好像它是前缀数据类型的全局变量的初始化程序。该函数将被放置为使得前缀数据的开始对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点不会对齐。如果需要对齐函数的入口点，则必须将填充添加到前缀数据中。</p>
<p>一个函数可能有前缀数据但没有主体。这与available_externally链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标机文件中发送数据。</p>
<h3 id="序言（Prologue）资料"><a href="#序言（Prologue）资料" class="headerlink" title="序言（Prologue）资料"></a>序言（Prologue）资料</h3><p>该prologue属性允许在函数体之前插入任意代码（以字节编码）。这可以用于启用函数热修补和仪器。</p>
<p>为了保持普通函数调用的语义，序言数据必须有特定的格式。具体来说，它必须以一系列字节开始，该字节序列解码为一系列机器指令，对模块的目标代码有效，将控制转移到紧接在序言数据之后的位置，而不执行任何其他可见动作。这允许内联和其他传递推理函数定义的语义，而不需要推理序言数据。显然这使得序言数据的格式高度依赖于目标。</p>
<p>x86体系结构的有效序言数据的一个简单示例是<code>i8 144</code>, 对指令<code>nop</code>进行编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prologue i8 144 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，可以通过对跳过元数据的相对分支指令进行编码来形成序言数据，如x86_64体系结构的有效序言数据的示例，其中前两个字节编码为：<code>jmp .+10</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = type &lt;&#123; i8, i8, i8* &#125;&gt;</span><br><span class="line"></span><br><span class="line">define void @f() prologue %0 &lt;&#123; i8 235, i8 8, i8* @md&#125;&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>一个函数可能有序言数据，但没有主体。这与<code>available_externally</code>链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标文件中发送数据。</p>
<h3 id="Personality功能"><a href="#Personality功能" class="headerlink" title="Personality功能"></a>Personality功能</h3><p>该<code>personality</code>属性允许函数指定用于异常处理的函数。</p>
<h3 id="属性组"><a href="#属性组" class="headerlink" title="属性组"></a>属性组</h3><p>属性组是由IR内的对象引用的属性组。它们对于保持<code>.ll</code>文件可读性很重要，因为许多函数将使用同一组属性。在与单个.c文件相对应的<code>.ll</code>文件的退化(degenerative)情况下，单个属性组将捕获用于构建该文件的重要命令行标志。</p>
<p>一个属性组是一个模块级别的对象。要使用属性组，对象引用属性组的ID（例如<code>#37</code>）。一个对象可能涉及多个属性组。在这种情况下，来自不同组的属性被合并。</p>
<p>下面是一个应该总是内联的函数的属性组的示例，其堆栈对齐方式为4，不应使用SSE指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Target-independent attributes:</span><br><span class="line">attributes #0 = &#123; alwaysinline alignstack=4 &#125;</span><br><span class="line"></span><br><span class="line">; Target-dependent attributes:</span><br><span class="line">attributes #1 = &#123; &quot;no-sse&quot; &#125;</span><br><span class="line"></span><br><span class="line">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span><br><span class="line">define void @f() #0 #1 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><p>函数属性被设置为传递关于函数的附加信息。函数属性被认为是函数的一部分，而不是函数类型的一部分，因此具有不同函数属性的函数可以具有相同的函数类型。</p>
<p>函数属性是遵循指定类型的简单关键字。如果需要多个属性，它们是空格分隔的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define void @f() noinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline optsize &#123; ... &#125;</span><br><span class="line">define void @f() optsize &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>alignstack(&lt;n&gt;)</code>: 这个属性表明，当发布序言和尾声(epilogue)时，后端应该强制堆栈指针对齐。在圆括号中指定所需的对齐方式，该对齐方式必须是2的幂。</li>
<li><code>allocsize(&lt;EltSizeParam&gt;[, &lt;NumEltsParam&gt;])</code>: 该属性指示注释的函数将始终返回至少给定数量的字节（或null）。它的参数是零索引参数号; 如果提供了一个参数，则假定至少有<code>CallSite.Args[EltSizeParam]</code>字节在返回的指针处可用。如果提供了两个参数，则假定<code>CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]</code>字节可用。引用的参数必须是整数类型。没有关于返回的内存块的内容的假设。</li>
<li><code>alwaysinline</code>: 该属性表示内联器应尽可能将该函数内联到调用者中，而忽略此调用者的任何活动内联大小阈值。</li>
<li><code>builtin</code>: 这表明，即使函数的声明使用<code>nobuiltin</code>属性，调用点上的被调用函数也应该被识别为内置函数。这仅在调用点有效，才能直接调用<code>nobuiltin</code>属性声明的函数。</li>
<li><code>cold</code>: 这个属性表明这个函数很少被调用。在计算边权重时，由冷函数调用后支配的基本块也被认为是冷的; 因此，轻量级。</li>
<li><code>convergent</code>: 在一些并行执行模型中，存在无法根据任何附加值进行控制的操作。我们称之为这样的操作<code>convergent</code>，并用这个属性标记它们。<br><code>convergent</code>属性可能出现在函数或<code>call/invoke</code>指令上。当它出现在一个函数上时，它表示对这个函数的调用不应该取决于附加值的控制。例如，内在的<code>llvm.nvvm.barrier0</code>是<code>convergent</code>，所以对这个内在的调用不能取决于附加值的控制。<br>当它出现在一个<code>call/invoke</code>中时，<code>convergent</code>属性表明我们应该把这个调用看作是我们正在调用一个收敛函数。这对间接调用特别有用; 没有这个，我们可以把这样的调用视为目标不收敛。<br>当可以证明函数不执行任何收敛操作时，优化器可以删除函数的<code>convergent</code>属性。同样，优化程序可以在<code>call/invoke</code>不能调用收敛函数时删除<code>calls/invokes</code>上的<code>convergent</code>。</li>
<li><code>inaccessiblememonly</code>: 该属性表明该函数只能访问正在编译的模块而无法访问的内存。这是一种较弱的<code>readnone</code>形式。</li>
<li><code>inaccessiblemem_or_argmemonly</code>: 该属性表明该函数只能访问被编译的模块而无法访问的内存，或者其指针参数指向的内存。这是一种较弱的<code>argmemonly</code>形式。</li>
<li><code>inlinehint</code>: 这个属性表明源代码包含一个暗示这个函数内联的提示是可取的（比如C / C ++中的“inline”关键字）。这只是一个暗示; 它对内联没有要求。</li>
<li><code>jumptable</code>: 该属性表示应该在代码生成时将函数添加到跳转指令表中，并且应将所有对此函数的地址引用引用替换为对相应的跳转指令表函数指针的引用。请注意，这会为原始函数创建一个新指针，这意味着依赖于函数指针标识的代码可能会中断。所以，<code>jumptable</code>注解的任何函数也必须是<code>unnamed_addr</code>。</li>
<li><code>minsize</code>: 此属性表明，优化途径（passes）和代码生成器途径之间进行选择，以使该函数的代码大小尽可能小，并执行可能牺牲运行时性能的优化，以最小化生成的代码的大小。</li>
<li><code>naked</code>: 该属性禁用该函数的序言/尾声(prologue/epilogue)发射。这可能会导致系统特定的后果。</li>
<li><code>no-jump-tables</code>: 当此属性设置为true时，可以从生成的跳转表和查找表被禁用。这些表都是会转换为小写的字母。</li>
<li><code>nobuiltin</code>: 这表明调用点的被调用方函数不被识别为内置函数。除非调用点使用该<code>builtin</code>属性，否则LLVM将保留原始调用并且不会使用基于内置函数的语义的等效代码替换它。这在调用点以及函数声明和定义中是有效的。</li>
<li><code>noduplicate</code>: 此属性表示对函数的调用不能重复。对<code>noduplicate</code>函数的调用可能会在其父函数内移动，但不能在其父函数内复制。<br>包含<code>noduplicate</code>调用的函数可能仍然是内联候选人，前提是调用不通过内联复制。这意味着该功能具有内部链接功能，并且只有一个调用点，所以原始调用在内联后死亡。</li>
<li><code>noimplicitfloat</code>: 该属性禁用隐式浮点指令。</li>
<li><code>noinline</code>: 该属性表示内联器在任何情况下都不应该内联该函数。该属性不能与<code>alwaysinline</code>属性一起使用。</li>
<li><code>nonlazybind</code>: 该属性禁止该函数的延迟符号绑定。如果在程序启动期间未调用该函数，则可能会以更多的程序启动时间为代价来更快地调用该函数。</li>
<li><code>noredzone</code>: 该属性指示代码生成器不应使用红色区域，即使目标特定的ABI通常允许它。</li>
<li><code>noreturn</code>: 该函数属性指示函数永远不会正常返回。如果函数在动态返回时会在运行时产生未定义的行为。</li>
<li><code>norecurse</code>: 该函数属性指示该函数不会直接或间接地调用自己的任何可能的调用路径。如果该函数执行递归，这会在运行时产生未定义的行为。</li>
<li><code>nounwind</code>: 该函数属性指示该函数不会引发异常。如果该函数确实引发异常，则其运行时行为未定义。但是，标记为<code>nounwind</code>的函数仍可能陷入或生成异步异常。由LLVM识别以处理异步异常（如SEH）的异常处理方案仍将提供其实现定义的语义。</li>
<li><code>optforfuzzing</code>: 该属性表示该函数应该针对最大模糊信号进行优化。</li>
<li><code>optnone</code>: 该函数属性指示大多数优化过程将跳过此函数，但过程间优化过程除外。代码生成默认为“<code>fast</code>”指令选择器。该属性不能与<code>alwaysinline</code>属性一起使用; 此属性也与<code>minsize</code>属性和<code>optsize</code>属性不兼容。<br>这个属性需要在<code>noinline</code>函数中指定属性，所以函数不会被内联到任何调用者中。只有具有该<code>alwaysinline</code>属性的函数才是用于内联到此函数主体中的有效候选项。</li>
<li><code>optsize</code>: 此属性表明，优化传递(passes)和代码生成器传递之间进行选择，以保持此函数的代码大小较低，否则，只要不会显着影响运行时性能，就会专门减少代码大小进行优化。</li>
<li>“<code>patchable-function</code>“: 这个属性告诉代码生成器，为这个函数生成的代码需要遵循特定的约定，以便运行时函数稍后可以修补它。该属性本身并不意味着对程序间优化的限制。所有修补语义效应可能必须通过连接类型单独传送。该属性的确切效果取决于其字符串值，目前有一个合法的可能性：<ul>
<li>“<code>prologue-short-redirect</code>“ - 这种类型的可修补函数旨在支持修补函数序言，以线程安全的方式将控制权重定向到函数之外。它保证函数的第一条指令足够大以容纳短跳转指令，并且将被充分对齐以允许通过原子比较和交换指令进行完全更改。尽管可以通过插入足够大的<code>NOP</code>来满足第一个要求，但LLVM可以并且将尝试将现有指令（即，不得不被发射的指令）重新用作大于短跳跃的可修改指令。<br>“<code>prologue-short-redirect</code>“目前仅在x86-64上受支持。</li>
</ul>
</li>
<li>“<code>probe-stack</code>“: 该属性表明该函数将在堆栈的末尾触发一个防护区域。它确保对堆栈的访问必须不会远离保护区域的大小，保护域是堆栈的先前访问。它需要一个必需的字符串值，即将被调用的堆栈探测函数的名称。<br>如果具有”<code>probe-stack</code>“属性的函数内联到另一个”<code>probe-stack</code>“属性的函数中，对调用者而言，则结果函数具有”<code>probe-stack</code>“属性。如果具有”<code>probe-stack</code>“属性的函数被内联到完全没有”<code>probe-stack</code>“属性的函数中，则结果函数具有”<code>probe-stack</code>“被调用者的属性。</li>
<li><code>readnone</code>: 在一个函数上，这个属性表明函数严格基于它的参数来计算它的结果（或者决定展开一个异常），而不需要逆向引用任何指针参数或者访问任何对调用者函数可见的可变状态（例如内存，控制寄存器等）。它不写任何指针参数（包括<code>byval</code>参数），也不会改变调用者可见的任何状态。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在参数上，该属性指示该函数不会对指针参数进行逆向引用，即使它可以读取或写入指针指向的内存（如果通过其他指针访问的话）。</li>
<li><code>readonly</code>: 在一个函数中，这个属性表明函数不会通过任何指针参数（包括<code>byval</code>参数）进行写入，也不会修改调用者函数可见的任何状态（例如内存，控制寄存器等）。它可能会逆向引用（就是*号操作）指针参数并读取调用者可能设置的状态。readonly函数在调用相同的参数集和全局状态时始终返回相同的值（或者展开相同的异常）。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在一个参数上，这个属性表明函数不会通过这个指针参数写入，即使它可能写入指针指向的内存。</li>
<li>“<code>stack-probe-size</code>“: 该属性控制堆栈探测器的行为：”<code>probe-stack</code>“属性或ABI所需的堆栈探测器（如果有的话）。它定义了防护区的大小。它确保如果函数可能会使用比保护区大小更多的堆栈空间，则会发出堆栈探测序列。它需要一个必需的整数值，默认为<code>4096</code>。<br>如果具有”<code>stack-probe-size</code>“属性的函数内联到另一个”<code>stack-probe-size</code>“属性函数中，则生成的函数具有”<code>stack-probe-size</code>“数值较小的属性。如果具有”<code>stack-probe-size</code>“属性的函数被内联到完全没有”stack-probe-size”属性的函数中，则结果函数具有”<code>stack-probe-size</code>“被调用者的属性。</li>
<li>“<code>no-stack-arg-probe</code>“: 该属性禁用ABI所需的堆栈探测器（如果有的话）。</li>
<li><code>writeonly</code>: 在一个函数上，这个属性表明函数可以写入但不从内存中读取。<br>在一个参数上，这个属性表明函数可以写入但不读取这个指针参数（即使它可以从指针指向的内存中读取）。</li>
<li><code>argmemonly</code>: 这个属性表明函数内部唯一的内存访问是加载并存储指针类型参数所指向的对象的任意偏移量。换句话说，函数中的所有内存操作都可以仅使用基于其函数参数的指针来引用内存。请注意，<code>argmemonly</code>可以与<code>readonly</code>属性一起使用，以便指定该函数只从其参数中读取。</li>
<li><code>returns_twice</code>: 该属性表示该函数可以返回两次。C的<a href="https://zh.wikipedia.org/wiki/Setjmp.h" target="_blank" rel="noopener"><code>setjmp</code></a>（<a href="http://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html" target="_blank" rel="noopener">这里</a>有一个更好的例子）是这种功能的一个例子。编译器在这些函数的调用者中禁用某些优化（如tail调用）。</li>
<li><code>safestack</code>: 此属性表示已为此函数启用<a href="http://clang.llvm.org/docs/SafeStack.html" target="_blank" rel="noopener">SafeStack</a>保护。<br>如果具有<code>safestack</code>属性的函数被内联到一个函数，这个函数不具有<code>safestack</code>属性或具有一个<code>ssp</code>，<code>sspstrong</code>或<code>sspreq</code>属性，然后将所得的函数将有一个<code>safestack</code>属性。</li>
<li><code>sanitize_address</code>: 此属性表明已为此函数启用<code>AddressSanitizer</code>检查（动态地址安全分析）。</li>
<li><code>sanitize_memory</code>: 此属性表示对此函数启用<code>MemorySanitizer</code>检查（对未初始化内存的访问的动态检测）。</li>
<li><code>sanitize_thread</code>: 此属性表示为此函数启用了<code>ThreadSanitizer</code>检查（动态线程安全分析）。</li>
<li><code>sanitize_hwaddress</code>: 此属性表示为此函数启用了<code>HWAddressSanitizer</code>检查（基于标记指针的动态地址安全分析）。</li>
<li><code>speculatable</code>: 这个函数属性表明函数除了计算结果之外没有任何影响，并且没有未定义的行为。请注意，这<code>speculatable</code>还不足以断定沿着任何特定的执行路径，对此函数的调用次数不会在外部可观察到。该属性仅适用于函数和声明，而不适用于单个调用点。如果一个函数被错误地标记为<code>speculatable</code>，并且确实表现出未定义的行为，即使该调用点是死代码，也可能会观察到未定义的行为。</li>
<li><p><code>ssp</code>: 该属性表示该函数应该发出一个<a href="https://blog.csdn.net/mantis_1984/article/details/72119575" target="_blank" rel="noopener">堆栈溢出保护器(stack smashing detected)</a>。它的形式是“canary” - 在从函数返回时检查局部变量以查看它是否被覆盖之前放置在堆栈上的随机值。启发式用于确定函数是否需要堆栈保护器。使用的启发式将使保护器具有以下特性的函数：</p>
<ul>
<li>大于<code>ssp-buffer-size</code>（默认8）的字符数组。</li>
<li>包含大于<code>ssp-buffer-size</code>的字符数组的聚合。</li>
<li>大小大于<code>ssp-buffer-size</code>的变量或者常量调用<code>alloca()</code>.</li>
</ul>
<p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。<br>如果一个具有<code>ssp</code>属性的函数被内联到一个没有<code>ssp</code>属性的函数中，那么结果函数将具有一个<code>ssp</code>属性。</p>
</li>
<li><p><code>sspreq</code>: 该属性表示该函数应该始终发出堆栈溢出保护器。这覆盖了<code>ssp</code>函数属性。<br>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p>
<ol>
<li>大型数组和包含大型数组（&gt;= ssp-buffer-size）的结构最接近堆栈保护器。</li>
<li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li>
<li>已经取得地址的变量是第三接近保护者。</li>
</ol>
<p>如果其具有<code>sspreq</code>属性的函数被内联到一个函数，它不具有<code>sspreq</code>属性或具有一个<code>ssp</code>或<code>sspstrong</code>属性，然后将所得的函数将有一个<code>sspreq</code>属性。</p>
</li>
<li><p><code>sspstrong</code>: 该属性表示该函数应该发出一个堆栈溢出保护器。该属性在确定函数是否需要堆栈保护器时会使用强启发式。强大的启发式功能可以为以下函数提供保护：</p>
<ul>
<li>任何大小和类型的阵列</li>
<li>包含任何大小和类型的数组的聚合。</li>
<li>调用alloca（）。</li>
<li>已经取得地址的局部变量。</li>
</ul>
<p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p>
<ol>
<li>大型数组和包含大型数组的结构（&gt;= ssp-buffer-size）最接近堆栈保护器。</li>
<li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li>
<li>已经取得地址的变量是第三接近保护者。</li>
</ol>
<p>这覆盖了<code>ssp</code>函数属性。<br>如果一个具有<code>sspstrong</code>属性的函数被内联到一个没有<code>sspstrong</code>属性的函数中，那么结果函数将具有一个<code>sspstrong</code>属性。</p>
</li>
<li><code>strictfp</code>: 该属性指示该函数是从需要严格浮点语义的作用域调用的。LLVM不会尝试任何需要假设浮点舍入模式的优化，或者可能会改变可能通过调用此函数来设置或清除的浮点状态标志的状态。</li>
<li>“<code>thunk</code>“: 该属性表示该函数将通过尾部调用委托给某个其他函数。不应将<code>thunk</code>的原型用于优化目的。预计调用者将投掷<code>thunk</code>原型以匹配<code>thunk</code>目标原型。</li>
<li><code>uwtable</code>: 这个属性表明被定位的ABI需要为这个函数生成一个展开的表入口，即使我们能够证明没有异常通过它。这通常适用于ELF x86-64 abi，​​但对于某些编译单元可以禁用它。</li>
<li><code>nocf_check</code>: 此属性表示不会对属性实体执行控制流检查。它会禁用特定实体的<code>-fcf-protection = &lt;&gt;</code>以细化HW控制流保护机制。该标志是目标独立的，并且当前属于函数或函数指针。</li>
<li><code>shadowcallstack</code>: 此属性表示为该函数启用了<code>ShadowCallStack</code>检查。仪器检查（instrumentation checks）函数的返回地址在函数<code>prolog</code>和<code>eiplog</code>之间没有改变。它目前是x86_64特定的。</li>
</ul>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>可以设置属性来传达关于全局变量的附加信息。与<a href="http://llvm.org/docs/LangRef.html#fnattrs" target="_blank" rel="noopener">函数属性</a>不同，全局变量上的属性被分组到单个<a href="http://llvm.org/docs/LangRef.html#attrgrp" target="_blank" rel="noopener">属性组中</a>。</p>
<h3 id="操作数捆绑-Operand-Bundles"><a href="#操作数捆绑-Operand-Bundles" class="headerlink" title="操作数捆绑(Operand Bundles)"></a>操作数捆绑(Operand Bundles)</h3><p>操作数捆绑是可与某些LLVM指令相关联的SSA值的标签set集（当前仅包含calls和invokes）。在某种程度上，它们就像元数据，但删除它们是不正确的，并且会改变程序的语义。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operand bundle set ::= &apos;[&apos; operand bundle (, operand bundle )* &apos;]&apos;</span><br><span class="line">operand bundle ::= tag &apos;(&apos; [ bundle operand ] (, bundle operand )* &apos;)&apos;</span><br><span class="line">bundle operand ::= SSA value</span><br><span class="line">tag ::= string constant</span><br></pre></td></tr></table></figure></p>
<p>操作数绑定不是函数签名的一部分，并且可以从具有不同类型操作数绑定的多个位置调用给定函数。这反映了操作数绑定在概念上是call（或invoke）的一部分，而不是被调度的被调用者。</p>
<p>操作数绑定是一种通用机制，旨在支持托管语言的类似运行时自反功能。虽然操作数绑定的确切语义取决于绑定标记，但操作数绑定的存在可以影响程序的语义有一定的限制。这些限制被描述为“unknown”操作数绑定的语义。只要操作数绑定的行为可以在这些限制内进行描述，LLVM就不需要对操作数绑定有特殊的了解，就不会错误地编译包含它的程序。</p>
<ul>
<li>未知操作数绑定的捆绑操作数在控制权转移给被调用者或调用者之前以未知方式转义。</li>
<li>使用操作数绑定进行调用和调用对入口和出口处的堆（即使调用目标是readnone或readonly）在堆上具有未知的读/写效果 ，除非它们被特定于调用点的属性覆盖。</li>
<li>调用点的操作数绑定不能更改被调用函数的实现。只要它们考虑到头两个属性，程序间优化就像往常一样工作。</li>
</ul>
<p>下面描述了更具体的操作数绑定类型。</p>
<h4 id="逆优化（Deoptimization）操作数绑定"><a href="#逆优化（Deoptimization）操作数绑定" class="headerlink" title="逆优化（Deoptimization）操作数绑定"></a>逆优化（Deoptimization）操作数绑定</h4><p>逆优化（Deoptimization）操作数绑定由”<code>deopt</code>“操作数绑定标签表征。这些操作数绑定表示它们所连接的调用点的替代“安全”延续，并且可以由适当的运行时使用，以便在指定的调用点对编译后的帧进行去优化。最多可以有一个”<code>deopt</code>“操作数绑定附加到调用点。逆优化（Deoptimization）的确切细节超出了语言参考的范围，但它通常涉及将编译帧重写为一组解释帧。</p>
<p>从编译器的角度来看，逆优化（Deoptimization）操作数绑定使得它们所连接的调用点至少是<code>readonly</code>。他们通读他们所有的指针类型操作数（即使它们没有被转义）和整个可见的堆。逆优化操作数绑定不会捕获它们的操作数，除非在逆优化过程中，在这种情况下，控制将不会返回到编译帧。</p>
<p>内联器知道如何通过具有逆优化操作数绑定的调用进行内联。就像通过一个正常的调用点进行内联，包括构成正常的和特殊的延续一样，通过调用点内联去耦优化操作数捆绑定需要适当地组成“安全”去优化延续。内联器通过在内联体中对每个逆优化延续预先实现父代的逆优化延续。例如内联<code>@f</code>到<code>@g</code>在下面的例子中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define void @f() &#123;</span><br><span class="line">  call void @x()  ;; no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @g() &#123;</span><br><span class="line">  call void @f() [ &quot;deopt&quot;(i32 20) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会导致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define void @g() &#123;</span><br><span class="line">  call void @x()  ;; still no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前端(frontend)的责任是以句法上将调用者的逆最优化状态预先加入到被调用者的逆最优化状态的方式来构造或编码逆最优化状态，这在语义上等同于在被调用者的逆最佳化延续之后构成调用者的逆最佳化延续。</p>
<h4 id="Funclet操作数捆绑"><a href="#Funclet操作数捆绑" class="headerlink" title="Funclet操作数捆绑"></a>Funclet操作数捆绑</h4><p>Funclet操作数绑定由”<code>funclet</code>“操作数绑定标签表征。这些操作数绑定表明调用点位于特定<code>funclet</code>内。最多可以有一个”<code>funclet</code>“操作数绑定附加到调用点，并且它必须只有一个捆绑操作数。</p>
<p>如果任何<code>funclet</code> EH焊盘(pads)已被“entered”但不是“exited”（根据<a href="http://llvm.org/docs/ExceptionHandling.html#wineh-constraints" target="_blank" rel="noopener">EH文档中的描述</a>），则对下面的执行一个call或者invoke是未定义的行为：</p>
<ul>
<li>没有”<code>funclet</code>“捆绑，并且不是对nounwind intrinsic的call，或者</li>
<li>有一个”<code>funclet</code>绑定，它的操作数不是最近输入的尚未退出funclet EH板（pad）。</li>
</ul>
<p>类似地，如果没有funclet EH焊盘（pads）进入但尚未退出，在一个”<code>funclet</code>“bundle中执行一个call或invoke是未定义的行为。</p>
<h4 id="GC转换操作数绑定"><a href="#GC转换操作数绑定" class="headerlink" title="GC转换操作数绑定"></a>GC转换操作数绑定</h4><p>GC转换操作数绑定由”gc-transition”操作数绑定标记表征。这些操作数绑定将一个调用标记为具有一个GC策略的函数与具有不同GC策略的函数之间的过渡。如果协调GC策略之间的转换需要在调用点生成额外的代码，则这些软件绑定可能包含生成的代码所需的任何值。有关更多详细信息，请参阅<a href="http://llvm.org/docs/Statepoints.html#gc-transition-args" target="_blank" rel="noopener">GC转场</a>。</p>
<h3 id="模块级内联汇编"><a href="#模块级内联汇编" class="headerlink" title="模块级内联汇编"></a>模块级内联汇编</h3><p>模块可能包含“模块级内联asm”块，它对应于GCC“文件范围inline asm”块。这些块由LLVM内部连接并作为一个单元进行处理，但如果需要可以在<code>.ll</code>文件中分开。语法非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module asm &quot;inline asm code goes here&quot;</span><br><span class="line">module asm &quot;more can go here&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串可以通过转义不可打印的字符来包含任何字符。使用的转义序列只是“\xx”，其中“xx”是数字的两位十六进制代码。</p>
<p>请注意，汇编字符串必须由LLVM的集成汇编程序解析（除非它被禁用），即使在发送<code>.s</code>文件时也是如此。</p>
<h3 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h3><p>模块可以指定目标特定数据布局字符串，该字符串指定数据如何布置在内存中。数据布局的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target datalayout = &quot;layout specification&quot;</span><br></pre></td></tr></table></figure></p>
<p>该布局规范包括规范用减号字符分隔（“-”）的列表中。每个规范都以字母开头，并可能在字母后包含其他信息以定义数据布局的某些方面。接受的规格如下：</p>
<ul>
<li><code>E</code>: 指定目标以big-endian格式显示数据。也就是说，最重要的位具有最低的地址位置。</li>
<li><code>e</code>: 指定目标以little-endian形式显示数据。也就是说，具有最低重要性的位具有最低的地址位置。</li>
<li><code>S&lt;size&gt;</code>: 指定堆栈的自然对齐位数。堆栈变量的对齐提升仅限于自然堆栈对齐，以避免动态堆栈重新对齐。堆栈对齐必须是8位的倍数。如果省略，则自然堆栈对齐默认为“未指定”，这不会阻止任何对齐升级。</li>
<li><code>P&lt;address space&gt;</code>: 指定对应于程序内存的地址空间。哈佛（Harvard）体系结构可以使用它来指定LLVM应该在哪些空间放置诸如函数之类的东西。如果省略，程序存储器空间默认为默认地址空间0，这对应于具有相同空间中的代码和数据的冯诺依曼体系结构。</li>
<li><code>A&lt;address space&gt;</code>: 指定由’<code>alloca</code>‘创建的对象的地址空间。默认为默认地址空间0。</li>
<li><code>p[n]:&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;:&lt;idx&gt;</code>: 这将指定大小的指针和它的<code>&lt;abi&gt;</code>和 <code>&lt;pref&gt;</code>错误的地址的空间对齐n。第四个参数<code>&lt;idx&gt;</code>是用于地址计算的索引大小。如果未指定，则默认索引大小等于指针大小。所有尺寸都是位。地址空间n是可选的，如果未指定，则表示默认地址空间0.值n必须在<code>[1,2^23)</code>范围内。</li>
<li><code>i&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的整数类型的对齐方式。值<code>&lt;size&gt;</code>必须在<code>[1,2^23)</code>范围内。</li>
<li><code>v&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的向量类型的对齐方式。</li>
<li><code>f&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的浮点类型的对齐方式。只有目标支持的<code>&lt;size&gt;</code>值才有效。所有目标都支持32（浮动）和64（双）。一些目标也支持80或128（不同长度的双重版本）。</li>
<li><code>a:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了聚合类型对象的对齐方式。</li>
<li><code>m:&lt;mangling&gt;</code>: 如果存在，则指定llvm名称在输出中被损坏。以mangling转义字符作为前缀的符号<code>\01</code>直接传递给汇编器而不使用转义字符。mangling风格选项是<ul>
<li><code>e</code>：ELF mangling：专用符号获取<code>.L</code>前缀。</li>
<li><code>m</code>：Mips mangling：私有符号获取<code>$</code>前缀。</li>
<li><code>o</code>：Mach-O修改：专用符号获取<code>L</code>前缀。其他符号会得到一个<code>_</code>前缀。</li>
<li><code>x</code>：Windows x86 COFF mangling：私有符号获取通常的前缀。普通的C符号会得到一个<code>_</code>前缀。带有<code>__stdcall</code>，<code>__fastcall</code>，和<code>__vectorcall</code>的函数具有附加的自定义修剪(mangling)，<code>@N</code>其中N是用于传递参数的字节数。以<code>?</code>开头的C++符号不会以任何方式的变形（mangling）。</li>
<li><code>w</code>：Windows COFF mangling：类似于<code>x</code>，除了普通的C符号不接受<code>_</code>前缀。</li>
</ul>
</li>
<li><code>n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</code>: 这为位目标CPU指定了一组本地整数宽度。例如，它可能包含32位PowerPC的n32，对于PowerPC 64是<code>n32:64</code>或对于X86-64是<code>n8:16:32:64</code>。这组元素被认为可以有效地支持大多数一般的算术运算。</li>
<li><code>ni:&lt;address space0&gt;:&lt;address space1&gt;:&lt;address space2&gt;...</code>: 这指定具有指定地址空间的指针类型作为<a href="http://llvm.org/docs/LangRef.html#nointptrtype" target="_blank" rel="noopener">非整体指针类型</a>。该<code>0</code>地址空间不能被指定为非积分(non-integral)。</li>
</ul>
<p>在每个采用的<code>&lt;abi&gt;:&lt;pref&gt;</code>规范上，指定<code>&lt;pref&gt;</code>对齐是可选的。如果省略，则前面的内容也应该省略, 并且<code>&lt;pref&gt;</code>等于<code>&lt;abi&gt;</code>。</p>
<p>在为给定目标构建数据布局时，LLVM从默认的一组规范开始，然后（可能）由<code>datalayout</code>关键字中的规范覆盖。默认规格在此列表中给出：</p>
<ul>
<li><code>E</code> - 大端</li>
<li><code>p:64:64:64</code> - 与64位对齐的64位指针。</li>
<li><code>p[n]:64:64:64</code> - 其他地址空间被假定为与默认地址空间相同。</li>
<li><code>S0</code> - 自然堆栈对齐未指定</li>
<li><code>i1:8:8</code> - i1是8位（字节）对齐</li>
<li><code>i8:8:8</code> - i8是8位（字节）对齐</li>
<li><code>i16:16:16</code> - i16是16位对齐的</li>
<li><code>i32:32:32</code> - i32是32位对齐的</li>
<li><code>i64:32:64</code> - i64具有32位的ABI对齐，但优选对齐64位</li>
<li><code>f16:16:16</code> - 一半是16位对齐的</li>
<li><code>f32:32:32</code> - 浮点数是32位对齐的</li>
<li><code>f64:64:64</code> - 双是64位对齐</li>
<li><code>f128:128:128</code> - 四位是128位对齐</li>
<li><code>v64:64:64</code> - 64位向量是64位对齐的</li>
<li><code>v128:128:128</code> - 128位向量是128位对齐的</li>
<li><code>a:0:64</code> - 聚合是64位对齐</li>
</ul>
<p>当LLVM确定给定类型的对齐时，它使用以下规则：</p>
<ol>
<li>如果所寻找的类型与其中一个规格完全匹配，则使用该规格。</li>
<li>如果未找到匹配项，并且所查找的类型是整数类型，则使用大于所查找类型的位宽的最小整数类型。如果没有任何规格大于位宽，则使用最大的整数类型。例如，给定上面的默认规格，<code>i7</code>类型将使用<code>i8</code>（次大）的对齐，而<code>i65</code>和<code>i256</code>将使用<code>i64</code>（最大指定）的对齐。</li>
<li>如果找不到匹配，并且所寻找的类型是矢量类型，那么将使用小于所寻找的矢量类型的最大矢量类型作为回退。发生这种情况是因为<code>&lt;128 x double&gt;</code>可以用<code>64 &lt;2 x double&gt;</code>来实现，例如。</li>
</ol>
<p>数据布局字符串的功能可能不是您所期望的。值得注意的是，这不是来自代码生成器应该使用的对齐前端(frontend)的规范。</p>
<p>相反，如果指定，则需要目标数据布局来匹配最终代码生成器所期望的内容。这个字符串被中级优化器用来改进代码，这只有在它与最终的代码生成器使用的匹配时才有效。没有办法生成IR，这并不会将这个特定于目标的细节嵌入到IR中。如果您未指定字符串，则将使用默认规格来生成数据布局，并且优化阶段将相应地运行，并针对这些默认规格向IR中引入目标特异性。</p>
<h3 id="目标机三重表示法-Target-Triple"><a href="#目标机三重表示法-Target-Triple" class="headerlink" title="目标机三重表示法(Target Triple)"></a>目标机三重表示法(Target Triple)</h3><p>模块可以指定描述目标主机的目标机三元字符串。目标三元组的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target triple = &quot;x86_64-apple-macosx10.7.0&quot;</span><br></pre></td></tr></table></figure></p>
<p>该目标机三重串包括由减号（“<code>-</code>”）字符分隔的一系列标识符。规范形式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM</span><br><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT</span><br></pre></td></tr></table></figure></p>
<p>这些信息被传递到后端，以便为适当的架构生成代码。可以使用<code>-mtriple</code>命令行选项在命令行上覆盖它。</p>
<h3 id="指针别名规则"><a href="#指针别名规则" class="headerlink" title="指针别名规则"></a>指针别名规则</h3><p>任何内存访问都必须通过与内存访问的地址范围关联的指针值来完成，否则行为是不确定的。根据以下规则，指针值与地址范围相关联：</p>
<ul>
<li>指针值与关联基于任何值的地址相关联。（这其实是比较绕口的废话）</li>
<li>全局变量的地址与变量存储的地址范围相关联。</li>
<li>分配指令的结果值与分配的存储器的地址范围相关联。</li>
<li>默认地址空间中的空指针与无地址相关联。</li>
<li>一个非零整数常量或从未在LLVM中定义的函数返回的指针值可能与通过LLVM提供的机制以外的机制分配的地址范围关联。这些范围不得与由LLVM提供的机制分配的任何地址范围重叠。</li>
</ul>
<p>根据以下规则，指针值基于另一个指针值：</p>
<ul>
<li>由标量<code>getelementptr</code>操作符形成的指针值基于指针类型的操作符<code>getelementptr</code>。</li>
<li>在车道(lane)中的指针/升的矢量的结果的<code>getelementptr</code>操作是基于对车道(lane)指针升的的类型的载体的指针操作符<code>getelementptr</code>。</li>
<li><code>bitcast</code>的结果值是基于操作符<code>bitcast</code>。</li>
<li>由<code>inttoptr</code>形成的指针值是基于对造成（直接或间接）到指针的值的计算中的所有指针值。</li>
<li>“基于”的关系是传递性的。</li>
</ul>
<p>请注意，这个“based”的定义有意地类似于C99 中“based”的定义，尽管它稍微弱一些。</p>
<p>LLVM IR不会将类型与内存相关联。<code>load</code>的结果类型仅指示要加载的内存的大小和对齐方式，以及对值的解释。类似的第一个操作数类型store仅指示存储的大小和对齐方式。</p>
<p>因此，基于类型的别名分析，又名TBAA，也就是说<code>-fstrict-aliasing</code>，不适用于通用的非LLVM IR。<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>可用于编码额外的信息，专门的优化过程可用于实现基于类型的别名分析。</p>
<h3 id="易失性-volatile-内存访问"><a href="#易失性-volatile-内存访问" class="headerlink" title="易失性(volatile)内存访问"></a>易失性(volatile)内存访问</h3><p>某些内存访问，如<a href="http://llvm.org/docs/LangRef.html#i-load" target="_blank" rel="noopener">load</a>‘s，<a href="http://llvm.org/docs/LangRef.html#i-store" target="_blank" rel="noopener">store</a>‘s和<a href="http://llvm.org/docs/LangRef.html#int-memcpy" target="_blank" rel="noopener">llvm.memcpy</a>‘s可能被标记<code>volatile</code>。优化器不得更改易失性操作的数量或更改其相对于其他volatile操作的执行顺序。优化器可以改变相对于非volatile操作的易失性操作的顺序。<b style="color:red">这不是Java的“volatile”，并且没有跨线程同步行为。</b></p>
<p>即使那些内部函数被标记为<code>volatile</code>，IR级别的volatile加载和存储也不能安全地优化到<code>llvm.memcpy</code>或<code>llvm.memmove</code>内在函数中。同样，后端不应该拆分或合并目标机器合法的易失性加载/存储指令。</p>
<table>
<thead>
<tr>
<th>合理</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台可能依赖volatile加载，并且本地支持的数据宽度存储将作为单条指令执行。例如，在C中，这适用于具有本地硬件支持的易失性基本类型的l值，但不一定适用于聚合类型。前端支持这些预期，这在IR中是故意没有说明的。上述规则确保IR转换不会违反前端（应该是前置的语言）与该语言的合同。</td>
</tr>
</tbody>
</table>
<h3 id="并发操作的内存模型"><a href="#并发操作的内存模型" class="headerlink" title="并发操作的内存模型"></a>并发操作的内存模型</h3><p>LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有特定于平台的方式来创建它们，并且我们定义LLVM IR他们存在的行为。该模型受C++ 0x内存模型的启发。</p>
<p>有关此模型的更多非正式介绍，请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">LLVM原子指令和并发指南</a>。</p>
<p>我们将发生之前的偏序定义为最小偏序(partial order).</p>
<ul>
<li>是单线程程序顺序的超集，并且</li>
<li>当同步<code>b</code>时，包含一个从<code>a</code>到<code>b</code>的边缘。通过特定于平台的技术（如pthread锁，线程创建，线程连接等）以及原子指令引入同步对。（另请参<a href="http://llvm.org/docs/LangRef.html#ordering" target="_blank" rel="noopener">阅原子内存排序约束</a>）。</li>
</ul>
<p>请注意，程序顺序不会在线程和该线程内执行的信号之间引入边界之前发生的事件。</p>
<p>每个（定义的）读取操作（加载指令，memcpy，原子加载/读取-修改-写入等）<code>R</code>读取由（定义的）写入操作写入的一系列字节（存储指令，原子存储/读取-修改-写入，memcpy等）。就本节而言，已初始化的全局变量被认为是写入了初始化程序，它是原子化的，并且在任何其他读或写有问题的内存之前发生。对于读R的每个字节，R<sub>byte</sub> 可能会看到对相同字节的任何写入，除了：</p>
<ul>
<li>如果write<sub>1</sub> 发生在write<sub>2</sub>之前，并且write<sub>2</sub>发生在R<sub>byte</sub>之前，则R<sub>byte</sub>不会看到Write<sub>1</sub>。</li>
<li>如果R<sub>byte</sub>在write<sub>3</sub>之前发生，则R<sub>byte</sub>不会看到write<sub>3</sub>。</li>
</ul>
<p>鉴于该定义，R<sub>byte</sub>定义如下：</p>
<ul>
<li>如果R是volatile的，则结果与目标相关。（Volatile应该提供可以在C/C++中支持<code>sig_atomic_t</code>的保证，并且可以用于访问不像正常内存那样行为的地址，它通常不会提供跨线程同步。）</li>
<li>否则，如果没有写入R<sub>byte</sub>发生之前的相同字节，则R<sub>byte</sub>会对该字节返回<code>undef</code>。</li>
<li>否则，如果R<sub>byte</sub>可能只看到一次写入，则R<sub>byte</sub>将返回该写入写入的值。</li>
<li>否则，如果R是原子的，并且所有写入的R<sub>byte</sub>可能看到的都是原子的，它将选择其中一个写入的值。请参阅<a href="http://llvm.org/docs/LangRef.html#ordering" target="_blank" rel="noopener">原子内存排序约束</a>部分了解如何进行选择的其他限制条件。</li>
<li>否则R<sub>byte</sub>返回undef。</li>
</ul>
<p>R返回由它读取的一系列字节组成的值。这意味着该值内的一些字节可能是<code>undef</code>，没有整个值的<code>undef</code>。请注意，这只定义了操作的语义; 这并不意味着目标将发出多个指令来读取一系列字节。</p>
<p>请注意，在没有使用任何原子内在函数的情况下，此模型仅对单线程执行所需的IR转换放置一个限制：将store引入可能不会被存储的字节一般是不允许的。（具体来说，在另一个线程可以写入和读取地址的情况下，引入一个store可以改变一个load，可以看到只有一个写入可能看到多个写入的load。）</p>
<h3 id="原子内存排序约束"><a href="#原子内存排序约束" class="headerlink" title="原子内存排序约束"></a>原子内存排序约束</h3><p>原子指令（<a href="http://llvm.org/docs/LangRef.html#i-cmpxchg" target="_blank" rel="noopener">cmpxchg</a>，<a href="http://llvm.org/docs/LangRef.html#i-atomicrmw" target="_blank" rel="noopener">atomicrmw</a>，<a href="http://llvm.org/docs/LangRef.html#i-fence" target="_blank" rel="noopener">fence</a>，<a href="http://llvm.org/docs/LangRef.html#i-load" target="_blank" rel="noopener">atomic load</a>和<a href="http://llvm.org/docs/LangRef.html#i-store" target="_blank" rel="noopener">atomic store</a>）使用排序参数来确定与它们同步的同一地址上的其他原子指令。这些语义是从Java和C ++ 0x中借用的，但是更通俗一点。如果这些描述不够精确，请检查这些规格（请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">Atomic指南</a>中的规格参考）。<a href="http://llvm.org/docs/LangRef.html#i-fence" target="_blank" rel="noopener">fence</a>指令对待这些排序有些不同，因为他们没有收到地址。有关详细信息，请参阅该说明文档。</p>
<p>有关排序约束的更简单介绍，请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">LLVM原子指令和并发指南</a>。</p>
<ul>
<li><code>unordered</code>: 可以读取的一组值由发生前的部分顺序决定。除非某些操作写入，否则无法读取值。这旨在提供足够强大的保证来模拟Java的非volatile共享变量。此顺序不能指定为读取-修改-写入操作; 它不足以使它们以任何有趣的方式成为原子。</li>
<li><code>monotonic</code>: 除了保证<code>unordered</code>之外，每个地址上的<code>monotonic</code>操作都有单个总顺序。所有修改顺序都必须与先发生的订单兼容。不能保证修改顺序可以合并到整个程序的全局总顺序中（而这通常是不可能的）。原子读取-修改-写入操作（<code>cmpxchg</code>和<code>atomicrmw</code>）中的读取会在写入值之前立即读取修改顺序中的值。如果在同一地址的另一个原子读取之前发生一次原子读取，则稍后的读取必须在地址的修改顺序中看到相同的值或更高的值。这不允许重新排序<code>monotonic</code>（或更强大）的操作。如果地址是由一个线程<code>monotonic-ally</code>写入和其他线程monotonic-ally读取的 - 反复读取该地址，其他线程最终必须看到写入。这对应于C++ 0x/C1x的<code>memory_order_relaxed</code>。</li>
<li><code>acquire</code>: 除了<code>monotonic</code>的保障，一个进行同步边缘可以与形成release操作。这是为了模拟C++的<code>memory_order_acquire</code>。</li>
<li><code>release</code>: 除了保证<code>monotonic</code>，如果此操作写入随后由<code>acquire</code>操作读取的值，则与该操作同步。（这不是一个完整的描述;请参阅发布序列的C++0x定义。）这对应于C ++ 0x/C1x的<code>memory_order_release</code>。</li>
<li><code>acq_rel （获取+释放）</code>: <code>acquire</code>和<code>release</code>操作作为地址的一部分。这对应于C ++ 0x / C1x <code>memory_order_acq_rel</code>。</li>
<li><code>seq_cst （顺序一致）</code>: 除了保证<code>acq_rel</code>（<code>acquire</code>对于仅读取的操作，<code>release</code>对于仅写入的操作），对于所有地址上的所有顺序一致的操作，存在全局总顺序，这与在部分顺序之前发生的以及与所有受影响地址的修改顺序一致。每个按顺序一致的读取将按照此全局顺序查看最后一个先前写入相同地址的内容。这对应于C ++ 0x / C1x <code>memory_order_seq_cst</code>和Java <code>volatile</code>。</li>
</ul>
<p>如果标记了一个原子操作<code>syncscope(&quot;singlethread&quot;)</code>，它只会同步并仅参与在同一线程中运行的其他操作（例如，在信号处理程序中）的<code>seq_cst</code>总排序。</p>
<p>如果标记了一个原子操作<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>，其中 <code>&lt;target-scope&gt;</code>是目标特定的同步范围，那么它与目标相关，如果它与其他操作的<code>seq_cst</code>总排序同步并参与其中。</p>
<p>否则，未标记的原子操作<code>syncscope(&quot;singlethread&quot;)</code> 或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code> 与同步和参与未标记<code>syncscope(&quot;singlethread&quot;)</code>或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>的其它操作的<code>seq_cst</code>总排序 。</p>
<h3 id="浮点环境"><a href="#浮点环境" class="headerlink" title="浮点环境"></a>浮点环境</h3><p>默认的LLVM浮点环境假定浮点指令没有副作用。结果假设为舍入到舍入模式。此环境中不保留浮点异常状态。因此，在这些示例中，不会尝试创建或保留无效操作（SNaN）或零除异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = fdiv 0x7ff0000000000001, %X  ; 64-bit SNaN hex value</span><br><span class="line">  %B = fdiv %X, 0.0</span><br><span class="line">Safe:</span><br><span class="line">  %A = NaN</span><br><span class="line">  %B = NaN</span><br></pre></td></tr></table></figure></p>
<p>这种无异常假设的好处是可以自由推测浮点运算，而无需对浮点模型进行任何其他快速数学放松(fast-math relaxations)。</p>
<p>需要与此不同的行为的代码应使用<a href="http://llvm.org/docs/LangRef.html#constrainedfp" target="_blank" rel="noopener">约束浮点内部函数</a>。</p>
<h3 id="快速数学标志"><a href="#快速数学标志" class="headerlink" title="快速数学标志"></a>快速数学标志</h3><p>LLVM IR浮点运算（<a href="http://llvm.org/docs/LangRef.html#i-fadd" target="_blank" rel="noopener"><code>fadd</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fsub" target="_blank" rel="noopener"><code>fsub</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fmul" target="_blank" rel="noopener"><code>fmul</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fdiv" target="_blank" rel="noopener"><code>fdiv</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-frem" target="_blank" rel="noopener"><code>frem</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fcmp" target="_blank" rel="noopener"><code>fcmp</code></a>）和<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener"><code>call</code></a>可以使用以下标志来启用其他不安全的浮点转换。</p>
<ul>
<li><code>nnan</code>: 没有NaNs - 允许优化假设参数和结果不是NaN。需要进行这样的优化才能在NaN上保留已定义的行为，但结果的值未定义。</li>
<li><code>ninf</code>: 无Infs - 允许优化假设参数和结果不是<code>+/-Inf</code>。需要进行这样的优化才能在<code>+/-Inf</code>上保留已定义的行为，但结果的值未定义。</li>
<li><code>nsz</code>: 无签名零 - 允许优化将零参数或结果的符号视为无关紧要。</li>
<li><code>arcp</code>: 允许互惠(Reciprocal) - 允许优化使用参数的倒数而不是执行除法。</li>
<li><code>contract</code>: 允许浮点收缩（例如，融合乘法，然后将加法融合为融合乘加）。</li>
<li><code>afn</code>: 近似函数 - 允许用近似计算代替函数（<code>sin</code>，<code>log</code>，<code>sqrt</code>等）。有关可应用于LLVM的内在数学函数的位置，请参阅浮点内在定义。</li>
<li><code>reassoc</code>: 允许重新关联转换为浮点指令。这可能会显着改变浮点结果。</li>
<li><code>fast</code>: 这个标志暗示其他所有的。</li>
</ul>
<h3 id="使用列表顺序指令"><a href="#使用列表顺序指令" class="headerlink" title="使用列表顺序指令"></a>使用列表顺序指令</h3><p>使用列表指令对每个使用列表的内存顺序进行编码，从而允许重新创建订单。<code>&lt;order-indexes&gt;</code>是分配给引用值用途的索引的逗号分隔列表。引用值的使用列表会立即按这些索引排序。</p>
<p>Use-List指令可能出现在函数作用域或全局作用域中。它们不是指令，对IR的语义没有影响。当它们在函数范围内时，它们必须出现在最终基本块的终止符之后。</p>
<p>如果基本块的地址是通过<code>blockaddress()</code>表达式获取的， <code>uselistorder_bb</code>则可用于从其函数范围之外对其使用列表重新排序。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uselistorder &lt;ty&gt; &lt;value&gt;, &#123; &lt;order-indexes&gt; &#125;</span><br><span class="line">uselistorder_bb @function, %block &#123; &lt;order-indexes&gt; &#125;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define void @foo(i32 %arg1, i32 %arg2) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line">bb:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line"></span><br><span class="line">  ; At function scope.</span><br><span class="line">  uselistorder i32 %arg1, &#123; 1, 0, 2 &#125;</span><br><span class="line">  uselistorder label %bb, &#123; 1, 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; At global scope.</span><br><span class="line">uselistorder i32* @global, &#123; 1, 2, 0 &#125;</span><br><span class="line">uselistorder i32 7, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder i32 (i32) @bar, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder_bb @foo, %bb, &#123; 5, 1, 3, 2, 0, 4 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h3><p>源文件名字符串设置为原来的模块标识符，当通过clang前端从源代码编译时，例如，这将是编译的源文件的名称。然后通过IR和比特码进行保存。</p>
<p>目前，这对于为配置文件数据中使用的本地函数生成一致的唯一全局标识符是非常必要的，该配置文件将源文件名预先设置为本地函数名称。</p>
<p>源文件名的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_filename = &quot;/path/to/source.c&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章，翻译起来的确是非常麻烦，由于没有通读全文，里面应该有不少错误的地方，日后会重新修改。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/12/编译原理/LLVM简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/编译原理/LLVM简介/" itemprop="url">LLVM简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T15:28:52+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是LLVM"><a href="#什么是LLVM" class="headerlink" title="什么是LLVM"></a>什么是LLVM</h2><p>官方的解释是：LLVM可以被看作是一系列的编译器和工具链技术的集合，而且它们是模块化并且是可重用的。官方网站是：<a href="http://llvm.org/" target="_blank" rel="noopener">http://llvm.org/</a> 。 不过从名称上看像一个虚拟机，然而与虚拟机没有一点关系，LLVM是这个项目的名称而已。</p>
<p>LLVM最初是伊利诺伊大学的一个研究项目，其目标是提供一种现代的，基于<a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener">SSA</a>（static single assignment form，静态单赋值形式）的编译策略，能够支持任意编程语言的静态和动态编译。 从那时起，LLVM已经发展成为一个由多个子项目组成的综合项目，其中许多子项目正在各种商业和开源项目的生产中使用，并且被广泛用于学术研究。 LLVM项目中的代码遵循“UIUC”BSD-Style许可证.</p>
<p>LLVM的主要子项目有：</p>
<ol>
<li>LLVM核心库提供了一个独立于现代的源和目标的<a href="http://llvm.org/docs/Passes.html" target="_blank" rel="noopener">优化器</a>，以及支持许多流行CPU的<a href="http://llvm.org/docs/CodeGenerator.html" target="_blank" rel="noopener">代码生成</a>（以及一些不太常见的CPU）。这些库是围绕一个<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">良好规范</a>的代码表示而建立的，称为LLVM<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%96%93%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">中间语言</a>（“LLVM IR”）。 LLVM Core库有<a href="http://llvm.org/docs/" target="_blank" rel="noopener">详细的文档</a>，并且<a href="http://llvm.org/docs/tutorial/" target="_blank" rel="noopener">使用LLVM用作优化器和代码生成器</a>，将使你特别容易地将创建自己的语言（或移植现有的编译器）。</li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="noopener">Clang</a>是一种“LLVM原生”的C/C++/Objective-C编译器，它旨在提供惊人的快速编译（例如，在编译调试配置中编译Objective-C代码时<a href="http://clang.llvm.org/features.html#performance" target="_blank" rel="noopener">比GCC快大约3倍</a>），非常有用的<a href="http://clang.llvm.org/diagnostics.html" target="_blank" rel="noopener">错误和警告消息</a>，为构建优秀的源代码级工具提供了一个平台。<a href="http://clang-analyzer.llvm.org/" target="_blank" rel="noopener">Clang静态分析器</a>是一个可以自动发现代码中的错误的工具，并且它是使用Clang前端作为库来解析C/C++代码的工具。</li>
<li><a href="http://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a>项目建立在由LLVM和Clang提供的库上，以提供一个出色的本地调试器。 它使用Clang AST和表达式解析器，LLVM JIT，LLVM反汇编器等，以便提供“正常工作”的体验。 在加载符号时，它比GDB更快速，内存效率更高。</li>
<li><a href="http://libcxx.llvm.org/" target="_blank" rel="noopener">libc++</a>和<a href="http://libcxxabi.llvm.org/" target="_blank" rel="noopener">libc++ ABI</a>项目提供了C++标准库的标准一致性和高性能实现，包括对C++11的全面支持。</li>
<li><a href="http://compiler-rt.llvm.org/" target="_blank" rel="noopener">编译器rt</a>项目提供高级优化的低级代码生成器支持例程的实现，例如<code>“__fixunsdfdi”</code>以及当目标没有执行核心IR操作的短序列本机指令时生成的其他调用。 它还为动态测试工具（如<a href="http://clang.llvm.org/docs/AddressSanitizer.html" target="_blank" rel="noopener">AddressSanitizer</a>，<a href="http://clang.llvm.org/docs/ThreadSanitizer.html" target="_blank" rel="noopener">ThreadSanitizer</a>，<a href="http://clang.llvm.org/docs/MemorySanitizer.html" target="_blank" rel="noopener">MemorySanitizer</a>和<a href="http://clang.llvm.org/docs/DataFlowSanitizer.html" target="_blank" rel="noopener">DataFlowSanitizer</a>）提供了运行时库的实现。</li>
<li><a href="http://openmp.llvm.org/" target="_blank" rel="noopener">OpenMP</a>子项目提供<a href="http://www.openmp.org/" target="_blank" rel="noopener">OpenMP</a> Runtime，以便与Clang中的OpenMP实现一起使用。</li>
<li><a href="http://polly.llvm.org/" target="_blank" rel="noopener">polly</a>项目实现了一套缓存局部优化以及使用多面体模型的自动并行和向量化。</li>
<li><a href="http://libclc.llvm.org/" target="_blank" rel="noopener">libclc</a>项目旨在实现OpenCL标准库。</li>
<li><a href="http://klee.llvm.org/" target="_blank" rel="noopener">klee</a>项目实现了一个“符号虚拟机”，它使用定理证明器来尝试评估程序中的所有动态路径，以努力寻找错误并证明函数的属性。 klee的一个主要特点是它可以在检测到错误的情况下生成一个测试用例。</li>
<li><a href="http://safecode.cs.illinois.edu/" target="_blank" rel="noopener">SAFECode</a>项目是用于C/C++程序的内存安全编译器。它使用运行时检查代码来检测运行时的内存安全错误（例如，缓冲区溢出）。它可以用来保护软件免受安全攻击，也可以用作Valgrind之类的内存安全错误调试工具。</li>
<li><a href="http://lld.llvm.org/" target="_blank" rel="noopener">lld</a>项目旨在成为clang/llvm的内置链接器。目前，clang必须调用系统链接器来生成可执行文件。</li>
</ol>
<p>除了LLVM的官方子项目之外，还有各种各样<a href="http://llvm.org/ProjectsWithLLVM/" target="_blank" rel="noopener">使用LLVM组件执行各种任务的其他项目</a>。 通过这些外部项目，您可以使用LLVM编译Ruby，Python，Haskell，Java，D，PHP，Pure，Lua和一些其他语言。 LLVM的一个主要优势是其多功能性，灵活性和可重用性，这就是为什么它被用于如此广泛的各种不同任务的原因：从Lua等嵌入式语言的轻量级JIT编译到编译Fortran代码以实现大规模超级电脑。</p>
<p>和其他所有事情一样，LLVM拥有广泛而友好的社区，他们对构建优秀的底层工具感兴趣。如果您有兴趣参与，首先要浏览<a href="http://blog.llvm.org/" target="_blank" rel="noopener">LLVM博客</a>并注册<a href="http://lists.llvm.org/mailman/listinfo/llvm-dev" target="_blank" rel="noopener">LLVM Developer邮件列表</a>。 有关如何发送补丁程序，获取提交权限以及版权和许可证主题的信息，请参阅<a href="http://llvm.org/docs/DeveloperPolicy.html" target="_blank" rel="noopener">LLVM开发者规则</a>。</p>
<h2 id="关于LLVM"><a href="#关于LLVM" class="headerlink" title="关于LLVM"></a><b style="color:red">关于LLVM</b></h2><p><b style="color:green">看上面的说明可能有点懵，但其实就是LLVM定义了一种<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%96%93%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">中间语言</a>或称<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">通用中间语言</a>,提供了丰富的中间码(IR),这样就为我们创建自己的语言提供了极大的便利，其实就是感觉自己用IR去生成自己的命令，类似于CPU中的微指令了。另外就是将自己的语言转成对应的LLVM IR，那么就可以直接使用LLVM子项目中的JIT，这样你就不用自己写虚拟机了，的确是带来了极大的遍历。</b></p>
<p><b style="color:blue">再比如像solidity这样的语言需要运行在以太坊的CPP节点，Go节点，Parity的Scala节点，这样的话我们要写很多的编译器和虚拟机，但是有了LLVM后，一切都不用担心了，实现起来还是比较靠谱的，不是吗？</b></p>
<p><b style="color:green">另外通过LLVM我们可以实现不同语言之间的互转，比如C++代码转成node代码。中间只要通过LLVM就可以了。以前不明白微软怎么支持多种语言实现在win10上安装，现在终于有思路了，只是微软要写多种编译器，可能这个过程比较难吧，他们放弃了。还有就比如以太坊的<a href="https://github.com/ethereum/solc-bin" target="_blank" rel="noopener">solc-bin</a>里面有用的文件只有一个7M多的js文件，而且还是压缩的，从ReadMe中我们可以发现，这个项目中的文件都是通过emscripten生成的；而emscripten是将LLVM中间语言转化为node代码，一切已然明了。</b></p>
<p><b style="color:blue">所以我觉得学习LLVM语言还是很有必要的过程，应该深入去学习一下。</b></p>
<h2 id="关于emscripten"><a href="#关于emscripten" class="headerlink" title="关于emscripten"></a>关于emscripten</h2><p>这是一个很棒的项目，将LLVM中间语言转化为node的代码。更多的东西就不用多介绍了，也不进行深入地学习了，这要精通node的编译器和语法知识才行，我就读读Readme、WIKI和api文档就好了。下面列一下学习的资料吧！<br><a href="https://github.com/kripken/emscripten" target="_blank" rel="noopener">官方github项目</a><br><a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="noopener">Emscripten Wiki</a><br><a href="http://kripken.github.io/emscripten-site/index.html" target="_blank" rel="noopener">Emscripten 文档</a></p>
<h2 id="LLVM的命令指南"><a href="#LLVM的命令指南" class="headerlink" title="LLVM的命令指南"></a>LLVM的命令指南</h2><p>以下文档是所有LLVM工具的命令描述。 这些页面描述如何使用LLVM命令以及它们的选项。 请注意，这些页面没有描述所有工具可用的所有选项。 要获得完整列表，请将–help（常规选项）或–help-hidden（常规和调试选项）参数传递给您感兴趣的工具。</p>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-as.html" target="_blank" rel="noopener">llvm-as - LLVM汇编程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-dis.html" target="_blank" rel="noopener">llvm-dis - LLVM反汇编程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/opt.html" target="_blank" rel="noopener">opt - LLVM优化器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llc.html" target="_blank" rel="noopener">llc - LLVM静态编译器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/lli.html" target="_blank" rel="noopener">lli - 直接从LLVM位码执行程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-link.html" target="_blank" rel="noopener">llvm-link - LLVM位码链接器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-ar.html" target="_blank" rel="noopener">llvm-ar - LLVM归档打包 archiver</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-lib.html" target="_blank" rel="noopener">llvm-lib - LLVM lib.exe lib.exe兼容库工具</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-nm.html" target="_blank" rel="noopener">llvm-nm - 列出LLVM位码和目标文件的符号表</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-config.html" target="_blank" rel="noopener">llvm-config - 打印LLVM编译选项</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-diff.html" target="_blank" rel="noopener">llvm-diff - LLVM结构差异</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-cov.html" target="_blank" rel="noopener">llvm-cov - 发布覆盖信息</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-profdata.html" target="_blank" rel="noopener">llvm-profdata - 配置数据工具</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-stress.html" target="_blank" rel="noopener">llvm-stress - 生成随机的.ll文件</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-symbolizer.html" target="_blank" rel="noopener">llvm-symbolizer - 将地址转换为源代码位置</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-dwarfdump.html" target="_blank" rel="noopener">llvm-dwarfdump - 转储并验证DWARF调试信息</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/dsymutil.html" target="_blank" rel="noopener">dsymutil - 处理归档的DWARF调试符号文件</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-mca.html" target="_blank" rel="noopener">llvm-mca - LLVM机器代码分析器</a></li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li><a href="http://llvm.org/docs/CommandGuide/bugpoint.html" target="_blank" rel="noopener">bugpoint - 自动测试案例缩减工具</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-extract.html" target="_blank" rel="noopener">llvm-extract - 从LLVM模块中提取函数</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html" target="_blank" rel="noopener">llvm-bcanalyzer - LLVM位码分析器</a></li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li><a href="http://llvm.org/docs/CommandGuide/FileCheck.html" target="_blank" rel="noopener">FileCheck - 灵活的模式匹配文件验证器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/tblgen.html" target="_blank" rel="noopener">tblgen - 目标描述到C ++代码生成器</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/lit.html" target="_blank" rel="noopener">lit - LLVM综合测试仪</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-build.html" target="_blank" rel="noopener">llvm-build - LLVM项目构建实用程序</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-exegesis.html" target="_blank" rel="noopener">llvm-exegesis - LLVM机器指令基准</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-pdbutil.html" target="_blank" rel="noopener">llvm-pdbutil - PDB文件取证和诊断</a></li>
<li><a href="http://llvm.org/docs/CommandGuide/llvm-readobj.html" target="_blank" rel="noopener">llvm-readobj - LLVM对象读取器</a></li>
</ul>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://llvm.org/" target="_blank" rel="noopener">The LLVM Compiler Infrastructure</a><br><a href="http://llvm.org/docs/CommandGuide/" target="_blank" rel="noopener">LLVM Command Guide</a><br><a href="https://blog.csdn.net/snsn1984/article/details/8232943" target="_blank" rel="noopener"> LLVM每日谈之七 Clang</a><br><a href="https://blog.csdn.net/snsn1984/article/details/8593380" target="_blank" rel="noopener">七天LLVM零基础入门（Linux版本）——第一天</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/11/golang/Go的汇编程序快速指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/golang/Go的汇编程序快速指南/" itemprop="url">Go的汇编程序快速指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T17:14:18+08:00">2018-04-11</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go语言/" itemprop="url" rel="index"><span itemprop="name">Go语言</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近日在研究solidity语言的时候，发现了很多关于汇编的有趣知识，感觉知识无涯，勤奋是道呀！要学习的东西还是很多的，今天就来研究一下这个Go语言的汇编。本文是参考Go语言官方的文档，好像这个没有详细的文档，就先入个门吧！</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档提到里面的内容是不全面的，试问全面的在哪？</p>
<p>Go的汇编语言基于<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB" target="_blank" rel="noopener">Plan 9</a>的汇编，<a href="https://9p.io/plan9/" target="_blank" rel="noopener">Plan 9网站</a>的页面上有详细描述。如果你想编写汇编语言，你应该读<a href="https://9p.io/sys/doc/asm.html" target="_blank" rel="noopener">这篇文档</a>，虽然它是Plan 9相关的。这边文档总结了汇编的语法，并且描述了使用汇编语言和Go程序交互时的特殊之处。</p>
<p>有一点是很重要的是，Go的汇编中没有直接体现出底层的机器。有些汇编细节能直接对应到机器，但有些不是。这是因为编译器套件在常规过程中不需要汇编语言。取而代之的是，编译器产生二进制的不完整的汇编指令集，链接器会完成它。<b style="color:blue">实际上，链接器做了汇编指令的选择，所以当你看到类似于MOV这样的指令，链接器的实际操作可能不是一个移动指令，也许是清除或者载入</b>。或者可能会根据指令的名字对应到真实的机器指令。总体上，机器相关的指令操作趋向于体现出真实的机器指令，但是一些通用的概念类似于移动内存数据、调用子例程、返回等操作就更抽象了。具体的细节和架构相关，我们为这种不精确性道歉;情况并不明确。</p>
<p>汇编程序是生成中间码的一种方法，未完整定义的指令集作为链接器的输入。如果你想看到特定CPU架构下的汇编指令集，如amd64，在Go标准库的源文件中就有许多例子，在<a href="https://golang.org/pkg/runtime/" target="_blank" rel="noopener">runtime</a>和<a href="https://golang.org/pkg/math/big/" target="_blank" rel="noopener">math/big</a>包中。 或者你还可以参照下面的程序，来检查编译器的汇编输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat x.go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> GOOS=linux GOARCH=amd64 go tool compile -S x.go        <span class="comment"># or: go build -gcflags -S x.go</span></span></span><br><span class="line"></span><br><span class="line">--- prog list "main" ---</span><br><span class="line">0000 (x.go:3) TEXT    main+0(SB),$8-0</span><br><span class="line">0001 (x.go:3) FUNCDATA $0,gcargs·0+0(SB)</span><br><span class="line">0002 (x.go:3) FUNCDATA $1,gclocals·0+0(SB)</span><br><span class="line">0003 (x.go:4) MOVQ    $3,(SP)</span><br><span class="line">0004 (x.go:4) PCDATA  $0,$8</span><br><span class="line">0005 (x.go:4) CALL    ,runtime.printint+0(SB)</span><br><span class="line">0006 (x.go:4) PCDATA  $0,$-1</span><br><span class="line">0007 (x.go:4) PCDATA  $0,$0</span><br><span class="line">0008 (x.go:4) CALL    ,runtime.printnl+0(SB)</span><br><span class="line">0009 (x.go:4) PCDATA  $0,$-1</span><br><span class="line">0010 (x.go:5) RET     ,</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>FUNCDATA和PCDATA指令包含一些垃圾收集器需要的信息。它们由编译器产生。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>尽管汇编程序从Plan 9汇编程序中获得了指导，但它是一个独特的程序，因此存在一些差异。一个是不断的评估。汇编器中的常量表达式使用Go的运算符优先级解析，而不是原始的类C优先级。因此<code>3&amp;1&lt;&lt;2</code>是4，而不是0–它解析为<code>(3&amp;1)&lt;&lt;2</code> 不是<code>3&amp;(1&lt;&lt;2)</code>。而且，常量总是被评估为64位无符号整数。因此-2，不是整数值负2，而是具有相同位模式的无符号64位整数。这种区别无关紧要，但是这是为了当右操作数的高位被设置，避免除法或右移的歧义性。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>一些符号（如R1或LR）是预定义的，并且指的是寄存器。确切的集合取决于体系结构。</p>
<p><b style="color:red">有四个预先标记的符号表示伪寄存器。这些不是真正的寄存器，而是由工具链维护的虚拟寄存器，例如帧指针</b>。所有体系结构的伪寄存器组都是相同的：</p>
<ul>
<li>FP：帧（frame）指针：参数和本地变量。</li>
<li>PC：程序计数器：跳转和分支。</li>
<li>SB：静态基址指针：全局符号。</li>
<li>SP：堆栈指针：堆栈顶部。</li>
</ul>
<p>所有用户定义的符号都被写为伪寄存器FP（参数和本地变量）和SB（全局）的偏移量 。</p>
<p>SB伪寄存器可以被认为是内存的原点，所以符号<code>foo(SB)</code>的名称是foo在内存中的地址。这种格式用于命名全局函数和数据。在名称中添加&lt;&gt;，就像<code>foo&lt;&gt;(SB)</code>一样，那么该名称只能在当前源文件中看到，就像C文件中的<code>static</code>顶级声明。给名称添加一个偏移量就是指符号地址的偏移量，因此<code>foo+4(SB)</code>是foo开始处的四个字节。</p>
<p><code>FP</code>伪寄存器是用来指向函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈中的参数作为该伪寄存器的偏移量。因此<code>0(FP)</code>是函数的第一个参数，<code>8(FP)</code>第二个参数（在64位机器上）等等。但是，当以这种方式引用函数参数时，有必要在开始处放置一个名称，如<code>first_arg+0(FP)</code>和<code>second_arg+8(FP)</code>。（帧指针的偏移量，偏移量的含义 - 与其使用SB的偏移量不同，它是与符号的偏移量。）有些汇编程序强制执行这个约定，拒绝普通的<code>0(FP)</code>和<code>8(FP)</code>。实际名称在语义上不相关，但应该用来记录参数的名称。值得强调的是<code>FP</code>始终是伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的体系结构中也是如此。</p>
<p>对于使用Go的汇编函数，<code>go vet</code>将检查参数名称和偏移量是否匹配。在32位系统上，64位值的低32位和高32位通过在名称中添加<code>_lo</code>或<code>_hi</code>后缀来区分，如<code>arg_lo+0(FP)</code>或<code>arg_hi+4(FP)</code>。如果Go原型没有命名它的结果，那么预期的汇编名称是<code>ret</code>。</p>
<p><code>SP</code>伪寄存器是虚拟堆栈指针，用来指向帧局部变量和为函数调用准备的参数。它指向本地堆栈帧的顶部，因此引用应使用负数表示的范围<code>[-framesize，0）</code>中：例如：<code>x-8(SP)</code>，<code>y-4(SP)</code>等等。</p>
<p><b style="color:blue">在名<code>SP</code>为硬件寄存器的体系结构中，名称前缀将对虚拟堆栈指针的引用与对帧（frame）SP寄存器的引用进行区分。即，<code>x-8(SP)</code>和<code>-8(SP)</code> 是不同的存储位置：所述第一指虚拟堆栈指针伪寄存器，而第二指硬件的SP寄存器。</b></p>
<p><b style="color:blue">在物理机器上SP和PC是传统的物理地址寄存器中的别名，在Go汇编中名称SP和PC仍然特殊处理; 例如，SP引用要求符号，很像FP。要访问实际的硬件寄存器，请使用真实的寄存器名称。例如，在ARM体系结构上的硬件上硬件SP，PC可作为R13和R15访问。</b></p>
<p>分支和直接跳转总是在PC中写为的偏移量，或跳转到标签：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">	MOVW $0, R1</span><br><span class="line">	JMP label</span><br></pre></td></tr></table></figure></p>
<p>每个标签只能在其定义的函数中可见。因此允许文件中的多个函数定义和使用相同的标签名称。直接跳转和调用指令可以将文本符号作为目标，例如<code>name(SB)</code>,但不是符号的偏移量<code>name+4(SB)</code>。</p>
<p>指令，寄存器和汇编程序指令总是以大写形式提醒您，汇编编程是一项艰巨的工作。（例外：在ARM平台下，代表当前goroutine的g寄存器被重新命名。）</p>
<p>在Go对象文件和二进制文件中，符号的完整名字是包的路径加上一个句点：<code>fmt.Printf</code>或<code>math/rand.Int</code>。由于汇编器的解析器将句点和斜线视为标点符号，因此这些字符串不能直接用作标识符名称。相反，汇编程序允许标识符中的中点字符<code>U+00B7</code>和除法斜杠<code>U+2215</code>，并将它们重写为纯句点和斜杠。在汇编源代码文件中，上面的符号写成<code>fmt·Printf</code>和<code>math∕rand·Int</code>。通过在编译时使用-S标志看到的汇编代码列表中直接显示了句点和斜杠，而不是在汇编程序中需要的Unicode替代字符(指上面的两个特殊Unicode字符)。</p>
<p>大部分手写的汇编文件中，不要在符号名中包含完整的包路径，因为链接器会在任何以句点开头的名字前面插入当前对象文件的路径：包含<code>math/rand</code>包的汇编源文件中，rand包的Int函数可以当做<code>·Int</code>来引用。这种便捷性避免了需要在自身的源代码中硬编码导入路径，可以让代码从一个地方移动到另一个地方时变得更容易。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>汇编程序使用各种指令将文本和数据绑定到符号名称。例如，这里是一个简单但是完整的函数定义。<code>TEXT</code>指令声明符号<code>runtime·profileloop</code>, 指令紧接在类似于函数的主体中。<code>TEXT</code>块中的最后一条指令必须是某种跳转，通常是<code>RET</code>（伪）指令。（如果不是，链接器会追加跳转到块自身的指令;<code>TEXT</code>块中没有<code>fallthrough</code>。）在符号之后，参数是<code>标志</code>（见下面）和<code>栈帧</code>的大小，是一个常量（参见下面的代码）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·profileloop(SB),NOSPLIT,$8</span><br><span class="line">    MOVQ    $runtime·profileloop1(SB), CX</span><br><span class="line">    MOVQ    CX, 0(SP)</span><br><span class="line">    CALL    runtime·externalthreadhandler(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">这个函数的栈帧大小为8字节(MOVQ CX, 0(SP)操作栈指针)，没有参数</b></p>
<p>一般情况下，栈帧大小后面跟着一个由减号分隔的参数大小。（这不是一个减法，只是特殊的语法。）栈帧大小是<code>$24-8</code>描述该函数有一个24字节的栈帧，并且需要一个8个字节的参数，它位于调用者的栈帧上。如果没有为<code>TEXT</code>指定<code>NOSPLIT</code>标志，则必须提供参数大小。对于使用Go标准的汇编函数，<code>go vet</code>将检查参数大小是否正确。</p>
<p>请注意，符号名称使用中点分隔组件，并且被定义为从伪寄存器SB开始的一个offsets。在Go源码的runtime包中，使用简称profileloop来调用。</p>
<p>全局数据符号使用初始化的一系列<code>DATA</code>指令来定义，并且跟在一个<code>GLOBAL</code>指令之后。每个<code>DATA</code>指令初始化一块指定的内存区域。没有明确初始化的内存区域会被置为零。标准的<code>DATA</code>指令形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA	symbol+offset(SB)/width, value</span><br></pre></td></tr></table></figure></p>
<p>这样就初始化了symbol，内存在指定的offset处，带有指定的width和给定的value。一个symbol中的DATA指令必须是逐渐增长的offsets。</p>
<p><code>GLOBL</code>指令声明一个符号是全局的。参数是可选的标志和需要声明为全局的数据的大小，除非<code>DATA</code>指令已初始化它，否则初始值将全部为零。<code>GLOBAL</code>指令必须跟在对应的<code>DATA</code>指令之后。</p>
<p>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA divtab&lt;&gt;+0x00(SB)/4, $0xf4f8fcff</span><br><span class="line">DATA divtab&lt;&gt;+0x04(SB)/4, $0xe6eaedf0</span><br><span class="line">...</span><br><span class="line">DATA divtab&lt;&gt;+0x3c(SB)/4, $0x81828384</span><br><span class="line">GLOBL divtab&lt;&gt;(SB), RODATA, $64</span><br><span class="line"></span><br><span class="line">GLOBL runtime·tlsoffset(SB), NOPTR, $4</span><br></pre></td></tr></table></figure></p>
<p>声明并初始化<code>divtab&lt;&gt;</code>, 一个只读的64位<code>table</code>含有4字节的整数值。并声明<code>runtime·tlsoffset</code>一个4字节的，隐式地置零的变量，该变量不包含指针。</p>
<p>指令可能有一个或两个参数。如果有两个，第一个是比特掩码的标志，它可以写成数字表达式，多个掩码之间可以相加或者做逻辑或运算，或者可以写成友好可读的形式。这些值定义在头文件<code>textflag.h</code>中：</p>
<ul>
<li><code>NOPROF = 1</code> (TEXT项使用.) 不优化NOPROF标记的函数。这个标志已废弃。</li>
<li><code>DUPOK = 2</code> 在二进制文件中允许一个符号的多个实例。链接器会选择其中之一。</li>
<li><code>NOSPLIT = 4</code> (TEXT项使用.) 不插入预先检测是否将栈空间分裂的代码。程序的栈帧中，如果调用任何其他代码都会增加栈帧的大小，必须在栈顶留出可用空间。用来保护处理栈空间分裂的代码本身。</li>
<li><code>RODATA = 8</code> (DATA和GLOBAL项使用.) 将这个数据放在只读的块中。</li>
<li><code>NOPTR = 16</code> (DATA和GLOBAL项使用.)这个数据不包含指针所以就不需要垃圾收集器来扫描。</li>
<li><code>WRAPPER = 32</code> (TEXT项使用.) This is a wrapper function and should not count as disabling recover.</li>
<li><code>NEEDCTXT= 64</code> （对于TEXT项目。）这个函数是一个闭包，所以它使用它的传入上下文寄存器。</li>
</ul>
<h2 id="协调Runtime"><a href="#协调Runtime" class="headerlink" title="协调Runtime"></a>协调Runtime</h2><p>要使垃圾收集正确运行，运行时必须知道所有全局数据和大多数堆栈帧中指针的位置。Go编译器在编译Go源文件时会发出此信息，但汇编程序必须明确定义这些信息。</p>
<p>标有NOPTR标志的数据符号（见上面）被视为不包含指向Runtime分配数据的指针。带有<code>RODATA</code>标志的数据符号被分配在只读存储器中，因此被视为隐式标记<code>NOPTR</code>。总的大小小于指针大小的数据符号也被视为隐式标记<code>NOPTR</code>。无法在汇编语言中定义包含指针的符号; 这种符号必须在Go源文件中定义。汇编源文件仍然可以通过名称来引用符号，即使这个符号没有使用<code>DATA</code>和<code>GLOBL</code>指令也是如此。一个很好的通用规则是，在Go代码中定义非只读的数据，而不是在汇编程序中。</p>
<p>每个函数都需要注释，标明在其参数、返回结果和本地栈帧上给出活动指针的位置。如果汇编函数没有指针类型的结果并且没有本地栈帧，或者没有调用函数，唯一需要做的是为函数在同名的包中定义一个Go函数原型（例如，syscall包中的函数Syscall应该在其TEXT指令中使用名称·Syscall而不是等效名称syscall·Syscall）。在更复杂的情况下，需要明确的注释出。这些注释使用在头文件<code>funcdata.h</code>中定义的伪指令。</p>
<p>如果一个函数没有参数并且没有结果，指针信息可以省略。这可以通过在TEXT指令中使用参数大小<code>$n-0</code>指出。否则，指针信息必须由Go源文件中的Go原型函数提供，即使汇编函数不是直接被Go代码调用的。（原型还会使用<code>go vet</code>检查参数引用。）在函数的开头，参数都假设是已经被初始化的，但是函数的返回结果会假设是未初始化的。如果在执行CALL指令时，结果中HOLD住一个指针，函数应该在开头就将返回结果初始化为零值，并且接着执行伪指令<code>GO_RESULTS_INITIALIZED</code>。这个指令记录了当前返回结果已经被初始化，并且在当栈帧转移和垃圾收集的时候扫描返回结果。非常具有代表性的是会安排汇编函数不返回指针或者不包含任何CALL指令；在Go标准库中的汇编函数都没有使用<code>GO_RESULTS_INITIALIZED</code>。</p>
<p>如果函数没有本地堆栈帧，则可以省略指针信息。这可以通过在TEXT指令中使用栈帧大小$0-n指出。如果函数不包含<code>CALL</code>指令，指针信息也可以省略。否则，本地栈帧不能包含指针，汇编必须通过执行<code>NO_LOCAL_POINTERS</code>伪指令来确认这种情况。由于堆栈大小调整是通过移动堆栈来实现的，栈指针可能在函数调用的时候发生改变：即使指向堆栈数据的指针也不能保存在局部变量中。</p>
<p>汇编程序函数应该总是给出Go原型，以提供参数和结果的指针信息，并用<code>go vet</code>检查访问偏移量的偏移量是否正确。</p>
<h2 id="架构相关的细节"><a href="#架构相关的细节" class="headerlink" title="架构相关的细节"></a>架构相关的细节</h2><p>列出某种机器的全部指令和细节是不切实际的。如果要查看为特定机器定义了哪些指令，比如ARM，请查看该体系结构支持库的obj源代码，源码在<code>src/cmd/internal/obj/arm</code>目录中。在那个目录中是一个文件<code>a.out.go</code>; 它包含一长串以<code>A</code>开头的常量，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	AAND = obj.ABaseARM + obj.A_ARCHSPECIFIC + iota</span><br><span class="line">	AEOR</span><br><span class="line">	ASUB</span><br><span class="line">	ARSB</span><br><span class="line">	AADD</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<p>这是该架构的汇编器和链接器已知的指令及其拼写列表。该列表中的每条指令都以首字母<code>A</code>开始，因此<code>AAND</code>表示按位和指令 <code>AND</code>（不带前导A），并以<code>AND</code>写入汇编源代码。枚举主要按字母顺序排列。（<code>AXXX</code>体系结构无关，在<code>cmd/internal/obj</code>程序包中定义 ，代表无效指令）。这些A名称的顺序与机器指令的实际编码无关。<code>cmd/internal/obj</code>包负责处理这些细节。</p>
<p>有关386和AMD64体系结构的说明均已列入<code>cmd/internal/obj/x86/a.out.go</code>。</p>
<p>这些架构共享共同寻址模式的标签名，例如 <code>(R1)</code>（直接寄存器寻址）， <code>4(R1)</code>（寄存器间接偏移）和 <code>$foo(SB)</code>（绝对地址）。汇编器还支持每种体系结构特有的一些（不一定是全部）寻址模式。下面的部分列出了这些。</p>
<p>前面几部分示例中的一个细节是指令中的数据从左向右流动： <code>MOVQ $0, CX</code>清除<code>CX</code>。即使在某些架构上顺序是相反的，这种规则也是适用的。</p>
<p>这里有一些对于Go所指的架构的相关的细节的描述。</p>
<h3 id="32位英特尔386"><a href="#32位英特尔386" class="headerlink" title="32位英特尔386"></a>32位英特尔386</h3><p>指向g(goroutine)结构的Runtime指针通过MMU中其他未使用（就go而言）寄存器的值进行维护。如果源文件包含一个特别的头<code>go_asm.h</code>, 则为汇编程序定义一个与操作系统相关的宏<code>get_tls</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;go_asm.h&quot;</span><br></pre></td></tr></table></figure></p>
<p>runtime中，<code>get_tls</code>宏通过一个指向<code>g</code>指针的指针来加载它的参数寄存器，<code>g</code>结构包含<code>m</code>指针。加载<code>g</code>和<code>m</code>的序列使用<code>CX</code>，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_tls(CX)</span><br><span class="line">MOVL	g(CX), AX     // Move g into AX.</span><br><span class="line">MOVL	g_m(AX), BX   // Move g.m into BX.</span><br></pre></td></tr></table></figure></p>
<p>寻址模式：</p>
<ul>
<li><code>(DI)(BX*2)</code>：地址<code>DI</code>加上<code>BX*2</code>的位置。</li>
<li><code>64(DI)(BX*2)</code>：地址<code>DI</code>加上<code>BX*2</code>加上<code>64</code> 的位置。这些模式只接受1,2,4和8作为比例因子。</li>
</ul>
<p>在使用编译器和汇编程序的<code>-dynlink</code>或<code>-shared</code>模式时，固定内存位置任何加载或存储（如全局变量）必须假定重写<code>CX</code>。因此，为了安全使用这些模式，除了在内存引用之间外，汇编源码通常应避免使用<code>CX</code>。</p>
<h3 id="64位Intel-386（又名amd64）"><a href="#64位Intel-386（又名amd64）" class="headerlink" title="64位Intel 386（又名amd64）"></a>64位Intel 386（又名amd64）</h3><p>这两种体系结构在汇编程序级别上表现基本相同。访问 64位版本的<code>m</code>和<code>g</code>指针的汇编代码与32位386相同，只是它使用MOVQ而不是MOVL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_tls(CX)</span><br><span class="line">MOVQ	g(CX), AX     // Move g into AX.</span><br><span class="line">MOVQ	g_m(AX), BX   // Move g.m into BX.</span><br></pre></td></tr></table></figure></p>
<h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>寄存器<code>R10</code>和<code>R11</code> 由编译器和链接保留使用。</p>
<p><b style="color:red"><code>R10</code>指向<code>g</code>（<code>goroutine</code>）结构</b>。在汇编源代码中，这个指针必须被称为g; 名称<code>R10</code>不被识别。</p>
<p>为了让人们和编译器更容易地编写汇编代码，ARM链接器允许一般寻址形式和<code>DIV</code>或者<code>MOD</code>伪指令，这些伪指令使用单个硬件指令可能无法表达。它实现这些多条指令形式，通常使用<code>R11</code>寄存器来保存临时值。手写汇编可以使用<code>R11</code>，但这样做需要确保链接程序不会使用它来实现函数中的任何其他指令。</p>
<p>定义一个<code>TEXT</code>时，指定帧大小<code>$-4</code>告诉链接器，这是一个叶函数，不需要在Entry上保存<code>LR</code>。</p>
<p><code>SP</code>始终指向前面描述的虚拟堆栈指针。对于硬件寄存器，请使用<code>R13</code>。</p>
<p>条件码的语法是在指令中添加一个句点和一个或两个字母的代码，如下所示<code>MOVW.EQ</code>。可以附加多个代码：<code>MOVM.IA.W</code>。代码修饰符的顺序是无关紧要的。</p>
<p>寻址模式：</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0-&gt;16 </span><br><span class="line">R0&gt;&gt;16 </span><br><span class="line">R0&lt;&lt;16 </span><br><span class="line">R0@&gt;16：对于&lt;&lt;，左移16位的R0。其他代码是-&gt;（算术右移）， &gt;&gt;（逻辑右移）和 @&gt;（右旋）。</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0-&gt;R1 </span><br><span class="line">R0&gt;&gt;R1 </span><br><span class="line">R0&lt;&lt;R1 </span><br><span class="line">R0@&gt;R1：因为&lt;&lt;，R0计数在左移R1。其他代码是-&gt;（算术右移）， &gt;&gt;（逻辑右移）和 @&gt;（右旋）。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>[R0,g,R12-R15]</code>：对于多寄存器指令，该组包括 <code>R0</code>，<code>g</code>，和<code>R12</code>到<code>R15</code>。</p>
</li>
<li><code>(R5, R6)</code>：目的寄存器对。</li>
</ul>
<h3 id="ARM64"><a href="#ARM64" class="headerlink" title="ARM64"></a>ARM64</h3><p>ARM64端口处于实验状态。</p>
<p>指令修饰符附加到指令后的句点。只有修饰符P（后置）和W（前递增）： <code>MOVW.P</code>，<code>MOVW.W</code></p>
<p>寻址模式：</p>
<ul>
<li><code>(R5, R6)</code>：LDP/STP的寄存器对。</li>
</ul>
<h3 id="64位PowerPC，又名ppc64"><a href="#64位PowerPC，又名ppc64" class="headerlink" title="64位PowerPC，又名ppc64"></a>64位PowerPC，又名ppc64</h3><p>64位PowerPC端口处于试验状态。</p>
<p>寻址模式：</p>
<ul>
<li><code>(R5)(R6*1)</code>：<code>R5</code>加<code>R6</code>的位置。它是x86上的缩放模式，但是唯一允许的扩展是1。</li>
<li><code>(R5+R6)</code>：<code>(R5)(R6*1)</code>的别名</li>
</ul>
<h3 id="IBM-z-Architecture，又名s390x"><a href="#IBM-z-Architecture，又名s390x" class="headerlink" title="IBM z/Architecture，又名s390x"></a>IBM z/Architecture，又名s390x</h3><p>寄存器<code>R10</code>和<code>R11</code>保留。汇编程序在汇编某些指令时使用它们来保存临时值。</p>
<p><code>R13</code>指向<code>g</code>（goroutine）结构。这个寄存器必须被称为g; 名称<code>R13</code>不被识别。</p>
<p><code>R15</code>指向堆栈帧，通常只能使用虚拟寄存器<code>SP</code>和<code>FP</code>。</p>
<p>加载和存储多条指令在一系列寄存器上运行。寄存器范围由开始寄存器和结束寄存器指定。例如，<code>LMG(R9)</code>, <code>R5</code>, <code>R7</code>将加载<code>R5</code>，<code>R6</code>和<code>R7</code>与在64位值<code>0(R9)</code>，<code>8(R9)</code>和<code>16(R9)</code>分别。</p>
<p>存储和存储指令（如<code>MVC</code>和<code>XC</code>）的长度作为第一个参数写入。例如，<code>XC $8, (R9)</code>, (R9)将在指定的地址处清除R9中八个字节。</p>
<p>如果一个向量指令将长度或索引作为参数，那么它将成为第一个参数。例如，<code>VLEIF $1, $16, V2</code>将16个值加载到V2索引之一中。使用向量指令时应注意确保它们在运行时可用。要使用矢量指令，机器必须同时具有矢量功能（设施列表中的位129）和内核支持。如果没有内核支持，矢量指令将不起作用（它将相当于一条<code>NOP</code>指令）。</p>
<p>寻址模式：</p>
<ul>
<li><code>(R5)(R6*1)</code>：R5加R6的位置。它是x86上的缩放模式，但是唯一允许的尺寸是1。</li>
</ul>
<h3 id="MIPS，MIPS64"><a href="#MIPS，MIPS64" class="headerlink" title="MIPS，MIPS64"></a>MIPS，MIPS64</h3><p>通用寄存器被命名<code>R0</code>到<code>R31</code>，浮点寄存器<code>F0</code>到<code>F31</code>。</p>
<p><code>R30</code>保留指向g。 <code>R23</code>被用作临时寄存器。</p>
<p>在<code>TEXT</code>指令中，栈大小MIPS是<code>$-4</code>，对于MIPS64是<code>$-8</code>，指示链接器不保存LR。</p>
<p><code>SP</code>指的是虚拟堆栈指针。对于硬件寄存器，请使用<code>R29</code>。</p>
<p>寻址模式：</p>
<ul>
<li>16(R1)：位置在R1加16。</li>
<li>(R1)：别名0(R1)。</li>
</ul>
<p>GOMIPS的环境变量的值（<code>hardfloat</code>或 <code>softfloat</code>）由预先定义<code>GOMIPS_hardfloat</code>或<code>GOMIPS_softfloat</code>提供给汇编代码。</p>
<h3 id="不支持的操作码"><a href="#不支持的操作码" class="headerlink" title="不支持的操作码"></a>不支持的操作码</h3><p>汇编器旨在支持编译器，因此并非所有硬件指令都针对所有体系结构定义：如果编译器不生成它，它可能不在那里。如果您需要使用缺少的指令，有两种方法可以继续。</p>
<ul>
<li>一种是直接修改汇编程序以支持该指令，这是直接的，但只有在指令可能再次使用时才值得。</li>
<li>相反，对于简单的一次性修改案例，可以使用<code>BYTE</code> 和<code>WORD</code>指令将明确的数据放入<code>TEXT</code>的指令流中。以下是386运行时如何定义64位原子加载函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// uint64 atomicload64(uint64 volatile* addr);</span><br><span class="line">// so actually</span><br><span class="line">// void atomicload64(uint64 *res, uint64 volatile *addr);</span><br><span class="line">TEXT runtime·atomicload64(SB), NOSPLIT, $0-12</span><br><span class="line">	MOVL	ptr+0(FP), AX</span><br><span class="line">	TESTL	$7, AX</span><br><span class="line">	JZ	2(PC)</span><br><span class="line">	MOVL	0, AX // crash with nil ptr deref</span><br><span class="line">	LEAL	ret_lo+4(FP), BX</span><br><span class="line">	// MOVQ (%EAX), %MM0</span><br><span class="line">	BYTE $0x0f; BYTE $0x6f; BYTE $0x00</span><br><span class="line">	// MOVQ %MM0, 0(%EBX)</span><br><span class="line">	BYTE $0x0f; BYTE $0x7f; BYTE $0x03</span><br><span class="line">	// EMMS</span><br><span class="line">	BYTE $0x0F; BYTE $0x77</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想看一些具体的例子，可以查看<a href="https://www.bbsmax.com/A/l1dyrW0zem/" target="_blank" rel="noopener">Golang汇编命令解读</a></p>
<p>我在网上也找到了一个比较有意思的<a href="https://talks.golang.org/2016/asm.slide#1" target="_blank" rel="noopener">Go汇编设计</a>的介绍。</p>
<p>Also, <a href="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/" target="_blank" rel="noopener">here</a> is another blog about go assembly programming from Scott Mansfield.</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="https://golang.org/doc/asm#arm64" target="_blank" rel="noopener">A Quick Guide to Go’s Assembler</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/10/blockchain/OpenZeppelin文档说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/blockchain/OpenZeppelin文档说明/" itemprop="url">OpenZeppelin文档说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T21:12:42+08:00">2018-04-10</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是官方文档的翻译</p>
<h2 id="OpenZeppelin"><a href="#OpenZeppelin" class="headerlink" title="OpenZeppelin"></a>OpenZeppelin</h2><p>OpenZeppelin是在以太坊上安全编写<a href="https://en.wikipedia.org/wiki/Smart_contract" target="_blank" rel="noopener">智能合约</a>的库。</p>
<p>借助OpenZeppelin，你可以构建分布式应用程序、协议和组织：</p>
<ul>
<li>使用通用合约安全模式（请参阅<a href="/2018/03/17/blockchain/安全编写以太坊的智能合约指南/">安全编写以太坊的智能合约指南</a>）</li>
<li>在<a href="https://solidity.readthedocs.io/en/develop/" target="_blank" rel="noopener">solidity语言</a>上</li>
</ul>
<p>注：如果你是入门的智能合约开发者，请查看我们的<a href="/2018/03/18/blockchain/以太坊智能合同搭建简易指南/">入门指南</a>。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>OpenZeppelin旨在提供安全、经过测试和社区审核的代码，但在处理真钱时请使用常识！我们对您的实施决定以及您可能遇到的任何安全问题不承担任何责任。</p>
<p>如果您发现安全问题，请发送电子邮件至<a href="mailto:security@openzeppelin.org" target="_blank" rel="noopener">security@openzeppelin.org</a>。</p>
<h3 id="开发者资源"><a href="#开发者资源" class="headerlink" title="开发者资源"></a>开发者资源</h3><p>使用OpenZeppelin构建分布式应用程序，协议或组织？</p>
<ul>
<li>参阅指南：<a href="https://blog.zeppelin.solutions/guides/home" target="_blank" rel="noopener">https://blog.zeppelin.solutions/guides/home</a></li>
<li>寻求帮助，并关注进度：<a href="https://slack.openzeppelin.org" target="_blank" rel="noopener">https://slack.openzeppelin.org</a></li>
</ul>
<p>有兴趣对OpenZeppelin做贡献？</p>
<ul>
<li>框架提案和路线图：<a href="https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab" target="_blank" rel="noopener">https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab</a></li>
<li>问题追踪：<a href="https://github.com/OpenZeppelin/zeppelin-solidity/issues" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/issues</a></li>
<li>贡献指南：<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md</a></li>
<li>wiki：<a href="https://github.com/OpenZeppelin/zeppelin-solidity/wiki" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/wiki</a></li>
</ul>
<h3 id="OpenZeppelin合作组织和审计"><a href="#OpenZeppelin合作组织和审计" class="headerlink" title="OpenZeppelin合作组织和审计"></a>OpenZeppelin合作组织和审计</h3><ul>
<li><a href="https://golem.network/" target="_blank" rel="noopener">Golem</a></li>
<li><a href="http://www.mediachain.io/" target="_blank" rel="noopener">Mediachain</a></li>
<li><a href="http://truffleframework.com/" target="_blank" rel="noopener">Truffle</a></li>
<li><a href="https://firstblood.io/" target="_blank" rel="noopener">Firstblood</a></li>
<li><a href="https://www.rsk.co/" target="_blank" rel="noopener">Rootstock</a></li>
<li><a href="https://consensys.net/" target="_blank" rel="noopener">Consensys</a></li>
<li><a href="https://www.dgx.io/" target="_blank" rel="noopener">DigixGlobal</a></li>
<li><a href="https://coinfund.io/" target="_blank" rel="noopener">Coinfund</a></li>
<li><a href="https://democracy.earth/" target="_blank" rel="noopener">DemocracyEarth</a></li>
<li><a href="https://signatura.co/" target="_blank" rel="noopener">Signatura</a></li>
<li><a href="http://www.ether.camp/" target="_blank" rel="noopener">Ether.camp</a></li>
<li><a href="https://aragon.one/" target="_blank" rel="noopener">Aragon</a></li>
<li><a href="https://wings.ai/" target="_blank" rel="noopener">Wings</a></li>
</ul>
<p>among others…</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>根据<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/LICENSE" target="_blank" rel="noopener">MIT许可证</a>发布的代码</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>OpenZeppelin与Truffle集成，Truffle是以太坊开发环境。请安装Truffle并用<code>truffle init</code>初始化您的项目。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br><span class="line">mkdir myproject &amp;&amp; <span class="built_in">cd</span> myproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure></p>
<p>要安装OpenZeppelin库，在项目根目录下运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install -E zeppelin-solidity</span><br></pre></td></tr></table></figure></p>
<p><b>请注意，OpenZeppelin目前不遵循语义版本控制</b>。您可能会遇到轻微版本凹凸处的重大更改。我们建议不要改变您使用的OpenZeppelin版本，就像<code>-E（--save-exact）</code>选项一样。</p>
<p>之后，您在node_modules/zeppelin-solidity/contracts文件夹下获得的所有的库合约。你可以像这样使用库中的合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &apos;zeppelin-solidity/contracts/ownership/Ownable.sol&apos;;</span><br><span class="line"></span><br><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>在完成使用OpenZeppelin的智能合同开发的第一步之后，您可能需要查看涵盖几个常见使用案例和良好实践的指南：<a href="https://blog.zeppelin.solutions/guides/home" target="_blank" rel="noopener">https://blog.zeppelin.solutions/guides/home</a></p>
<p>例如，<a href="/2018/03/18/blockchain/以太坊智能合同搭建简易指南/">“以太坊智能合同搭便车指南”</a>将帮助您了解智能合同开发所需的各种工具，并设置您的环境。</p>
<p><a href="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094" target="_blank" rel="noopener">以太坊编程的基础介绍，第1部分</a>提供了介绍级的非常有用的信息，包括以太坊平台的许多基本概念。</p>
<p>要进行更深入的探索，您可以阅读<a href="https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317" target="_blank" rel="noopener">设计您的Ethereum应用程序架构指南</a>，其中讨论了如何更好地构建应用程序及其与现实世界的关系。</p>
<p>您也可以寻求帮助或关注OpenZeppelin在<a href="https://slack.openzeppelin.org/" target="_blank" rel="noopener">Slack</a>社区中的进展，或者阅读本网站上OpenZeppelin的完整API介绍。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/09/blockchain/truffle指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/blockchain/truffle指南/" itemprop="url">truffle指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T14:27:50+08:00">2018-04-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:blue">本文是truffle官方文档的翻译，不确定版本，但是看到truffle官方github的版本是4.1.15.</b></p>
<p>Truffle是一个世界级的开发环境，用于以太坊的测试框架和资产管道，旨在使以太坊开发人员的开发更轻松。truffle有以下的一些特性：</p>
<ul>
<li>内置智能合约编译，链接，部署和二进制管理。</li>
<li>用于快速开发的合约自动测试。</li>
<li>可编写脚本的可扩展部署和迁移框架。</li>
<li>用于部署到任意数量的公共和专用网络的网络管理。</li>
<li>使用ERC190标准，使用EthPM和NPM进行包装管理。</li>
<li>交互式控制台，用于直接与合约交互。</li>
<li>可配置的构建流水线，支持紧密集成。</li>
<li>外部脚本运行器，用于在Truffle环境中执行脚本。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure>
<p>最好使用node 5.0+，另外最好有一个打开json rpc api的以太坊节点。</p>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>对于那些刚刚开始使用的人，可通过<a href="http://truffleframework.com/boxes" target="_blank" rel="noopener">松露盒</a>获取许多样板和示例应用程序。</p>
<p>你可以从我们的MetaCoin例子开始，在命令行上运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir MetaCoin</span><br><span class="line">cd MetaCoin</span><br><span class="line">truffle unbox metacoin</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#c7254e">注意：MetaCoin松露项目过去是通过运行<code>truffle init</code>创建的。现在它作为松露盒存在。</b></p>
<p>您可以使用该<code>truffle unbox &lt;box-name&gt;</code>命令下载任何其他应用程序。</p>
<p>如果你想从头开始构建一个项目，可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir myproject</span><br><span class="line">cd myproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure></p>
<p>一旦完成，您现在将拥有包含以下项目的项目结构：</p>
<ul>
<li><code>contracts/</code>：<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">Solidity合同</a>目录</li>
<li><code>migrations/</code>：<a href="http://truffleframework.com/docs/getting_started/migrations#migration-files" target="_blank" rel="noopener">可编写脚本的部署文件的目录</a></li>
<li><code>test/</code>：用于<a href="http://truffleframework.com/docs/getting_started/testing" target="_blank" rel="noopener">测试您的应用程序和合约的</a>测试文件目录</li>
<li><code>truffle.js</code>：Truffle配置文件</li>
</ul>
<h2 id="选择以太坊客户端"><a href="#选择以太坊客户端" class="headerlink" title="选择以太坊客户端"></a>选择以太坊客户端</h2><p>有许多以太坊客户端可供选择。根据您是在开发还是部署，我们推荐不同的客户端。</p>
<h3 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h3><h4 id="Ganache"><a href="#Ganache" class="headerlink" title="Ganache"></a>Ganache</h4><p>我们建议您在桌面上运行Ethereum开发的个人区块链<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>。作为truffle套件的一部分，Ganache通过将合约和交易放在前面和中心处，简化了dapp的开发。使用Ganache，您可以快速看到应用程序如何影响区块链，并反馈到您的账户，余额，合约创建和gas成本等细节。您还可以对Ganache的高级采矿控制进行微调，以更好地满足您的需求。Ganache可用于Windows，Mac和Linux，您可以<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">在此下载</a>。</p>
<p>Ganache在启动时运行在<code>http://127.0.0.1:7545</code>。它将显示前10个帐户和用于创建这些帐户的助记符。（<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">阅读有关帐户助记符的更多信息</a>。）</p>
<p>默认情况下，Ganache将使用以下助记符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p>
<p>该助记符可以更改为随机生成，也可以输入自己的助记符。</p>
<p><b style="color:#c7254e">警告：请勿在以太网主网络（mainnet）上使用此助记符。如果您将ETH发送到由此助记符生成的任何帐户，您将失去所有！</b></p>
<h4 id="truffle开发"><a href="#truffle开发" class="headerlink" title="truffle开发"></a>truffle开发</h4><p>我们还建议使用Truffle Develop，一种直接构建在truffle中区块链。Truffle Develop可帮助您使用单个命令设置集成区块链环境，无需安装。通过在终端中键入以下命令即可开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure></p>
<p>这将运行客户端<code>http://127.0.0.1:9545</code>。它将显示前10个帐户和用于创建这些帐户的助记符。Truffle Develop每次都使用相同的助记符来尽可能简化开发应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p>
<p>一旦启动，Truffle Develop将为您提供一个控制台，您可以使用它来运行所有可用的truffle命令。这些命令是通过省略truffle前缀来输入的。</p>
<p>要了解更多关于与控制台交互的信息，请参阅<a href="http://truffleframework.com/docs/getting_started/console" target="_blank" rel="noopener">使用控制台</a>部分。</p>
<h4 id="GANACHE-CLI"><a href="#GANACHE-CLI" class="headerlink" title="GANACHE CLI"></a>GANACHE CLI</h4><p>Ganache还为那些在图形环境下工作的人提供了一个命令行界面。非常适合自动化测试和持续集成环境，Ganache CLI可以无人运行，可以配置为满足您的所有开发需求。Ganache CLI可以立即处理交易，而不是等待默认的区块时间，因此您可以快速测试您的代码是否可以工作。它还会在您的智能合约出现错误时立即告诉您，并直接与Truffle集成，以将测试运行时间与其他客户端相比降低90％。<a href="https://github.com/trufflesuite/ganache-cli/" target="_blank" rel="noopener">了解关于Ganache CLI的更多信息</a>。</p>
<h3 id="正式环境部署"><a href="#正式环境部署" class="headerlink" title="正式环境部署"></a>正式环境部署</h3><p>有许多官方和非官方的以太坊客户可供您使用。以下是一个简短列表：</p>
<ul>
<li>geth：<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum</a></li>
<li>WebThree（cpp-ethereum）：<a href="https://github.com/ethereum/cpp-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/cpp-ethereum</a></li>
<li>Parity： <a href="https://github.com/paritytech/parity" target="_blank" rel="noopener">https://github.com/paritytech/parity</a></li>
<li>More： <a href="https://www.ethereum.org/cli" target="_blank" rel="noopener">https://www.ethereum.org/cli</a></li>
</ul>
<h3 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h3><p><a href="https://zhuanlan.zhihu.com/p/29010231" target="_blank" rel="noopener">玩转以太坊(Ethereum)的测试网络</a></p>
<h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>所有的合同都位于您项目的contracts/目录中。<code>Migrations.sol</code>帮助部署合约。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure>
<p>第一次运行时，所有合同都将被编译。后续运行时，松露只会编译自上次编译以来已更改的合同。如果您想覆盖此行为，请使用该<code>--all</code>选项运行上述命令。</p>
<h3 id="构建结果"><a href="#构建结果" class="headerlink" title="构建结果"></a>构建结果</h3><p>您编译的结果将被放置在<code>build/contracts/</code>目录中. 这些文件是truffle内部使用，你不需要编辑。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>您可以使用Solidity的导入命令来声明合约依赖关系。truffle将按照正确的顺序编译合约，并确保将所有依赖关系发送给编译器。依赖性可以用两种方式指定：</p>
<h4 id="通过文件名导入依赖关系"><a href="#通过文件名导入依赖关系" class="headerlink" title="通过文件名导入依赖关系"></a>通过文件名导入依赖关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./AnotherContract.sol&quot;;</span><br></pre></td></tr></table></figure>
<p>这里<code>AnotherContract.sol</code>是相对于当前正在编写的合约的路径。</p>
<h4 id="从外部包导入合约"><a href="#从外部包导入合约" class="headerlink" title="从外部包导入合约"></a>从外部包导入合约</h4><p>Truffle支持通过<a href="http://truffleframework.com/docs/getting_started/packages-ethpm" target="_blank" rel="noopener">EthPM</a>和<a href="http://truffleframework.com/docs/getting_started/packages-npm" target="_blank" rel="noopener">NPM</a>安装的依赖项。要从依赖项导入合约，请使用以下语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;somepackage/SomeContract.sol&quot;;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>somepackage</code>表示通过EthPM或NPM安装的软件包，<code>SomeContract.sol</code>表示该软件包提供的Solidity 源文件。</p>
<h2 id="运行迁移"><a href="#运行迁移" class="headerlink" title="运行迁移"></a>运行迁移</h2><p>Migration是帮助您将合约部署到以太坊网络的JavaScript文件。这些文件负责暂存您的部署任务，并且这些文件是在您的部署需求随时间变化的前提下编写的。随着您的项目不断发展，您将创建新的迁移脚本以进一步推动区块链的发展。以前运行的迁移历史记录通过特定的Migrations合约记录在链上，详情如下。</p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle migrate</span><br></pre></td></tr></table></figure>
<p>这将运行位于项目<code>migrations</code>目录中的所有迁移。简而言之，迁移只是一组受管理的部署脚本。如果您的迁移先前已成功运行，<code>truffle migrate</code>则将从上次运行的迁移开始执行，仅运行新创建的迁移。如果不存在新的迁移，<code>truffle migrate</code>则根本不会执行任何操作。您可以使用该<code>--reset</code>选项从头开始运行所有迁移。对于本地测试，确保在执行<code>migrate</code>之前安装并运行测试区块链，例如<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>.</p>
<h3 id="迁移文件"><a href="#迁移文件" class="headerlink" title="迁移文件"></a>迁移文件</h3><p>一个简单的迁移文件如下所示：文件名：<code>4_example_migration.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var MyContract = artifacts.require(&quot;MyContract&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // deployment steps</span><br><span class="line">  deployer.deploy(MyContract);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请注意，文件名以数字为前缀，后缀为说明。需要编号的前缀才能记录迁移是否成功运行。后缀纯粹是为了人类的可读性和理解。</p>
<h4 id="ARTIFACTS-REQUIRE"><a href="#ARTIFACTS-REQUIRE" class="headerlink" title="ARTIFACTS.REQUIRE()"></a>ARTIFACTS.REQUIRE()</h4><p>在迁移开始时，我们告诉Truffle我们希望通过该<code>artifacts.require()</code>方法取得要进行交互的合约。此方法与Node的<code>require</code>类似，但在我们的情况，它特别返回了我们可以在我们的部署脚本的其余部分中使用的合约抽象。指定的名称应与该源文件中的合约定义的名称相匹配。不要传递源文件的名称，因为文件可以包含多个合同。</p>
<h4 id="MODULE-EXPORTS"><a href="#MODULE-EXPORTS" class="headerlink" title="MODULE.EXPORTS"></a>MODULE.EXPORTS</h4><p>所有的迁移必须通过<code>module.exports</code>语法导出一个函数。每个迁移导出的函数应接受一个<code>deployer</code>对象作为其第一个参数。该对象通过为部署智能合约提供清晰的语法以及执行一些部署的更普通的职责（如保存部署的工件供以后使用）来帮助部署。该<code>deployer</code>对象是用于暂存部署任务的主接口，其页面底部介绍了其API。</p>
<p>您的迁移函数也可以接受其他参数。看下面的例子。</p>
<h3 id="初始化迁移"><a href="#初始化迁移" class="headerlink" title="初始化迁移"></a>初始化迁移</h3><p>truffle需要您拥有迁移合约才能使用迁移功能。此合约必须包含特定的接口，但您可以随意编辑此合约。对于大多数项目而言，此合约最初将作为第一次迁移进行部署，不会再进行更新。在创建新项目时，您通过<code>truffle init</code>还将默认收到此合约。</p>
<p>文件名：<code>contracts/Migrations.sol</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.8;</span><br><span class="line"></span><br><span class="line">contract Migrations &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  // A function with the signature `last_completed_migration()`, returning a uint, is required.</span><br><span class="line">  uint public last_completed_migration;</span><br><span class="line"></span><br><span class="line">  modifier restricted() &#123;</span><br><span class="line">    if (msg.sender == owner) _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Migrations() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // A function with the signature `setCompleted(uint)` is required.</span><br><span class="line">  function setCompleted(uint completed) restricted &#123;</span><br><span class="line">    last_completed_migration = completed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function upgrade(address new_address) restricted &#123;</span><br><span class="line">    Migrations upgraded = Migrations(new_address);</span><br><span class="line">    upgraded.setCompleted(last_completed_migration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>您必须在第一次迁移中部署此合约才能利用迁移功能。为此，请创建以下迁移：<code>migrations/1_initial_migration.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Migrations = artifacts.require(&quot;Migrations&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Deploy the Migrations contract as our only task</span><br><span class="line">  deployer.deploy(Migrations);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从这里，您可以使用增加的编号前缀创建新的迁移，以部署其他合约并执行进一步的部署步骤。</p>
<h3 id="DEPLOYER"><a href="#DEPLOYER" class="headerlink" title="DEPLOYER"></a>DEPLOYER</h3><p>您的迁移文件将使用部署者来部署部署任务。因此，您可以同步编写部署任务，并按正确的顺序执行它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Stage deploying A before B</span><br><span class="line">deployer.deploy(A);</span><br><span class="line">deployer.deploy(B);</span><br></pre></td></tr></table></figure></p>
<p>或者，可以将部署者上的每个功能用作Promise，以排队依赖于前一个任务执行的部署任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Deploy A, then deploy B, passing in A&apos;s newly deployed address</span><br><span class="line">deployer.deploy(A).then(function() &#123;</span><br><span class="line">  return deployer.deploy(B, A.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="网络考虑"><a href="#网络考虑" class="headerlink" title="网络考虑"></a>网络考虑</h3><p>可以根据部署到的网络有条件地运行部署步骤。这是一项高级功能，因此请先参阅<a href="http://truffleframework.com/docs/advanced/networks" target="_blank" rel="noopener">网络</a>部分，然后再继续。</p>
<p>要有条件有步骤地部署，请编写您的迁移，以便他们接受名为的第二个参数<code>network</code>。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(deployer, network) &#123;</span><br><span class="line">  if (network == &quot;live&quot;) &#123;</span><br><span class="line">    // Do something specific to the network named &quot;live&quot;.</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Perform a different step otherwise.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可用的账户"><a href="#可用的账户" class="headerlink" title="可用的账户"></a>可用的账户</h3><p>迁移还会通过您的以太坊客户端和web3提供商提供给您的帐户列表，供您在部署期间使用。这与<code>web3.eth.getAccounts()</code>从中返回的帐户完全相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(deployer, network, accounts) &#123;</span><br><span class="line">  // Use the accounts within your migrations.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DEPLOYER-API"><a href="#DEPLOYER-API" class="headerlink" title="DEPLOYER API"></a>DEPLOYER API</h3><p>Deployer包含许多可用于简化迁移的功能。</p>
<h4 id="DEPLOYER-DEPLOY-CONTRACT-ARGS…-OPTIONS"><a href="#DEPLOYER-DEPLOY-CONTRACT-ARGS…-OPTIONS" class="headerlink" title="DEPLOYER.DEPLOY(CONTRACT, ARGS…, OPTIONS)"></a>DEPLOYER.DEPLOY(CONTRACT, ARGS…, OPTIONS)</h4><p>使用可选的构造函数参数部署合约对象指定的特定合约。这对于单个合约很有用，因此您的dapp只有一份此合约的实例。这将在部署之后设置合约的地址（即，<code>Contract.address</code>将等于新部署的地址），并且它将覆盖任何先前存储的地址。</p>
<p>您可以选择传递一组合约或一组数组，以加速部署多个合约。此外，最后一个参数是一个可选对象，可以包含指定的键<code>overwrite</code>以及其他交易参数（如<code>gas</code>和<code>from</code>）。如果<code>overwrite</code>设置为<code>false</code>，则Deployer将不会部署此合约（如果已部署）。这对于某些合约地址由外部依赖项提供的情况很有用。</p>
<p>请注意，在调用<code>deploy</code>之前，您需要首先部署和链接您的合约所依赖的任何库。有关link更多详细信息，请参阅以下功能.</p>
<p>欲了解更多信息，请参阅<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle-contract</a>文档。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Deploy a single contract without constructor arguments</span><br><span class="line">deployer.deploy(A);</span><br><span class="line"></span><br><span class="line">// Deploy a single contract with constructor arguments</span><br><span class="line">deployer.deploy(A, arg1, arg2, ...);</span><br><span class="line"></span><br><span class="line">// Don&apos;t deploy this contract if it has already been deployed</span><br><span class="line">deployer.deploy(A, &#123;overwrite: false&#125;);</span><br><span class="line"></span><br><span class="line">// Set a maximum amount of gas and `from` address for the deployment</span><br><span class="line">deployer.deploy(A, &#123;gas: 4612388, from: &quot;0x....&quot;&#125;);</span><br><span class="line"></span><br><span class="line">// Deploy multiple contracts, some with arguments and some without.</span><br><span class="line">// This is quicker than writing three `deployer.deploy()` statements as the deployer</span><br><span class="line">// can perform the deployment as a single batched request.</span><br><span class="line">deployer.deploy([</span><br><span class="line">  [A, arg1, arg2, ...],</span><br><span class="line">  B,</span><br><span class="line">  [C, arg1]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// External dependency example:</span><br><span class="line">//</span><br><span class="line">// For this example, our dependency provides an address when we&apos;re deploying to the</span><br><span class="line">// live network, but not for any other networks like testing and development.</span><br><span class="line">// When we&apos;re deploying to the live network we want it to use that address, but in</span><br><span class="line">// testing and development we need to deploy a version of our own. Instead of writing</span><br><span class="line">// a bunch of conditionals, we can simply use the `overwrite` key.</span><br><span class="line">deployer.deploy(SomeDependency, &#123;overwrite: false&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="DEPLOYER-LINK-LIBRARY-DESTINATIONS"><a href="#DEPLOYER-LINK-LIBRARY-DESTINATIONS" class="headerlink" title="DEPLOYER.LINK(LIBRARY, DESTINATIONS)"></a>DEPLOYER.LINK(LIBRARY, DESTINATIONS)</h4><p>将已部署的库链接到合约或多个合约。<code>destinations</code>可以是单个合约或多个合约的数组。如果<code>destinations</code>的任何合约不依赖于链接的库，则合约将被忽略。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Deploy library LibA, then link LibA to contract B, then deploy B.</span><br><span class="line">deployer.deploy(LibA);</span><br><span class="line">deployer.link(LibA, B);</span><br><span class="line">deployer.deploy(B);</span><br><span class="line"></span><br><span class="line">// Link LibA to many contracts</span><br><span class="line">deployer.link(LibA, [B, C, D]);</span><br></pre></td></tr></table></figure></p>
<h4 id="DEPLOYER-THEN-FUNCTION-…"><a href="#DEPLOYER-THEN-FUNCTION-…" class="headerlink" title="DEPLOYER.THEN(FUNCTION() {…})"></a>DEPLOYER.THEN(FUNCTION() {…})</h4><p>就像承诺一样，运行一个任意的部署步骤。在您的迁移过程中使用它来调用特定合同的函数来添加、编辑和重新组织合约数据。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a, b;</span><br><span class="line">deployer.then(function() &#123;</span><br><span class="line">  // Create a new version of A</span><br><span class="line">  return A.new();</span><br><span class="line">&#125;).then(function(instance) &#123;</span><br><span class="line">  a = instance;</span><br><span class="line">  // Get the deployed instance of B</span><br><span class="line">  return B.deployed();</span><br><span class="line">&#125;).then(function(instance) &#123;</span><br><span class="line">  b = instance;</span><br><span class="line">  // Set the new instance of A&apos;s address on B via B&apos;s setA() function.</span><br><span class="line">  return b.setA(a.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="测试你的合约"><a href="#测试你的合约" class="headerlink" title="测试你的合约"></a>测试你的合约</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>truffle配置了自动化测试框架，可以轻松测试你的合约。这个框架可以让你用两种不同的方式编写简单且易于管理的测试：</p>
<ul>
<li>在<a href="http://truffleframework.com/docs/getting_started/javascript-tests" target="_blank" rel="noopener">JavaScript中</a>，用于运行来自外部世界的合约，就像您的应用程序一样。</li>
<li>在<a href="http://truffleframework.com/docs/getting_started/solidity-tests" target="_blank" rel="noopener">Solidity</a>中，高级特性，在公开的场景中行使您的合约。</li>
</ul>
<p>两种类型的测试都有其优点和缺点。请参阅接下来的两节来讨论。</p>
<h3 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h3><p>所有测试文件应位于<code>./test</code>目录中。truffle将只与下列扩展名的文件运行测试文件：<code>.js</code>，<code>.es</code>，<code>.es6</code>，<code>.jsx</code>和<code>.sol</code>。所有其他文件都被忽略。</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test</span><br></pre></td></tr></table></figure>
<p>或者，您可以运行指定路径的文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test ./path/to/test/file.js</span><br></pre></td></tr></table></figure></p>
<h3 id="清空环境"><a href="#清空环境" class="headerlink" title="清空环境"></a>清空环境</h3><p>运行测试文件时，truffle提供了一个无尘室环境。在针对<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>或Truffle Develop 运行测试时，Truffle将使用高级快照功能来确保您的测试文件不会彼此共享状态。当与其他以太坊客户一起运行时，Truffle将在每个测试文件开始时重新部署所有迁移，以确保您拥有一组新的测试合约。</p>
<h3 id="速度和可靠性考虑"><a href="#速度和可靠性考虑" class="headerlink" title="速度和可靠性考虑"></a>速度和可靠性考虑</h3><p>运行自动化测试时，Ganache和Truffle Develop比其他客户快得多。此外，它们还包含Truffle利用其特殊功能将测试运行时间提高近90％。作为一个通用的工作流程，我们建议您在正常开发和测试过程中使用Ganache或Truffle Develop，然后在您准备部署到现场或生产网络时，针对以太坊或其他官方Ethereum客户端运行一次测试。</p>
<h2 id="在JavaScript中编写测试"><a href="#在JavaScript中编写测试" class="headerlink" title="在JavaScript中编写测试"></a>在JavaScript中编写测试</h2><p>Truffle使用<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>测试框架和<a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a>进行断言，为您提供一个可编写JavaScript测试的可靠框架。让我们深入了解Truffle如何在Mocha上建立轻松您的合同的测试。</p>
<p><b style="color:#6ab0de">注意：如果您不熟悉在Mocha中编写单元测试，请在继续之前参阅<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha的文档</a>。</b></p>
<h3 id="使用CONTRACT-取代DESCRIBE"><a href="#使用CONTRACT-取代DESCRIBE" class="headerlink" title="使用CONTRACT()取代DESCRIBE()"></a>使用CONTRACT()取代DESCRIBE()</h3><p>在结构上，你的测试应该与Mocha的测试基本保持不变：你的测试应该存在于<code>./test</code>目录中，它们应该以<code>.js</code>扩展名结尾，并且它们应该包含Mocha将认为是自动化测试的代码。什么使truffle测试不同于Mocha的测试是<code>contract()</code>函数：该函数的工作原理与<code>describe()</code>相同，只是没有Truffle无尘室功能。它是这样工作的：</p>
<ul>
<li>在每个<code>contract()</code>函数运行之前，您的合约将重新部署到正在运行的以太坊客户端，以便其中的测试以干净的合约状态运行。</li>
<li>该<code>contract()</code>函数提供了您的以太坊客户端提供的账户列表，您可以使用它来编写测试。</li>
</ul>
<p><b style="color:#6ab0de">由于Truffle在发动机罩下使用了Mocha，因此<code>describe()</code>只要不需要松露清洁室功能，您仍然可以使用它来运行正常的Mocha测试。</b></p>
<h3 id="在测试中使用合约抽象"><a href="#在测试中使用合约抽象" class="headerlink" title="在测试中使用合约抽象"></a>在测试中使用合约抽象</h3><p>合约抽象是通过JavaScript实现合约交互的基础（它们基本上就是我们的助熔电容器）。由于truffle无法检测到在测试中需要与哪些合约进行交互，因此您需要明确要求这些合约。您可以通过使用<code>artifacts.require()</code>方法来做到这一点，该方法是由Truffle提供的一种方法，允许您为特定的Solidity合约请求可用的合约抽象。正如你在下面的例子中看到的那样，你可以使用这个抽象来确保你的合约正常工作。</p>
<p>有关使用合同抽象的更多信息，请参阅<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">与您的合同交互</a>一节。</p>
<h3 id="使用ARTIFACTS-REQUIRE"><a href="#使用ARTIFACTS-REQUIRE" class="headerlink" title="使用ARTIFACTS.REQUIRE()"></a>使用ARTIFACTS.REQUIRE()</h3><p>测试中使用<code>artifacts.require()</code>的工作方式与您在迁移中使用它是一样的; 你只需要通过合约的名称。有关详细用法，请参阅<a href="http://truffleframework.com/docs/getting_started/migrations#artifacts-require-" target="_blank" rel="noopener">artifacts.require()</a>的文档。</p>
<h3 id="使用web3"><a href="#使用web3" class="headerlink" title="使用web3"></a>使用web3</h3><p>每个测试文件都有一个<code>web3</code>实例，配置为正确的提供者。所以调用<code>web3.eth.getBalance</code>就行了！</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="使用-THEN"><a href="#使用-THEN" class="headerlink" title="使用.THEN"></a>使用<code>.THEN</code></h4><p>这是<a href="http://truffleframework.com/boxes/metacoin" target="_blank" rel="noopener">MetaCoin Truffle Box</a>中提供的一个示例测试。请注意使用该<code>contract()</code>函数，该<code>accounts</code>数组用于指定可用的以太坊帐户，以及我们使用<code>artifacts.require()</code>直接与我们的合同进行交互。</p>
<p>文件：<code>./test/metacoin.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">var MetaCoin = artifacts.require(&quot;./MetaCoin.sol&quot;);</span><br><span class="line"></span><br><span class="line">contract(&apos;MetaCoin&apos;, function(accounts) &#123;</span><br><span class="line">  it(&quot;should put 10000 MetaCoin in the first account&quot;, function() &#123;</span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      return instance.getBalance.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      assert.equal(balance.valueOf(), 10000, &quot;10000 wasn&apos;t in the first account&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should call a function that depends on a linked library&quot;, function() &#123;</span><br><span class="line">    var meta;</span><br><span class="line">    var metaCoinBalance;</span><br><span class="line">    var metaCoinEthBalance;</span><br><span class="line"></span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      return meta.getBalance.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(outCoinBalance) &#123;</span><br><span class="line">      metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">      return meta.getBalanceInEth.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(outCoinBalanceEth) &#123;</span><br><span class="line">      metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">      assert.equal(metaCoinEthBalance, 2 * metaCoinBalance, &quot;Library function returned unexpected function, linkage may be broken&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should send coin correctly&quot;, function() &#123;</span><br><span class="line">    var meta;</span><br><span class="line"></span><br><span class="line">    // Get initial balances of first and second account.</span><br><span class="line">    var account_one = accounts[0];</span><br><span class="line">    var account_two = accounts[1];</span><br><span class="line"></span><br><span class="line">    var account_one_starting_balance;</span><br><span class="line">    var account_two_starting_balance;</span><br><span class="line">    var account_one_ending_balance;</span><br><span class="line">    var account_two_ending_balance;</span><br><span class="line"></span><br><span class="line">    var amount = 10;</span><br><span class="line"></span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      return meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_one_starting_balance = balance.toNumber();</span><br><span class="line">      return meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_two_starting_balance = balance.toNumber();</span><br><span class="line">      return meta.sendCoin(account_two, amount, &#123;from: account_one&#125;);</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">      return meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_one_ending_balance = balance.toNumber();</span><br><span class="line">      return meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&apos;t correctly taken from the sender&quot;);</span><br><span class="line">      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&apos;t correctly sent to the receiver&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个测试会输出下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Contract: MetaCoin</span><br><span class="line">  √ should put 10000 MetaCoin in the first account (83ms)</span><br><span class="line">  √ should call a function that depends on a linked library (43ms)</span><br><span class="line">  √ should send coin correctly (122ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 passing (293ms)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ASYNC-AWAIT"><a href="#使用ASYNC-AWAIT" class="headerlink" title="使用ASYNC/AWAIT"></a>使用ASYNC/AWAIT</h3><p>这里是一个相似的实例，但是是使用<a href="https://javascript.info/async-await" target="_blank" rel="noopener">async/await</a>符号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const MetaCoin = artifacts.require(&quot;MetaCoin&quot;);</span><br><span class="line"></span><br><span class="line">contract(&apos;2nd MetaCoin test&apos;, async (accounts) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;should put 10000 MetaCoin in the first account&quot;, async () =&gt; &#123;</span><br><span class="line">     let instance = await MetaCoin.deployed();</span><br><span class="line">     let balance = await instance.getBalance.call(accounts[0]);</span><br><span class="line">     assert.equal(balance.valueOf(), 10000);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(&quot;should call a function that depends on a linked library&quot;, async () =&gt; &#123;</span><br><span class="line">    let meta = await MetaCoin.deployed();</span><br><span class="line">    let outCoinBalance = await meta.getBalance.call(accounts[0]);</span><br><span class="line">    let metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">    let outCoinBalanceEth = await meta.getBalanceInEth.call(accounts[0]);</span><br><span class="line">    let metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    assert.equal(metaCoinEthBalance, 2 * metaCoinBalance);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should send coin correctly&quot;, async () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // Get initial balances of first and second account.</span><br><span class="line">    let account_one = accounts[0];</span><br><span class="line">    let account_two = accounts[1];</span><br><span class="line"></span><br><span class="line">    let amount = 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let instance = await MetaCoin.deployed();</span><br><span class="line">    let meta = instance;</span><br><span class="line"></span><br><span class="line">    let balance = await meta.getBalance.call(account_one);</span><br><span class="line">    let account_one_starting_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_two);</span><br><span class="line">    let account_two_starting_balance = balance.toNumber();</span><br><span class="line">    await meta.sendCoin(account_two, amount, &#123;from: account_one&#125;);</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_one);</span><br><span class="line">    let account_one_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_two);</span><br><span class="line">    let account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&apos;t correctly taken from the sender&quot;);</span><br><span class="line">    assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&apos;t correctly sent to the receiver&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这个测试将产生与前面例子相同的输出。</p>
<h3 id="指定测试"><a href="#指定测试" class="headerlink" title="指定测试"></a>指定测试</h3><p>您可以限制特定文件执行的测试，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle test ./test/metacoin.js</span><br></pre></td></tr></table></figure></p>
<p>有关更多信息，请参阅完整的<a href="http://truffleframework.com/docs/advanced/commands#test" target="_blank" rel="noopener">命令</a>参考。</p>
<h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>truffle可以让你访问Mocha的配置，这样你就可以改变Mocha的行为方式。请参阅<a href="http://truffleframework.com/docs/advanced/configuration#mocha" target="_blank" rel="noopener">项目配置</a>部分了解更多详情。</p>
<h2 id="在SOLIDITY中编写测试"><a href="#在SOLIDITY中编写测试" class="headerlink" title="在SOLIDITY中编写测试"></a>在SOLIDITY中编写测试</h2><p>solidity测试合约与Javascript测试一起作为<code>.sol</code>文件存在。当<code>truffle test</code>运行时，它们将被包括作为每个测试合约单独的测试套件。这些合约保留了Javascript测试的所有好处：即每个测试套件都有一个<a href="http://truffleframework.com/docs/getting_started/testing#clean-room-environment" target="_blank" rel="noopener">洁净室环境</a>，可直接访问已部署的合约以及导入任何合约依赖关系的能力。除了这些特性外，Truffle的Solidity测试框架的构建还考虑到以下问题：</p>
<ul>
<li>solidity测试不应该来自任何合约（如Test合约）。这使您的测试尽可能最小化，并让您完全控制您编写的合约。</li>
<li>solidity测试不应受任何断言库的影响。truffle为您提供了一个默认的断言库，但您可以随时更改此库以符合您的需求。</li>
<li>您应该能够针对任何Ethereum客户端运行您的Solidity测试。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在深入探索之前，我们来看一个示例Solidity测试。以下是通过<code>truffle unbox metacoin</code>为您提供的示例Solidity测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;</span><br><span class="line">import &quot;../contracts/MetaCoin.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestMetacoin &#123;</span><br><span class="line">  function testInitialBalanceUsingDeployedContract() &#123;</span><br><span class="line">    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());</span><br><span class="line"></span><br><span class="line">    uint expected = 10000;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testInitialBalanceWithNewMetaCoin() &#123;</span><br><span class="line">    MetaCoin meta = new MetaCoin();</span><br><span class="line"></span><br><span class="line">    uint expected = 10000;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test</span><br><span class="line">Compiling ConvertLib.sol...</span><br><span class="line">Compiling MetaCoin.sol...</span><br><span class="line">Compiling truffle/Assert.sol</span><br><span class="line">Compiling truffle/DeployedAddresses.sol</span><br><span class="line">Compiling ../test/TestMetacoin.sol...</span><br><span class="line"></span><br><span class="line">  TestMetacoin</span><br><span class="line">    ✓ testInitialBalanceUsingDeployedContract (61ms)</span><br><span class="line">    ✓ testInitialBalanceWithNewMetaCoin (69ms)</span><br><span class="line"></span><br><span class="line">  2 passing (3s)</span><br></pre></td></tr></table></figure></p>
<h3 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h3><p>为了更好地理解发生了什么，让我们更详细地讨论一些事情。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>您的断言功能就像<code>Assert.equal()</code>通过<code>truffle/Assert.sol</code>库提供给你。这是默认的断言库，但是只要库通过触发正确的断言事件而松散地与Truffle的测试运行器集成，就可以包含自己的断言库。你可以在<a href="https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol" target="_blank" rel="noopener">Assert.sol</a>中找到所有可用的断言函数。</p>
<h4 id="部署的地址"><a href="#部署的地址" class="headerlink" title="部署的地址"></a>部署的地址</h4><p>您部署的合约的地址（即作为迁移一部分部署的合约）可通过<code>truffle/DeployedAddresses.sol</code>库获得。这是由Truffle提供的，并且在每个套件运行之前重新编译并重新链接，以便为您的测试提供Truffle的洁净室环境。该库为所有已部署的合约提供函数，形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeployedAddresses.&lt;contract name&gt;();</span><br></pre></td></tr></table></figure></p>
<p>这将返回一个地址，然后您可以使用该地址访问该合约。请参阅上面的示例测试了解使用情况。</p>
<p>为了使用已部署的合约，您必须将合约代码导入到测试套件中。注意示例中的<code>import &quot;../contracts/MetaCoin.sol&quot;;</code>。此导入与<code>./test</code>目录中存在的测试合约相关，并且它位于测试目录之外以便查找MetaCoin合约。然后它使用该合约将该地址转换为<code>MetaCoin</code>类型。</p>
<h3 id="测试合约名称"><a href="#测试合约名称" class="headerlink" title="测试合约名称"></a>测试合约名称</h3><p>所有测试合同必须<code>Test</code>开头，<code>t</code>为大写字母<code>T</code>。这与测试助手和项目合约（即被测合约）区别开来，让测试运行人员知道哪些合约代表测试套件。</p>
<h3 id="测试函数的名称"><a href="#测试函数的名称" class="headerlink" title="测试函数的名称"></a>测试函数的名称</h3><p>与测试合约名称一样，所有测试函数都必须以test小写字母开头。每个测试函数都按单个交易执行，按测试文件中的指定顺序（如Javascript测试）执行。由<code>truffle/Assert.sol</code>测试运行程序评估以确定测试结果的触发事件提供的断言函数。断言函数返回一个表示断言结果的布尔值，您可以使用它来尽早从测试中返回以防止执行错误（例如，<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>或Truffle Develop将会公开的错误）。</p>
<h3 id="Before-After钩子"><a href="#Before-After钩子" class="headerlink" title="Before/After钩子"></a>Before/After钩子</h3><p>提供了许多测试钩子，如下例所示。这些钩子是<code>beforeAll</code>，<code>beforeEach</code>，<code>afterAll</code>和<code>afterEach</code>;你的Javascript测试中由Mocha提供的相同钩子。您可以使用这些钩子在每次测试之前和之后，或每个套件运行之前和之后执行设置和拆卸操作。像测试函数一样，每个钩子都作为单个交易执行。请注意，一些复杂的测试需要执行大量的设置，这可能会溢出单个交易的gas限制; 您可以通过创建具有不同后缀的多个钩子来解决此限制，如下例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestHooks &#123;</span><br><span class="line">  uint someValue;</span><br><span class="line"></span><br><span class="line">  function beforeEach() &#123;</span><br><span class="line">    someValue = 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function beforeEachAgain() &#123;</span><br><span class="line">    someValue += 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testSomeValueIsSix() &#123;</span><br><span class="line">    uint expected = 6;</span><br><span class="line"></span><br><span class="line">    Assert.equal(someValue, expected, &quot;someValue should have been 6&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该测试合约还显示您的测试函数和钩子函数都共享相同的合约状态。您可以在测试之前设置合约数据，在测试过程中使用该数据，然后重新设置数据以便下一个测试。请注意，就像您的Javascript测试一样，您的下一个测试函数将从之前运行的测试函数的状态继续。</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>Solidity测试具有一些高级功能，可以让您测试Solidity中的特定用例。</p>
<h4 id="测试例外情况"><a href="#测试例外情况" class="headerlink" title="测试例外情况"></a>测试例外情况</h4><p>您可以轻松测试您的合同是否应该引发异常（例如，针对<code>require()</code>/ <code>assert()</code>/ <code>revert()</code>语句; 以前版本的Solidity会<code>throw</code>）。</p>
<p>这个主题首先由作者Simon de la Rouviere在他的教程“<a href="http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests" target="_blank" rel="noopener">松露固体测试中的投掷测试</a>”中撰写。N.B.的教程中大量使用通过过时的关键字<code>throw</code>,，从Solidity v0.4.13开始, 取而代之的是<code>revert()</code>，<code>require()</code>和<code>assert()</code>。</p>
<h4 id="测试以太网交易"><a href="#测试以太网交易" class="headerlink" title="测试以太网交易"></a>测试以太网交易</h4><p>您还可以测试您的合同如何对接收Ether做出反应，并在Solidity中编写该交互的脚本。要做到这一点，你的Solidity测试应该有一个返回一个uint叫做<code>initialBalance</code>的公共函数。这可以直接写成函数或公共变量，如下所示。当您的测试合同被部署到网络中时，truffle会向您的测试合同的测试账户中的发送这一数量的以太币。然后，您的测试合约可以使用该以太网币来与您的合约测试中的以太网交互。请注意，这<code>initialBalance</code>是可选的，不是必需的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;</span><br><span class="line">import &quot;../contracts/MyContract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestContract &#123;</span><br><span class="line">  // Truffle will send the TestContract one Ether after deploying the contract.</span><br><span class="line">  uint public initialBalance = 1 ether;</span><br><span class="line"></span><br><span class="line">  function testInitialBalanceUsingDeployedContract() &#123;</span><br><span class="line">    MyContract myContract = MyContract(DeployedAddresses.MyContract());</span><br><span class="line"></span><br><span class="line">    // perform an action which sends value to myContract, then assert.</span><br><span class="line">    myContract.send(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function () &#123;</span><br><span class="line">    // This will NOT be executed when Ether is sent. \o/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，Truffle向你的账户发送以太币，但是不会执行fallback函数，因此您仍然可以在您的Solidity测试中使用fallback函数进行高级测试用例。</p>
<h2 id="与你的合约交互"><a href="#与你的合约交互" class="headerlink" title="与你的合约交互"></a>与你的合约交互</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>如果您为了与您的合约进行交互而自己向以太坊网络写入原始请求，您很快就会意识到编写这些请求非常笨重和麻烦。同样，你可能会发现管理状态的每个请求都很复杂。幸运的是，truffle为您处理这一复杂问题，轻松与您的合约进行互动。</p>
<h3 id="读取和写入数据"><a href="#读取和写入数据" class="headerlink" title="读取和写入数据"></a>读取和写入数据</h3><p>以太坊网络区分了将数据写入网络和从中读取数据的区别，这种区别在您编写应用程序的方式中起着重要作用。一般来说，写入数据称为交易（Transaction），而读取数据称为调用（call）。事务和调用的处理方式非常不同，并具有以下特征。</p>
<h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>交易从根本上改变了网络的状态。交易可以像发送以太币到其他账户一样简单，或像执行合约函数或向网络添加新合约一样复杂。交易的定义特征是它写入（或更改）数据。交易使Ether运行成为“gas”，交易需要时间来处理。当您通过交易执行合约的函数时，您不能立即处理该交易，因此无法接收该函数的返回值。一般来说，意图通过交易执行的函数不会返回值; 他们将会返回一个交易ID。所以总之，交易：</p>
<ul>
<li>成本gas（以太币）</li>
<li>改变网络的状态</li>
<li>不会立即处理</li>
<li>不会公开一个返回值（只有一个交易ID）。</li>
</ul>
<h4 id="调用-Call"><a href="#调用-Call" class="headerlink" title="调用 Call"></a>调用 Call</h4><p>另一方面，调用则非常不同。调用可用于在网络上执行代码，但不会永久更改数据。调用可以自由运行，其特征是他们读取数据。当您通过调用执行合约函数时，您将立即收到返回值。总之，调用：</p>
<ul>
<li>是免费的（不花费gas）</li>
<li>不要改变网络的状态</li>
<li>立即处理</li>
<li>将公开一个返回值（hooray！）</li>
</ul>
<p>在交易和调用之间进行选择与决定是要读取数据还是写入数据一样简单。</p>
<h3 id="抽象介绍"><a href="#抽象介绍" class="headerlink" title="抽象介绍"></a>抽象介绍</h3><p>合约抽象是与来自Javascript的以太坊合约进行交互的面包和黄油。简而言之，合约抽象是一种包装代码，可以让您轻松地与合约进行交互，从而让您忘记在引擎盖下执行的许多引擎和齿轮。truffle通过<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle合约</a>模块使用其自己的合约抽象，正是这种合约抽象如下所述。</p>
<p>然而，为了了解合约抽象的有用性，我们首先需要一个合约来谈论。我们将通过<code>truffle unbox metacoin</code>从Truffle Boxes获取MetaCoin合约。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">import &quot;./ConvertLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">// This is just a simple example of a coin-like contract.</span><br><span class="line">// It is not standards compatible and cannot be expected to talk to other</span><br><span class="line">// coin/token contracts. If you want to create a standards-compliant</span><br><span class="line">// token, see: https://github.com/ConsenSys/Tokens. Cheers!</span><br><span class="line"></span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">    mapping (address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">    function MetaCoin() &#123;</span><br><span class="line">        balances[tx.origin] = 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendCoin(address receiver, uint amount) returns(bool sufficient) &#123;</span><br><span class="line">        if (balances[msg.sender] &lt; amount) return false;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Transfer(msg.sender, receiver, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalanceInEth(address addr) returns(uint)&#123;</span><br><span class="line">        return ConvertLib.convert(getBalance(addr),2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance(address addr) returns(uint) &#123;</span><br><span class="line">        return balances[addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本合约有三种方法除了构造函数（<code>sendCoin</code>，<code>getBalanceInEth</code>，和<code>getBalance</code>）。所有三种方法都可以作为交易或调用来执行。</p>
<p>现在让我们来看一看<code>MetaCoinTruffle</code>提供给我们的Javascript对象，就像在<a href="http://truffleframework.com/docs/getting_started/console" target="_blank" rel="noopener">Truffle控制台中</a>提供的那样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Print the deployed version of MetaCoin.</span><br><span class="line">// Note that getting the deployed version requires a promise, hence the .then.</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  console.log(instance);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// outputs:</span><br><span class="line">//</span><br><span class="line">// Contract</span><br><span class="line">// - address: &quot;0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92&quot;</span><br><span class="line">// - allEvents: ()</span><br><span class="line">// - getBalance: ()</span><br><span class="line">// - getBalanceInEth: ()</span><br><span class="line">// - sendCoin: ()</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></p>
<p>请注意，抽象包含我们合约中存在的完全相同的函数。它还包含指向MetaCoin合约的已部署版本的地址。</p>
<h3 id="执行合约函数"><a href="#执行合约函数" class="headerlink" title="执行合约函数"></a>执行合约函数</h3><p>使用抽象，您可以轻松地在以太坊网络上执行合约函数。</p>
<h4 id="进行交易"><a href="#进行交易" class="headerlink" title="进行交易"></a>进行交易</h4><p>MetaCoin合约上有三项我们可以执行的函数。如果你分析它们中的每一个，你会发现这<code>sendCoin</code>是唯一一个旨在改变网络的函数。<code>sendCoin</code>是从一个帐户“发送”一些元币到下一个，并且这些更改是持续的。</p>
<p>在调用sendCoin时，我们会将其作为交易执行。在下面的例子中，我们将从一个账户向另一个账户发送10个Meta币，以保持网络变化的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line">var account_two = &quot;0xabcd...&quot;; // another address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  return meta.sendCoin(account_two, 10, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(result) &#123;</span><br><span class="line">  // If this callback is called, the transaction was successfully processed.</span><br><span class="line">  alert(&quot;Transaction successful!&quot;)</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有一些有趣的地方：</p>
<ul>
<li>我们直接调用了抽象的函数<code>sendCoin</code>。这将导致默认交易（即写入数据）而不是调用。</li>
<li>当交易成功时，直到交易处理完成才会触发fallback函数。这使工作变得轻松，意味着您不必亲自检查交易状态。</li>
<li>我们通过一个对象作为第三个参数传递给<code>sendCoin</code>。请注意，我们的Solidity合同中的<code>sendCoin</code>函数没有第三个参数。你在上面看到的是一个特殊的对象，它可以作为函数的最后一个参数传递，让你编辑有关交易的特定细节。在这里，我们设置<code>from</code>确保此交易是来自的地址<code>account_one</code>。</li>
</ul>
<h4 id="执行调用"><a href="#执行调用" class="headerlink" title="执行调用"></a>执行调用</h4><p>继续使用MetaCoin，请注意<code>getBalance</code>函数是从网络读取数据的理想选择。它不需要做任何改变，因为它只是返回传递给它的地址的MetaCoin余额。让我们试试看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  return meta.getBalance.call(account_one, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(balance) &#123;</span><br><span class="line">  // If this callback is called, the call was successfully executed.</span><br><span class="line">  // Note that this returns immediately without any waiting.</span><br><span class="line">  // Let&apos;s print the return value.</span><br><span class="line">  console.log(balance.toNumber());</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里有趣的是：</p>
<ul>
<li>我们必须<code>.call()</code>明确地执行该函数，以让以太坊网络知道我们不打算坚持任何更改。</li>
<li>我们在成功时会收到了返回值而不是交易ID。请注意，因为以太坊网络可以处理非常大的数字，所以我们得到一个<a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener">BigNumber</a>对象，然后我们将其转换为数字。</li>
</ul>
<p><b style="color:#6ab0de">警告：我们将返回值转换为数字，因为在这个例子中数字很小。但是，如果您尝试转换大于Javascript支持的最大整数的BigNumber，则可能会遇到错误或意外行为。</b></p>
<h4 id="捕捉事件"><a href="#捕捉事件" class="headerlink" title="捕捉事件"></a>捕捉事件</h4><p>您的合同可以触发您可以捕获的事件，以更深入地了解您的合约在做什么。处理事件的最简单方法是处理触发事件的交易的结果对象，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line">var account_two = &quot;0xabcd...&quot;; // another address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;  </span><br><span class="line">  return meta.sendCoin(account_two, 10, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(result) &#123;</span><br><span class="line">  // result is an object with the following values:</span><br><span class="line">  //</span><br><span class="line">  // result.tx      =&gt; transaction hash, string</span><br><span class="line">  // result.logs    =&gt; array of decoded events that were triggered within this transaction</span><br><span class="line">  // result.receipt =&gt; transaction receipt object, which includes gas used</span><br><span class="line"></span><br><span class="line">  // We can loop through result.logs to see if we triggered the Transfer event.</span><br><span class="line">  for (var i = 0; i &lt; result.logs.length; i++) &#123;</span><br><span class="line">    var log = result.logs[i];</span><br><span class="line"></span><br><span class="line">    if (log.event == &quot;Transfer&quot;) &#123;</span><br><span class="line">      // We found the event!</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="处理交易结果"><a href="#处理交易结果" class="headerlink" title="处理交易结果"></a>处理交易结果</h4><p>当您进行交易时，您会收到一个<code>result</code>对象，可以为您提供有关交易的丰富信息。具体来说，你会得到以下结果：</p>
<ul>
<li><code>result.tx</code>（字符串） - 交易散列</li>
<li><code>result.logs</code>（数组） - 解码事件（日志）</li>
<li><code>result.receipt</code>（对象） - 交易收据</li>
</ul>
<p>欲了解更多信息，请参阅README中<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle-contract</a>的项目。</p>
<h4 id="向网络添加新的合约"><a href="#向网络添加新的合约" class="headerlink" title="向网络添加新的合约"></a>向网络添加新的合约</h4><p>在上述所有情况下，我们一直在使用已经部署的合约抽象。我们可以使用以下<code>.new()</code>函数将我们自己的版本部署到网络中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MetaCoin.new().then(function(instance) &#123;</span><br><span class="line">  // Print the new address</span><br><span class="line">  console.log(instance.address);</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="在特定地址使用合约"><a href="#在特定地址使用合约" class="headerlink" title="在特定地址使用合约"></a>在特定地址使用合约</h4><p>如果您已经拥有合约地址，则可以创建一个新抽象来表示该地址的合约。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var instance = MetaCoin.at(&quot;0x1234...&quot;);</span><br></pre></td></tr></table></figure></p>
<h4 id="发送以太币到合约"><a href="#发送以太币到合约" class="headerlink" title="发送以太币到合约"></a>发送以太币到合约</h4><p>您可能只想直接将Ether发送给合同，或者触发合同的<a href="http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function" target="_blank" rel="noopener">fallback函数</a>。您可以使用以下两个选项之一来完成此操作。</p>
<p>选项1：通过<code>instance.sendTransaction()</code>直接发送交易给合约。这与所有可用的合约实例函数是一样的，并且与<code>web3.eth.sendTransaction</code>具有相同的API，但没有回调。<code>to</code>的值如果没有指定，该值将自动填入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.sendTransaction(&#123;...&#125;).then(function(result) &#123;</span><br><span class="line">  // Same transaction result object as above.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>选项2：也可以直接发送Ether：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.send(web3.toWei(1, &quot;ether&quot;)).then(function(result) &#123;</span><br><span class="line">  // Same result object as above.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>truffle提供的合同抽象包含丰富的实用工具，可轻松与您的合约进行交互。查看<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">松露合同</a>文档以获得更多建议，技巧和见解。</p>
<h2 id="通过ETHPM进行包管理"><a href="#通过ETHPM进行包管理" class="headerlink" title="通过ETHPM进行包管理"></a>通过ETHPM进行包管理</h2><p>EthPM是以太坊的新<a href="https://www.ethpm.com/" target="_blank" rel="noopener">包注册器</a>。它遵循<a href="https://github.com/ethereum/EIPs/issues/190" target="_blank" rel="noopener">ERC190规范</a>发布和使用智能合约包，并得到了许多不同以太坊开发工具的广泛支持。为了表明我们的支持，我们将以太坊包注册表直接整合到truffle中。</p>
<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>从EthPM安装一个包就像npm安装包一样简单。你可以直接运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install &lt;package name&gt;</span><br></pre></td></tr></table></figure></p>
<p>你也可以安装指定版本的包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install &lt;package name&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure></p>
<p>和NPM类型，EthPM版本遵从<a href="https://semver.org/" target="_blank" rel="noopener">semver</a>。你可在<a href="https://www.ethpm.com/registry" target="_blank" rel="noopener">Ethereum Package Registry</a>处找到所有可用的包列表。</p>
<h3 id="安装依赖关系"><a href="#安装依赖关系" class="headerlink" title="安装依赖关系"></a>安装依赖关系</h3><p>您的项目可以定义一个<code>ethpm.json</code>文件，其中可以将项目固定到特定的依赖项和版本。要安装<code>ethpm.json</code>文件中列出的所有依赖项，请运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install</span><br></pre></td></tr></table></figure></p>
<p>有关该ethpm.json文件的更多详细信息，请参阅下面的<a href="http://truffleframework.com/docs/getting_started/packages-ethpm#package-configuration" target="_blank" rel="noopener">包配置</a>。</p>
<h3 id="消费（CONSUMING）已安装合约"><a href="#消费（CONSUMING）已安装合约" class="headerlink" title="消费（CONSUMING）已安装合约"></a>消费（CONSUMING）已安装合约</h3><p>安装的软件包将被放置在您的项目文件夹中的<code>installed_contracts</code>目录中。如果没有<code>installed_contracts</code>目录存在，它会为你创建。你应该像对待NPM的<code>node_modules</code>文件夹那样对待这个文件夹 - 也就是说，除非你知道你在做什么，否则你不应该编辑里面的内容。:)</p>
<p>安装的软件包可以在您的测试，迁移和solidity合约文件中使用，通过<code>import</code>,<code>require</code>包或按名称找到的合约。例如，以下Solidity合约将从包<code>owned</code>中导入<code>owned.sol</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">import &quot;owned/owned.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract is owned &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，以下迁移文件将使用包<code>ens</code>中的ENS.sol合约：(文件：<code>./migrations/2_deploy_contracts.js</code>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ENS = artifacts.require(&quot;ens/ENS&quot;);</span><br><span class="line">var MyContract = artifacts.require(&quot;MyContract&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Only deploy ENS if there&apos;s not already an address already.</span><br><span class="line">  // i.e., don&apos;t deploy if we&apos;re using the canonical ENS address,</span><br><span class="line">  // but do deploy it if we&apos;re on a test network and ENS doesn&apos;t exist.</span><br><span class="line">  deployer.deploy(ENS, &#123;overwrite: false&#125;).then(function() &#123;</span><br><span class="line">    return deployer.deploy(MyContract, ENS.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请注意，在上面的迁移中，我们会根据ENS是否已经设置地址来有条件地使用<code>ens</code>包并部署ENS合约。这是<a href="http://truffleframework.com/docs/getting_started/migrations#deployer-deploy-contract-args-options-" target="_blank" rel="noopener">deployer</a>提供给你的一个奇妙的技巧，它使写入迁移依赖于网络工件的存在变得更加容易。在这种情况下，如果我们在Ropsten网络上运行我们的迁移，则此迁移不会部署该ENS合同，因为（在撰写本文时）Ropsten是规范ENS合同存在的地方 - 我们不想部署我们自己的合约。但是，如果我们正在针对不同的网络或测试网络运行我们的迁移，那么我们想要部署该ENS合约，以便我们有一个依赖合约来处理。</p>
<h3 id="发布你自己的软件包"><a href="#发布你自己的软件包" class="headerlink" title="发布你自己的软件包"></a>发布你自己的软件包</h3><p>发布自己的软件包与安装一样简单，但与NPM一样，需要更多配置。</p>
<h4 id="ROPSTEN"><a href="#ROPSTEN" class="headerlink" title="ROPSTEN"></a>ROPSTEN</h4><p>Ethereum软件包注册表目前存在于Ropsten测试网络中。要发布到注册中心，我们需要建立我们自己的Ropsten配置，因为我们将进行需要签名的交易。</p>
<p>在本例中，我们将使用Infura与NPM<code>truffle-hdwallet-provider</code>模块一起发布软件包以及一个代表Ropsten网络上Ethereum地址的12字钱包助记符。首先，在您的项目目录中通过NPM安装<code>truffle-hdwallet-provider</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install truffle-hdwallet-provider --save</span><br></pre></td></tr></table></figure></p>
<p>然后编辑您的配置，使用12字助记符添加<code>ropsten</code>网络：文件： <code>truffle.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);</span><br><span class="line"></span><br><span class="line">// 12-word mnemonic</span><br><span class="line">var mnemonic = &quot;opinion destroy betray ...&quot;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: &quot;127.0.0.1&quot;,</span><br><span class="line">      port: 8545,</span><br><span class="line">      network_id: &quot;*&quot; // Match any network id</span><br><span class="line">    &#125;,</span><br><span class="line">    ropsten: &#123;</span><br><span class="line">      provider: new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;),</span><br><span class="line">      network_id: 3 // official id of the ropsten network</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="程序包配置"><a href="#程序包配置" class="headerlink" title="程序包配置"></a>程序包配置</h4><p>与NPM类似，EthPM的配置选项位于单独的JSON文件中ethpm.json。此文件与您的Truffle配置并列，并为Truffle发布包装所需的所有信息。您可以在<a href="http://truffleframework.com/docs/advanced/configuration" target="_blank" rel="noopener">配置</a>部分看到可用选项的完整列表。</p>
<p>文件： <code>ethpm.json</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;package_name&quot;: &quot;adder&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.3&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Simple contract to add two numbers&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;ethereum&quot;,</span><br><span class="line">    &quot;addition&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;owned&quot;: &quot;^0.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p>在确定您的配置后，发布很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle publish</span><br></pre></td></tr></table></figure></p>
<p>您会看到类似于下面的输出，并确认您的包已成功发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ truffle publish</span><br><span class="line">Gathering contracts...</span><br><span class="line">Finding publishable artifacts...</span><br><span class="line">Uploading sources and publishing to registry...</span><br><span class="line">+ adder@0.0.3</span><br></pre></td></tr></table></figure></p>
<h4 id="发布之前"><a href="#发布之前" class="headerlink" title="发布之前"></a>发布之前</h4><p>当使用<code>develop</code>配置为匹配任何Ethereum客户端的默认网络（如Ganache或Truffle Develop）时，您肯定会存在不希望发布到网络中的工件。在发布您的软件包之前，请考虑运行以下命令以删除任何无关的网络工件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle networks --clean</span><br></pre></td></tr></table></figure></p>
<p>有关更多信息，请参阅<a href="http://truffleframework.com/docs/advanced/commands#networks" target="_blank" rel="noopener">命令参考</a>。</p>
<h2 id="通过NPM进行包管理"><a href="#通过NPM进行包管理" class="headerlink" title="通过NPM进行包管理"></a>通过NPM进行包管理</h2><p>Truffle标配npm集成，并且知道node_modules项目中的目录（如果存在）。这意味着您可以通过使用和分发合约，通过npm获取dapps和启用以太坊的库，使您的代码可被自己以及其其他人的代码使用。</p>
<h3 id="包布局"><a href="#包布局" class="headerlink" title="包布局"></a>包布局</h3><p>使用Truffle创建的项目默认具有特定的布局，可以将它们用作包。这种布局不是必需的，但如果用作公共约定 - 或“事实上的标准” - 则通过NPM分发合约和dapps将变得更容易。</p>
<p>truffle套件中最重要的目录如下：</p>
<ul>
<li><code>/contracts</code></li>
<li><code>/build</code>（其中包括<code>/build/contracts</code>由truffle创建的）</li>
</ul>
<p>第一个目录是您的合约目录，其中包含您的原始Solidity合同。第二个目录是构建目录，更具体地说<code>/build/contracts</code>，它以<code>.json</code>文件形式存放构建工件。在你的软件包中包括原始合约将允许其他人在他们自己的solidity代码中导入这些合约。同样，<code>.json</code>在你的包中包含你的构建工件将允许其他人无缝地与你的JavaScript合约交互，这可以在dapps，脚本和迁移中使用。</p>
<h3 id="使用一个包"><a href="#使用一个包" class="headerlink" title="使用一个包"></a>使用一个包</h3><p>在自己的项目中使用软件包时，需要注意的是，有两个地方可能对使用感兴趣的其他合约代码：在您的合约中以及您的Javascript代码（迁移和测试）中。以下提供了每个案例的示例，并讨论了充分利用其他合约并构建工件的技巧。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>在本例中，我们将使用<a href="https://github.com/ConsenSys/example-truffle-library" target="_blank" rel="noopener">truffle示例库</a>，该库提供了一个简单的名称注册，该注册表已部署到Morden测试网络。为了将其用作依赖项，我们必须首先通过npm用以下方式将其安装在我们的项目中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd my_project</span><br><span class="line">$ npm install example-truffle-library</span><br></pre></td></tr></table></figure></p>
<p>请注意，上面的最后一个命令会下载软件包并将它放在<code>my_project/node_modules</code>目录中，这对于下面的示例很重要。请参阅<a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm文档</a>以获取使用npm安装软件包的帮助。</p>
<h4 id="嵌入你的合约"><a href="#嵌入你的合约" class="headerlink" title="嵌入你的合约"></a>嵌入你的合约</h4><p>要在合约中使用包的合约，这可以与Solidity的<a href="http://solidity.readthedocs.io/en/develop/layout-of-source-files.html?#importing-other-source-files" target="_blank" rel="noopener">import</a>声明一样简单。当您的导入路径不是明确的相对或绝对时，这表示您要从特定命名包中查找文件。考虑使用上面提到的示例truffle库的这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;</span><br></pre></td></tr></table></figure></p>
<p>由于路径并未以<code>./</code>开始，Truffle知道要在项目的<code>node_modules</code>目录中查找该<code>example-truffle-library</code>文件夹。从那里，它解决了为您提供您所要求的合约的路径。</p>
<h4 id="嵌入JavaScript代码中"><a href="#嵌入JavaScript代码中" class="headerlink" title="嵌入JavaScript代码中"></a>嵌入JavaScript代码中</h4><p>要在JavaScript代码中与包的合约进行交互，您只需要<code>require</code>包的<code>.json</code>文件，然后使用<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle-contract</a>模块将这些文件转换为可用的抽象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var contract = require(&quot;truffle-contract&quot;);</span><br><span class="line">var data = require(&quot;example-truffle-library/build/contracts/SimpleNameRegistry.json&quot;);</span><br><span class="line">var SimpleNameRegistry = contract(data);</span><br></pre></td></tr></table></figure></p>
<p>要使用这些抽象概念，请参阅<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">与您的合同交互</a>一节以获取更多详细信息。</p>
<h4 id="包的部署地址"><a href="#包的部署地址" class="headerlink" title="包的部署地址"></a>包的部署地址</h4><p>有时候你希望你的合约与这个包的先前部署的合约进行交互。由于部署的地址存在于包的<code>.json</code>文件中，因此您必须执行额外的步骤才能将这些地址存入您的合约。为此，请使您的合约接受依存关系合约的地址，然后使用迁移。以下是项目中存在的示例合约以及示例迁移：</p>
<p>合约：<code>MyContract.sol</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.13;</span><br><span class="line"></span><br><span class="line">import &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">  SimpleNameRegistry registry;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function MyContract &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Simple example that uses the deployed registry from the package.</span><br><span class="line">  function getModule(bytes32 name) returns (address) &#123;</span><br><span class="line">    return registry.names(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set the registry if you&apos;re the owner.</span><br><span class="line">  function setRegistry(address addr) &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">    registry = SimpleNameRegistry(addr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迁移：<code>3_hook_up_example_library.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Note that artifacts.require takes care of creating an abstraction for us.</span><br><span class="line">var SimpleNameRegistry = artifacts.require(&quot;example-truffle-library/SimpleNameRegistry&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Deploy our contract, then set the address of the registry.</span><br><span class="line">  deployer.deploy(MyContract).then(function() &#123;</span><br><span class="line">    return MyContract.deployed();</span><br><span class="line">  &#125;).then(function(deployed) &#123;</span><br><span class="line">    return deployed.setRegistry(SimpleNameRegistry.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布之前-1"><a href="#发布之前-1" class="headerlink" title="发布之前"></a>发布之前</h4><p>当使用develop配置为匹配任何Ethereum客户端的默认网络（如Ganache或Truffle Develop）时，您肯定会在网络中存在不希望发布的工件。在发布您的软件包之前，请考虑运行以下命令以删除任何无关的网络工件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle networks --clean</span><br></pre></td></tr></table></figure></p>
<p>有关更多信息，请参阅<a href="http://truffleframework.com/docs/advanced/commands#networks" target="_blank" rel="noopener">命令参考</a>。</p>
<h2 id="调试您的合约"><a href="#调试您的合约" class="headerlink" title="调试您的合约"></a>调试您的合约</h2><p>truffle包含一个集成的调试器，以便您可以调试对您的合约进行的交易。这个调试器看起来和现有的可用于传统开发环境的命令行调试器相似。</p>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在区块链上调试交易与调试传统应用程序（例如，用C ++或Javascript编写的应用程序）不同。在区块链上调试交易时，您不是实时运行代码; 相反，您正在逐步执行该交易的历史执行，并将该执行映射到其相关代码。这为我们调试提供了许多自由度，因为我们可以在任何时候调试任何交易，只要我们拥有交易交互的合同的代码和工件即可。将这些代码和工件看作类似于传统调试器所需的调试符号。</p>
<p>为了调试交易，您需要以下内容：</p>
<ul>
<li>truffle 4.0或以上。</li>
<li>交易在您想要的区块链上的哈希值。</li>
<li>交易发生的源代码和工件。</li>
</ul>
<p>请注意，如果您希望的交易导致异常情况或用完gas，那也没问题。交易仍然存在于链上，所以你仍然可以调试它！</p>
<h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>要使用调试器，请收集您想要调试的交易，然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle debug &lt;transaction hash&gt;</span><br></pre></td></tr></table></figure></p>
<p>以一个交易<code>0x8e5dadfb921dd...</code>开始，该命令如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76</span><br></pre></td></tr></table></figure></p>
<p>这将启动下面描述的调试接口。</p>
<h3 id="调试界面"><a href="#调试界面" class="headerlink" title="调试界面"></a>调试界面</h3><p>启动调试器将打开一个熟悉的调试其他类型应用程序的界面。开始时，您会看到以下内容：</p>
<ul>
<li>在此交易过程中进行交易或创建的地址列表。</li>
<li>使用调试器的可用命令列表。</li>
<li>以及交易的初始入口点，包括合约源文件和代码预览。</li>
</ul>
<p><code>enter</code>键被设置为执行输入的最后一个命令。当调试器启动时，该enter键被设置为步进到在执行期间遇到的下一个逻辑源代码元素（即，由以太坊虚拟机评估的下一个表达式或语句）。此时，您可以按键enter逐步完成交易，或者输入其中一个可用命令来更详细地分析交易。命令列表详述如下。</p>
<h4 id="（O）跨越（Step-Over）"><a href="#（O）跨越（Step-Over）" class="headerlink" title="（O）跨越（Step Over）"></a>（O）跨越（Step Over）</h4><p>此命令遍历当前行，相对于当前在Solidity源文件中正在评估的语句或表达式的位置。如果您不想在当前行中进入函数调用或合约创建，或者想要快速跳转到源文件中的特定点，请使用此命令。</p>
<h4 id="（I）进入-Step-into"><a href="#（I）进入-Step-into" class="headerlink" title="（I）进入(Step into)"></a>（I）进入(Step into)</h4><p>该命令进入当前正在评估的函数调用或合同创建。使用此命令跳转到该函数并快速开始调试那里存在的代码。</p>
<h4 id="（U）走出去-Step-Out"><a href="#（U）走出去-Step-Out" class="headerlink" title="（U）走出去(Step Out)"></a>（U）走出去(Step Out)</h4><p>该命令退出当前正在运行的函数。如果这是交易的入口点，则使用此命令可以快速返回调用函数，或者结束交易的执行。</p>
<h4 id="（N）下一步（STEP-NEXT）"><a href="#（N）下一步（STEP-NEXT）" class="headerlink" title="（N）下一步（STEP NEXT）"></a>（N）下一步（STEP NEXT）</h4><p>该命令转到源代码中的下一个逻辑语句或表达式。例如，在虚拟机可以评估完整表达式之前，需要先评估子表达式。如果您想分析虚拟机评估的每个逻辑项，请使用此命令。</p>
<h4 id="（-）步指令"><a href="#（-）步指令" class="headerlink" title="（;）步指令"></a>（;）步指令</h4><p>该命令允许您逐步查看虚拟机评估的每条单独指令。如果您有兴趣了解由Solidity源代码创建的低级别字节码，这非常有用。当你使用这个命令时，调试器在评估指令时也会打印出栈数据。</p>
<h4 id="（P）打印指令"><a href="#（P）打印指令" class="headerlink" title="（P）打印指令"></a>（P）打印指令</h4><p>该命令打印当前的指令和堆栈数据，但不会进入下一条指令。如果希望在使用上述逻辑命令浏览交易后查看当前指令和堆栈数据，请使用此选项。</p>
<h4 id="（H）打印此帮助"><a href="#（H）打印此帮助" class="headerlink" title="（H）打印此帮助"></a>（H）打印此帮助</h4><p>打印可用命令的列表。</p>
<h4 id="（Q）退出"><a href="#（Q）退出" class="headerlink" title="（Q）退出"></a>（Q）退出</h4><p>退出调试器。</p>
<h2 id="使用Truffle开发和控制台"><a href="#使用Truffle开发和控制台" class="headerlink" title="使用Truffle开发和控制台"></a>使用Truffle开发和控制台</h2><p>有时，为了测试和调试目的，或者手工执行交易，交互式地处理您的合约是很好的。Truffle为您提供了两种通过交互式控制台执行此操作的简单方法，您的合约可供使用并随时可用。</p>
<ul>
<li>Truffle控制台：连接到任何以太坊客户端的基本交互式控制台</li>
<li>Truffle开发：交互式控制台，也产生一个发展区块链</li>
</ul>
<h3 id="为啥是两个不同的控制台？"><a href="#为啥是两个不同的控制台？" class="headerlink" title="为啥是两个不同的控制台？"></a>为啥是两个不同的控制台？</h3><p>拥有两个不同的控制台可让您根据自己的需求选择最佳工具。</p>
<p>使用Truffle控制台的理由：</p>
<ul>
<li>你有一个你已经使用的客户端，如Ganache或geth</li>
<li>你想迁移到测试网络（或以太坊网络）</li>
<li>您想要使用特定的助记符或帐户列表</li>
</ul>
<p>使用Truffle Develop的原因：</p>
<ul>
<li>您正在测试您的项目，无意立即部署</li>
<li>您无需使用特定帐户（并且使用默认开发帐户即可）</li>
<li>您不想安装和管理单独的区块链客户端</li>
</ul>
<h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><p>所有你需要的命令都在你的项目文件夹中。你不需要在根目录。</p>
<h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>启动控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle console</span><br></pre></td></tr></table></figure></p>
<p>这将查找在配置中称为<code>development</code>的网络定义，并连接到它（如果可用）。您可以使用该<code>--network &lt;name&gt;</code>选项覆盖此选项。在<a href="http://truffleframework.com/docs/advanced/networks" target="_blank" rel="noopener">“网络”</a>部分以及<a href="http://truffleframework.com/docs/advanced/commands" target="_blank" rel="noopener">命令参考</a>中查看更多详细信息。</p>
<p>当您加载控制台时，您会立即看到以下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle(development)&gt;</span><br></pre></td></tr></table></figure></p>
<p>这告诉你你正在使用d<code>evelopment</code>网络在Truffle控制台中运行。</p>
<h4 id="TRUFFLE-DEVELOP"><a href="#TRUFFLE-DEVELOP" class="headerlink" title="TRUFFLE DEVELOP"></a>TRUFFLE DEVELOP</h4><p>启动TRUFFLE DEVELOP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure></p>
<p>无论您的<code>truffle.js</code>配置文件需要什么，这将在端口<code>9545</code>上本地产生一个开发区块链。</p>
<p>当你启动了TRUFFLE DEVELOP，你会看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Truffle Develop started at http://localhost:9545/</span><br><span class="line"></span><br><span class="line">Accounts:</span><br><span class="line">(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57</span><br><span class="line">(1) 0xf17f52151ebef6c7334fad080c5704d77216b732</span><br><span class="line">(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef</span><br><span class="line">(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544</span><br><span class="line">(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2</span><br><span class="line">(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e</span><br><span class="line">(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5</span><br><span class="line">(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5</span><br><span class="line">(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc</span><br><span class="line">(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de</span><br><span class="line"></span><br><span class="line">Private Keys:</span><br><span class="line">(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3</span><br><span class="line">(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f</span><br><span class="line">(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1</span><br><span class="line">(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c</span><br><span class="line">(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418</span><br><span class="line">(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63</span><br><span class="line">(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8</span><br><span class="line">(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7</span><br><span class="line">(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4</span><br><span class="line">(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5</span><br><span class="line"></span><br><span class="line">Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p>
<p>这会向您显示此特定区块链的地址，私钥和助记符。</p>
<p><b style="color:#6ab0de">注意：助记符和地址不能更改。如果您想使用不同的助记符或一组地址，我们推荐使用Ganache。</b></p>
<p><b style="color:#c7254e">警告：切记不要使用这些地址或主网上的助记符。这仅用于开发。</b></p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>Truffle Develop和控制台都提供了Truffle命令行工具中的大部分功能。例如，您可以在控制台中输入内容<code>migrate --reset</code>，并将其解释为与在命令行上运行<code>truffle migrate --reset</code>时相同。</p>
<p>此外，Truffle Develop和控制台还具有以下特点：</p>
<ul>
<li>你所有的编译合约都可以使用。</li>
<li>在每个命令（例如<code>migrate --reset</code>）您的合同被重新配置后，您可以立即开始使用新分配的地址和二进制文件。</li>
<li>该<code>web3</code>库已经可用，并已设置为连接到您的以太坊客户端。</li>
<li>所有返回承诺的命令都会自动解析，并打印结果，不需要为简单的命令使用<code>.then()</code>。例如，以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyContract.at(&quot;0xabcd...&quot;).getValue.call();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>会返回类似如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h3 id="可用的命令"><a href="#可用的命令" class="headerlink" title="可用的命令"></a>可用的命令</h3><ul>
<li><code>build</code></li>
<li><code>compile</code></li>
<li><code>create</code></li>
<li><code>debug</code></li>
<li><code>exec</code></li>
<li><code>install</code></li>
<li><code>migrate</code></li>
<li><code>networks</code></li>
<li><code>opcode</code></li>
<li><code>publish</code></li>
<li><code>test</code></li>
<li><code>version</code></li>
</ul>
<p>如果truffle命令不可用，那是因为它与现有项目无关（例如<code>init</code>）或者没有意义（例如<code>develop</code>或<code>console</code>）。</p>
<p>查看完整的<a href="http://truffleframework.com/docs/advanced/commands" target="_blank" rel="noopener">命令参考</a>了解更多信息。</p>
<h2 id="编写外部脚本"><a href="#编写外部脚本" class="headerlink" title="编写外部脚本"></a>编写外部脚本</h2><p>通常您可能想要运行与您的合同交互的外部脚本。truffle提供了一种简单的方法来实现这一点，根据您所需的网络引导您的合同，并根据您的<a href="http://truffleframework.com/docs/advanced/configuration" target="_blank" rel="noopener">项目配置</a>自动连接到您的以太坊客户端。</p>
<h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><p>要运行外部脚本，请执行以下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle exec &lt;path/to/file.js&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>为了使外部脚本正确运行，<code>Truffle</code>期望它们导出一个函数，该函数唯一的参数作为回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(callback) &#123;</span><br><span class="line">  // perform actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要在脚本结束时调用回调函数，就可以在该脚本中执行任何您想要的操作。回调接受一个错误作为它的第一个也是唯一的参数。如果提供了错误，执行将暂停并且该进程将返回非零退出代码。</p>
<h2 id="使用构建管道"><a href="#使用构建管道" class="headerlink" title="使用构建管道"></a>使用构建管道</h2><p>Truffle 1.0和2.0标准的默认构建系统主要面向Web应用程序（这里，术语“构建”意味着将代码工件转换为HTML，Javascript和CSS）。该构建系统已被引入<a href="https://github.com/trufflesuite/truffle-default-builder/tree/master" target="_blank" rel="noopener">自己的模块</a>，使Truffle可用于各种应用并可扩展。</p>
<p>Truffle可以配置为与任何构建系统紧密集成。要配置自定义生成系统，请参阅<a href="http://truffleframework.com/docs/advanced/build_processes" target="_blank" rel="noopener">高级生成过程</a>部分以获取更多详细信息。</p>
<h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><p>要在构建系统时编译应用程序，请运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle build</span><br></pre></td></tr></table></figure></p>
<p>请注意，如果您尝试在未首先配置自定义构建过程的情况下运行<code>build</code>命令，则会收到错误。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/09/blockchain/solidity内联装配通用语言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/blockchain/solidity内联装配通用语言/" itemprop="url">solidity内联装配通用语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T10:14:10+08:00">2018-04-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">JULIA是一种可以编译到各种不同后端的中间语言（EVM1.0，EVM 1.5和eWASM正在计划中）。正因为如此，它被设计为所有三个平台均可用。它已经可以用于Solidity内部的“内联汇编”，并且未来版本的Solidity编译器甚至将JULIA用作中间语言。为JULIA构建高级优化器阶段也应该很容易。</b></p>
<p><b style="color:#6ab0de">注意:请注意，用于“内联汇编”的风格不具有类型（所有内容均是<code>u256</code>类型），并且内置函数与EVM操作码相同。有关详细信息，请参阅内联汇编文档。</b></p>
<p>JULIA的核心组件是函数，语句块，变量，文本（literals），for循环，if语句，switch语句，表达式和变量赋值。</p>
<p>JULIA是类型化的，变量和文字（Literals）都必须用后缀表示法指定类型。支持的类型有<code>bool</code>，<code>u8</code>，<code>s8</code>，<code>u32</code>，<code>s32</code>， <code>u64</code>，<code>s64</code>，<code>u128</code>，<code>s128</code>，<code>u256</code>和<code>s256</code>。</p>
<p>JULIA本身甚至不提供操作符。如果EVM是运行目标，则操作码将以内置函数提供，但如果后端更改，则可以重新实现它们。有关强制性内置函数的列表，请参阅下面的部分。</p>
<p>下面的示例程序假定EVM操作码<code>mul</code>，<code>div</code>和<code>mod</code>可以本地或者作为函数可用并计算求幂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base:u256, exponent:u256) -&gt; result:u256</span><br><span class="line">    &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0:u256 &#123; result := 1:u256 &#125;</span><br><span class="line">        case 1:u256 &#123; result := base &#125;</span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2:u256))</span><br><span class="line">            switch mod(exponent, 2:u256)</span><br><span class="line">                case 1:u256 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用for循环而不是递归来实现相同的函数。在这里，我们需要EVM操作码<code>lt</code>（小于）和<code>add</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base:u256, exponent:u256) -&gt; result:u256</span><br><span class="line">    &#123;</span><br><span class="line">        result := 1:u256</span><br><span class="line">        for &#123; let i := 0:u256 &#125; lt(i, exponent) &#123; i := add(i, 1:u256) &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            result := mul(result, base)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="JULIA规格"><a href="#JULIA规格" class="headerlink" title="JULIA规格"></a>JULIA规格</h2><p>本章介绍JULIA代码。JULIA代码通常放置在JULIA对象中，将在下一章中介绍。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement =</span><br><span class="line">    Block |</span><br><span class="line">    FunctionDefinition |</span><br><span class="line">    VariableDeclaration |</span><br><span class="line">    Assignment |</span><br><span class="line">    Expression |</span><br><span class="line">    Switch |</span><br><span class="line">    ForLoop |</span><br><span class="line">    BreakContinue</span><br><span class="line">FunctionDefinition =</span><br><span class="line">    &apos;function&apos; Identifier &apos;(&apos; TypedIdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; TypedIdentifierList )? Block</span><br><span class="line">VariableDeclaration =</span><br><span class="line">    &apos;let&apos; TypedIdentifierList ( &apos;:=&apos; Expression )?</span><br><span class="line">Assignment =</span><br><span class="line">    IdentifierList &apos;:=&apos; Expression</span><br><span class="line">Expression =</span><br><span class="line">    FunctionCall | Identifier | Literal</span><br><span class="line">If =</span><br><span class="line">    &apos;if&apos; Expression Block</span><br><span class="line">Switch =</span><br><span class="line">    &apos;switch&apos; Expression Case* ( &apos;default&apos; Block )?</span><br><span class="line">Case =</span><br><span class="line">    &apos;case&apos; Literal Block</span><br><span class="line">ForLoop =</span><br><span class="line">    &apos;for&apos; Block Expression Block Block</span><br><span class="line">BreakContinue =</span><br><span class="line">    &apos;break&apos; | &apos;continue&apos;</span><br><span class="line">FunctionCall =</span><br><span class="line">    Identifier &apos;(&apos; ( Expression ( &apos;,&apos; Expression )* )? &apos;)&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">TypeName = Identifier | BuiltinTypeName</span><br><span class="line">BuiltinTypeName = &apos;bool&apos; | [us] ( &apos;8&apos; | &apos;32&apos; | &apos;64&apos; | &apos;128&apos; | &apos;256&apos; )</span><br><span class="line">TypedIdentifierList = Identifier &apos;:&apos; TypeName ( &apos;,&apos; Identifier &apos;:&apos; TypeName )*</span><br><span class="line">Literal =</span><br><span class="line">    (NumberLiteral | StringLiteral | HexLiteral | TrueLiteral | FalseLiteral) &apos;:&apos; TypeName</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">TrueLiteral = &apos;true&apos;</span><br><span class="line">FalseLiteral = &apos;false&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure></p>
<h3 id="对语法的限制"><a href="#对语法的限制" class="headerlink" title="对语法的限制"></a>对语法的限制</h3><p>Switches必须至少有一个case（包括默认case）。如果表达式的所有可能值都被覆盖了，那么就不应该允许使用默认情况（例如，一个带有bool表达式的开关，同时具有true和false的情况下不应允许默认情况）。</p>
<p>每个表达式都计算为零个或多个值。标识符和文字只计算一个值，函数调用计算的值等于所调用函数的返回值。</p>
<p>在变量声明和赋值中，右侧表达式（如果存在）必须计算出与左侧变量数量相等的许多值。这是唯一允许评估多个值的表达式。</p>
<p>也是语句的表达式（例如语句块级别的）必须评估为零值。</p>
<p>在所有其他情况下，表达式必须评估为恰好一个值。</p>
<p><code>continue</code>和<code>break</code>语句只能在循环体内部使用和必须在相同的函数的循环（或两者都必须在顶层）。<code>for-loop</code>的条件部分必须评估到一个值。</p>
<p>文字(Literals)不能大于他们的类型。定义的最大类型是256位宽。</p>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>JULIA中的作用域与语句块相关（例外是函数和for循环，如下所述），所有声明（<code>FunctionDefinition</code>，<code>VariableDeclaration</code>）都将新标识符引入到这些作用域中。</p>
<p>标识符在其定义的语句块中（包括所有子节点和子语句块）中都可见。作为例外，for循环（第一个块）的“init”部分中定义的标识符在for循环的所有其他部分（但不在循环之外）中都是可见的。在for循环的其他部分声明的标识符遵守常规的作用域范围规则。函数的参数和返回参数在函数体中可见，并且它们的名称不能重叠。</p>
<p>变量只能在声明后引用。特别是变量不能在自己的变量声明的右边引用。函数可以在声明之前被引用（如果它们是可见的）。</p>
<p>阴影是不允许的，也就是说，即使不可访问，也不能在另一个具有相同名称的标识符可见的位置声明标识符。（也就是同名变量不能存在）</p>
<p>在函数内部，不可能访问在该函数之外声明的变量。</p>
<h3 id="形式规范"><a href="#形式规范" class="headerlink" title="形式规范"></a>形式规范</h3><p>我们通过在AST的各个节点上提供评估重载函数E来正式指定JULIA。任何函数都可能有副作用，所以E需要两个状态对象和AST节点，并返回两个新的状态对象和可变数量的其他值。这两个状态对象是全局状态对象（在EVM的上下文中是区块链的内存，存储和状态）和本地状态对象（局部变量的状态，即EVM中堆栈的一部分） 。如果AST节点是一个语句，E将返回两个状态对象和一个用于<code>break</code>和<code>continue</code>语句的“模式” 。如果AST节点是表达式，则E返回两个状态对象，并返回与表达式计算结果相同的值。</p>
<p>对于这个高层次的描述，全局状态的确切性质并没有说明。本地状态<code>L</code>是标识符<code>i</code>到值<code>v</code>的映射，表示为<code>L[i] = v</code>。</p>
<p>对于标识符<code>v</code>，让<code>$v</code>成为标识符的名称。</p>
<p>我们将使用AST节点的解构符号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">E(G, L, &lt;&#123;St1, ..., Stn&#125;&gt;: Block) =</span><br><span class="line">    let G1, L1, mode = E(G, L, St1, ..., Stn)</span><br><span class="line">    let L2 be a restriction of L1 to the identifiers of L</span><br><span class="line">    G1, L2, mode</span><br><span class="line">E(G, L, St1, ..., Stn: Statement) =</span><br><span class="line">    if n is zero:</span><br><span class="line">        G, L, regular</span><br><span class="line">    else:</span><br><span class="line">        let G1, L1, mode = E(G, L, St1)</span><br><span class="line">        if mode is regular then</span><br><span class="line">            E(G1, L1, St2, ..., Stn)</span><br><span class="line">        otherwise</span><br><span class="line">            G1, L1, mode</span><br><span class="line">E(G, L, FunctionDefinition) =</span><br><span class="line">    G, L, regular</span><br><span class="line">E(G, L, &lt;let var1, ..., varn := rhs&gt;: VariableDeclaration) =</span><br><span class="line">    E(G, L, &lt;var1, ..., varn := rhs&gt;: Assignment)</span><br><span class="line">E(G, L, &lt;let var1, ..., varn&gt;: VariableDeclaration) =</span><br><span class="line">    let L1 be a copy of L where L1[$vari] = 0 for i = 1, ..., n</span><br><span class="line">    G, L1, regular</span><br><span class="line">E(G, L, &lt;var1, ..., varn := rhs&gt;: Assignment) =</span><br><span class="line">    let G1, L1, v1, ..., vn = E(G, L, rhs)</span><br><span class="line">    let L2 be a copy of L1 where L2[$vari] = vi for i = 1, ..., n</span><br><span class="line">    G, L2, regular</span><br><span class="line">E(G, L, &lt;for &#123; i1, ..., in &#125; condition post body&gt;: ForLoop) =</span><br><span class="line">    if n &gt;= 1:</span><br><span class="line">        let G1, L1, mode = E(G, L, i1, ..., in)</span><br><span class="line">        // mode has to be regular due to the syntactic restrictions</span><br><span class="line">        let G2, L2, mode = E(G1, L1, for &#123;&#125; condition post body)</span><br><span class="line">        // mode has to be regular due to the syntactic restrictions</span><br><span class="line">        let L3 be the restriction of L2 to only variables of L</span><br><span class="line">        G2, L3, regular</span><br><span class="line">    else:</span><br><span class="line">        let G1, L1, v = E(G, L, condition)</span><br><span class="line">        if v is false:</span><br><span class="line">            G1, L1, regular</span><br><span class="line">        else:</span><br><span class="line">            let G2, L2, mode = E(G1, L, body)</span><br><span class="line">            if mode is break:</span><br><span class="line">                G2, L2, regular</span><br><span class="line">            else:</span><br><span class="line">                G3, L3, mode = E(G2, L2, post)</span><br><span class="line">                E(G3, L3, for &#123;&#125; condition post body)</span><br><span class="line">E(G, L, break: BreakContinue) =</span><br><span class="line">    G, L, break</span><br><span class="line">E(G, L, continue: BreakContinue) =</span><br><span class="line">    G, L, continue</span><br><span class="line">E(G, L, &lt;if condition body&gt;: If) =</span><br><span class="line">    let G0, L0, v = E(G, L, condition)</span><br><span class="line">    if v is true:</span><br><span class="line">        E(G0, L0, body)</span><br><span class="line">    else:</span><br><span class="line">        G0, L0, regular</span><br><span class="line">E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn&gt;: Switch) =</span><br><span class="line">    E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default &#123;&#125;)</span><br><span class="line">E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn default st&apos;&gt;: Switch) =</span><br><span class="line">    let G0, L0, v = E(G, L, condition)</span><br><span class="line">    // i = 1 .. n</span><br><span class="line">    // Evaluate literals, context doesn&apos;t matter</span><br><span class="line">    let _, _, v1 = E(G0, L0, l1)</span><br><span class="line">    ...</span><br><span class="line">    let _, _, vn = E(G0, L0, ln)</span><br><span class="line">    if there exists smallest i such that vi = v:</span><br><span class="line">        E(G0, L0, sti)</span><br><span class="line">    else:</span><br><span class="line">        E(G0, L0, st&apos;)</span><br><span class="line"></span><br><span class="line">E(G, L, &lt;name&gt;: Identifier) =</span><br><span class="line">    G, L, L[$name]</span><br><span class="line">E(G, L, &lt;fname(arg1, ..., argn)&gt;: FunctionCall) =</span><br><span class="line">    G1, L1, vn = E(G, L, argn)</span><br><span class="line">    ...</span><br><span class="line">    G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)</span><br><span class="line">    Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)</span><br><span class="line">    Let &lt;function fname (param1, ..., paramn) -&gt; ret1, ..., retm block&gt;</span><br><span class="line">    be the function of name $fname visible at the point of the call.</span><br><span class="line">    Let L&apos; be a new local state such that</span><br><span class="line">    L&apos;[$parami] = vi and L&apos;[$reti] = 0 for all i.</span><br><span class="line">    Let G&apos;&apos;, L&apos;&apos;, mode = E(Gn, L&apos;, block)</span><br><span class="line">    G&apos;&apos;, Ln, L&apos;&apos;[$ret1], ..., L&apos;&apos;[$retm]</span><br><span class="line">E(G, L, l: HexLiteral) = G, L, hexString(l),</span><br><span class="line">    where hexString decodes l from hex and left-aligns it into 32 bytes</span><br><span class="line">E(G, L, l: StringLiteral) = G, L, utf8EncodeLeftAligned(l),</span><br><span class="line">    where utf8EncodeLeftAligned performs a utf8 encoding of l</span><br><span class="line">    and aligns it left into 32 bytes</span><br><span class="line">E(G, L, n: HexNumber) = G, L, hex(n)</span><br><span class="line">    where hex is the hexadecimal decoding function</span><br><span class="line">E(G, L, n: DecimalNumber) = G, L, dec(n),</span><br><span class="line">    where dec is the decimal decoding function</span><br></pre></td></tr></table></figure></p>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>JULIA不支持隐式类型转换，因此存在提供显式转换的函数。在将较大类型转换为较短类型时，如果发生溢出，则可能会发生运行时异常。</p>
<p>以下类型转换功能必须可用： -<code>u32tobool(x:u32) -&gt; y:bool</code> -<code>booltou32(x:bool) -&gt; y:u32</code> -<code>u32tou64(x:u32) -&gt; y:u64</code> -<code>u64tou32(x:u64) -&gt; y:u32</code> - 等（TBD）.</p>
<h3 id="低级函数"><a href="#低级函数" class="headerlink" title="低级函数"></a>低级函数</h3><p>以下函数必须可用：</p>
<table>
<thead>
<tr>
<th>算术</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>addu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x + y</td>
</tr>
<tr>
<td>subu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x - y</td>
</tr>
<tr>
<td>mulu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x * y</td>
</tr>
<tr>
<td>divu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x / y</td>
</tr>
<tr>
<td>divs256(x:s256, y:s256) -&gt; z:s256</td>
<td>x / y，用于补码中的有符号数</td>
</tr>
<tr>
<td>modu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x % y</td>
</tr>
<tr>
<td>mods256(x:s256, y:s256) -&gt; z:s256</td>
<td>x % y，用于补码中的有符号数</td>
</tr>
<tr>
<td>signextendu256(i:u256, x:u256) -&gt; z:u256</td>
<td>符号从最低有效位（i * 8 + 7）位开始计数</td>
</tr>
<tr>
<td>expu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x对y的幂</td>
</tr>
<tr>
<td>addmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td>
<td>(x + y)％m，任意精确算术</td>
</tr>
<tr>
<td>mulmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td>
<td>（x * y）％m,任意精确算术</td>
</tr>
<tr>
<td>ltu256(x:u256, y:u256) -&gt; z:bool</td>
<td>如果x &lt;y,1，否则为0</td>
</tr>
<tr>
<td>gtu256(x:u256, y:u256) -&gt; z:bool</td>
<td>如果x&gt;y，1,否则为0</td>
</tr>
<tr>
<td>sltu256(x:s256, y:s256) -&gt; z:bool</td>
<td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>sgtu256(x:s256, y:s256) -&gt; z:bool</td>
<td>如果x&gt;y,1，否则为0，否则为2的补码中的有符号数</td>
</tr>
<tr>
<td>equ256(x:u256, y:u256) -&gt; z:bool</td>
<td>如果x == y,1，否则为0</td>
</tr>
<tr>
<td>notu256(x:u256) -&gt; z:u256</td>
<td>〜x，x的每一位取反</td>
</tr>
<tr>
<td>andu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x和y按位与</td>
</tr>
<tr>
<td>oru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x和y按位或</td>
</tr>
<tr>
<td>xoru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x和y的按位异或</td>
</tr>
<tr>
<td>shlu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x以y的逻辑左移</td>
</tr>
<tr>
<td>shru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x，y的逻辑右移</td>
</tr>
<tr>
<td>saru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x以y的算术右移</td>
</tr>
<tr>
<td>byte(n:u256, x:u256) -&gt; v:u256</td>
<td>x的第n个字节，其中最重要的字节是第0个字节不能用and256（shr256（n，x），0xff替换它）并让它由EVM后端进行优化？</td>
</tr>
<tr>
<td>内存和存储</td>
<td></td>
</tr>
<tr>
<td>mload(p:u256) -&gt; v:u256</td>
<td>mem[p..(p+32))</td>
</tr>
<tr>
<td>mstore(p:u256, v:u256)</td>
<td>mem[p..(p+32)) := v</td>
</tr>
<tr>
<td>mstore8(p:u256, v:u256)</td>
<td>mem[p] := v &amp; 0xff - 仅修改单个字节</td>
</tr>
<tr>
<td>sload(p:u256) -&gt; v:u256</td>
<td>storage[p]</td>
</tr>
<tr>
<td>sstore(p:u256, v:u256)</td>
<td>storage[p] := v</td>
</tr>
<tr>
<td>msize() -&gt; size:u256</td>
<td>内存大小，即最大访问内存索引，虽然是由于内存扩展功能（由字扩展）造成的，但它总是32个字节的倍数</td>
</tr>
<tr>
<td>执行控制</td>
<td></td>
</tr>
<tr>
<td>create(v:u256, p:u256, s:u256)</td>
<td>用代码mem [p ..（p + s））创建新的合同并发送v wei并返回新的地址</td>
</tr>
<tr>
<td>call(g:u256, a:u256, v:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td>
<td>在输入mem [in ..（in + insize））时提供g gas和v wei以及输出区mem [out ..（out + oversize）），在地址a处调用合同，并在错误时返回0（例如， 1成功</td>
</tr>
<tr>
<td>callcode(g:u256, a:u256, v:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td>
<td>相同call但只能使用a的代码，否则保留在当前合同的上下文中</td>
</tr>
<tr>
<td>delegatecall(g:u256, a:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td>
<td>相同callcode，但也保持caller 和callvalue</td>
</tr>
<tr>
<td>atop()</td>
<td>停止执行，与返回相同（0,0）也许它会有意义的退休，因为它等于return（0,0）。它可以是EVM后端的优化。</td>
</tr>
<tr>
<td>abort()</td>
<td>中止（相当于EVM上的无效指令）</td>
</tr>
<tr>
<td>return(p:u256, s:u256)</td>
<td>结束执行，返回数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>revert(p:u256, s:u256)</td>
<td>结束执行，恢复状态更改，返回数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>selfdestruct(a:u256)</td>
<td>终止执行，摧毁当前合同并将资金发送给</td>
</tr>
<tr>
<td>log0(p:u256, s:u256)</td>
<td>没有主题和数据记录[p ..（p + s））</td>
</tr>
<tr>
<td>log1(p:u256, s:u256, t1:u256)</td>
<td>记录主题t1和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>log2(p:u256, s:u256, t1:u256, t2:u256)</td>
<td>记录主题t1，t2和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>log3(p:u256, s:u256, t1:u256, t2:u256, t3:u256)</td>
<td>记录主题t，t2，t3和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>log4(p:u256, s:u256, t1:u256, t2:u256, t3:u256, t4:u256)</td>
<td>记录主题t1，t2，t3，t4和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>状态查询</td>
<td></td>
</tr>
<tr>
<td>blockcoinbase() -&gt; address:u256</td>
<td>目前的采矿受益者</td>
</tr>
<tr>
<td>blockdifficulty() -&gt; difficulty:u256</td>
<td>当前块的难度</td>
</tr>
<tr>
<td>blockgaslimit() -&gt; limit:u256</td>
<td>阻止当前块的气体限制</td>
</tr>
<tr>
<td>blockhash(b:u256) -&gt; hash:u256</td>
<td>块nr b的散列值 - 仅适用于不包括当前值的最后256个块</td>
</tr>
<tr>
<td>blocknumber() -&gt; block:u256</td>
<td>当前程序段号</td>
</tr>
<tr>
<td>blocktimestamp() -&gt; timestamp:u256</td>
<td>当前块的时间戳，以秒为单位</td>
</tr>
<tr>
<td>txorigin() -&gt; address:u256</td>
<td>交易发件人</td>
</tr>
<tr>
<td>txgasprice() -&gt; price:u256</td>
<td>交易的天然气价格</td>
</tr>
<tr>
<td>gasleft() -&gt; gas:u256</td>
<td>仍然可以用于执行的gas</td>
</tr>
<tr>
<td>balance(a:u256) -&gt; v:u256</td>
<td>地址a的余额（wei）</td>
</tr>
<tr>
<td>this() -&gt; address:u256</td>
<td>当前合同/执行上下文的地址</td>
</tr>
<tr>
<td>caller() -&gt; address:u256</td>
<td>呼叫发送者（不包括委托呼叫）</td>
</tr>
<tr>
<td>callvalue() -&gt; v:u256</td>
<td>目前的调用一起发送的以太币</td>
</tr>
<tr>
<td>calldataload(p:u256) -&gt; v:u256</td>
<td>从位置p开始的调用数据（32字节）</td>
</tr>
<tr>
<td>calldatasize() -&gt; v:u256</td>
<td>通话数据的大小以字节为单位</td>
</tr>
<tr>
<td>calldatacopy(t:u256, f:u256, s:u256)</td>
<td>从位置f的calldata复制s个字节到位置t的mem</td>
</tr>
<tr>
<td>codesize() -&gt; size:u256</td>
<td>当前合同/执行上下文的代码大小</td>
</tr>
<tr>
<td>codecopy(t:u256, f:u256, s:u256)</td>
<td>从位置f的代码复制s字节到位置t的mem</td>
</tr>
<tr>
<td>extcodesize(a:u256) -&gt; size:u256</td>
<td>地址a处代码的大小</td>
</tr>
<tr>
<td>extcodecopy(a:u256, t:u256, f:u256, s:u256)</td>
<td>像代码复制（t，f，s），但需要在地址a处进行编码</td>
</tr>
<tr>
<td>其他</td>
<td></td>
</tr>
<tr>
<td>discardu256(unused:u256)</td>
<td>丢弃价值</td>
</tr>
<tr>
<td>splitu256tou64(x:u256) -&gt; (x1:u64, x2:u64,x3:u64, x4:u64)</td>
<td>将u256分成四个u64</td>
</tr>
<tr>
<td>combineu64tou256(x1:u64, x2:u64, x3:u64,x4:u64) -&gt; (x:u256)</td>
<td>将四个U64组合成一个U256</td>
</tr>
<tr>
<td>sha3(p:u256, s:u256) -&gt; v:u256</td>
<td>keccak（MEM [P …（P + S）））</td>
</tr>
</tbody>
</table>
<p>以上的表格内容都是机翻，由于之前在solidity的内联汇编中都有类似的指令，大概进行翻译，这里有时间的话会进行相应的处理。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端或目标是JULIA到特定字节码的翻译。每个后端都可以暴露以后端名称为前缀的函数。我们为两个建议的后端预留<code>evm_</code>并加上<code>ewasm_</code>前缀。</p>
<h3 id="后端：EVM"><a href="#后端：EVM" class="headerlink" title="后端：EVM"></a>后端：EVM</h3><p>EVM目标将具有以<code>evm_</code>前缀暴露的所有底层EVM操作码。</p>
<h3 id="后端：“EVM-1-5”"><a href="#后端：“EVM-1-5”" class="headerlink" title="后端：“EVM 1.5”"></a>后端：“EVM 1.5”</h3><p>TBD</p>
<h3 id="后端：eWASM"><a href="#后端：eWASM" class="headerlink" title="后端：eWASM"></a>后端：eWASM</h3><p>TBD</p>
<h2 id="JULIA对象的规范"><a href="#JULIA对象的规范" class="headerlink" title="JULIA对象的规范"></a>JULIA对象的规范</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TopLevelObject = &apos;object&apos; &apos;&#123;&apos; Code? ( Object | Data )* &apos;&#125;&apos;</span><br><span class="line">Object = &apos;object&apos; StringLiteral &apos;&#123;&apos; Code? ( Object | Data )* &apos;&#125;&apos;</span><br><span class="line">Code = &apos;code&apos; Block</span><br><span class="line">Data = &apos;data&apos; StringLiteral HexLiteral</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br></pre></td></tr></table></figure></p>
<p>以上<code>Block</code>是指<code>Block</code>前一章中介绍的JULIA代码语法。</p>
<p>JULIA对象示例如下所示：</p>
<p>..代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Code consists of a single object. A single &quot;code&quot; node is the code of the object.</span><br><span class="line">// Every (other) named object or data section is serialized and</span><br><span class="line">// made accessible to the special built-in functions datacopy / dataoffset / datasize</span><br><span class="line">object &#123;</span><br><span class="line">    code &#123;</span><br><span class="line">        let size = datasize(&quot;runtime&quot;)</span><br><span class="line">        let offset = allocate(size)</span><br><span class="line">        // This will turn into a memory-&gt;memory copy for eWASM and</span><br><span class="line">        // a codecopy for EVM</span><br><span class="line">        datacopy(dataoffset(&quot;runtime&quot;), offset, size)</span><br><span class="line">        // this is a constructor and the runtime code is returned</span><br><span class="line">        return(offset, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data &quot;Table2&quot; hex&quot;4123&quot;</span><br><span class="line"></span><br><span class="line">    object &quot;runtime&quot; &#123;</span><br><span class="line">        code &#123;</span><br><span class="line">            // runtime code</span><br><span class="line"></span><br><span class="line">            let size = datasize(&quot;Contract2&quot;)</span><br><span class="line">            let offset = allocate(size)</span><br><span class="line">            // This will turn into a memory-&gt;memory copy for eWASM and</span><br><span class="line">            // a codecopy for EVM</span><br><span class="line">            datacopy(dataoffset(&quot;Contract2&quot;), offset, size)</span><br><span class="line">            // constructor parameter is a single number 0x1234</span><br><span class="line">            mstore(add(offset, size), 0x1234)</span><br><span class="line">            create(offset, add(size, 32))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Embedded object. Use case is that the outside is a factory contract,</span><br><span class="line">        // and Contract2 is the code to be created by the factory</span><br><span class="line">        object &quot;Contract2&quot; &#123;</span><br><span class="line">            code &#123;</span><br><span class="line">                // code here ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            object &quot;runtime&quot; &#123;</span><br><span class="line">                code &#123;</span><br><span class="line">                    // code here ...</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             data &quot;Table1&quot; hex&quot;4123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">92</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">88</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
