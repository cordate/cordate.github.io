<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/10/blockchain/OpenZeppelin文档说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/blockchain/OpenZeppelin文档说明/" itemprop="url">OpenZeppelin文档说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T21:12:42+08:00">2018-04-10</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是官方文档的翻译</p>
<h2 id="OpenZeppelin"><a href="#OpenZeppelin" class="headerlink" title="OpenZeppelin"></a>OpenZeppelin</h2><p>OpenZeppelin是在以太坊上安全编写<a href="https://en.wikipedia.org/wiki/Smart_contract" target="_blank" rel="noopener">智能合约</a>的库。</p>
<p>借助OpenZeppelin，你可以构建分布式应用程序、协议和组织：</p>
<ul>
<li>使用通用合约安全模式（请参阅<a href="/2018/03/17/blockchain/安全编写以太坊的智能合约指南/">安全编写以太坊的智能合约指南</a>）</li>
<li>在<a href="https://solidity.readthedocs.io/en/develop/" target="_blank" rel="noopener">solidity语言</a>上</li>
</ul>
<p>注：如果你是入门的智能合约开发者，请查看我们的<a href="/2018/03/18/blockchain/以太坊智能合同搭建简易指南/">入门指南</a>。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>OpenZeppelin旨在提供安全、经过测试和社区审核的代码，但在处理真钱时请使用常识！我们对您的实施决定以及您可能遇到的任何安全问题不承担任何责任。</p>
<p>如果您发现安全问题，请发送电子邮件至<a href="mailto:security@openzeppelin.org" target="_blank" rel="noopener">security@openzeppelin.org</a>。</p>
<h3 id="开发者资源"><a href="#开发者资源" class="headerlink" title="开发者资源"></a>开发者资源</h3><p>使用OpenZeppelin构建分布式应用程序，协议或组织？</p>
<ul>
<li>参阅指南：<a href="https://blog.zeppelin.solutions/guides/home" target="_blank" rel="noopener">https://blog.zeppelin.solutions/guides/home</a></li>
<li>寻求帮助，并关注进度：<a href="https://slack.openzeppelin.org" target="_blank" rel="noopener">https://slack.openzeppelin.org</a></li>
</ul>
<p>有兴趣对OpenZeppelin做贡献？</p>
<ul>
<li>框架提案和路线图：<a href="https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab" target="_blank" rel="noopener">https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab</a></li>
<li>问题追踪：<a href="https://github.com/OpenZeppelin/zeppelin-solidity/issues" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/issues</a></li>
<li>贡献指南：<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md</a></li>
<li>wiki：<a href="https://github.com/OpenZeppelin/zeppelin-solidity/wiki" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/wiki</a></li>
</ul>
<h3 id="OpenZeppelin合作组织和审计"><a href="#OpenZeppelin合作组织和审计" class="headerlink" title="OpenZeppelin合作组织和审计"></a>OpenZeppelin合作组织和审计</h3><ul>
<li><a href="https://golem.network/" target="_blank" rel="noopener">Golem</a></li>
<li><a href="http://www.mediachain.io/" target="_blank" rel="noopener">Mediachain</a></li>
<li><a href="http://truffleframework.com/" target="_blank" rel="noopener">Truffle</a></li>
<li><a href="https://firstblood.io/" target="_blank" rel="noopener">Firstblood</a></li>
<li><a href="https://www.rsk.co/" target="_blank" rel="noopener">Rootstock</a></li>
<li><a href="https://consensys.net/" target="_blank" rel="noopener">Consensys</a></li>
<li><a href="https://www.dgx.io/" target="_blank" rel="noopener">DigixGlobal</a></li>
<li><a href="https://coinfund.io/" target="_blank" rel="noopener">Coinfund</a></li>
<li><a href="https://democracy.earth/" target="_blank" rel="noopener">DemocracyEarth</a></li>
<li><a href="https://signatura.co/" target="_blank" rel="noopener">Signatura</a></li>
<li><a href="http://www.ether.camp/" target="_blank" rel="noopener">Ether.camp</a></li>
<li><a href="https://aragon.one/" target="_blank" rel="noopener">Aragon</a></li>
<li><a href="https://wings.ai/" target="_blank" rel="noopener">Wings</a></li>
</ul>
<p>among others…</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>根据<a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/LICENSE" target="_blank" rel="noopener">MIT许可证</a>发布的代码</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>OpenZeppelin与Truffle集成，Truffle是以太坊开发环境。请安装Truffle并用<code>truffle init</code>初始化您的项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br><span class="line">mkdir myproject &amp;&amp; cd myproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure></p>
<p>要安装OpenZeppelin库，在项目根目录下运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install -E zeppelin-solidity</span><br></pre></td></tr></table></figure></p>
<p><b>请注意，OpenZeppelin目前不遵循语义版本控制</b>。您可能会遇到轻微版本凹凸处的重大更改。我们建议不要改变您使用的OpenZeppelin版本，就像<code>-E（--save-exact）</code>选项一样。</p>
<p>之后，您在node_modules/zeppelin-solidity/contracts文件夹下获得的所有的库合约。你可以像这样使用库中的合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &apos;zeppelin-solidity/contracts/ownership/Ownable.sol&apos;;</span><br><span class="line"></span><br><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>在完成使用OpenZeppelin的智能合同开发的第一步之后，您可能需要查看涵盖几个常见使用案例和良好实践的指南：<a href="https://blog.zeppelin.solutions/guides/home" target="_blank" rel="noopener">https://blog.zeppelin.solutions/guides/home</a></p>
<p>例如，<a href="/2018/03/18/blockchain/以太坊智能合同搭建简易指南/">“以太坊智能合同搭便车指南”</a>将帮助您了解智能合同开发所需的各种工具，并设置您的环境。</p>
<p><a href="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094" target="_blank" rel="noopener">以太坊编程的基础介绍，第1部分</a>提供了介绍级的非常有用的信息，包括以太坊平台的许多基本概念。</p>
<p>要进行更深入的探索，您可以阅读<a href="https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317" target="_blank" rel="noopener">设计您的Ethereum应用程序架构指南</a>，其中讨论了如何更好地构建应用程序及其与现实世界的关系。</p>
<p>您也可以寻求帮助或关注OpenZeppelin在<a href="https://slack.openzeppelin.org/" target="_blank" rel="noopener">Slack</a>社区中的进展，或者阅读本网站上OpenZeppelin的完整API介绍。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/09/blockchain/truffle指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/blockchain/truffle指南/" itemprop="url">truffle指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T14:27:50+08:00">2018-04-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:blue">本文是truffle官方文档的翻译，不确定版本，但是看到truffle官方github的版本是4.1.15.</b></p>
<p>Truffle是一个世界级的开发环境，用于以太坊的测试框架和资产管道，旨在使以太坊开发人员的开发更轻松。truffle有以下的一些特性：</p>
<ul>
<li>内置智能合约编译，链接，部署和二进制管理。</li>
<li>用于快速开发的合约自动测试。</li>
<li>可编写脚本的可扩展部署和迁移框架。</li>
<li>用于部署到任意数量的公共和专用网络的网络管理。</li>
<li>使用ERC190标准，使用EthPM和NPM进行包装管理。</li>
<li>交互式控制台，用于直接与合约交互。</li>
<li>可配置的构建流水线，支持紧密集成。</li>
<li>外部脚本运行器，用于在Truffle环境中执行脚本。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure>
<p>最好使用node 5.0+，另外最好有一个打开json rpc api的以太坊节点。</p>
<h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>对于那些刚刚开始使用的人，可通过<a href="http://truffleframework.com/boxes" target="_blank" rel="noopener">松露盒</a>获取许多样板和示例应用程序。</p>
<p>你可以从我们的MetaCoin例子开始，在命令行上运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir MetaCoin</span><br><span class="line">cd MetaCoin</span><br><span class="line">truffle unbox metacoin</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#c7254e">注意：MetaCoin松露项目过去是通过运行<code>truffle init</code>创建的。现在它作为松露盒存在。</b></p>
<p>您可以使用该<code>truffle unbox &lt;box-name&gt;</code>命令下载任何其他应用程序。</p>
<p>如果你想从头开始构建一个项目，可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir myproject</span><br><span class="line">cd myproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure></p>
<p>一旦完成，您现在将拥有包含以下项目的项目结构：</p>
<ul>
<li><code>contracts/</code>：<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">Solidity合同</a>目录</li>
<li><code>migrations/</code>：<a href="http://truffleframework.com/docs/getting_started/migrations#migration-files" target="_blank" rel="noopener">可编写脚本的部署文件的目录</a></li>
<li><code>test/</code>：用于<a href="http://truffleframework.com/docs/getting_started/testing" target="_blank" rel="noopener">测试您的应用程序和合约的</a>测试文件目录</li>
<li><code>truffle.js</code>：Truffle配置文件</li>
</ul>
<h2 id="选择以太坊客户端"><a href="#选择以太坊客户端" class="headerlink" title="选择以太坊客户端"></a>选择以太坊客户端</h2><p>有许多以太坊客户端可供选择。根据您是在开发还是部署，我们推荐不同的客户端。</p>
<h3 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h3><h4 id="Ganache"><a href="#Ganache" class="headerlink" title="Ganache"></a>Ganache</h4><p>我们建议您在桌面上运行Ethereum开发的个人区块链<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>。作为truffle套件的一部分，Ganache通过将合约和交易放在前面和中心处，简化了dapp的开发。使用Ganache，您可以快速看到应用程序如何影响区块链，并反馈到您的账户，余额，合约创建和gas成本等细节。您还可以对Ganache的高级采矿控制进行微调，以更好地满足您的需求。Ganache可用于Windows，Mac和Linux，您可以<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">在此下载</a>。</p>
<p>Ganache在启动时运行在<code>http://127.0.0.1:7545</code>。它将显示前10个帐户和用于创建这些帐户的助记符。（<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank" rel="noopener">阅读有关帐户助记符的更多信息</a>。）</p>
<p>默认情况下，Ganache将使用以下助记符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p>
<p>该助记符可以更改为随机生成，也可以输入自己的助记符。</p>
<p><b style="color:#c7254e">警告：请勿在以太网主网络（mainnet）上使用此助记符。如果您将ETH发送到由此助记符生成的任何帐户，您将失去所有！</b></p>
<h4 id="truffle开发"><a href="#truffle开发" class="headerlink" title="truffle开发"></a>truffle开发</h4><p>我们还建议使用Truffle Develop，一种直接构建在truffle中区块链。Truffle Develop可帮助您使用单个命令设置集成区块链环境，无需安装。通过在终端中键入以下命令即可开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure></p>
<p>这将运行客户端<code>http://127.0.0.1:9545</code>。它将显示前10个帐户和用于创建这些帐户的助记符。Truffle Develop每次都使用相同的助记符来尽可能简化开发应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p>
<p>一旦启动，Truffle Develop将为您提供一个控制台，您可以使用它来运行所有可用的truffle命令。这些命令是通过省略truffle前缀来输入的。</p>
<p>要了解更多关于与控制台交互的信息，请参阅<a href="http://truffleframework.com/docs/getting_started/console" target="_blank" rel="noopener">使用控制台</a>部分。</p>
<h4 id="GANACHE-CLI"><a href="#GANACHE-CLI" class="headerlink" title="GANACHE CLI"></a>GANACHE CLI</h4><p>Ganache还为那些在图形环境下工作的人提供了一个命令行界面。非常适合自动化测试和持续集成环境，Ganache CLI可以无人运行，可以配置为满足您的所有开发需求。Ganache CLI可以立即处理交易，而不是等待默认的区块时间，因此您可以快速测试您的代码是否可以工作。它还会在您的智能合约出现错误时立即告诉您，并直接与Truffle集成，以将测试运行时间与其他客户端相比降低90％。<a href="https://github.com/trufflesuite/ganache-cli/" target="_blank" rel="noopener">了解关于Ganache CLI的更多信息</a>。</p>
<h3 id="正式环境部署"><a href="#正式环境部署" class="headerlink" title="正式环境部署"></a>正式环境部署</h3><p>有许多官方和非官方的以太坊客户可供您使用。以下是一个简短列表：</p>
<ul>
<li>geth：<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum</a></li>
<li>WebThree（cpp-ethereum）：<a href="https://github.com/ethereum/cpp-ethereum" target="_blank" rel="noopener">https://github.com/ethereum/cpp-ethereum</a></li>
<li>Parity： <a href="https://github.com/paritytech/parity" target="_blank" rel="noopener">https://github.com/paritytech/parity</a></li>
<li>More： <a href="https://www.ethereum.org/cli" target="_blank" rel="noopener">https://www.ethereum.org/cli</a></li>
</ul>
<h3 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h3><p><a href="https://zhuanlan.zhihu.com/p/29010231" target="_blank" rel="noopener">玩转以太坊(Ethereum)的测试网络</a></p>
<h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>所有的合同都位于您项目的contracts/目录中。<code>Migrations.sol</code>帮助部署合约。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure>
<p>第一次运行时，所有合同都将被编译。后续运行时，松露只会编译自上次编译以来已更改的合同。如果您想覆盖此行为，请使用该<code>--all</code>选项运行上述命令。</p>
<h3 id="构建结果"><a href="#构建结果" class="headerlink" title="构建结果"></a>构建结果</h3><p>您编译的结果将被放置在<code>build/contracts/</code>目录中. 这些文件是truffle内部使用，你不需要编辑。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>您可以使用Solidity的导入命令来声明合约依赖关系。truffle将按照正确的顺序编译合约，并确保将所有依赖关系发送给编译器。依赖性可以用两种方式指定：</p>
<h4 id="通过文件名导入依赖关系"><a href="#通过文件名导入依赖关系" class="headerlink" title="通过文件名导入依赖关系"></a>通过文件名导入依赖关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./AnotherContract.sol&quot;;</span><br></pre></td></tr></table></figure>
<p>这里<code>AnotherContract.sol</code>是相对于当前正在编写的合约的路径。</p>
<h4 id="从外部包导入合约"><a href="#从外部包导入合约" class="headerlink" title="从外部包导入合约"></a>从外部包导入合约</h4><p>Truffle支持通过<a href="http://truffleframework.com/docs/getting_started/packages-ethpm" target="_blank" rel="noopener">EthPM</a>和<a href="http://truffleframework.com/docs/getting_started/packages-npm" target="_blank" rel="noopener">NPM</a>安装的依赖项。要从依赖项导入合约，请使用以下语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;somepackage/SomeContract.sol&quot;;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>somepackage</code>表示通过EthPM或NPM安装的软件包，<code>SomeContract.sol</code>表示该软件包提供的Solidity 源文件。</p>
<h2 id="运行迁移"><a href="#运行迁移" class="headerlink" title="运行迁移"></a>运行迁移</h2><p>Migration是帮助您将合约部署到以太坊网络的JavaScript文件。这些文件负责暂存您的部署任务，并且这些文件是在您的部署需求随时间变化的前提下编写的。随着您的项目不断发展，您将创建新的迁移脚本以进一步推动区块链的发展。以前运行的迁移历史记录通过特定的Migrations合约记录在链上，详情如下。</p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle migrate</span><br></pre></td></tr></table></figure>
<p>这将运行位于项目<code>migrations</code>目录中的所有迁移。简而言之，迁移只是一组受管理的部署脚本。如果您的迁移先前已成功运行，<code>truffle migrate</code>则将从上次运行的迁移开始执行，仅运行新创建的迁移。如果不存在新的迁移，<code>truffle migrate</code>则根本不会执行任何操作。您可以使用该<code>--reset</code>选项从头开始运行所有迁移。对于本地测试，确保在执行<code>migrate</code>之前安装并运行测试区块链，例如<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>.</p>
<h3 id="迁移文件"><a href="#迁移文件" class="headerlink" title="迁移文件"></a>迁移文件</h3><p>一个简单的迁移文件如下所示：文件名：<code>4_example_migration.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var MyContract = artifacts.require(&quot;MyContract&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // deployment steps</span><br><span class="line">  deployer.deploy(MyContract);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请注意，文件名以数字为前缀，后缀为说明。需要编号的前缀才能记录迁移是否成功运行。后缀纯粹是为了人类的可读性和理解。</p>
<h4 id="ARTIFACTS-REQUIRE"><a href="#ARTIFACTS-REQUIRE" class="headerlink" title="ARTIFACTS.REQUIRE()"></a>ARTIFACTS.REQUIRE()</h4><p>在迁移开始时，我们告诉Truffle我们希望通过该<code>artifacts.require()</code>方法取得要进行交互的合约。此方法与Node的<code>require</code>类似，但在我们的情况，它特别返回了我们可以在我们的部署脚本的其余部分中使用的合约抽象。指定的名称应与该源文件中的合约定义的名称相匹配。不要传递源文件的名称，因为文件可以包含多个合同。</p>
<h4 id="MODULE-EXPORTS"><a href="#MODULE-EXPORTS" class="headerlink" title="MODULE.EXPORTS"></a>MODULE.EXPORTS</h4><p>所有的迁移必须通过<code>module.exports</code>语法导出一个函数。每个迁移导出的函数应接受一个<code>deployer</code>对象作为其第一个参数。该对象通过为部署智能合约提供清晰的语法以及执行一些部署的更普通的职责（如保存部署的工件供以后使用）来帮助部署。该<code>deployer</code>对象是用于暂存部署任务的主接口，其页面底部介绍了其API。</p>
<p>您的迁移函数也可以接受其他参数。看下面的例子。</p>
<h3 id="初始化迁移"><a href="#初始化迁移" class="headerlink" title="初始化迁移"></a>初始化迁移</h3><p>truffle需要您拥有迁移合约才能使用迁移功能。此合约必须包含特定的接口，但您可以随意编辑此合约。对于大多数项目而言，此合约最初将作为第一次迁移进行部署，不会再进行更新。在创建新项目时，您通过<code>truffle init</code>还将默认收到此合约。</p>
<p>文件名：<code>contracts/Migrations.sol</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.8;</span><br><span class="line"></span><br><span class="line">contract Migrations &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  // A function with the signature `last_completed_migration()`, returning a uint, is required.</span><br><span class="line">  uint public last_completed_migration;</span><br><span class="line"></span><br><span class="line">  modifier restricted() &#123;</span><br><span class="line">    if (msg.sender == owner) _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Migrations() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // A function with the signature `setCompleted(uint)` is required.</span><br><span class="line">  function setCompleted(uint completed) restricted &#123;</span><br><span class="line">    last_completed_migration = completed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function upgrade(address new_address) restricted &#123;</span><br><span class="line">    Migrations upgraded = Migrations(new_address);</span><br><span class="line">    upgraded.setCompleted(last_completed_migration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>您必须在第一次迁移中部署此合约才能利用迁移功能。为此，请创建以下迁移：<code>migrations/1_initial_migration.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Migrations = artifacts.require(&quot;Migrations&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Deploy the Migrations contract as our only task</span><br><span class="line">  deployer.deploy(Migrations);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从这里，您可以使用增加的编号前缀创建新的迁移，以部署其他合约并执行进一步的部署步骤。</p>
<h3 id="DEPLOYER"><a href="#DEPLOYER" class="headerlink" title="DEPLOYER"></a>DEPLOYER</h3><p>您的迁移文件将使用部署者来部署部署任务。因此，您可以同步编写部署任务，并按正确的顺序执行它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Stage deploying A before B</span><br><span class="line">deployer.deploy(A);</span><br><span class="line">deployer.deploy(B);</span><br></pre></td></tr></table></figure></p>
<p>或者，可以将部署者上的每个功能用作Promise，以排队依赖于前一个任务执行的部署任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Deploy A, then deploy B, passing in A&apos;s newly deployed address</span><br><span class="line">deployer.deploy(A).then(function() &#123;</span><br><span class="line">  return deployer.deploy(B, A.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="网络考虑"><a href="#网络考虑" class="headerlink" title="网络考虑"></a>网络考虑</h3><p>可以根据部署到的网络有条件地运行部署步骤。这是一项高级功能，因此请先参阅<a href="http://truffleframework.com/docs/advanced/networks" target="_blank" rel="noopener">网络</a>部分，然后再继续。</p>
<p>要有条件有步骤地部署，请编写您的迁移，以便他们接受名为的第二个参数<code>network</code>。例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(deployer, network) &#123;</span><br><span class="line">  if (network == &quot;live&quot;) &#123;</span><br><span class="line">    // Do something specific to the network named &quot;live&quot;.</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Perform a different step otherwise.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可用的账户"><a href="#可用的账户" class="headerlink" title="可用的账户"></a>可用的账户</h3><p>迁移还会通过您的以太坊客户端和web3提供商提供给您的帐户列表，供您在部署期间使用。这与<code>web3.eth.getAccounts()</code>从中返回的帐户完全相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(deployer, network, accounts) &#123;</span><br><span class="line">  // Use the accounts within your migrations.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DEPLOYER-API"><a href="#DEPLOYER-API" class="headerlink" title="DEPLOYER API"></a>DEPLOYER API</h3><p>Deployer包含许多可用于简化迁移的功能。</p>
<h4 id="DEPLOYER-DEPLOY-CONTRACT-ARGS…-OPTIONS"><a href="#DEPLOYER-DEPLOY-CONTRACT-ARGS…-OPTIONS" class="headerlink" title="DEPLOYER.DEPLOY(CONTRACT, ARGS…, OPTIONS)"></a>DEPLOYER.DEPLOY(CONTRACT, ARGS…, OPTIONS)</h4><p>使用可选的构造函数参数部署合约对象指定的特定合约。这对于单个合约很有用，因此您的dapp只有一份此合约的实例。这将在部署之后设置合约的地址（即，<code>Contract.address</code>将等于新部署的地址），并且它将覆盖任何先前存储的地址。</p>
<p>您可以选择传递一组合约或一组数组，以加速部署多个合约。此外，最后一个参数是一个可选对象，可以包含指定的键<code>overwrite</code>以及其他交易参数（如<code>gas</code>和<code>from</code>）。如果<code>overwrite</code>设置为<code>false</code>，则Deployer将不会部署此合约（如果已部署）。这对于某些合约地址由外部依赖项提供的情况很有用。</p>
<p>请注意，在调用<code>deploy</code>之前，您需要首先部署和链接您的合约所依赖的任何库。有关link更多详细信息，请参阅以下功能.</p>
<p>欲了解更多信息，请参阅<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle-contract</a>文档。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Deploy a single contract without constructor arguments</span><br><span class="line">deployer.deploy(A);</span><br><span class="line"></span><br><span class="line">// Deploy a single contract with constructor arguments</span><br><span class="line">deployer.deploy(A, arg1, arg2, ...);</span><br><span class="line"></span><br><span class="line">// Don&apos;t deploy this contract if it has already been deployed</span><br><span class="line">deployer.deploy(A, &#123;overwrite: false&#125;);</span><br><span class="line"></span><br><span class="line">// Set a maximum amount of gas and `from` address for the deployment</span><br><span class="line">deployer.deploy(A, &#123;gas: 4612388, from: &quot;0x....&quot;&#125;);</span><br><span class="line"></span><br><span class="line">// Deploy multiple contracts, some with arguments and some without.</span><br><span class="line">// This is quicker than writing three `deployer.deploy()` statements as the deployer</span><br><span class="line">// can perform the deployment as a single batched request.</span><br><span class="line">deployer.deploy([</span><br><span class="line">  [A, arg1, arg2, ...],</span><br><span class="line">  B,</span><br><span class="line">  [C, arg1]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// External dependency example:</span><br><span class="line">//</span><br><span class="line">// For this example, our dependency provides an address when we&apos;re deploying to the</span><br><span class="line">// live network, but not for any other networks like testing and development.</span><br><span class="line">// When we&apos;re deploying to the live network we want it to use that address, but in</span><br><span class="line">// testing and development we need to deploy a version of our own. Instead of writing</span><br><span class="line">// a bunch of conditionals, we can simply use the `overwrite` key.</span><br><span class="line">deployer.deploy(SomeDependency, &#123;overwrite: false&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="DEPLOYER-LINK-LIBRARY-DESTINATIONS"><a href="#DEPLOYER-LINK-LIBRARY-DESTINATIONS" class="headerlink" title="DEPLOYER.LINK(LIBRARY, DESTINATIONS)"></a>DEPLOYER.LINK(LIBRARY, DESTINATIONS)</h4><p>将已部署的库链接到合约或多个合约。<code>destinations</code>可以是单个合约或多个合约的数组。如果<code>destinations</code>的任何合约不依赖于链接的库，则合约将被忽略。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Deploy library LibA, then link LibA to contract B, then deploy B.</span><br><span class="line">deployer.deploy(LibA);</span><br><span class="line">deployer.link(LibA, B);</span><br><span class="line">deployer.deploy(B);</span><br><span class="line"></span><br><span class="line">// Link LibA to many contracts</span><br><span class="line">deployer.link(LibA, [B, C, D]);</span><br></pre></td></tr></table></figure></p>
<h4 id="DEPLOYER-THEN-FUNCTION-…"><a href="#DEPLOYER-THEN-FUNCTION-…" class="headerlink" title="DEPLOYER.THEN(FUNCTION() {…})"></a>DEPLOYER.THEN(FUNCTION() {…})</h4><p>就像承诺一样，运行一个任意的部署步骤。在您的迁移过程中使用它来调用特定合同的函数来添加、编辑和重新组织合约数据。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a, b;</span><br><span class="line">deployer.then(function() &#123;</span><br><span class="line">  // Create a new version of A</span><br><span class="line">  return A.new();</span><br><span class="line">&#125;).then(function(instance) &#123;</span><br><span class="line">  a = instance;</span><br><span class="line">  // Get the deployed instance of B</span><br><span class="line">  return B.deployed();</span><br><span class="line">&#125;).then(function(instance) &#123;</span><br><span class="line">  b = instance;</span><br><span class="line">  // Set the new instance of A&apos;s address on B via B&apos;s setA() function.</span><br><span class="line">  return b.setA(a.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="测试你的合约"><a href="#测试你的合约" class="headerlink" title="测试你的合约"></a>测试你的合约</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>truffle配置了自动化测试框架，可以轻松测试你的合约。这个框架可以让你用两种不同的方式编写简单且易于管理的测试：</p>
<ul>
<li>在<a href="http://truffleframework.com/docs/getting_started/javascript-tests" target="_blank" rel="noopener">JavaScript中</a>，用于运行来自外部世界的合约，就像您的应用程序一样。</li>
<li>在<a href="http://truffleframework.com/docs/getting_started/solidity-tests" target="_blank" rel="noopener">Solidity</a>中，高级特性，在公开的场景中行使您的合约。</li>
</ul>
<p>两种类型的测试都有其优点和缺点。请参阅接下来的两节来讨论。</p>
<h3 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h3><p>所有测试文件应位于<code>./test</code>目录中。truffle将只与下列扩展名的文件运行测试文件：<code>.js</code>，<code>.es</code>，<code>.es6</code>，<code>.jsx</code>和<code>.sol</code>。所有其他文件都被忽略。</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test</span><br></pre></td></tr></table></figure>
<p>或者，您可以运行指定路径的文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test ./path/to/test/file.js</span><br></pre></td></tr></table></figure></p>
<h3 id="清空环境"><a href="#清空环境" class="headerlink" title="清空环境"></a>清空环境</h3><p>运行测试文件时，truffle提供了一个无尘室环境。在针对<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>或Truffle Develop 运行测试时，Truffle将使用高级快照功能来确保您的测试文件不会彼此共享状态。当与其他以太坊客户一起运行时，Truffle将在每个测试文件开始时重新部署所有迁移，以确保您拥有一组新的测试合约。</p>
<h3 id="速度和可靠性考虑"><a href="#速度和可靠性考虑" class="headerlink" title="速度和可靠性考虑"></a>速度和可靠性考虑</h3><p>运行自动化测试时，Ganache和Truffle Develop比其他客户快得多。此外，它们还包含Truffle利用其特殊功能将测试运行时间提高近90％。作为一个通用的工作流程，我们建议您在正常开发和测试过程中使用Ganache或Truffle Develop，然后在您准备部署到现场或生产网络时，针对以太坊或其他官方Ethereum客户端运行一次测试。</p>
<h2 id="在JavaScript中编写测试"><a href="#在JavaScript中编写测试" class="headerlink" title="在JavaScript中编写测试"></a>在JavaScript中编写测试</h2><p>Truffle使用<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>测试框架和<a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a>进行断言，为您提供一个可编写JavaScript测试的可靠框架。让我们深入了解Truffle如何在Mocha上建立轻松您的合同的测试。</p>
<p><b style="color:#6ab0de">注意：如果您不熟悉在Mocha中编写单元测试，请在继续之前参阅<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha的文档</a>。</b></p>
<h3 id="使用CONTRACT-取代DESCRIBE"><a href="#使用CONTRACT-取代DESCRIBE" class="headerlink" title="使用CONTRACT()取代DESCRIBE()"></a>使用CONTRACT()取代DESCRIBE()</h3><p>在结构上，你的测试应该与Mocha的测试基本保持不变：你的测试应该存在于<code>./test</code>目录中，它们应该以<code>.js</code>扩展名结尾，并且它们应该包含Mocha将认为是自动化测试的代码。什么使truffle测试不同于Mocha的测试是<code>contract()</code>函数：该函数的工作原理与<code>describe()</code>相同，只是没有Truffle无尘室功能。它是这样工作的：</p>
<ul>
<li>在每个<code>contract()</code>函数运行之前，您的合约将重新部署到正在运行的以太坊客户端，以便其中的测试以干净的合约状态运行。</li>
<li>该<code>contract()</code>函数提供了您的以太坊客户端提供的账户列表，您可以使用它来编写测试。</li>
</ul>
<p><b style="color:#6ab0de">由于Truffle在发动机罩下使用了Mocha，因此<code>describe()</code>只要不需要松露清洁室功能，您仍然可以使用它来运行正常的Mocha测试。</b></p>
<h3 id="在测试中使用合约抽象"><a href="#在测试中使用合约抽象" class="headerlink" title="在测试中使用合约抽象"></a>在测试中使用合约抽象</h3><p>合约抽象是通过JavaScript实现合约交互的基础（它们基本上就是我们的助熔电容器）。由于truffle无法检测到在测试中需要与哪些合约进行交互，因此您需要明确要求这些合约。您可以通过使用<code>artifacts.require()</code>方法来做到这一点，该方法是由Truffle提供的一种方法，允许您为特定的Solidity合约请求可用的合约抽象。正如你在下面的例子中看到的那样，你可以使用这个抽象来确保你的合约正常工作。</p>
<p>有关使用合同抽象的更多信息，请参阅<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">与您的合同交互</a>一节。</p>
<h3 id="使用ARTIFACTS-REQUIRE"><a href="#使用ARTIFACTS-REQUIRE" class="headerlink" title="使用ARTIFACTS.REQUIRE()"></a>使用ARTIFACTS.REQUIRE()</h3><p>测试中使用<code>artifacts.require()</code>的工作方式与您在迁移中使用它是一样的; 你只需要通过合约的名称。有关详细用法，请参阅<a href="http://truffleframework.com/docs/getting_started/migrations#artifacts-require-" target="_blank" rel="noopener">artifacts.require()</a>的文档。</p>
<h3 id="使用web3"><a href="#使用web3" class="headerlink" title="使用web3"></a>使用web3</h3><p>每个测试文件都有一个<code>web3</code>实例，配置为正确的提供者。所以调用<code>web3.eth.getBalance</code>就行了！</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="使用-THEN"><a href="#使用-THEN" class="headerlink" title="使用.THEN"></a>使用<code>.THEN</code></h4><p>这是<a href="http://truffleframework.com/boxes/metacoin" target="_blank" rel="noopener">MetaCoin Truffle Box</a>中提供的一个示例测试。请注意使用该<code>contract()</code>函数，该<code>accounts</code>数组用于指定可用的以太坊帐户，以及我们使用<code>artifacts.require()</code>直接与我们的合同进行交互。</p>
<p>文件：<code>./test/metacoin.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">var MetaCoin = artifacts.require(&quot;./MetaCoin.sol&quot;);</span><br><span class="line"></span><br><span class="line">contract(&apos;MetaCoin&apos;, function(accounts) &#123;</span><br><span class="line">  it(&quot;should put 10000 MetaCoin in the first account&quot;, function() &#123;</span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      return instance.getBalance.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      assert.equal(balance.valueOf(), 10000, &quot;10000 wasn&apos;t in the first account&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should call a function that depends on a linked library&quot;, function() &#123;</span><br><span class="line">    var meta;</span><br><span class="line">    var metaCoinBalance;</span><br><span class="line">    var metaCoinEthBalance;</span><br><span class="line"></span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      return meta.getBalance.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(outCoinBalance) &#123;</span><br><span class="line">      metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">      return meta.getBalanceInEth.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(outCoinBalanceEth) &#123;</span><br><span class="line">      metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">      assert.equal(metaCoinEthBalance, 2 * metaCoinBalance, &quot;Library function returned unexpected function, linkage may be broken&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should send coin correctly&quot;, function() &#123;</span><br><span class="line">    var meta;</span><br><span class="line"></span><br><span class="line">    // Get initial balances of first and second account.</span><br><span class="line">    var account_one = accounts[0];</span><br><span class="line">    var account_two = accounts[1];</span><br><span class="line"></span><br><span class="line">    var account_one_starting_balance;</span><br><span class="line">    var account_two_starting_balance;</span><br><span class="line">    var account_one_ending_balance;</span><br><span class="line">    var account_two_ending_balance;</span><br><span class="line"></span><br><span class="line">    var amount = 10;</span><br><span class="line"></span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      return meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_one_starting_balance = balance.toNumber();</span><br><span class="line">      return meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_two_starting_balance = balance.toNumber();</span><br><span class="line">      return meta.sendCoin(account_two, amount, &#123;from: account_one&#125;);</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">      return meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_one_ending_balance = balance.toNumber();</span><br><span class="line">      return meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&apos;t correctly taken from the sender&quot;);</span><br><span class="line">      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&apos;t correctly sent to the receiver&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个测试会输出下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Contract: MetaCoin</span><br><span class="line">  √ should put 10000 MetaCoin in the first account (83ms)</span><br><span class="line">  √ should call a function that depends on a linked library (43ms)</span><br><span class="line">  √ should send coin correctly (122ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 passing (293ms)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ASYNC-AWAIT"><a href="#使用ASYNC-AWAIT" class="headerlink" title="使用ASYNC/AWAIT"></a>使用ASYNC/AWAIT</h3><p>这里是一个相似的实例，但是是使用<a href="https://javascript.info/async-await" target="_blank" rel="noopener">async/await</a>符号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const MetaCoin = artifacts.require(&quot;MetaCoin&quot;);</span><br><span class="line"></span><br><span class="line">contract(&apos;2nd MetaCoin test&apos;, async (accounts) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;should put 10000 MetaCoin in the first account&quot;, async () =&gt; &#123;</span><br><span class="line">     let instance = await MetaCoin.deployed();</span><br><span class="line">     let balance = await instance.getBalance.call(accounts[0]);</span><br><span class="line">     assert.equal(balance.valueOf(), 10000);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(&quot;should call a function that depends on a linked library&quot;, async () =&gt; &#123;</span><br><span class="line">    let meta = await MetaCoin.deployed();</span><br><span class="line">    let outCoinBalance = await meta.getBalance.call(accounts[0]);</span><br><span class="line">    let metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">    let outCoinBalanceEth = await meta.getBalanceInEth.call(accounts[0]);</span><br><span class="line">    let metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    assert.equal(metaCoinEthBalance, 2 * metaCoinBalance);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should send coin correctly&quot;, async () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // Get initial balances of first and second account.</span><br><span class="line">    let account_one = accounts[0];</span><br><span class="line">    let account_two = accounts[1];</span><br><span class="line"></span><br><span class="line">    let amount = 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let instance = await MetaCoin.deployed();</span><br><span class="line">    let meta = instance;</span><br><span class="line"></span><br><span class="line">    let balance = await meta.getBalance.call(account_one);</span><br><span class="line">    let account_one_starting_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_two);</span><br><span class="line">    let account_two_starting_balance = balance.toNumber();</span><br><span class="line">    await meta.sendCoin(account_two, amount, &#123;from: account_one&#125;);</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_one);</span><br><span class="line">    let account_one_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_two);</span><br><span class="line">    let account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&apos;t correctly taken from the sender&quot;);</span><br><span class="line">    assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&apos;t correctly sent to the receiver&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这个测试将产生与前面例子相同的输出。</p>
<h3 id="指定测试"><a href="#指定测试" class="headerlink" title="指定测试"></a>指定测试</h3><p>您可以限制特定文件执行的测试，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle test ./test/metacoin.js</span><br></pre></td></tr></table></figure></p>
<p>有关更多信息，请参阅完整的<a href="http://truffleframework.com/docs/advanced/commands#test" target="_blank" rel="noopener">命令</a>参考。</p>
<h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>truffle可以让你访问Mocha的配置，这样你就可以改变Mocha的行为方式。请参阅<a href="http://truffleframework.com/docs/advanced/configuration#mocha" target="_blank" rel="noopener">项目配置</a>部分了解更多详情。</p>
<h2 id="在SOLIDITY中编写测试"><a href="#在SOLIDITY中编写测试" class="headerlink" title="在SOLIDITY中编写测试"></a>在SOLIDITY中编写测试</h2><p>solidity测试合约与Javascript测试一起作为<code>.sol</code>文件存在。当<code>truffle test</code>运行时，它们将被包括作为每个测试合约单独的测试套件。这些合约保留了Javascript测试的所有好处：即每个测试套件都有一个<a href="http://truffleframework.com/docs/getting_started/testing#clean-room-environment" target="_blank" rel="noopener">洁净室环境</a>，可直接访问已部署的合约以及导入任何合约依赖关系的能力。除了这些特性外，Truffle的Solidity测试框架的构建还考虑到以下问题：</p>
<ul>
<li>solidity测试不应该来自任何合约（如Test合约）。这使您的测试尽可能最小化，并让您完全控制您编写的合约。</li>
<li>solidity测试不应受任何断言库的影响。truffle为您提供了一个默认的断言库，但您可以随时更改此库以符合您的需求。</li>
<li>您应该能够针对任何Ethereum客户端运行您的Solidity测试。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在深入探索之前，我们来看一个示例Solidity测试。以下是通过<code>truffle unbox metacoin</code>为您提供的示例Solidity测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;</span><br><span class="line">import &quot;../contracts/MetaCoin.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestMetacoin &#123;</span><br><span class="line">  function testInitialBalanceUsingDeployedContract() &#123;</span><br><span class="line">    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());</span><br><span class="line"></span><br><span class="line">    uint expected = 10000;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testInitialBalanceWithNewMetaCoin() &#123;</span><br><span class="line">    MetaCoin meta = new MetaCoin();</span><br><span class="line"></span><br><span class="line">    uint expected = 10000;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test</span><br><span class="line">Compiling ConvertLib.sol...</span><br><span class="line">Compiling MetaCoin.sol...</span><br><span class="line">Compiling truffle/Assert.sol</span><br><span class="line">Compiling truffle/DeployedAddresses.sol</span><br><span class="line">Compiling ../test/TestMetacoin.sol...</span><br><span class="line"></span><br><span class="line">  TestMetacoin</span><br><span class="line">    ✓ testInitialBalanceUsingDeployedContract (61ms)</span><br><span class="line">    ✓ testInitialBalanceWithNewMetaCoin (69ms)</span><br><span class="line"></span><br><span class="line">  2 passing (3s)</span><br></pre></td></tr></table></figure></p>
<h3 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h3><p>为了更好地理解发生了什么，让我们更详细地讨论一些事情。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>您的断言功能就像<code>Assert.equal()</code>通过<code>truffle/Assert.sol</code>库提供给你。这是默认的断言库，但是只要库通过触发正确的断言事件而松散地与Truffle的测试运行器集成，就可以包含自己的断言库。你可以在<a href="https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol" target="_blank" rel="noopener">Assert.sol</a>中找到所有可用的断言函数。</p>
<h4 id="部署的地址"><a href="#部署的地址" class="headerlink" title="部署的地址"></a>部署的地址</h4><p>您部署的合约的地址（即作为迁移一部分部署的合约）可通过<code>truffle/DeployedAddresses.sol</code>库获得。这是由Truffle提供的，并且在每个套件运行之前重新编译并重新链接，以便为您的测试提供Truffle的洁净室环境。该库为所有已部署的合约提供函数，形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeployedAddresses.&lt;contract name&gt;();</span><br></pre></td></tr></table></figure></p>
<p>这将返回一个地址，然后您可以使用该地址访问该合约。请参阅上面的示例测试了解使用情况。</p>
<p>为了使用已部署的合约，您必须将合约代码导入到测试套件中。注意示例中的<code>import &quot;../contracts/MetaCoin.sol&quot;;</code>。此导入与<code>./test</code>目录中存在的测试合约相关，并且它位于测试目录之外以便查找MetaCoin合约。然后它使用该合约将该地址转换为<code>MetaCoin</code>类型。</p>
<h3 id="测试合约名称"><a href="#测试合约名称" class="headerlink" title="测试合约名称"></a>测试合约名称</h3><p>所有测试合同必须<code>Test</code>开头，<code>t</code>为大写字母<code>T</code>。这与测试助手和项目合约（即被测合约）区别开来，让测试运行人员知道哪些合约代表测试套件。</p>
<h3 id="测试函数的名称"><a href="#测试函数的名称" class="headerlink" title="测试函数的名称"></a>测试函数的名称</h3><p>与测试合约名称一样，所有测试函数都必须以test小写字母开头。每个测试函数都按单个交易执行，按测试文件中的指定顺序（如Javascript测试）执行。由<code>truffle/Assert.sol</code>测试运行程序评估以确定测试结果的触发事件提供的断言函数。断言函数返回一个表示断言结果的布尔值，您可以使用它来尽早从测试中返回以防止执行错误（例如，<a href="http://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>或Truffle Develop将会公开的错误）。</p>
<h3 id="Before-After钩子"><a href="#Before-After钩子" class="headerlink" title="Before/After钩子"></a>Before/After钩子</h3><p>提供了许多测试钩子，如下例所示。这些钩子是<code>beforeAll</code>，<code>beforeEach</code>，<code>afterAll</code>和<code>afterEach</code>;你的Javascript测试中由Mocha提供的相同钩子。您可以使用这些钩子在每次测试之前和之后，或每个套件运行之前和之后执行设置和拆卸操作。像测试函数一样，每个钩子都作为单个交易执行。请注意，一些复杂的测试需要执行大量的设置，这可能会溢出单个交易的gas限制; 您可以通过创建具有不同后缀的多个钩子来解决此限制，如下例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestHooks &#123;</span><br><span class="line">  uint someValue;</span><br><span class="line"></span><br><span class="line">  function beforeEach() &#123;</span><br><span class="line">    someValue = 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function beforeEachAgain() &#123;</span><br><span class="line">    someValue += 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testSomeValueIsSix() &#123;</span><br><span class="line">    uint expected = 6;</span><br><span class="line"></span><br><span class="line">    Assert.equal(someValue, expected, &quot;someValue should have been 6&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该测试合约还显示您的测试函数和钩子函数都共享相同的合约状态。您可以在测试之前设置合约数据，在测试过程中使用该数据，然后重新设置数据以便下一个测试。请注意，就像您的Javascript测试一样，您的下一个测试函数将从之前运行的测试函数的状态继续。</p>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>Solidity测试具有一些高级功能，可以让您测试Solidity中的特定用例。</p>
<h4 id="测试例外情况"><a href="#测试例外情况" class="headerlink" title="测试例外情况"></a>测试例外情况</h4><p>您可以轻松测试您的合同是否应该引发异常（例如，针对<code>require()</code>/ <code>assert()</code>/ <code>revert()</code>语句; 以前版本的Solidity会<code>throw</code>）。</p>
<p>这个主题首先由作者Simon de la Rouviere在他的教程“<a href="http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests" target="_blank" rel="noopener">松露固体测试中的投掷测试</a>”中撰写。N.B.的教程中大量使用通过过时的关键字<code>throw</code>,，从Solidity v0.4.13开始, 取而代之的是<code>revert()</code>，<code>require()</code>和<code>assert()</code>。</p>
<h4 id="测试以太网交易"><a href="#测试以太网交易" class="headerlink" title="测试以太网交易"></a>测试以太网交易</h4><p>您还可以测试您的合同如何对接收Ether做出反应，并在Solidity中编写该交互的脚本。要做到这一点，你的Solidity测试应该有一个返回一个uint叫做<code>initialBalance</code>的公共函数。这可以直接写成函数或公共变量，如下所示。当您的测试合同被部署到网络中时，truffle会向您的测试合同的测试账户中的发送这一数量的以太币。然后，您的测试合约可以使用该以太网币来与您的合约测试中的以太网交互。请注意，这<code>initialBalance</code>是可选的，不是必需的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;</span><br><span class="line">import &quot;../contracts/MyContract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestContract &#123;</span><br><span class="line">  // Truffle will send the TestContract one Ether after deploying the contract.</span><br><span class="line">  uint public initialBalance = 1 ether;</span><br><span class="line"></span><br><span class="line">  function testInitialBalanceUsingDeployedContract() &#123;</span><br><span class="line">    MyContract myContract = MyContract(DeployedAddresses.MyContract());</span><br><span class="line"></span><br><span class="line">    // perform an action which sends value to myContract, then assert.</span><br><span class="line">    myContract.send(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function () &#123;</span><br><span class="line">    // This will NOT be executed when Ether is sent. \o/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，Truffle向你的账户发送以太币，但是不会执行fallback函数，因此您仍然可以在您的Solidity测试中使用fallback函数进行高级测试用例。</p>
<h2 id="与你的合约交互"><a href="#与你的合约交互" class="headerlink" title="与你的合约交互"></a>与你的合约交互</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>如果您为了与您的合约进行交互而自己向以太坊网络写入原始请求，您很快就会意识到编写这些请求非常笨重和麻烦。同样，你可能会发现管理状态的每个请求都很复杂。幸运的是，truffle为您处理这一复杂问题，轻松与您的合约进行互动。</p>
<h3 id="读取和写入数据"><a href="#读取和写入数据" class="headerlink" title="读取和写入数据"></a>读取和写入数据</h3><p>以太坊网络区分了将数据写入网络和从中读取数据的区别，这种区别在您编写应用程序的方式中起着重要作用。一般来说，写入数据称为交易（Transaction），而读取数据称为调用（call）。事务和调用的处理方式非常不同，并具有以下特征。</p>
<h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>交易从根本上改变了网络的状态。交易可以像发送以太币到其他账户一样简单，或像执行合约函数或向网络添加新合约一样复杂。交易的定义特征是它写入（或更改）数据。交易使Ether运行成为“gas”，交易需要时间来处理。当您通过交易执行合约的函数时，您不能立即处理该交易，因此无法接收该函数的返回值。一般来说，意图通过交易执行的函数不会返回值; 他们将会返回一个交易ID。所以总之，交易：</p>
<ul>
<li>成本gas（以太币）</li>
<li>改变网络的状态</li>
<li>不会立即处理</li>
<li>不会公开一个返回值（只有一个交易ID）。</li>
</ul>
<h4 id="调用-Call"><a href="#调用-Call" class="headerlink" title="调用 Call"></a>调用 Call</h4><p>另一方面，调用则非常不同。调用可用于在网络上执行代码，但不会永久更改数据。调用可以自由运行，其特征是他们读取数据。当您通过调用执行合约函数时，您将立即收到返回值。总之，调用：</p>
<ul>
<li>是免费的（不花费gas）</li>
<li>不要改变网络的状态</li>
<li>立即处理</li>
<li>将公开一个返回值（hooray！）</li>
</ul>
<p>在交易和调用之间进行选择与决定是要读取数据还是写入数据一样简单。</p>
<h3 id="抽象介绍"><a href="#抽象介绍" class="headerlink" title="抽象介绍"></a>抽象介绍</h3><p>合约抽象是与来自Javascript的以太坊合约进行交互的面包和黄油。简而言之，合约抽象是一种包装代码，可以让您轻松地与合约进行交互，从而让您忘记在引擎盖下执行的许多引擎和齿轮。truffle通过<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle合约</a>模块使用其自己的合约抽象，正是这种合约抽象如下所述。</p>
<p>然而，为了了解合约抽象的有用性，我们首先需要一个合约来谈论。我们将通过<code>truffle unbox metacoin</code>从Truffle Boxes获取MetaCoin合约。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">import &quot;./ConvertLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">// This is just a simple example of a coin-like contract.</span><br><span class="line">// It is not standards compatible and cannot be expected to talk to other</span><br><span class="line">// coin/token contracts. If you want to create a standards-compliant</span><br><span class="line">// token, see: https://github.com/ConsenSys/Tokens. Cheers!</span><br><span class="line"></span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">    mapping (address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">    function MetaCoin() &#123;</span><br><span class="line">        balances[tx.origin] = 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendCoin(address receiver, uint amount) returns(bool sufficient) &#123;</span><br><span class="line">        if (balances[msg.sender] &lt; amount) return false;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Transfer(msg.sender, receiver, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalanceInEth(address addr) returns(uint)&#123;</span><br><span class="line">        return ConvertLib.convert(getBalance(addr),2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance(address addr) returns(uint) &#123;</span><br><span class="line">        return balances[addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本合约有三种方法除了构造函数（<code>sendCoin</code>，<code>getBalanceInEth</code>，和<code>getBalance</code>）。所有三种方法都可以作为交易或调用来执行。</p>
<p>现在让我们来看一看<code>MetaCoinTruffle</code>提供给我们的Javascript对象，就像在<a href="http://truffleframework.com/docs/getting_started/console" target="_blank" rel="noopener">Truffle控制台中</a>提供的那样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Print the deployed version of MetaCoin.</span><br><span class="line">// Note that getting the deployed version requires a promise, hence the .then.</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  console.log(instance);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// outputs:</span><br><span class="line">//</span><br><span class="line">// Contract</span><br><span class="line">// - address: &quot;0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92&quot;</span><br><span class="line">// - allEvents: ()</span><br><span class="line">// - getBalance: ()</span><br><span class="line">// - getBalanceInEth: ()</span><br><span class="line">// - sendCoin: ()</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure></p>
<p>请注意，抽象包含我们合约中存在的完全相同的函数。它还包含指向MetaCoin合约的已部署版本的地址。</p>
<h3 id="执行合约函数"><a href="#执行合约函数" class="headerlink" title="执行合约函数"></a>执行合约函数</h3><p>使用抽象，您可以轻松地在以太坊网络上执行合约函数。</p>
<h4 id="进行交易"><a href="#进行交易" class="headerlink" title="进行交易"></a>进行交易</h4><p>MetaCoin合约上有三项我们可以执行的函数。如果你分析它们中的每一个，你会发现这<code>sendCoin</code>是唯一一个旨在改变网络的函数。<code>sendCoin</code>是从一个帐户“发送”一些元币到下一个，并且这些更改是持续的。</p>
<p>在调用sendCoin时，我们会将其作为交易执行。在下面的例子中，我们将从一个账户向另一个账户发送10个Meta币，以保持网络变化的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line">var account_two = &quot;0xabcd...&quot;; // another address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  return meta.sendCoin(account_two, 10, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(result) &#123;</span><br><span class="line">  // If this callback is called, the transaction was successfully processed.</span><br><span class="line">  alert(&quot;Transaction successful!&quot;)</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有一些有趣的地方：</p>
<ul>
<li>我们直接调用了抽象的函数<code>sendCoin</code>。这将导致默认交易（即写入数据）而不是调用。</li>
<li>当交易成功时，直到交易处理完成才会触发fallback函数。这使工作变得轻松，意味着您不必亲自检查交易状态。</li>
<li>我们通过一个对象作为第三个参数传递给<code>sendCoin</code>。请注意，我们的Solidity合同中的<code>sendCoin</code>函数没有第三个参数。你在上面看到的是一个特殊的对象，它可以作为函数的最后一个参数传递，让你编辑有关交易的特定细节。在这里，我们设置<code>from</code>确保此交易是来自的地址<code>account_one</code>。</li>
</ul>
<h4 id="执行调用"><a href="#执行调用" class="headerlink" title="执行调用"></a>执行调用</h4><p>继续使用MetaCoin，请注意<code>getBalance</code>函数是从网络读取数据的理想选择。它不需要做任何改变，因为它只是返回传递给它的地址的MetaCoin余额。让我们试试看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  return meta.getBalance.call(account_one, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(balance) &#123;</span><br><span class="line">  // If this callback is called, the call was successfully executed.</span><br><span class="line">  // Note that this returns immediately without any waiting.</span><br><span class="line">  // Let&apos;s print the return value.</span><br><span class="line">  console.log(balance.toNumber());</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这里有趣的是：</p>
<ul>
<li>我们必须<code>.call()</code>明确地执行该函数，以让以太坊网络知道我们不打算坚持任何更改。</li>
<li>我们在成功时会收到了返回值而不是交易ID。请注意，因为以太坊网络可以处理非常大的数字，所以我们得到一个<a href="https://github.com/MikeMcl/bignumber.js/" target="_blank" rel="noopener">BigNumber</a>对象，然后我们将其转换为数字。</li>
</ul>
<p><b style="color:#6ab0de">警告：我们将返回值转换为数字，因为在这个例子中数字很小。但是，如果您尝试转换大于Javascript支持的最大整数的BigNumber，则可能会遇到错误或意外行为。</b></p>
<h4 id="捕捉事件"><a href="#捕捉事件" class="headerlink" title="捕捉事件"></a>捕捉事件</h4><p>您的合同可以触发您可以捕获的事件，以更深入地了解您的合约在做什么。处理事件的最简单方法是处理触发事件的交易的结果对象，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line">var account_two = &quot;0xabcd...&quot;; // another address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;  </span><br><span class="line">  return meta.sendCoin(account_two, 10, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(result) &#123;</span><br><span class="line">  // result is an object with the following values:</span><br><span class="line">  //</span><br><span class="line">  // result.tx      =&gt; transaction hash, string</span><br><span class="line">  // result.logs    =&gt; array of decoded events that were triggered within this transaction</span><br><span class="line">  // result.receipt =&gt; transaction receipt object, which includes gas used</span><br><span class="line"></span><br><span class="line">  // We can loop through result.logs to see if we triggered the Transfer event.</span><br><span class="line">  for (var i = 0; i &lt; result.logs.length; i++) &#123;</span><br><span class="line">    var log = result.logs[i];</span><br><span class="line"></span><br><span class="line">    if (log.event == &quot;Transfer&quot;) &#123;</span><br><span class="line">      // We found the event!</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="处理交易结果"><a href="#处理交易结果" class="headerlink" title="处理交易结果"></a>处理交易结果</h4><p>当您进行交易时，您会收到一个<code>result</code>对象，可以为您提供有关交易的丰富信息。具体来说，你会得到以下结果：</p>
<ul>
<li><code>result.tx</code>（字符串） - 交易散列</li>
<li><code>result.logs</code>（数组） - 解码事件（日志）</li>
<li><code>result.receipt</code>（对象） - 交易收据</li>
</ul>
<p>欲了解更多信息，请参阅README中<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle-contract</a>的项目。</p>
<h4 id="向网络添加新的合约"><a href="#向网络添加新的合约" class="headerlink" title="向网络添加新的合约"></a>向网络添加新的合约</h4><p>在上述所有情况下，我们一直在使用已经部署的合约抽象。我们可以使用以下<code>.new()</code>函数将我们自己的版本部署到网络中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MetaCoin.new().then(function(instance) &#123;</span><br><span class="line">  // Print the new address</span><br><span class="line">  console.log(instance.address);</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="在特定地址使用合约"><a href="#在特定地址使用合约" class="headerlink" title="在特定地址使用合约"></a>在特定地址使用合约</h4><p>如果您已经拥有合约地址，则可以创建一个新抽象来表示该地址的合约。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var instance = MetaCoin.at(&quot;0x1234...&quot;);</span><br></pre></td></tr></table></figure></p>
<h4 id="发送以太币到合约"><a href="#发送以太币到合约" class="headerlink" title="发送以太币到合约"></a>发送以太币到合约</h4><p>您可能只想直接将Ether发送给合同，或者触发合同的<a href="http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function" target="_blank" rel="noopener">fallback函数</a>。您可以使用以下两个选项之一来完成此操作。</p>
<p>选项1：通过<code>instance.sendTransaction()</code>直接发送交易给合约。这与所有可用的合约实例函数是一样的，并且与<code>web3.eth.sendTransaction</code>具有相同的API，但没有回调。<code>to</code>的值如果没有指定，该值将自动填入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.sendTransaction(&#123;...&#125;).then(function(result) &#123;</span><br><span class="line">  // Same transaction result object as above.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>选项2：也可以直接发送Ether：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.send(web3.toWei(1, &quot;ether&quot;)).then(function(result) &#123;</span><br><span class="line">  // Same result object as above.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>truffle提供的合同抽象包含丰富的实用工具，可轻松与您的合约进行交互。查看<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">松露合同</a>文档以获得更多建议，技巧和见解。</p>
<h2 id="通过ETHPM进行包管理"><a href="#通过ETHPM进行包管理" class="headerlink" title="通过ETHPM进行包管理"></a>通过ETHPM进行包管理</h2><p>EthPM是以太坊的新<a href="https://www.ethpm.com/" target="_blank" rel="noopener">包注册器</a>。它遵循<a href="https://github.com/ethereum/EIPs/issues/190" target="_blank" rel="noopener">ERC190规范</a>发布和使用智能合约包，并得到了许多不同以太坊开发工具的广泛支持。为了表明我们的支持，我们将以太坊包注册表直接整合到truffle中。</p>
<h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>从EthPM安装一个包就像npm安装包一样简单。你可以直接运行下面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install &lt;package name&gt;</span><br></pre></td></tr></table></figure></p>
<p>你也可以安装指定版本的包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install &lt;package name&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure></p>
<p>和NPM类型，EthPM版本遵从<a href="https://semver.org/" target="_blank" rel="noopener">semver</a>。你可在<a href="https://www.ethpm.com/registry" target="_blank" rel="noopener">Ethereum Package Registry</a>处找到所有可用的包列表。</p>
<h3 id="安装依赖关系"><a href="#安装依赖关系" class="headerlink" title="安装依赖关系"></a>安装依赖关系</h3><p>您的项目可以定义一个<code>ethpm.json</code>文件，其中可以将项目固定到特定的依赖项和版本。要安装<code>ethpm.json</code>文件中列出的所有依赖项，请运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install</span><br></pre></td></tr></table></figure></p>
<p>有关该ethpm.json文件的更多详细信息，请参阅下面的<a href="http://truffleframework.com/docs/getting_started/packages-ethpm#package-configuration" target="_blank" rel="noopener">包配置</a>。</p>
<h3 id="消费（CONSUMING）已安装合约"><a href="#消费（CONSUMING）已安装合约" class="headerlink" title="消费（CONSUMING）已安装合约"></a>消费（CONSUMING）已安装合约</h3><p>安装的软件包将被放置在您的项目文件夹中的<code>installed_contracts</code>目录中。如果没有<code>installed_contracts</code>目录存在，它会为你创建。你应该像对待NPM的<code>node_modules</code>文件夹那样对待这个文件夹 - 也就是说，除非你知道你在做什么，否则你不应该编辑里面的内容。:)</p>
<p>安装的软件包可以在您的测试，迁移和solidity合约文件中使用，通过<code>import</code>,<code>require</code>包或按名称找到的合约。例如，以下Solidity合约将从包<code>owned</code>中导入<code>owned.sol</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">import &quot;owned/owned.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract is owned &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，以下迁移文件将使用包<code>ens</code>中的ENS.sol合约：(文件：<code>./migrations/2_deploy_contracts.js</code>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ENS = artifacts.require(&quot;ens/ENS&quot;);</span><br><span class="line">var MyContract = artifacts.require(&quot;MyContract&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Only deploy ENS if there&apos;s not already an address already.</span><br><span class="line">  // i.e., don&apos;t deploy if we&apos;re using the canonical ENS address,</span><br><span class="line">  // but do deploy it if we&apos;re on a test network and ENS doesn&apos;t exist.</span><br><span class="line">  deployer.deploy(ENS, &#123;overwrite: false&#125;).then(function() &#123;</span><br><span class="line">    return deployer.deploy(MyContract, ENS.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>请注意，在上面的迁移中，我们会根据ENS是否已经设置地址来有条件地使用<code>ens</code>包并部署ENS合约。这是<a href="http://truffleframework.com/docs/getting_started/migrations#deployer-deploy-contract-args-options-" target="_blank" rel="noopener">deployer</a>提供给你的一个奇妙的技巧，它使写入迁移依赖于网络工件的存在变得更加容易。在这种情况下，如果我们在Ropsten网络上运行我们的迁移，则此迁移不会部署该ENS合同，因为（在撰写本文时）Ropsten是规范ENS合同存在的地方 - 我们不想部署我们自己的合约。但是，如果我们正在针对不同的网络或测试网络运行我们的迁移，那么我们想要部署该ENS合约，以便我们有一个依赖合约来处理。</p>
<h3 id="发布你自己的软件包"><a href="#发布你自己的软件包" class="headerlink" title="发布你自己的软件包"></a>发布你自己的软件包</h3><p>发布自己的软件包与安装一样简单，但与NPM一样，需要更多配置。</p>
<h4 id="ROPSTEN"><a href="#ROPSTEN" class="headerlink" title="ROPSTEN"></a>ROPSTEN</h4><p>Ethereum软件包注册表目前存在于Ropsten测试网络中。要发布到注册中心，我们需要建立我们自己的Ropsten配置，因为我们将进行需要签名的交易。</p>
<p>在本例中，我们将使用Infura与NPM<code>truffle-hdwallet-provider</code>模块一起发布软件包以及一个代表Ropsten网络上Ethereum地址的12字钱包助记符。首先，在您的项目目录中通过NPM安装<code>truffle-hdwallet-provider</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install truffle-hdwallet-provider --save</span><br></pre></td></tr></table></figure></p>
<p>然后编辑您的配置，使用12字助记符添加<code>ropsten</code>网络：文件： <code>truffle.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);</span><br><span class="line"></span><br><span class="line">// 12-word mnemonic</span><br><span class="line">var mnemonic = &quot;opinion destroy betray ...&quot;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: &quot;127.0.0.1&quot;,</span><br><span class="line">      port: 8545,</span><br><span class="line">      network_id: &quot;*&quot; // Match any network id</span><br><span class="line">    &#125;,</span><br><span class="line">    ropsten: &#123;</span><br><span class="line">      provider: new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;),</span><br><span class="line">      network_id: 3 // official id of the ropsten network</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="程序包配置"><a href="#程序包配置" class="headerlink" title="程序包配置"></a>程序包配置</h4><p>与NPM类似，EthPM的配置选项位于单独的JSON文件中ethpm.json。此文件与您的Truffle配置并列，并为Truffle发布包装所需的所有信息。您可以在<a href="http://truffleframework.com/docs/advanced/configuration" target="_blank" rel="noopener">配置</a>部分看到可用选项的完整列表。</p>
<p>文件： <code>ethpm.json</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;package_name&quot;: &quot;adder&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.3&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Simple contract to add two numbers&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;ethereum&quot;,</span><br><span class="line">    &quot;addition&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;owned&quot;: &quot;^0.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p>在确定您的配置后，发布很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle publish</span><br></pre></td></tr></table></figure></p>
<p>您会看到类似于下面的输出，并确认您的包已成功发布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ truffle publish</span><br><span class="line">Gathering contracts...</span><br><span class="line">Finding publishable artifacts...</span><br><span class="line">Uploading sources and publishing to registry...</span><br><span class="line">+ adder@0.0.3</span><br></pre></td></tr></table></figure></p>
<h4 id="发布之前"><a href="#发布之前" class="headerlink" title="发布之前"></a>发布之前</h4><p>当使用<code>develop</code>配置为匹配任何Ethereum客户端的默认网络（如Ganache或Truffle Develop）时，您肯定会存在不希望发布到网络中的工件。在发布您的软件包之前，请考虑运行以下命令以删除任何无关的网络工件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle networks --clean</span><br></pre></td></tr></table></figure></p>
<p>有关更多信息，请参阅<a href="http://truffleframework.com/docs/advanced/commands#networks" target="_blank" rel="noopener">命令参考</a>。</p>
<h2 id="通过NPM进行包管理"><a href="#通过NPM进行包管理" class="headerlink" title="通过NPM进行包管理"></a>通过NPM进行包管理</h2><p>Truffle标配npm集成，并且知道node_modules项目中的目录（如果存在）。这意味着您可以通过使用和分发合约，通过npm获取dapps和启用以太坊的库，使您的代码可被自己以及其其他人的代码使用。</p>
<h3 id="包布局"><a href="#包布局" class="headerlink" title="包布局"></a>包布局</h3><p>使用Truffle创建的项目默认具有特定的布局，可以将它们用作包。这种布局不是必需的，但如果用作公共约定 - 或“事实上的标准” - 则通过NPM分发合约和dapps将变得更容易。</p>
<p>truffle套件中最重要的目录如下：</p>
<ul>
<li><code>/contracts</code></li>
<li><code>/build</code>（其中包括<code>/build/contracts</code>由truffle创建的）</li>
</ul>
<p>第一个目录是您的合约目录，其中包含您的原始Solidity合同。第二个目录是构建目录，更具体地说<code>/build/contracts</code>，它以<code>.json</code>文件形式存放构建工件。在你的软件包中包括原始合约将允许其他人在他们自己的solidity代码中导入这些合约。同样，<code>.json</code>在你的包中包含你的构建工件将允许其他人无缝地与你的JavaScript合约交互，这可以在dapps，脚本和迁移中使用。</p>
<h3 id="使用一个包"><a href="#使用一个包" class="headerlink" title="使用一个包"></a>使用一个包</h3><p>在自己的项目中使用软件包时，需要注意的是，有两个地方可能对使用感兴趣的其他合约代码：在您的合约中以及您的Javascript代码（迁移和测试）中。以下提供了每个案例的示例，并讨论了充分利用其他合约并构建工件的技巧。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>在本例中，我们将使用<a href="https://github.com/ConsenSys/example-truffle-library" target="_blank" rel="noopener">truffle示例库</a>，该库提供了一个简单的名称注册，该注册表已部署到Morden测试网络。为了将其用作依赖项，我们必须首先通过npm用以下方式将其安装在我们的项目中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd my_project</span><br><span class="line">$ npm install example-truffle-library</span><br></pre></td></tr></table></figure></p>
<p>请注意，上面的最后一个命令会下载软件包并将它放在<code>my_project/node_modules</code>目录中，这对于下面的示例很重要。请参阅<a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm文档</a>以获取使用npm安装软件包的帮助。</p>
<h4 id="嵌入你的合约"><a href="#嵌入你的合约" class="headerlink" title="嵌入你的合约"></a>嵌入你的合约</h4><p>要在合约中使用包的合约，这可以与Solidity的<a href="http://solidity.readthedocs.io/en/develop/layout-of-source-files.html?#importing-other-source-files" target="_blank" rel="noopener">import</a>声明一样简单。当您的导入路径不是明确的相对或绝对时，这表示您要从特定命名包中查找文件。考虑使用上面提到的示例truffle库的这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;</span><br></pre></td></tr></table></figure></p>
<p>由于路径并未以<code>./</code>开始，Truffle知道要在项目的<code>node_modules</code>目录中查找该<code>example-truffle-library</code>文件夹。从那里，它解决了为您提供您所要求的合约的路径。</p>
<h4 id="嵌入JavaScript代码中"><a href="#嵌入JavaScript代码中" class="headerlink" title="嵌入JavaScript代码中"></a>嵌入JavaScript代码中</h4><p>要在JavaScript代码中与包的合约进行交互，您只需要<code>require</code>包的<code>.json</code>文件，然后使用<a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">truffle-contract</a>模块将这些文件转换为可用的抽象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var contract = require(&quot;truffle-contract&quot;);</span><br><span class="line">var data = require(&quot;example-truffle-library/build/contracts/SimpleNameRegistry.json&quot;);</span><br><span class="line">var SimpleNameRegistry = contract(data);</span><br></pre></td></tr></table></figure></p>
<p>要使用这些抽象概念，请参阅<a href="http://truffleframework.com/docs/getting_started/contracts" target="_blank" rel="noopener">与您的合同交互</a>一节以获取更多详细信息。</p>
<h4 id="包的部署地址"><a href="#包的部署地址" class="headerlink" title="包的部署地址"></a>包的部署地址</h4><p>有时候你希望你的合约与这个包的先前部署的合约进行交互。由于部署的地址存在于包的<code>.json</code>文件中，因此您必须执行额外的步骤才能将这些地址存入您的合约。为此，请使您的合约接受依存关系合约的地址，然后使用迁移。以下是项目中存在的示例合约以及示例迁移：</p>
<p>合约：<code>MyContract.sol</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.13;</span><br><span class="line"></span><br><span class="line">import &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">  SimpleNameRegistry registry;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function MyContract &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Simple example that uses the deployed registry from the package.</span><br><span class="line">  function getModule(bytes32 name) returns (address) &#123;</span><br><span class="line">    return registry.names(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set the registry if you&apos;re the owner.</span><br><span class="line">  function setRegistry(address addr) &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">    registry = SimpleNameRegistry(addr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迁移：<code>3_hook_up_example_library.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Note that artifacts.require takes care of creating an abstraction for us.</span><br><span class="line">var SimpleNameRegistry = artifacts.require(&quot;example-truffle-library/SimpleNameRegistry&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Deploy our contract, then set the address of the registry.</span><br><span class="line">  deployer.deploy(MyContract).then(function() &#123;</span><br><span class="line">    return MyContract.deployed();</span><br><span class="line">  &#125;).then(function(deployed) &#123;</span><br><span class="line">    return deployed.setRegistry(SimpleNameRegistry.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="发布之前-1"><a href="#发布之前-1" class="headerlink" title="发布之前"></a>发布之前</h4><p>当使用develop配置为匹配任何Ethereum客户端的默认网络（如Ganache或Truffle Develop）时，您肯定会在网络中存在不希望发布的工件。在发布您的软件包之前，请考虑运行以下命令以删除任何无关的网络工件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle networks --clean</span><br></pre></td></tr></table></figure></p>
<p>有关更多信息，请参阅<a href="http://truffleframework.com/docs/advanced/commands#networks" target="_blank" rel="noopener">命令参考</a>。</p>
<h2 id="调试您的合约"><a href="#调试您的合约" class="headerlink" title="调试您的合约"></a>调试您的合约</h2><p>truffle包含一个集成的调试器，以便您可以调试对您的合约进行的交易。这个调试器看起来和现有的可用于传统开发环境的命令行调试器相似。</p>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在区块链上调试交易与调试传统应用程序（例如，用C ++或Javascript编写的应用程序）不同。在区块链上调试交易时，您不是实时运行代码; 相反，您正在逐步执行该交易的历史执行，并将该执行映射到其相关代码。这为我们调试提供了许多自由度，因为我们可以在任何时候调试任何交易，只要我们拥有交易交互的合同的代码和工件即可。将这些代码和工件看作类似于传统调试器所需的调试符号。</p>
<p>为了调试交易，您需要以下内容：</p>
<ul>
<li>truffle 4.0或以上。</li>
<li>交易在您想要的区块链上的哈希值。</li>
<li>交易发生的源代码和工件。</li>
</ul>
<p>请注意，如果您希望的交易导致异常情况或用完gas，那也没问题。交易仍然存在于链上，所以你仍然可以调试它！</p>
<h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>要使用调试器，请收集您想要调试的交易，然后运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle debug &lt;transaction hash&gt;</span><br></pre></td></tr></table></figure></p>
<p>以一个交易<code>0x8e5dadfb921dd...</code>开始，该命令如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76</span><br></pre></td></tr></table></figure></p>
<p>这将启动下面描述的调试接口。</p>
<h3 id="调试界面"><a href="#调试界面" class="headerlink" title="调试界面"></a>调试界面</h3><p>启动调试器将打开一个熟悉的调试其他类型应用程序的界面。开始时，您会看到以下内容：</p>
<ul>
<li>在此交易过程中进行交易或创建的地址列表。</li>
<li>使用调试器的可用命令列表。</li>
<li>以及交易的初始入口点，包括合约源文件和代码预览。</li>
</ul>
<p><code>enter</code>键被设置为执行输入的最后一个命令。当调试器启动时，该enter键被设置为步进到在执行期间遇到的下一个逻辑源代码元素（即，由以太坊虚拟机评估的下一个表达式或语句）。此时，您可以按键enter逐步完成交易，或者输入其中一个可用命令来更详细地分析交易。命令列表详述如下。</p>
<h4 id="（O）跨越（Step-Over）"><a href="#（O）跨越（Step-Over）" class="headerlink" title="（O）跨越（Step Over）"></a>（O）跨越（Step Over）</h4><p>此命令遍历当前行，相对于当前在Solidity源文件中正在评估的语句或表达式的位置。如果您不想在当前行中进入函数调用或合约创建，或者想要快速跳转到源文件中的特定点，请使用此命令。</p>
<h4 id="（I）进入-Step-into"><a href="#（I）进入-Step-into" class="headerlink" title="（I）进入(Step into)"></a>（I）进入(Step into)</h4><p>该命令进入当前正在评估的函数调用或合同创建。使用此命令跳转到该函数并快速开始调试那里存在的代码。</p>
<h4 id="（U）走出去-Step-Out"><a href="#（U）走出去-Step-Out" class="headerlink" title="（U）走出去(Step Out)"></a>（U）走出去(Step Out)</h4><p>该命令退出当前正在运行的函数。如果这是交易的入口点，则使用此命令可以快速返回调用函数，或者结束交易的执行。</p>
<h4 id="（N）下一步（STEP-NEXT）"><a href="#（N）下一步（STEP-NEXT）" class="headerlink" title="（N）下一步（STEP NEXT）"></a>（N）下一步（STEP NEXT）</h4><p>该命令转到源代码中的下一个逻辑语句或表达式。例如，在虚拟机可以评估完整表达式之前，需要先评估子表达式。如果您想分析虚拟机评估的每个逻辑项，请使用此命令。</p>
<h4 id="（-）步指令"><a href="#（-）步指令" class="headerlink" title="（;）步指令"></a>（;）步指令</h4><p>该命令允许您逐步查看虚拟机评估的每条单独指令。如果您有兴趣了解由Solidity源代码创建的低级别字节码，这非常有用。当你使用这个命令时，调试器在评估指令时也会打印出栈数据。</p>
<h4 id="（P）打印指令"><a href="#（P）打印指令" class="headerlink" title="（P）打印指令"></a>（P）打印指令</h4><p>该命令打印当前的指令和堆栈数据，但不会进入下一条指令。如果希望在使用上述逻辑命令浏览交易后查看当前指令和堆栈数据，请使用此选项。</p>
<h4 id="（H）打印此帮助"><a href="#（H）打印此帮助" class="headerlink" title="（H）打印此帮助"></a>（H）打印此帮助</h4><p>打印可用命令的列表。</p>
<h4 id="（Q）退出"><a href="#（Q）退出" class="headerlink" title="（Q）退出"></a>（Q）退出</h4><p>退出调试器。</p>
<h2 id="使用Truffle开发和控制台"><a href="#使用Truffle开发和控制台" class="headerlink" title="使用Truffle开发和控制台"></a>使用Truffle开发和控制台</h2><p>有时，为了测试和调试目的，或者手工执行交易，交互式地处理您的合约是很好的。Truffle为您提供了两种通过交互式控制台执行此操作的简单方法，您的合约可供使用并随时可用。</p>
<ul>
<li>Truffle控制台：连接到任何以太坊客户端的基本交互式控制台</li>
<li>Truffle开发：交互式控制台，也产生一个发展区块链</li>
</ul>
<h3 id="为啥是两个不同的控制台？"><a href="#为啥是两个不同的控制台？" class="headerlink" title="为啥是两个不同的控制台？"></a>为啥是两个不同的控制台？</h3><p>拥有两个不同的控制台可让您根据自己的需求选择最佳工具。</p>
<p>使用Truffle控制台的理由：</p>
<ul>
<li>你有一个你已经使用的客户端，如Ganache或geth</li>
<li>你想迁移到测试网络（或以太坊网络）</li>
<li>您想要使用特定的助记符或帐户列表</li>
</ul>
<p>使用Truffle Develop的原因：</p>
<ul>
<li>您正在测试您的项目，无意立即部署</li>
<li>您无需使用特定帐户（并且使用默认开发帐户即可）</li>
<li>您不想安装和管理单独的区块链客户端</li>
</ul>
<h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><p>所有你需要的命令都在你的项目文件夹中。你不需要在根目录。</p>
<h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>启动控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle console</span><br></pre></td></tr></table></figure></p>
<p>这将查找在配置中称为<code>development</code>的网络定义，并连接到它（如果可用）。您可以使用该<code>--network &lt;name&gt;</code>选项覆盖此选项。在<a href="http://truffleframework.com/docs/advanced/networks" target="_blank" rel="noopener">“网络”</a>部分以及<a href="http://truffleframework.com/docs/advanced/commands" target="_blank" rel="noopener">命令参考</a>中查看更多详细信息。</p>
<p>当您加载控制台时，您会立即看到以下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle(development)&gt;</span><br></pre></td></tr></table></figure></p>
<p>这告诉你你正在使用d<code>evelopment</code>网络在Truffle控制台中运行。</p>
<h4 id="TRUFFLE-DEVELOP"><a href="#TRUFFLE-DEVELOP" class="headerlink" title="TRUFFLE DEVELOP"></a>TRUFFLE DEVELOP</h4><p>启动TRUFFLE DEVELOP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure></p>
<p>无论您的<code>truffle.js</code>配置文件需要什么，这将在端口<code>9545</code>上本地产生一个开发区块链。</p>
<p>当你启动了TRUFFLE DEVELOP，你会看到以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Truffle Develop started at http://localhost:9545/</span><br><span class="line"></span><br><span class="line">Accounts:</span><br><span class="line">(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57</span><br><span class="line">(1) 0xf17f52151ebef6c7334fad080c5704d77216b732</span><br><span class="line">(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef</span><br><span class="line">(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544</span><br><span class="line">(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2</span><br><span class="line">(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e</span><br><span class="line">(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5</span><br><span class="line">(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5</span><br><span class="line">(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc</span><br><span class="line">(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de</span><br><span class="line"></span><br><span class="line">Private Keys:</span><br><span class="line">(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3</span><br><span class="line">(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f</span><br><span class="line">(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1</span><br><span class="line">(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c</span><br><span class="line">(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418</span><br><span class="line">(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63</span><br><span class="line">(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8</span><br><span class="line">(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7</span><br><span class="line">(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4</span><br><span class="line">(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5</span><br><span class="line"></span><br><span class="line">Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure></p>
<p>这会向您显示此特定区块链的地址，私钥和助记符。</p>
<p><b style="color:#6ab0de">注意：助记符和地址不能更改。如果您想使用不同的助记符或一组地址，我们推荐使用Ganache。</b></p>
<p><b style="color:#c7254e">警告：切记不要使用这些地址或主网上的助记符。这仅用于开发。</b></p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>Truffle Develop和控制台都提供了Truffle命令行工具中的大部分功能。例如，您可以在控制台中输入内容<code>migrate --reset</code>，并将其解释为与在命令行上运行<code>truffle migrate --reset</code>时相同。</p>
<p>此外，Truffle Develop和控制台还具有以下特点：</p>
<ul>
<li>你所有的编译合约都可以使用。</li>
<li>在每个命令（例如<code>migrate --reset</code>）您的合同被重新配置后，您可以立即开始使用新分配的地址和二进制文件。</li>
<li>该<code>web3</code>库已经可用，并已设置为连接到您的以太坊客户端。</li>
<li>所有返回承诺的命令都会自动解析，并打印结果，不需要为简单的命令使用<code>.then()</code>。例如，以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyContract.at(&quot;0xabcd...&quot;).getValue.call();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>会返回类似如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h3 id="可用的命令"><a href="#可用的命令" class="headerlink" title="可用的命令"></a>可用的命令</h3><ul>
<li><code>build</code></li>
<li><code>compile</code></li>
<li><code>create</code></li>
<li><code>debug</code></li>
<li><code>exec</code></li>
<li><code>install</code></li>
<li><code>migrate</code></li>
<li><code>networks</code></li>
<li><code>opcode</code></li>
<li><code>publish</code></li>
<li><code>test</code></li>
<li><code>version</code></li>
</ul>
<p>如果truffle命令不可用，那是因为它与现有项目无关（例如<code>init</code>）或者没有意义（例如<code>develop</code>或<code>console</code>）。</p>
<p>查看完整的<a href="http://truffleframework.com/docs/advanced/commands" target="_blank" rel="noopener">命令参考</a>了解更多信息。</p>
<h2 id="编写外部脚本"><a href="#编写外部脚本" class="headerlink" title="编写外部脚本"></a>编写外部脚本</h2><p>通常您可能想要运行与您的合同交互的外部脚本。truffle提供了一种简单的方法来实现这一点，根据您所需的网络引导您的合同，并根据您的<a href="http://truffleframework.com/docs/advanced/configuration" target="_blank" rel="noopener">项目配置</a>自动连接到您的以太坊客户端。</p>
<h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><p>要运行外部脚本，请执行以下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle exec &lt;path/to/file.js&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>为了使外部脚本正确运行，<code>Truffle</code>期望它们导出一个函数，该函数唯一的参数作为回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(callback) &#123;</span><br><span class="line">  // perform actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要在脚本结束时调用回调函数，就可以在该脚本中执行任何您想要的操作。回调接受一个错误作为它的第一个也是唯一的参数。如果提供了错误，执行将暂停并且该进程将返回非零退出代码。</p>
<h2 id="使用构建管道"><a href="#使用构建管道" class="headerlink" title="使用构建管道"></a>使用构建管道</h2><p>Truffle 1.0和2.0标准的默认构建系统主要面向Web应用程序（这里，术语“构建”意味着将代码工件转换为HTML，Javascript和CSS）。该构建系统已被引入<a href="https://github.com/trufflesuite/truffle-default-builder/tree/master" target="_blank" rel="noopener">自己的模块</a>，使Truffle可用于各种应用并可扩展。</p>
<p>Truffle可以配置为与任何构建系统紧密集成。要配置自定义生成系统，请参阅<a href="http://truffleframework.com/docs/advanced/build_processes" target="_blank" rel="noopener">高级生成过程</a>部分以获取更多详细信息。</p>
<h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><p>要在构建系统时编译应用程序，请运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle build</span><br></pre></td></tr></table></figure></p>
<p>请注意，如果您尝试在未首先配置自定义构建过程的情况下运行<code>build</code>命令，则会收到错误。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/09/blockchain/solidity内联装配通用语言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/09/blockchain/solidity内联装配通用语言/" itemprop="url">solidity内联装配通用语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-09T10:14:10+08:00">2018-04-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">JULIA是一种可以编译到各种不同后端的中间语言（EVM1.0，EVM 1.5和eWASM正在计划中）。正因为如此，它被设计为所有三个平台均可用。它已经可以用于Solidity内部的“内联汇编”，并且未来版本的Solidity编译器甚至将JULIA用作中间语言。为JULIA构建高级优化器阶段也应该很容易。</b></p>
<p><b style="color:#6ab0de">注意:请注意，用于“内联汇编”的风格不具有类型（所有内容均是<code>u256</code>类型），并且内置函数与EVM操作码相同。有关详细信息，请参阅内联汇编文档。</b></p>
<p>JULIA的核心组件是函数，语句块，变量，文本（literals），for循环，if语句，switch语句，表达式和变量赋值。</p>
<p>JULIA是类型化的，变量和文字（Literals）都必须用后缀表示法指定类型。支持的类型有<code>bool</code>，<code>u8</code>，<code>s8</code>，<code>u32</code>，<code>s32</code>， <code>u64</code>，<code>s64</code>，<code>u128</code>，<code>s128</code>，<code>u256</code>和<code>s256</code>。</p>
<p>JULIA本身甚至不提供操作符。如果EVM是运行目标，则操作码将以内置函数提供，但如果后端更改，则可以重新实现它们。有关强制性内置函数的列表，请参阅下面的部分。</p>
<p>下面的示例程序假定EVM操作码<code>mul</code>，<code>div</code>和<code>mod</code>可以本地或者作为函数可用并计算求幂。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base:u256, exponent:u256) -&gt; result:u256</span><br><span class="line">    &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0:u256 &#123; result := 1:u256 &#125;</span><br><span class="line">        case 1:u256 &#123; result := base &#125;</span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2:u256))</span><br><span class="line">            switch mod(exponent, 2:u256)</span><br><span class="line">                case 1:u256 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以使用for循环而不是递归来实现相同的函数。在这里，我们需要EVM操作码<code>lt</code>（小于）和<code>add</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base:u256, exponent:u256) -&gt; result:u256</span><br><span class="line">    &#123;</span><br><span class="line">        result := 1:u256</span><br><span class="line">        for &#123; let i := 0:u256 &#125; lt(i, exponent) &#123; i := add(i, 1:u256) &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            result := mul(result, base)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="JULIA规格"><a href="#JULIA规格" class="headerlink" title="JULIA规格"></a>JULIA规格</h2><p>本章介绍JULIA代码。JULIA代码通常放置在JULIA对象中，将在下一章中介绍。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement =</span><br><span class="line">    Block |</span><br><span class="line">    FunctionDefinition |</span><br><span class="line">    VariableDeclaration |</span><br><span class="line">    Assignment |</span><br><span class="line">    Expression |</span><br><span class="line">    Switch |</span><br><span class="line">    ForLoop |</span><br><span class="line">    BreakContinue</span><br><span class="line">FunctionDefinition =</span><br><span class="line">    &apos;function&apos; Identifier &apos;(&apos; TypedIdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; TypedIdentifierList )? Block</span><br><span class="line">VariableDeclaration =</span><br><span class="line">    &apos;let&apos; TypedIdentifierList ( &apos;:=&apos; Expression )?</span><br><span class="line">Assignment =</span><br><span class="line">    IdentifierList &apos;:=&apos; Expression</span><br><span class="line">Expression =</span><br><span class="line">    FunctionCall | Identifier | Literal</span><br><span class="line">If =</span><br><span class="line">    &apos;if&apos; Expression Block</span><br><span class="line">Switch =</span><br><span class="line">    &apos;switch&apos; Expression Case* ( &apos;default&apos; Block )?</span><br><span class="line">Case =</span><br><span class="line">    &apos;case&apos; Literal Block</span><br><span class="line">ForLoop =</span><br><span class="line">    &apos;for&apos; Block Expression Block Block</span><br><span class="line">BreakContinue =</span><br><span class="line">    &apos;break&apos; | &apos;continue&apos;</span><br><span class="line">FunctionCall =</span><br><span class="line">    Identifier &apos;(&apos; ( Expression ( &apos;,&apos; Expression )* )? &apos;)&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">TypeName = Identifier | BuiltinTypeName</span><br><span class="line">BuiltinTypeName = &apos;bool&apos; | [us] ( &apos;8&apos; | &apos;32&apos; | &apos;64&apos; | &apos;128&apos; | &apos;256&apos; )</span><br><span class="line">TypedIdentifierList = Identifier &apos;:&apos; TypeName ( &apos;,&apos; Identifier &apos;:&apos; TypeName )*</span><br><span class="line">Literal =</span><br><span class="line">    (NumberLiteral | StringLiteral | HexLiteral | TrueLiteral | FalseLiteral) &apos;:&apos; TypeName</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">TrueLiteral = &apos;true&apos;</span><br><span class="line">FalseLiteral = &apos;false&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure></p>
<h3 id="对语法的限制"><a href="#对语法的限制" class="headerlink" title="对语法的限制"></a>对语法的限制</h3><p>Switches必须至少有一个case（包括默认case）。如果表达式的所有可能值都被覆盖了，那么就不应该允许使用默认情况（例如，一个带有bool表达式的开关，同时具有true和false的情况下不应允许默认情况）。</p>
<p>每个表达式都计算为零个或多个值。标识符和文字只计算一个值，函数调用计算的值等于所调用函数的返回值。</p>
<p>在变量声明和赋值中，右侧表达式（如果存在）必须计算出与左侧变量数量相等的许多值。这是唯一允许评估多个值的表达式。</p>
<p>也是语句的表达式（例如语句块级别的）必须评估为零值。</p>
<p>在所有其他情况下，表达式必须评估为恰好一个值。</p>
<p><code>continue</code>和<code>break</code>语句只能在循环体内部使用和必须在相同的函数的循环（或两者都必须在顶层）。<code>for-loop</code>的条件部分必须评估到一个值。</p>
<p>文字(Literals)不能大于他们的类型。定义的最大类型是256位宽。</p>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>JULIA中的作用域与语句块相关（例外是函数和for循环，如下所述），所有声明（<code>FunctionDefinition</code>，<code>VariableDeclaration</code>）都将新标识符引入到这些作用域中。</p>
<p>标识符在其定义的语句块中（包括所有子节点和子语句块）中都可见。作为例外，for循环（第一个块）的“init”部分中定义的标识符在for循环的所有其他部分（但不在循环之外）中都是可见的。在for循环的其他部分声明的标识符遵守常规的作用域范围规则。函数的参数和返回参数在函数体中可见，并且它们的名称不能重叠。</p>
<p>变量只能在声明后引用。特别是变量不能在自己的变量声明的右边引用。函数可以在声明之前被引用（如果它们是可见的）。</p>
<p>阴影是不允许的，也就是说，即使不可访问，也不能在另一个具有相同名称的标识符可见的位置声明标识符。（也就是同名变量不能存在）</p>
<p>在函数内部，不可能访问在该函数之外声明的变量。</p>
<h3 id="形式规范"><a href="#形式规范" class="headerlink" title="形式规范"></a>形式规范</h3><p>我们通过在AST的各个节点上提供评估重载函数E来正式指定JULIA。任何函数都可能有副作用，所以E需要两个状态对象和AST节点，并返回两个新的状态对象和可变数量的其他值。这两个状态对象是全局状态对象（在EVM的上下文中是区块链的内存，存储和状态）和本地状态对象（局部变量的状态，即EVM中堆栈的一部分） 。如果AST节点是一个语句，E将返回两个状态对象和一个用于<code>break</code>和<code>continue</code>语句的“模式” 。如果AST节点是表达式，则E返回两个状态对象，并返回与表达式计算结果相同的值。</p>
<p>对于这个高层次的描述，全局状态的确切性质并没有说明。本地状态<code>L</code>是标识符<code>i</code>到值<code>v</code>的映射，表示为<code>L[i] = v</code>。</p>
<p>对于标识符<code>v</code>，让<code>$v</code>成为标识符的名称。</p>
<p>我们将使用AST节点的解构符号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">E(G, L, &lt;&#123;St1, ..., Stn&#125;&gt;: Block) =</span><br><span class="line">    let G1, L1, mode = E(G, L, St1, ..., Stn)</span><br><span class="line">    let L2 be a restriction of L1 to the identifiers of L</span><br><span class="line">    G1, L2, mode</span><br><span class="line">E(G, L, St1, ..., Stn: Statement) =</span><br><span class="line">    if n is zero:</span><br><span class="line">        G, L, regular</span><br><span class="line">    else:</span><br><span class="line">        let G1, L1, mode = E(G, L, St1)</span><br><span class="line">        if mode is regular then</span><br><span class="line">            E(G1, L1, St2, ..., Stn)</span><br><span class="line">        otherwise</span><br><span class="line">            G1, L1, mode</span><br><span class="line">E(G, L, FunctionDefinition) =</span><br><span class="line">    G, L, regular</span><br><span class="line">E(G, L, &lt;let var1, ..., varn := rhs&gt;: VariableDeclaration) =</span><br><span class="line">    E(G, L, &lt;var1, ..., varn := rhs&gt;: Assignment)</span><br><span class="line">E(G, L, &lt;let var1, ..., varn&gt;: VariableDeclaration) =</span><br><span class="line">    let L1 be a copy of L where L1[$vari] = 0 for i = 1, ..., n</span><br><span class="line">    G, L1, regular</span><br><span class="line">E(G, L, &lt;var1, ..., varn := rhs&gt;: Assignment) =</span><br><span class="line">    let G1, L1, v1, ..., vn = E(G, L, rhs)</span><br><span class="line">    let L2 be a copy of L1 where L2[$vari] = vi for i = 1, ..., n</span><br><span class="line">    G, L2, regular</span><br><span class="line">E(G, L, &lt;for &#123; i1, ..., in &#125; condition post body&gt;: ForLoop) =</span><br><span class="line">    if n &gt;= 1:</span><br><span class="line">        let G1, L1, mode = E(G, L, i1, ..., in)</span><br><span class="line">        // mode has to be regular due to the syntactic restrictions</span><br><span class="line">        let G2, L2, mode = E(G1, L1, for &#123;&#125; condition post body)</span><br><span class="line">        // mode has to be regular due to the syntactic restrictions</span><br><span class="line">        let L3 be the restriction of L2 to only variables of L</span><br><span class="line">        G2, L3, regular</span><br><span class="line">    else:</span><br><span class="line">        let G1, L1, v = E(G, L, condition)</span><br><span class="line">        if v is false:</span><br><span class="line">            G1, L1, regular</span><br><span class="line">        else:</span><br><span class="line">            let G2, L2, mode = E(G1, L, body)</span><br><span class="line">            if mode is break:</span><br><span class="line">                G2, L2, regular</span><br><span class="line">            else:</span><br><span class="line">                G3, L3, mode = E(G2, L2, post)</span><br><span class="line">                E(G3, L3, for &#123;&#125; condition post body)</span><br><span class="line">E(G, L, break: BreakContinue) =</span><br><span class="line">    G, L, break</span><br><span class="line">E(G, L, continue: BreakContinue) =</span><br><span class="line">    G, L, continue</span><br><span class="line">E(G, L, &lt;if condition body&gt;: If) =</span><br><span class="line">    let G0, L0, v = E(G, L, condition)</span><br><span class="line">    if v is true:</span><br><span class="line">        E(G0, L0, body)</span><br><span class="line">    else:</span><br><span class="line">        G0, L0, regular</span><br><span class="line">E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn&gt;: Switch) =</span><br><span class="line">    E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default &#123;&#125;)</span><br><span class="line">E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn default st&apos;&gt;: Switch) =</span><br><span class="line">    let G0, L0, v = E(G, L, condition)</span><br><span class="line">    // i = 1 .. n</span><br><span class="line">    // Evaluate literals, context doesn&apos;t matter</span><br><span class="line">    let _, _, v1 = E(G0, L0, l1)</span><br><span class="line">    ...</span><br><span class="line">    let _, _, vn = E(G0, L0, ln)</span><br><span class="line">    if there exists smallest i such that vi = v:</span><br><span class="line">        E(G0, L0, sti)</span><br><span class="line">    else:</span><br><span class="line">        E(G0, L0, st&apos;)</span><br><span class="line"></span><br><span class="line">E(G, L, &lt;name&gt;: Identifier) =</span><br><span class="line">    G, L, L[$name]</span><br><span class="line">E(G, L, &lt;fname(arg1, ..., argn)&gt;: FunctionCall) =</span><br><span class="line">    G1, L1, vn = E(G, L, argn)</span><br><span class="line">    ...</span><br><span class="line">    G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)</span><br><span class="line">    Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)</span><br><span class="line">    Let &lt;function fname (param1, ..., paramn) -&gt; ret1, ..., retm block&gt;</span><br><span class="line">    be the function of name $fname visible at the point of the call.</span><br><span class="line">    Let L&apos; be a new local state such that</span><br><span class="line">    L&apos;[$parami] = vi and L&apos;[$reti] = 0 for all i.</span><br><span class="line">    Let G&apos;&apos;, L&apos;&apos;, mode = E(Gn, L&apos;, block)</span><br><span class="line">    G&apos;&apos;, Ln, L&apos;&apos;[$ret1], ..., L&apos;&apos;[$retm]</span><br><span class="line">E(G, L, l: HexLiteral) = G, L, hexString(l),</span><br><span class="line">    where hexString decodes l from hex and left-aligns it into 32 bytes</span><br><span class="line">E(G, L, l: StringLiteral) = G, L, utf8EncodeLeftAligned(l),</span><br><span class="line">    where utf8EncodeLeftAligned performs a utf8 encoding of l</span><br><span class="line">    and aligns it left into 32 bytes</span><br><span class="line">E(G, L, n: HexNumber) = G, L, hex(n)</span><br><span class="line">    where hex is the hexadecimal decoding function</span><br><span class="line">E(G, L, n: DecimalNumber) = G, L, dec(n),</span><br><span class="line">    where dec is the decimal decoding function</span><br></pre></td></tr></table></figure></p>
<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>JULIA不支持隐式类型转换，因此存在提供显式转换的函数。在将较大类型转换为较短类型时，如果发生溢出，则可能会发生运行时异常。</p>
<p>以下类型转换功能必须可用： -<code>u32tobool(x:u32) -&gt; y:bool</code> -<code>booltou32(x:bool) -&gt; y:u32</code> -<code>u32tou64(x:u32) -&gt; y:u64</code> -<code>u64tou32(x:u64) -&gt; y:u32</code> - 等（TBD）.</p>
<h3 id="低级函数"><a href="#低级函数" class="headerlink" title="低级函数"></a>低级函数</h3><p>以下函数必须可用：</p>
<table>
<thead>
<tr>
<th>算术</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>addu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x + y</td>
</tr>
<tr>
<td>subu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x - y</td>
</tr>
<tr>
<td>mulu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x * y</td>
</tr>
<tr>
<td>divu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x / y</td>
</tr>
<tr>
<td>divs256(x:s256, y:s256) -&gt; z:s256</td>
<td>x / y，用于补码中的有符号数</td>
</tr>
<tr>
<td>modu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x % y</td>
</tr>
<tr>
<td>mods256(x:s256, y:s256) -&gt; z:s256</td>
<td>x % y，用于补码中的有符号数</td>
</tr>
<tr>
<td>signextendu256(i:u256, x:u256) -&gt; z:u256</td>
<td>符号从最低有效位（i * 8 + 7）位开始计数</td>
</tr>
<tr>
<td>expu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x对y的幂</td>
</tr>
<tr>
<td>addmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td>
<td>(x + y)％m，任意精确算术</td>
</tr>
<tr>
<td>mulmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td>
<td>（x * y）％m,任意精确算术</td>
</tr>
<tr>
<td>ltu256(x:u256, y:u256) -&gt; z:bool</td>
<td>如果x &lt;y,1，否则为0</td>
</tr>
<tr>
<td>gtu256(x:u256, y:u256) -&gt; z:bool</td>
<td>如果x&gt;y，1,否则为0</td>
</tr>
<tr>
<td>sltu256(x:s256, y:s256) -&gt; z:bool</td>
<td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>sgtu256(x:s256, y:s256) -&gt; z:bool</td>
<td>如果x&gt;y,1，否则为0，否则为2的补码中的有符号数</td>
</tr>
<tr>
<td>equ256(x:u256, y:u256) -&gt; z:bool</td>
<td>如果x == y,1，否则为0</td>
</tr>
<tr>
<td>notu256(x:u256) -&gt; z:u256</td>
<td>〜x，x的每一位取反</td>
</tr>
<tr>
<td>andu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x和y按位与</td>
</tr>
<tr>
<td>oru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x和y按位或</td>
</tr>
<tr>
<td>xoru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x和y的按位异或</td>
</tr>
<tr>
<td>shlu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x以y的逻辑左移</td>
</tr>
<tr>
<td>shru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x，y的逻辑右移</td>
</tr>
<tr>
<td>saru256(x:u256, y:u256) -&gt; z:u256</td>
<td>x以y的算术右移</td>
</tr>
<tr>
<td>byte(n:u256, x:u256) -&gt; v:u256</td>
<td>x的第n个字节，其中最重要的字节是第0个字节不能用and256（shr256（n，x），0xff替换它）并让它由EVM后端进行优化？</td>
</tr>
<tr>
<td>内存和存储</td>
<td></td>
</tr>
<tr>
<td>mload(p:u256) -&gt; v:u256</td>
<td>mem[p..(p+32))</td>
</tr>
<tr>
<td>mstore(p:u256, v:u256)</td>
<td>mem[p..(p+32)) := v</td>
</tr>
<tr>
<td>mstore8(p:u256, v:u256)</td>
<td>mem[p] := v &amp; 0xff - 仅修改单个字节</td>
</tr>
<tr>
<td>sload(p:u256) -&gt; v:u256</td>
<td>storage[p]</td>
</tr>
<tr>
<td>sstore(p:u256, v:u256)</td>
<td>storage[p] := v</td>
</tr>
<tr>
<td>msize() -&gt; size:u256</td>
<td>内存大小，即最大访问内存索引，虽然是由于内存扩展功能（由字扩展）造成的，但它总是32个字节的倍数</td>
</tr>
<tr>
<td>执行控制</td>
<td></td>
</tr>
<tr>
<td>create(v:u256, p:u256, s:u256)</td>
<td>用代码mem [p ..（p + s））创建新的合同并发送v wei并返回新的地址</td>
</tr>
<tr>
<td>call(g:u256, a:u256, v:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td>
<td>在输入mem [in ..（in + insize））时提供g gas和v wei以及输出区mem [out ..（out + oversize）），在地址a处调用合同，并在错误时返回0（例如， 1成功</td>
</tr>
<tr>
<td>callcode(g:u256, a:u256, v:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td>
<td>相同call但只能使用a的代码，否则保留在当前合同的上下文中</td>
</tr>
<tr>
<td>delegatecall(g:u256, a:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td>
<td>相同callcode，但也保持caller 和callvalue</td>
</tr>
<tr>
<td>atop()</td>
<td>停止执行，与返回相同（0,0）也许它会有意义的退休，因为它等于return（0,0）。它可以是EVM后端的优化。</td>
</tr>
<tr>
<td>abort()</td>
<td>中止（相当于EVM上的无效指令）</td>
</tr>
<tr>
<td>return(p:u256, s:u256)</td>
<td>结束执行，返回数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>revert(p:u256, s:u256)</td>
<td>结束执行，恢复状态更改，返回数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>selfdestruct(a:u256)</td>
<td>终止执行，摧毁当前合同并将资金发送给</td>
</tr>
<tr>
<td>log0(p:u256, s:u256)</td>
<td>没有主题和数据记录[p ..（p + s））</td>
</tr>
<tr>
<td>log1(p:u256, s:u256, t1:u256)</td>
<td>记录主题t1和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>log2(p:u256, s:u256, t1:u256, t2:u256)</td>
<td>记录主题t1，t2和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>log3(p:u256, s:u256, t1:u256, t2:u256, t3:u256)</td>
<td>记录主题t，t2，t3和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>log4(p:u256, s:u256, t1:u256, t2:u256, t3:u256, t4:u256)</td>
<td>记录主题t1，t2，t3，t4和数据mem [p ..（p + s））</td>
</tr>
<tr>
<td>状态查询</td>
<td></td>
</tr>
<tr>
<td>blockcoinbase() -&gt; address:u256</td>
<td>目前的采矿受益者</td>
</tr>
<tr>
<td>blockdifficulty() -&gt; difficulty:u256</td>
<td>当前块的难度</td>
</tr>
<tr>
<td>blockgaslimit() -&gt; limit:u256</td>
<td>阻止当前块的气体限制</td>
</tr>
<tr>
<td>blockhash(b:u256) -&gt; hash:u256</td>
<td>块nr b的散列值 - 仅适用于不包括当前值的最后256个块</td>
</tr>
<tr>
<td>blocknumber() -&gt; block:u256</td>
<td>当前程序段号</td>
</tr>
<tr>
<td>blocktimestamp() -&gt; timestamp:u256</td>
<td>当前块的时间戳，以秒为单位</td>
</tr>
<tr>
<td>txorigin() -&gt; address:u256</td>
<td>交易发件人</td>
</tr>
<tr>
<td>txgasprice() -&gt; price:u256</td>
<td>交易的天然气价格</td>
</tr>
<tr>
<td>gasleft() -&gt; gas:u256</td>
<td>仍然可以用于执行的gas</td>
</tr>
<tr>
<td>balance(a:u256) -&gt; v:u256</td>
<td>地址a的余额（wei）</td>
</tr>
<tr>
<td>this() -&gt; address:u256</td>
<td>当前合同/执行上下文的地址</td>
</tr>
<tr>
<td>caller() -&gt; address:u256</td>
<td>呼叫发送者（不包括委托呼叫）</td>
</tr>
<tr>
<td>callvalue() -&gt; v:u256</td>
<td>目前的调用一起发送的以太币</td>
</tr>
<tr>
<td>calldataload(p:u256) -&gt; v:u256</td>
<td>从位置p开始的调用数据（32字节）</td>
</tr>
<tr>
<td>calldatasize() -&gt; v:u256</td>
<td>通话数据的大小以字节为单位</td>
</tr>
<tr>
<td>calldatacopy(t:u256, f:u256, s:u256)</td>
<td>从位置f的calldata复制s个字节到位置t的mem</td>
</tr>
<tr>
<td>codesize() -&gt; size:u256</td>
<td>当前合同/执行上下文的代码大小</td>
</tr>
<tr>
<td>codecopy(t:u256, f:u256, s:u256)</td>
<td>从位置f的代码复制s字节到位置t的mem</td>
</tr>
<tr>
<td>extcodesize(a:u256) -&gt; size:u256</td>
<td>地址a处代码的大小</td>
</tr>
<tr>
<td>extcodecopy(a:u256, t:u256, f:u256, s:u256)</td>
<td>像代码复制（t，f，s），但需要在地址a处进行编码</td>
</tr>
<tr>
<td>其他</td>
<td></td>
</tr>
<tr>
<td>discardu256(unused:u256)</td>
<td>丢弃价值</td>
</tr>
<tr>
<td>splitu256tou64(x:u256) -&gt; (x1:u64, x2:u64,x3:u64, x4:u64)</td>
<td>将u256分成四个u64</td>
</tr>
<tr>
<td>combineu64tou256(x1:u64, x2:u64, x3:u64,x4:u64) -&gt; (x:u256)</td>
<td>将四个U64组合成一个U256</td>
</tr>
<tr>
<td>sha3(p:u256, s:u256) -&gt; v:u256</td>
<td>keccak（MEM [P …（P + S）））</td>
</tr>
</tbody>
</table>
<p>以上的表格内容都是机翻，由于之前在solidity的内联汇编中都有类似的指令，大概进行翻译，这里有时间的话会进行相应的处理。</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端或目标是JULIA到特定字节码的翻译。每个后端都可以暴露以后端名称为前缀的函数。我们为两个建议的后端预留<code>evm_</code>并加上<code>ewasm_</code>前缀。</p>
<h3 id="后端：EVM"><a href="#后端：EVM" class="headerlink" title="后端：EVM"></a>后端：EVM</h3><p>EVM目标将具有以<code>evm_</code>前缀暴露的所有底层EVM操作码。</p>
<h3 id="后端：“EVM-1-5”"><a href="#后端：“EVM-1-5”" class="headerlink" title="后端：“EVM 1.5”"></a>后端：“EVM 1.5”</h3><p>TBD</p>
<h3 id="后端：eWASM"><a href="#后端：eWASM" class="headerlink" title="后端：eWASM"></a>后端：eWASM</h3><p>TBD</p>
<h2 id="JULIA对象的规范"><a href="#JULIA对象的规范" class="headerlink" title="JULIA对象的规范"></a>JULIA对象的规范</h2><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TopLevelObject = &apos;object&apos; &apos;&#123;&apos; Code? ( Object | Data )* &apos;&#125;&apos;</span><br><span class="line">Object = &apos;object&apos; StringLiteral &apos;&#123;&apos; Code? ( Object | Data )* &apos;&#125;&apos;</span><br><span class="line">Code = &apos;code&apos; Block</span><br><span class="line">Data = &apos;data&apos; StringLiteral HexLiteral</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br></pre></td></tr></table></figure></p>
<p>以上<code>Block</code>是指<code>Block</code>前一章中介绍的JULIA代码语法。</p>
<p>JULIA对象示例如下所示：</p>
<p>..代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Code consists of a single object. A single &quot;code&quot; node is the code of the object.</span><br><span class="line">// Every (other) named object or data section is serialized and</span><br><span class="line">// made accessible to the special built-in functions datacopy / dataoffset / datasize</span><br><span class="line">object &#123;</span><br><span class="line">    code &#123;</span><br><span class="line">        let size = datasize(&quot;runtime&quot;)</span><br><span class="line">        let offset = allocate(size)</span><br><span class="line">        // This will turn into a memory-&gt;memory copy for eWASM and</span><br><span class="line">        // a codecopy for EVM</span><br><span class="line">        datacopy(dataoffset(&quot;runtime&quot;), offset, size)</span><br><span class="line">        // this is a constructor and the runtime code is returned</span><br><span class="line">        return(offset, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data &quot;Table2&quot; hex&quot;4123&quot;</span><br><span class="line"></span><br><span class="line">    object &quot;runtime&quot; &#123;</span><br><span class="line">        code &#123;</span><br><span class="line">            // runtime code</span><br><span class="line"></span><br><span class="line">            let size = datasize(&quot;Contract2&quot;)</span><br><span class="line">            let offset = allocate(size)</span><br><span class="line">            // This will turn into a memory-&gt;memory copy for eWASM and</span><br><span class="line">            // a codecopy for EVM</span><br><span class="line">            datacopy(dataoffset(&quot;Contract2&quot;), offset, size)</span><br><span class="line">            // constructor parameter is a single number 0x1234</span><br><span class="line">            mstore(add(offset, size), 0x1234)</span><br><span class="line">            create(offset, add(size, 32))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Embedded object. Use case is that the outside is a factory contract,</span><br><span class="line">        // and Contract2 is the code to be created by the factory</span><br><span class="line">        object &quot;Contract2&quot; &#123;</span><br><span class="line">            code &#123;</span><br><span class="line">                // code here ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            object &quot;runtime&quot; &#123;</span><br><span class="line">                code &#123;</span><br><span class="line">                    // code here ...</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             data &quot;Table1&quot; hex&quot;4123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity编码风格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity编码风格/" itemprop="url">solidity编码风格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T20:27:30+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本指南旨在为编写可靠性代码提供编码约定。本指南应该被认为是一个不断变化的规范，随着时间的推移会发生变化，因为找到有用的约定而旧的惯例已经过时。</p>
<p>许多项目将实施他们自己的风格指南。在发生冲突时，项目特定的风格指南优先。</p>
<p>该风格指南中的结构和许多建议均取自python的<a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">pep8风格指南</a>。</p>
<p>本指南的目标不是编写可靠代码的正确方式或最佳方式。本指南的目标是一致性。来自python的<a href="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds" target="_blank" rel="noopener">pep8</a>的引用很好地捕捉了这个概念。</p>
<p>风格指南是关于一致性的。与此风格指南的一致性非常重要。项目中的一致性更重要。一个模块或功能内的一致性是最重要的。但最重要的是：知道什么时候不一致 - 有时风格指南不适用。如有疑问，请使用您的最佳判断。看看其他例子，并决定什么看起来最好。不要犹豫，问！</p>
<h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>每个缩进级别使用4个空格。</p>
<h3 id="Tabs或空格"><a href="#Tabs或空格" class="headerlink" title="Tabs或空格"></a>Tabs或空格</h3><p>空格是首选的缩进方法。</p>
<p>应该避免混合tabs和空格。</p>
<h3 id="空白行"><a href="#空白行" class="headerlink" title="空白行"></a>空白行</h3><p>顶层声明用两个空白行分隔。</p>
<p>正确做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示范<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个合同环绕函数声明中有一个空白行。在相关单行的组之间可以省略空行（例如抽象合约的存根函数）</p>
<p>正确做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    function spam() public;</span><br><span class="line">    function ham() public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function spam() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ham() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示范<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    function spam() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    function ham() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大行的长度"><a href="#最大行的长度" class="headerlink" title="最大行的长度"></a>最大行的长度</h3><p>PEP 8建议的行保持在79（或99）字符，可帮助读者轻松解析代码。</p>
<p>行包裹（看示例你就明白了）应符合以下准则：</p>
<ol>
<li>第一个参数不应该附在开头括号上。</li>
<li>应该使用一个，并且只有一个缩进。</li>
<li>每个参数都应该落在自己的位置上。</li>
<li>终止元素<code>);</code>应该放在最后一行上。</li>
</ol>
<p>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">                              longArgument2,</span><br><span class="line">                              longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1, longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">longArgument1,</span><br><span class="line">longArgument2,</span><br><span class="line">longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3);</span><br></pre></td></tr></table></figure></p>
<p>赋值语句：<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(</span><br><span class="line">    argument1,</span><br><span class="line">    argument2,</span><br><span class="line">    argument3,</span><br><span class="line">    argument4</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1,</span><br><span class="line">                                                                   argument2,</span><br><span class="line">                                                                   argument3,</span><br><span class="line">                                                                   argument4);</span><br></pre></td></tr></table></figure></p>
<p>事件定义和事件触发器：<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(</span><br><span class="line">    adress sender,</span><br><span class="line">    adress recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(adress sender,</span><br><span class="line">                        adress recipient,</span><br><span class="line">                        uint256 publicKey,</span><br><span class="line">                        uint256 amount,</span><br><span class="line">                        bytes32[] options);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(sender,</span><br><span class="line">                  recipient,</span><br><span class="line">                  publicKey,</span><br><span class="line">                  amount,</span><br><span class="line">                  options);</span><br></pre></td></tr></table></figure></p>
<h3 id="源文件编码"><a href="#源文件编码" class="headerlink" title="源文件编码"></a>源文件编码</h3><p>UTF-8 或者 ASCII编码是首选。</p>
<h3 id="Imports语句"><a href="#Imports语句" class="headerlink" title="Imports语句"></a>Imports语句</h3><p>导入语句必须是文件的开头。</p>
<p>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &quot;owned&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &quot;owned&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数的排序"><a href="#函数的排序" class="headerlink" title="函数的排序"></a>函数的排序</h3><p>排序有助于读者识别他们可以调用哪些函数，并更容易地找到构造函数和回退定义。</p>
<p>函数应根据其可见性分组，并按照如下顺序排列：</p>
<ul>
<li>constructor</li>
<li>fallback function (if exists)</li>
<li>external</li>
<li>public</li>
<li>internal</li>
<li>private</li>
</ul>
<p>在分组中，将<code>constant</code>函数放在最后。</p>
<p>正确示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    function A() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // External functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // External functions that are constant</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Public functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Internal functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Private functions</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line"></span><br><span class="line">    // External functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Private functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Public functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    function A() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Internal functions</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="表达式中的空白符"><a href="#表达式中的空白符" class="headerlink" title="表达式中的空白符"></a>表达式中的空白符</h3><p>在以下情况下避免无关的空白：</p>
<p>立即在括号，括号或大括号内，除单行函数声明外。</p>
<p>正确的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam(ham[1], Coin(&#123;name: &quot;ham&quot;&#125;));</span><br></pre></td></tr></table></figure></p>
<p>错误的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam( ham[ 1 ], Coin( &#123; name: &quot;ham&quot; &#125; ) );</span><br></pre></td></tr></table></figure></p>
<p>例外情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function singleLine() public &#123; spam(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>紧接在逗号,分号前面的空白符：<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function spam(uint i, Coin coin) public;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function spam(uint i , Coin coin) public ;</span><br></pre></td></tr></table></figure></p>
<p>在任务或其他操作符周围的多个空间与另一个空间对齐：<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 1;</span><br><span class="line">y = 2;</span><br><span class="line">long_variable = 3;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x             = 1;</span><br><span class="line">y             = 2;</span><br><span class="line">long_variable = 3;</span><br></pre></td></tr></table></figure></p>
<p>不要在fallback函数中包含空格：<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() public &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function () public &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>表示合同，库，函数和结构主体的大括号应该：</p>
<ol>
<li>与声明在同一行</li>
<li>在声明开始的同一缩进级别自行关闭。</li>
<li>开口支架应该由一个空间进行。</li>
</ol>
<p>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Coin</span><br><span class="line">&#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于if, else, while， for这些语句也是一样的。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>对于简短的函数声明，建议将函数体的左大括号与函数声明保持在同一行。</p>
<p>右大括号应该与函数声明的缩进级别相同。</p>
<p>前面的大括号应该在前面有一个空格。</p>
<p>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function increment(uint x) public pure returns (uint) &#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure onlyowner returns (uint) &#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function increment(uint x) public pure returns (uint)</span><br><span class="line">&#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure returns (uint)&#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure returns (uint) &#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure returns (uint) &#123;</span><br><span class="line">    return x + 1;&#125;</span><br></pre></td></tr></table></figure></p>
<p>你应该明确标注所有函数的可见性，包括构造函数。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function explicitlyPublic(uint val) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function implicitlyPublic(uint val) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的可见性修饰符应位于任何自定义修饰符之前。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function kill() public onlyowner &#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function kill() onlyowner public &#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于长函数声明，建议将每个参数放在与函数体相同的缩进级别的自己的行上。 右括号和左括号应该放在它们自己的行上，以及与函数声明相同的缩进级别。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionHasLotsOfArguments(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c,</span><br><span class="line">    address d,</span><br><span class="line">    address e,</span><br><span class="line">    address f</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionHasLotsOfArguments(address a, address b, address c,</span><br><span class="line">    address d, address e, address f) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionHasLotsOfArguments(address a,</span><br><span class="line">                                        address b,</span><br><span class="line">                                        address c,</span><br><span class="line">                                        address d,</span><br><span class="line">                                        address e,</span><br><span class="line">                                        address f) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionHasLotsOfArguments(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c,</span><br><span class="line">    address d,</span><br><span class="line">    address e,</span><br><span class="line">    address f) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一个长函数声明有修饰符，那么每个修饰符应该放在它自己的行中。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">    public</span><br><span class="line">    onlyowner</span><br><span class="line">    priced</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionNameIsReallyLong(</span><br><span class="line">    address x,</span><br><span class="line">    address y,</span><br><span class="line">    address z,</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    onlyowner</span><br><span class="line">    priced</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">                                      public</span><br><span class="line">                                      onlyowner</span><br><span class="line">                                      priced</span><br><span class="line">                                      returns (address) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">    public onlyowner priced returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">    public</span><br><span class="line">    onlyowner</span><br><span class="line">    priced</span><br><span class="line">    returns (address) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多行输出参数和返回语句应遵循建议用于包装“最大行长度”部分中找到的长行的相同样式。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    returns (</span><br><span class="line">        address someAddressName,</span><br><span class="line">        uint256 LongArgument,</span><br><span class="line">        uint256 Argument</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    doSomething()</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        veryLongReturnArg1,</span><br><span class="line">        veryLongReturnArg2,</span><br><span class="line">        veryLongReturnArg3</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    returns (address someAddressName,</span><br><span class="line">             uint256 LongArgument,</span><br><span class="line">             uint256 Argument)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething()</span><br><span class="line"></span><br><span class="line">    return (veryLongReturnArg1,</span><br><span class="line">            veryLongReturnArg1,</span><br><span class="line">            veryLongReturnArg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于基础需要参数的继承合约的构造函数，如果函数声明很长或难以阅读，建议将基础构造函数以与修饰符相同的方式放到新行上。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A is B, C, D &#123;</span><br><span class="line">    function A(uint param1, uint param2, uint param3, uint param4, uint param5)</span><br><span class="line">        B(param1)</span><br><span class="line">        C(param2, param3)</span><br><span class="line">        D(param4)</span><br><span class="line">        public</span><br><span class="line">    &#123;</span><br><span class="line">        // do something with param5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract A is B, C, D &#123;</span><br><span class="line">    function A(uint param1, uint param2, uint param3, uint param4, uint param5)</span><br><span class="line">    B(param1)</span><br><span class="line">    C(param2, param3)</span><br><span class="line">    D(param4)</span><br><span class="line">    public</span><br><span class="line">    &#123;</span><br><span class="line">        // do something with param5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract A is B, C, D &#123;</span><br><span class="line">    function A(uint param1, uint param2, uint param3, uint param4, uint param5)</span><br><span class="line">        B(param1)</span><br><span class="line">        C(param2, param3)</span><br><span class="line">        D(param4)</span><br><span class="line">        public &#123;</span><br><span class="line">        // do something with param5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用单个语句声明简短函数时，允许在一行中完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function shortFunction() public &#123; doSomething(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>这些函数声明的准则旨在提高可读性。 作者应该使用他们的最佳判断，因为本指南并不试图涵盖函数声明的所有可能的排列。</p>
<h3 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h3><p>待讨论</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>数组变量的声明在类型和括号之间不应该有空格。<br>正确示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] x;</span><br></pre></td></tr></table></figure></p>
<p>错误示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint [] x;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h3><ul>
<li>字符串应该用双引号而不是单引号引用。</li>
<li>操作符左右都应该有空格，例如<code>x += 3 + 4;</code></li>
<li>比其他优先级高的运算符可以排除周围的空白，以表示优先级。 这是为了提高复杂语句的可读性。 您应该始终在运算符的任一侧使用相同数量的空白：</li>
</ul>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>命名约定在被广泛采用和使用时功能强大。 使用不同的约定可以传达重要的元信息，否则这些信息将不会立即可用。</p>
<p>这里给出的命名建议旨在提高可读性，因此它们不是规则，而是试图帮助通过事物名称传达最多信息的指导原则。</p>
<p>最后，代码库中的一致性应始终取代本文档中概述的任何约定。</p>
<h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><p>防止混淆，以下名称将用于指代不同的命名风格。</p>
<ul>
<li><code>b</code> (single lowercase letter)</li>
<li><code>B</code> (single uppercase letter)</li>
<li><code>lowercase</code></li>
<li><code>lower_case_with_underscores</code></li>
<li><code>UPPERCASE</code></li>
<li><code>UPPER_CASE_WITH_UNDERSCORES</code></li>
<li><code>CapitalizedWords</code> (or CapWords)</li>
<li><code>mixedCase</code> (differs from CapitalizedWords by initial lowercase character!)</li>
<li><code>Capitalized_Words_With_Underscores</code></li>
</ul>
<h3 id="规避的命名"><a href="#规避的命名" class="headerlink" title="规避的命名"></a>规避的命名</h3><ul>
<li><code>l</code> - Lowercase letter el</li>
<li><code>O</code> - Uppercase letter oh</li>
<li><code>I</code> - Uppercase letter eye</li>
</ul>
<p>切勿将任何这些用于单个字母的变量名称。 它们通常与数字1和零不可区分。</p>
<h3 id="合约和库命名"><a href="#合约和库命名" class="headerlink" title="合约和库命名"></a>合约和库命名</h3><p>大写风格：<code>SimpleToken</code>, <code>SmartBank</code>, <code>CertificateHashRepository</code>, <code>Player</code></p>
<h3 id="结构命名"><a href="#结构命名" class="headerlink" title="结构命名"></a>结构命名</h3><p>大写风格：<code>MyCoin</code>, <code>Position</code>, <code>PositionXY</code></p>
<h3 id="事件命名"><a href="#事件命名" class="headerlink" title="事件命名"></a>事件命名</h3><p>大写风格：<code>Deposit</code>, <code>Transfer</code>, <code>Approval</code>, <code>BeforeTransfer</code>, <code>AfterTransfer</code></p>
<h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>mixedCase：<code>getBalance</code>, <code>transfer</code>, <code>verifyOwner</code>, <code>addMember</code>, <code>changeOwner</code></p>
<h3 id="函数参数命名"><a href="#函数参数命名" class="headerlink" title="函数参数命名"></a>函数参数命名</h3><p>mixedCase：<code>initialSupply</code>, <code>account</code>, <code>recipientAddress</code>, <code>senderAddress</code>, <code>newOwner</code></p>
<h3 id="本地变量与状态变量"><a href="#本地变量与状态变量" class="headerlink" title="本地变量与状态变量"></a>本地变量与状态变量</h3><p>mixedCase：</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><code>MAX_BLOCKS</code></p>
<h3 id="函数修饰符命名"><a href="#函数修饰符命名" class="headerlink" title="函数修饰符命名"></a>函数修饰符命名</h3><p>mixedCase：<code>onlyBy</code>, <code>onlyAfter</code>, <code>onlyDuringThePreSale</code>.</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>CapWords：<code>TokenGroup</code>, <code>Frame</code>, <code>HashStyle</code>, <code>CharacterLocation</code>.</p>
<h3 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a>避免命名冲突</h3><p><code>single_trailing_underscore_</code></p>
<p>当所需名称与内置名称或其他名称相冲突时，会提示此惯例。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity应用程序二进制接口规范（ABI）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity应用程序二进制接口规范（ABI）/" itemprop="url">solidity应用程序二进制接口规范（ABI）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T14:17:18+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>应用程序二进制接口（ABI）是与区块链以外的以太坊生态系统中的合约进行交互的标准方式，也是合约到合约交互的标准方式。数据根据其类型进行编码，如本规范中所述。编码不是自描述的，因此需要一个模式才能解码。</p>
<p>我们假设合约的接口函数是强类型的，在编译时和静态时都是已知的。不会提供自检机制。我们假设所有合约都将具有编译时可用的任何合约的接口定义。</p>
<p>本规范不涉及其接口是动态的或仅在运行时才知道的合约。如果这些情况变得重要，那么它们可以作为以太坊生态系统内的设施进行充分处理。</p>
<h2 id="函数选择器"><a href="#函数选择器" class="headerlink" title="函数选择器"></a>函数选择器</h2><p>函数调用的调用数据的前四个字节指定要调用的函数。它是函数签名的Keccak（SHA-3）哈希中的前面（左边，高位在大端）四个字节。签名被定义为基本原型的规范表达式，即带有括号括起来的参数类型列表的函数名称。参数类型由一个逗号分隔 - 不使用空格。</p>
<p><b style="color:#6ab0de">注意：函数的返回类型不是此签名的一部分。在Solidity的函数中，不考虑<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#overload-function" target="_blank" rel="noopener">重载</a>类型。原因是保持函数调用的解析与上下文无关。然而，ABI的JSON描述包含输入和输出。请参阅（<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-json" target="_blank" rel="noopener">JSON ABI</a>）</b></p>
<h2 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h2><p>从第五个字节开始，是编码的参数。这种编码也用于其他地方，例如返回值和事件参数都以相同的方式编码，而不用四个字节指定函数。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>存在以下基本类型：</p>
<ul>
<li><code>uint&lt;M&gt;</code>：<code>M</code>位的无符号整数类型，<code>0 &lt; M &lt;= 256</code>, <code>M % 8 == 0</code>。例如<code>uint32</code>，<code>uint8</code>，<code>uint256</code>。</li>
<li><code>int&lt;M&gt;</code>：<code>M</code>位的二进制补码有符号整数类型，<code>0 &lt; M &lt;= 256</code>, <code>M % 8 == 0</code>。</li>
<li><code>address</code>：相当于<code>uint160</code>，除了假设的解释和语言类型。为了计算函数选择器，使用<code>address</code>。</li>
<li><code>uint</code>，<code>int</code>：同义词<code>uint256</code>，<code>int256</code>分别。为了计算函数选择器，<code>uint256</code>和<code>int256</code>必须使用。</li>
<li><code>bool</code>：等同于<code>uint8</code>限制为0和1的值。为了计算函数选择器，bool被使用。</li>
<li><code>fixed&lt;M&gt;x&lt;N&gt;</code>：<code>M</code>位有符号的定点小数，<code>8 &lt;= M &lt;= 256</code>，<code>M % 8 ==0</code>和<code>0 &lt; N &lt;= 80</code>，其表示的值<code>v</code>作为<code>v / (10 ** N)</code>。</li>
<li><code>fixed</code>，<code>ufixed</code>：同义词<code>fixed128x19</code>，<code>ufixed128x19</code>分别。用于计算函数选择器，<code>fixed128x19</code>和<code>ufixed128x19</code>必须使用。</li>
<li><code>bytes&lt;M&gt;</code>：M位字节类型，<code>0 &lt; M &lt;= 32</code>。</li>
<li><code>function</code>：由函数选择器（4字节）填充的地址（20字节）。编码与<code>bytes24</code>完全相同。</li>
</ul>
<p>存在以下（固定大小）数组类型：</p>
<ul>
<li><code>&lt;type&gt;[M]</code>：给定类型的固定长度为<code>M</code>个元素的数组。<code>M &gt; 0</code>.</li>
</ul>
<p>存在以下非固定大小类型：</p>
<ul>
<li><code>bytes</code>：动态大小的字节序列。</li>
<li><code>string</code>：动态大小的unicode字符串，假定UTF-8编码。</li>
<li><code>&lt;type&gt;[]</code>：给定类型的元素的可变长度数组。</li>
</ul>
<p>类型可以通过在圆括号内包含一个有限的非负数的数字来组合成一个元组，用逗号分隔：</p>
<ul>
<li><code>(T1,T2,...,Tn)</code>：由类型<code>T1，... Tn</code>，<code>n &gt;= 0</code>组成的元组</li>
</ul>
<p>可以形成元组的元组，元组数组等等。</p>
<p><b style="color:#6ab0de">注意: 除了元组之外，Solidity支持上面提到的所有同名的类型。ABI元组类型用于编码Solidity<code>structs</code>。</b></p>
<h2 id="编码的形式规范"><a href="#编码的形式规范" class="headerlink" title="编码的形式规范"></a>编码的形式规范</h2><p>我们现在将正式指定编码，以便它具有以下属性，如果某些参数是嵌套数组，则这些属性特别有用：</p>
<p>属性：</p>
<ol>
<li>访问一个值所需的读取次数至多是参数数组结构中值的深度，即需要四次读取才能检索<code>a_i[k][l][r]</code>。在以前版本的ABI中，读数的数量与最坏情况下动态参数的总数成线性关系。</li>
<li>变量或数组元素的数据不与其他数据交织，并且可重定位，即它只使用相对“地址”</li>
</ol>
<p>我们区分静态和动态类型。静态类型就地编码，动态类型在当前语句块之后的位置，单独分配的位置进行编码。</p>
<p>定义：以下类型称为“动态类型”：</p>
<ul>
<li><code>bytes</code></li>
<li><code>string</code></li>
<li><code>T[]</code> 为任何类型 <code>T</code></li>
<li><code>T[k]</code>任何动态<code>T</code>和任何<code>k &gt; 0</code></li>
<li><code>(T1,...,Tk)</code>如果有的话<code>Ti</code>是动态的<code>1 &lt;= i &lt;= k</code>。</li>
</ul>
<p>所有其他类型被称为“静态的”。</p>
<p>定义：len(a)是二进制字符串<code>a</code>中的字节数。len(a)假定的类型是uint256。</p>
<p>我们将<code>enc</code>实际编码定义为ABI类型值与二进制字符串的映射关系，当且仅当<code>X</code>的类型是动态的，len(enc(X))取决于<code>X</code>的值。</p>
<p>定义：对于任何ABI值<code>X</code>，我们递归定义<code>enc(X)</code>，根据<code>X</code>类型是</p>
<ul>
<li><b style="color:red"><code>(T1,...,Tk)</code></b>对于<code>k&gt;=0</code>并且任何类型，<code>T1</code>, …,<code>Tk</code><br><code>enc(X) = head(X(1)) ... head(X(k-1)) tail(X(0)) ... tail(X(k-1))</code><br><code>X(i)</code>是<code>ith</code>值的组成部分， <code>head</code>和<code>tail</code>是为<code>Ti</code>静态类型定义的，<code>head(X(i)) = enc(X(i))</code>和<code>tail(X(i)) = &quot;&quot;</code>（空字符串）。<br>并作为<code>head(X(i)) = enc(len(head(X(0)) ... head(X(k-1)) tail(X(0)) ... tail(X(i-1))))</code>和<code>tail(X(i)) = enc(X(i))</code><br>否则，即如果<code>Ti</code>是动态类型。<br>请注意，在动态情况下，<code>head(X(i))</code>由于头部长度仅取决于类型而非值，因此定义良好(well-defined)。它的值是<code>tail(X(i))</code>开始相对于<code>enc(X)</code>开始的偏移量。</li>
<li><code>T[k]</code>对于任何<code>T</code>和<code>k</code>：<br><code>enc(X) = enc((X[0], ..., X[k-1]))</code><br>即它被编码为它是具有<code>k</code>相同类型元素的元组。</li>
<li><code>T[]</code>其中<code>X</code>有<code>k</code>个元素（<code>k</code>假定是类型<code>uint256</code>）：<br><code>enc(X) = enc(k) enc([X[1], ..., X[k]])</code><br>即它被编码，就好像它是一个静态大小的数组k，以元素的数量为前缀。</li>
<li><code>bytes</code>，长度<code>k</code>（假定为类型<code>uint256</code>）：<br><code>enc(X) = enc(k) pad_right(X)</code>，即bytes的数字被编码为<code>uint256</code>接着是<code>X</code>作为字节序列的实际值，接着是零字节的最小数目，例如<code>len(enc(X))</code>是32的倍数。</li>
<li><code>string</code>：<code>enc(X) = enc(enc_utf8(X))</code>即<code>X</code>是utf-8编码，并且该值被解释为bytes类型并被进一步编码。请注意，此后续编码中使用的长度是utf-8编码字符串的字节数，而不是其字符数。</li>
<li><code>uint&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>的大端编码，用零字节填充在高阶（左侧），长度为32字节。</li>
<li><code>address</code>：这和<code>uint160</code>一样</li>
<li><code>int&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>的大端的二进制补码编码，对于负数<code>X</code>在较高阶（左侧）填充<code>0xff</code>，对于正数<code>X</code>为使用零字节，<code>X</code>长度为32字节。</li>
<li><code>bool</code>：如同在这种<code>uint8</code>下的情况，<code>1</code>用于<code>true</code>和<code>0</code>用于<code>false</code></li>
<li><code>fixed&lt;M&gt;x&lt;N&gt;</code>：当<code>X * 10**N</code>被解读为<code>uint256</code>,<code>enc(X)</code>是<code>enc(X * 10**N)</code>。</li>
<li><code>fixed</code>：就像<code>fixed128x19</code>这样</li>
<li><code>ufixed&lt;M&gt;x&lt;N&gt;</code>：当<code>X * 10**N</code>被解读为<code>uint256</code>,<code>enc(X)</code>是<code>enc(X * 10**N)</code>。</li>
<li><code>ufixed</code>：就像<code>ufixed128x19</code>这样</li>
<li><code>bytes&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>填充后的零字节长度为32个字节的字节序列。</li>
</ul>
<p>请注意，对于任何<code>X</code>，<code>len(enc(X))</code>是32的倍数。</p>
<h2 id="函数选择器和参数编码"><a href="#函数选择器和参数编码" class="headerlink" title="函数选择器和参数编码"></a>函数选择器和参数编码</h2><p>总而言之，通过参数<code>a_1, ..., a_n</code>调用函数<code>f</code>被编码为<code>function_selector(f) enc((a_1, ..., a_n))</code>; <code>f</code>的返回值<code>v_1, ..., v_k</code>被编码为：<code>enc((v_1, ..., v_k))</code>；即这些值被组合成一个元组并被编码。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>给出下面的合同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，对于我们的<code>Foo</code>例子，如果我们想调用<code>baz</code>,参数为<code>69</code>和<code>true</code>，我们将传递总计68个字节消息，可细分为：</p>
<ul>
<li><code>0xcdcd77c0</code>：函数ID。这是作为签名<code>baz(uint32,bool)</code>的ASCII形式的Keccak散列的前4个字节而得出的。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个uint32值<code>69</code>填充的32个字节。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数 - 布尔值true，填充为32个字节</li>
</ul>
<p>总计：<code>0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</code><br>它返回一个单一的<code>bool</code>。例如，如果它要返回<code>false</code>，它的输出将是单个字节数组<code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，单个布尔值。</p>
<p>如果我们用参数<code>[&quot;abc&quot;, &quot;def&quot;]</code>来调用<code>bar</code>方法，我们将总共传递68个字节，分解为：</p>
<ul>
<li><code>0xfce353f6</code>：方法ID。这是从<code>bar(bytes3[2])</code>的签名派生。</li>
<li><code>0x6162630000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第一部分，一个bytes3值”abc”（左对齐）。</li>
<li><code>0x6465660000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第二部分，一个bytes3值”def”（左对齐）。</li>
</ul>
<p>总共：<code>0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000</code></p>
<p>如果我们想用参数<code>&quot;dave&quot;</code>, <code>true</code>和<code>[1, 2, 3]</code>调用<code>sam</code>，我们将总共传递292个字节，分解为：</p>
<ul>
<li><code>0xa5643bf2</code>：方法ID。这是从<code>sam(bytes,bool,uint256[])</code>签名派生的。请注意，它将<code>uint</code>被其规范<code>uint256</code>表示所取代。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000060</code>：第一个参数（动态类型）的数据部分的位置，从参数块的开始字节开始测量。在这种情况下，<code>0x60</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数：boolean true。</li>
<li><code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>：第三个参数（动态类型）的数据部分的位置，以字节为单位。在这种情况下，<code>0xa0</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000004</code>：<b style="color:red">第一个参数的数据部分，它以元素中字节数组的长度开始，在本例中为4</b>。</li>
<li><code>0x6461766500000000000000000000000000000000000000000000000000000000</code>：第一个参数的内容：UTF-8（在这种情况下等于ASCII）的编码”dave”，在右边填充到32个字节。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：<b style="color:red">第三个参数的数据部分，它以元素中数组的长度开始，在本例中为3。</b></li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第三个参数的第一个条目。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>：第三个参数的第二个条目。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的第三个条目。</li>
</ul>
<p>总共：<br><code>0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</code></p>
<h2 id="动态类型的使用"><a href="#动态类型的使用" class="headerlink" title="动态类型的使用"></a>动态类型的使用</h2><p>通过签名<code>f(uint,uint32[],bytes10,bytes)</code>连同参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>来调用一个函数，按以下方式进行编码：</p>
<p>我们采取<code>sha3(&quot;f(uint256,uint32[],bytes10,bytes)&quot;)</code>前四个字节，即<code>0x8be65246</code>。然后我们对所有四个参数的头部分进行编码。对于静态类型<code>uint256</code>和<code>bytes10</code>，这些是直接我们想要传递的值，而对于动态类型<code>uint32[]</code>和<code>bytes</code>，我们使用在字节偏移到它们的数据区的开始，从值编码开始测量（即，不计数前四个字节包含函数签名的散列）。这些是：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000123</code>（<code>0x123</code>填充到32个字节）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000080</code> （偏移到第二个参数的数据部分的开始，4 * 32个字节，正好是头部的大小）</li>
<li><code>0x3132333435363738393000000000000000000000000000000000000000000000</code>（”1234567890”填充到右侧的32个字节）</li>
<li><code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>（第四个参数的数据部分的起始偏移量=第一个动态参数的数据部分的起始偏移量+第一个动态参数的数据部分的大小= 4 <em> 32 + 3 </em> 32（见下文））</li>
</ul>
<p>在此之后，第一个动态参数的数据部分<code>[0x456, 0x789]</code>,如下所示：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code> （阵列元素的数量，2）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000456</code> （第一元素）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000789</code> （第二元素）</li>
</ul>
<p>最后，我们编码第二个动态参数的数据部分：<code>&quot;Hello, world!&quot;</code></p>
<ul>
<li><code>0x000000000000000000000000000000000000000000000000000000000000000d</code> （元素数量（在这种情况下是字节数）：13）</li>
<li><code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>（填充到右侧的32个字节）”Hello, world!”</li>
</ul>
<p>总的来说，编码是（为了清晰起见,每32字节换行显示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是以太坊日志/事件监听协议的抽象。日志条目提供合约的地址，一系列最多四个主题（其实就是索引）和一些任意长度的二进制数据。事件利用现有的ABI函数来解释这个（与一个接口规范一起）为一个正确类型的结构。</p>
<p>给定一个事件名称和一系列事件参数，我们将它们分成两个子系列：索引的和不是索引的。<b style="color:red">那些被编入索引的，最多可达3个，与事件签名的Keccak散列一起使用，以形成日志条目的主题</b>。那些没有索引的事件形成事件的字节数组。</p>
<p>实际上，使用这个ABI的日志条目被描述为：</p>
<ul>
<li><code>address</code>：合同地址（本质上由以太坊提供）;</li>
<li><code>topics[0]</code>：<code>keccak(EVENT_NAME+&quot;(&quot;+EVENT_ARGS.map(canonical_type_of).join(&quot;,&quot;)+&quot;)&quot;)</code>（<code>canonical_type_of</code>就是简单地返回所述规范类型给定的参数的函数，例如对于<code>uint indexed foo</code>，它会返回<code>uint256</code>）。如果该事件被声明为<code>anonymous</code>，<code>topics[0]</code>不会生成;</li>
<li><code>topics[n]</code>：<code>EVENT_INDEXED_ARGS[n - 1]</code>（<code>EVENT_INDEXED_ARGS</code>是<code>EVENT_ARGS</code>被索引的序列;</li>
<li><code>data</code>：<code>abi_serialise(EVENT_NON_INDEXED_ARGS)</code>（<code>EVENT_NON_INDEXED_ARGS</code>是该系列的<code>EVENT_ARGS</code>未索引的部分，<code>abi_serialise</code>用于从函数返回的一系列类型的值的ABI序列化的功能，如上文所述）。</li>
</ul>
<p>对于所有固定长度的Solidity类型，<code>EVENT_INDEXED_ARGS</code>数组直接包含32字节的编码值。然而，对于动态长度的类型，包括<code>string</code>，<code>bytes</code>和数组，<code>EVENT_INDEXED_ARGS</code>将包含Keccak散列的编码值，而不是直接对值进行编码。这允许应用程序高效地查询动态长度类型的值（通过将编码值的散列设置为主题），但是应用程序无法解码他们没有查询的索引值。对于动态长度类型，应用程序开发人员需要在快速搜索预定值（如果参数为索引）和任意值的易读性（这要求参数不被索引）之间进行权衡。开发人员可以通过定义具有两个参数的事件（一个索引，一个不打算保持相同的值）来克服这种折衷并实现有效搜索和任意易读性。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>合约接口的JSON格式由一组函数和/或事件描述给出。函数描述是一个带有如下字段的JSON对象：</p>
<ul>
<li><code>type</code>：<code>&quot;function&quot;</code>，<code>&quot;constructor&quot;</code>或<code>&quot;fallback&quot;</code>（未命名的“默认”函数）;</li>
<li><code>name</code>：函数的名称;</li>
<li><code>inputs</code>：一个对象数组，每个对象都包含：<ul>
<li><code>name</code>：参数的名称;</li>
<li><code>type</code>：参数的规范类型（下面更多）。</li>
<li><code>components</code>：用于元组类型（下面会介绍）。</li>
</ul>
</li>
<li><code>outputs</code>：类似于<code>inputs</code>对象的数组，如果函数不返回任何东西，则可以省略它;</li>
<li><code>payable</code>：如果函数接受ether为<code>true</code>，则默认为false;</li>
<li><code>stateMutability</code>：具有以下值之一的字符串：<code>pure</code>（指定为不读blockchain状态）， <code>view</code>（指定为不修改blockchain状态），<code>nonpayable</code>和<code>payable</code>（同上述<code>payable</code>）。</li>
<li><code>constant</code>：如果函数是<code>pure</code>或者<code>view</code>, 则为true。</li>
</ul>
<p><code>type</code>可以省略，默认为<code>&quot;function&quot;</code>。</p>
<p>构造函数和fallback函数从来没有<code>name</code>或<code>outputs</code>。fallback函数也没有<code>inputs</code>。</p>
<p>发送非零以太币到没有<code>payable</code>的函数将抛出异常。不要这样做。</p>
<p>事件描述是一个具有如下相似字段的JSON对象：</p>
<ul>
<li><code>type</code>：总是<code>&quot;event&quot;</code></li>
<li><code>name</code>：事件的名称;</li>
<li><code>inputs</code>：一个对象数组，每个对象都包含：<ul>
<li><code>name</code>：参数的名称;</li>
<li><code>type</code>：参数的规范类型（下面更多）。</li>
<li><code>components</code>：用于元组类型（下面更多）。</li>
</ul>
</li>
<li><code>indexed</code>：如果该字段是日志主题的一部分为true，false的话，那么它是日志数据段中的一个。</li>
<li><code>anonymous</code>：如果事件被声明为<code>anonymous</code>为true。</li>
</ul>
<p>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  function Test() public &#123; b = 0x12345678901234567890123456789012; &#125;</span><br><span class="line">  event Event(uint indexed a, bytes32 b);</span><br><span class="line">  event Event2(uint indexed a, bytes32 b);</span><br><span class="line">  function foo(uint a) public &#123; Event(a, b); &#125;</span><br><span class="line">  bytes32 b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会生成如下json结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">&quot;type&quot;:&quot;event&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes32&quot;,&quot;indexed&quot;:false&#125;],</span><br><span class="line">&quot;name&quot;:&quot;Event&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;type&quot;:&quot;event&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes32&quot;,&quot;indexed&quot;:false&#125;],</span><br><span class="line">&quot;name&quot;:&quot;Event2&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;type&quot;:&quot;function&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],</span><br><span class="line">&quot;name&quot;:&quot;foo&quot;,</span><br><span class="line">&quot;outputs&quot;: []</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<h3 id="处理元组类型"><a href="#处理元组类型" class="headerlink" title="处理元组类型"></a>处理元组类型</h3><p>尽管这些名称不是ABI编码的一部分，但它们确实在JSON中包含很多意义，以便将其显示给最终用户。该结构以如下方式嵌套：</p>
<p>包含<code>name</code>,<code>type</code>和可能的<code>components</code>成员的对象描述类型化变量。规范类型被确定，直到达到一个元组类型和字符串描述到这一点被存储在<code>type</code>,以<code>tuple</code>为前缀，即，其将在<code>tuple</code>随后的序列<code>[]</code>和<code>[k]</code>连同整数<code>k</code>。然后将元组的元素存储在成员<code>components</code>中，该成员是数组类型的，并且具有与顶级对象相同的结构，除非在那里<code>indexed</code>不允许。</p>
<p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  struct S &#123; uint a; uint[] b; T[] c; &#125;</span><br><span class="line">  struct T &#123; uint x; uint y; &#125;</span><br><span class="line">  function f(S s, T t, uint a) public &#123; &#125;</span><br><span class="line">  function g() public returns (S s, T t, uint a) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会生成如下的JSON：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;f&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;function&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;s&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;b&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256[]&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;tuple[]&quot;,</span><br><span class="line">            &quot;components&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;t&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outputs&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="非标准打包模式"><a href="#非标准打包模式" class="headerlink" title="非标准打包模式"></a>非标准打包模式</h2><p>Solidity支持非标准打包模式，其中：</p>
<ul>
<li>没有<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-function-selector" target="_blank" rel="noopener">函数选择器</a>被编码，</li>
<li>短于32字节的类型既不填零也不签名扩展</li>
<li>动态类型就地编码并且没有长度。</li>
</ul>
<p>使用值<code>-1, 0x42, 0x2424, &quot;Hello, world!&quot;</code>进行编码<code>int1, bytes1, uint16, string</code>的示例结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xff42242448656c6c6f2c20776f726c6421</span><br><span class="line">  ^^                                 int1(-1)</span><br><span class="line">    ^^                               bytes1(0x42)</span><br><span class="line">      ^^^^                           uint16(0x2424)</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(&quot;Hello, world!&quot;) without a length field</span><br></pre></td></tr></table></figure></p>
<p>更具体地说，每个静态大小的类型占用其范围所具有的字节数量，以及动态大小的类型<code>string</code>，<code>bytes</code>或者<code>uint[]</code>在不使用其长度字段的情况下进行编码。这意味着只要有两个动态大小的元素，编码就不明确。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity合约元数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity合约元数据/" itemprop="url">solidity合约元数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T13:32:47+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Solidity编译器自动生成JSON文件，即合约元数据，其中包含有关当前合约的信息。它可以用于查询编译器版本，使用的源代码，ABI和NatSpec文档，以便更安全地与合约进行交互并验证其源代码。</p>
<p>编译器会将元数据文件的Swarm哈希值附加到每个合约的字节码末尾（详情请参阅下文），以便您可以以认证的方式检索文件，而不必求助于集中式数据提供者。（swarm是和ipfs一样的服务吗？还是文件去中心化的一种规范？）</p>
<p>当然，您必须将元数据文件发布到Swarm（或其他服务），以便其他人可以访问它。该文件可以通过使用<code>solc --metadata</code>输出，文件<code>solc --metadataContractName_meta.json</code>将被调用。它将包含Swarm对源代码的引用，因此您必须上传所有源文件和元数据文件。</p>
<p><b style="color:blue">元数据文件具有以下格式。下面的例子以可读的方式呈现。正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的关键字进行排序以得到唯一的格式。注释当然也是不允许的，这里仅用于解释目的。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Required: The version of the metadata format</span><br><span class="line">  version: &quot;1&quot;,</span><br><span class="line">  // Required: Source code language, basically selects a &quot;sub-version&quot;</span><br><span class="line">  // of the specification</span><br><span class="line">  language: &quot;Solidity&quot;,</span><br><span class="line">  // Required: Details about the compiler, contents are specific</span><br><span class="line">  // to the language.</span><br><span class="line">  compiler: &#123;</span><br><span class="line">    // Required for Solidity: Version of the compiler</span><br><span class="line">    version: &quot;0.4.6+commit.2dabbdf0.Emscripten.clang&quot;,</span><br><span class="line">    // Optional: Hash of the compiler binary which produced this output</span><br><span class="line">    keccak256: &quot;0x123...&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Compilation source files/source units, keys are file names</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;myFile.sol&quot;: &#123;</span><br><span class="line">      // Required: keccak256 hash of the source file</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x123...&quot;,</span><br><span class="line">      // Required (unless &quot;content&quot; is used, see below): Sorted URL(s)</span><br><span class="line">      // to the source file, protocol is more or less arbitrary, but a</span><br><span class="line">      // Swarm URL is recommended</span><br><span class="line">      &quot;urls&quot;: [ &quot;bzzr://56ab...&quot; ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mortal&quot;: &#123;</span><br><span class="line">      // Required: keccak256 hash of the source file</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x234...&quot;,</span><br><span class="line">      // Required (unless &quot;url&quot; is used): literal contents of the source file</span><br><span class="line">      &quot;content&quot;: &quot;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Compiler settings</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // Required for Solidity: Sorted list of remappings</span><br><span class="line">    remappings: [ &quot;:g/dir&quot; ],</span><br><span class="line">    // Optional: Optimizer settings (enabled defaults to false)</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: File and name of the contract or library this</span><br><span class="line">    // metadata is created for.</span><br><span class="line">    compilationTarget: &#123;</span><br><span class="line">      &quot;myFile.sol&quot;: &quot;MyContract&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: Addresses for libraries used</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      &quot;MyLib&quot;: &quot;0x123123...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Generated information about the contract.</span><br><span class="line">  output:</span><br><span class="line">  &#123;</span><br><span class="line">    // Required: ABI definition of the contract</span><br><span class="line">    abi: [ ... ],</span><br><span class="line">    // Required: NatSpec user documentation of the contract</span><br><span class="line">    userdoc: [ ... ],</span><br><span class="line">    // Required: NatSpec developer documentation of the contract</span><br><span class="line">    devdoc: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:#6ab0de">注意:注意上面的ABI定义没有固定的顺序。它可以随编译器版本改变。</b></p>
<p><b style="color:#6ab0de">注意:由于生成的合约的字节码包含元数据散列，因此对元数据的任何更改都会导致字节码的更改。此外，由于元数据包含所有使用的源的散列，所以任何源代码中的单个空白变化将导致不同的元数据，并随后产生不同的字节代码。</b></p>
<h2 id="编码字节码中的元数据散列"><a href="#编码字节码中的元数据散列" class="headerlink" title="编码字节码中的元数据散列"></a>编码字节码中的元数据散列</h2><p>由于我们可能会支持其他方式来检索未来的元数据文件，因此映射<code>{&quot;bzzr0&quot;: &lt;Swarm hash&gt;}</code>将存储为<a href="https://tools.ietf.org/html/rfc7049" target="_blank" rel="noopener">CBOR</a>编码。由于该编码的开始不容易找到，因此其长度以两字节大端编码添加。Solidity编译器的当前版本因此将以下内容添加到部署的字节码的末尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xa1 0x65 &apos;b&apos; &apos;z&apos; &apos;z&apos; &apos;r&apos; &apos;0&apos; 0x58 0x20 &lt;32 bytes swarm hash&gt; 0x00 0x29</span><br></pre></td></tr></table></figure></p>
<p>因此，为了恢复数据，可以检查部署的字节码的末尾以匹配该模式，并使用Swarm哈希来取回文件。</p>
<h2 id="自动接口生成和NatSpec的用法"><a href="#自动接口生成和NatSpec的用法" class="headerlink" title="自动接口生成和NatSpec的用法"></a>自动接口生成和NatSpec的用法</h2><p>元数据以下列方式使用：想要与合约交互的组件（例如Mist）从合并代码中检索合约代码，然后从该文件的Swarm散列中检索合约代码。该文件被JSON解码成上述结构。</p>
<p>然后该组件可以使用ABI自动生成合同的基本用户界面。</p>
<p>此外，Mist可以使用userdoc在用户与合约交互时向用户显示确认消息。</p>
<p>关于以太坊自然规范（NatSpec）的更多信息可以在<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format" target="_blank" rel="noopener">这里</a>找到。(这里面其实讲得是以太坊solidity文档注释的规范。)</p>
<h2 id="源代码验证的用法"><a href="#源代码验证的用法" class="headerlink" title="源代码验证的用法"></a>源代码验证的用法</h2><p>为了验证编译，可以通过元数据文件中的链接从Swarm中检索源代码。使用指定的设置在该输入上调用正确版本的编译器（将其选中为“官方”编译器的一部分）。得到的字节码与创建交易或CREATE操作码数据的数据进行比较。这会自动验证元数据，因为它的散列是字节码的一部分。过多的数据对应于构造函数的输入数据，应该根据接口将其解码并呈现给用户。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity编译器使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity编译器使用/" itemprop="url">solidity编译器使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T11:45:19+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用命令行编译器"><a href="#使用命令行编译器" class="headerlink" title="使用命令行编译器"></a>使用命令行编译器</h2><p><b style="color:#6ab0de">注意：本篇不适用于<a href="https://solidity.readthedocs.io/en/v0.4.21/installing-solidity.html#solcjs" target="_blank" rel="noopener">solcjs</a>。</b></p>
<p>Solidity库的构建目标之一是solidity<code>solc</code>命令行编译器。使用<code>solc --help</code>为您提供了所有选项的解释。编译器可以生成各种输出，范围从简单的二进制文件和汇编到抽象语法树（解析树），以估计gas的使用情况。如果你只想编译一个文件，你可以运行<code>solc --bin sourceFile.sol</code>，它会打印出二进制信息。在部署合约之前，在使用<code>solc --optimize --bin sourceFile.sol</code>编译时激活优化器。如果您想获得一些更高级的<code>solc</code>输出变体，最好告诉它使用<code>solc -o outputDirectory --bin --ast --asm sourceFile.sol</code>将所有内容输出到单独使用的文件中。</p>
<p>命令行编译器将读取自动从文件系统中导入的文件，但也可以使用以下<code>prefix=path</code>的方式提供路径重定向：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol</span><br></pre></td></tr></table></figure></p>
<p>这实质上指示编译器来搜索任何以<code>github.com/ethereum/dapp-bin/</code>开始的东西，可以在<code>/usr/local/lib/dapp-bin</code>目录下找，如果没有找到该文件，它会在<code>/usr/local/lib/fallback</code>（空格前缀始终匹配）下继续搜索。<code>solc</code>将不会从位于重映射目标之外和显式指定的源文件所在目录之外的文件系统读取文件，因此<code>import &quot;/etc/passwd&quot;;</code>只有在添加为重映射<code>=/</code>时才会起作用。</p>
<p>如果由于重映射而存在多个匹配，则选择具有最长公共前缀的那个匹配。(这个类似于java的双亲委派模型了)</p>
<p>出于安全原因，编译器限制了它可以访问的目录。在命令行中指定的源文件的路径（及其子目录）和通过重映射定义的路径可用于导入语句，但其他所有内容都被拒绝。额外的路径（及其子目录）可以通过<code>--allow-paths /sample/path,/another/sample/path</code>切换。</p>
<p>如果您的合约使用<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#libraries" target="_blank" rel="noopener">库</a>，您会注意到该字节码包含表单<code>__LibraryName______</code>的子字符串。您可以将<code>solc</code>用作链接器，这意味着它将在这些位置为您插入库地址.</p>
<p>无论是添加<code>--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;</code>到您的命令提供的每个库地址或是储存在一个文件中的字符串（每行一个库），并运行<code>--libraries fileName</code>。</p>
<p>如果<code>solc</code>使用该选项<code>--link</code>调用，所有在上面提到的<code>__LibraryName____</code>-格式输入文件将被解释为未链接的二进制文件（十六进制编码），并就地链接（如果输入从stdin读取，写入stdout）。在这种情况下，所有的选项除了<code>--libraries</code>将被忽略（包括<code>-o</code>）。</p>
<p>如果<code>solc</code>使用该选项调用<code>--standard-json</code>，则会在标准输入上使用JSON输入（如下所述），并在标准输出上返回JSON输出。</p>
<h2 id="编译器输入和输出JSON描述"><a href="#编译器输入和输出JSON描述" class="headerlink" title="编译器输入和输出JSON描述"></a>编译器输入和输出JSON描述</h2><p>这些JSON格式由编译器API使用，也可以通过<code>solc</code>。这些可能会发生变化，有些字段是可选的（如上所述），但其目的仅在于进行向后兼容的更改。</p>
<p>编译器API需要JSON格式的输入，并以JSON格式的输出编译结果。</p>
<p><b style="color:blue">注释当然是不允许的，这里仅用于解释目的。</b></p>
<h3 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Required: 源码的语言, 比如&quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc.</span><br><span class="line">  language: &quot;Solidity&quot;,</span><br><span class="line">  // Required</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    // 这里的keys是源文件的“global”名称，</span><br><span class="line">    // 导入可以通过重新映射使用其他文件（参见下文）。</span><br><span class="line">    &quot;myFile.sol&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: 源文件的keccak256散列值，它用于验证通过URL导入的检索内容。</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x123...&quot;,</span><br><span class="line">      // Required（除非使用“content”，见下文）：源文件的URL。</span><br><span class="line">      // URL应该以下面的顺序被导入，并且需要使用keccak256散列检查结果（如果可用）。如果哈希值不匹配或者没有任何一个URL导致成功，则应该引发错误。</span><br><span class="line">      &quot;urls&quot;:</span><br><span class="line">      [</span><br><span class="line">        &quot;bzzr://56ab...&quot;,</span><br><span class="line">        &quot;ipfs://Qma...&quot;,</span><br><span class="line">        &quot;file:///tmp/path/to/file.sol&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mortal&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: 源文件的keccak256 hash</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x234...&quot;,</span><br><span class="line">      // Required(除非urls被使用)：源文件的文字内容</span><br><span class="line">      &quot;content&quot;: &quot;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Optional</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // Optional: Sorted list of remappings</span><br><span class="line">    remappings: [ &quot;:g/dir&quot; ],</span><br><span class="line">    // Optional: 优化器设置 (enabled的默认值是false)</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500</span><br><span class="line">    &#125;,</span><br><span class="line">    evmVersion: &quot;byzantium&quot;, // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople</span><br><span class="line">    // Metadata settings (optional)</span><br><span class="line">    metadata: &#123;</span><br><span class="line">      // Use only literal content and not URLs (false by default)</span><br><span class="line">      useLiteralContent: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      // The top level key is the the name of the source file where the library is used.</span><br><span class="line">      // If remappings are used, this source file should match the global path after remappings were applied.</span><br><span class="line">      // If this key is an empty string, that refers to a global level.</span><br><span class="line">      &quot;myFile.sol&quot;: &#123;</span><br><span class="line">        &quot;MyLib&quot;: &quot;0x123123...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // The following can be used to select desired outputs.</span><br><span class="line">    // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.</span><br><span class="line">    // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,</span><br><span class="line">    // while the star refers to all of the contracts.</span><br><span class="line">    //</span><br><span class="line">    // The available output types are as follows:</span><br><span class="line">    //   abi - ABI</span><br><span class="line">    //   ast - AST of all source files</span><br><span class="line">    //   legacyAST - legacy AST of all source files</span><br><span class="line">    //   devdoc - Developer documentation (natspec)</span><br><span class="line">    //   userdoc - User documentation (natspec)</span><br><span class="line">    //   metadata - Metadata</span><br><span class="line">    //   ir - New assembly format before desugaring</span><br><span class="line">    //   evm.assembly - New assembly format after desugaring</span><br><span class="line">    //   evm.legacyAssembly - Old-style assembly format in JSON</span><br><span class="line">    //   evm.bytecode.object - Bytecode object</span><br><span class="line">    //   evm.bytecode.opcodes - Opcodes list</span><br><span class="line">    //   evm.bytecode.sourceMap - Source mapping (useful for debugging)</span><br><span class="line">    //   evm.bytecode.linkReferences - Link references (if unlinked object)</span><br><span class="line">    //   evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode)</span><br><span class="line">    //   evm.methodIdentifiers - The list of function hashes</span><br><span class="line">    //   evm.gasEstimates - Function gas estimates</span><br><span class="line">    //   ewasm.wast - eWASM S-expressions format (not supported atm)</span><br><span class="line">    //   ewasm.wasm - eWASM binary format (not supported atm)</span><br><span class="line">    //</span><br><span class="line">    // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every</span><br><span class="line">    // target part of that output. Additionally, `*` can be used as a wildcard to request everything.</span><br><span class="line">    //</span><br><span class="line">    outputSelection: &#123;</span><br><span class="line">      // Enable the metadata and bytecode outputs of every single contract.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the abi and opcodes output of MyContract defined in file def.</span><br><span class="line">      &quot;def&quot;: &#123;</span><br><span class="line">        &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.bytecode.opcodes&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the source map output of every single contract.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;*&quot;: [ &quot;evm.bytecode.sourceMap&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the legacy AST output of every single file.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;&quot;: [ &quot;legacyAST&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Optional: not present if no errors/warnings were encountered</span><br><span class="line">  errors: [</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: Location within the source file.</span><br><span class="line">      sourceLocation: &#123;</span><br><span class="line">        file: &quot;sourceFile.sol&quot;,</span><br><span class="line">        start: 0,</span><br><span class="line">        end: 100</span><br><span class="line">      ],</span><br><span class="line">      // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc.</span><br><span class="line">      // See below for complete list of types.</span><br><span class="line">      type: &quot;TypeError&quot;,</span><br><span class="line">      // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc.</span><br><span class="line">      component: &quot;general&quot;,</span><br><span class="line">      // Mandatory (&quot;error&quot; or &quot;warning&quot;)</span><br><span class="line">      severity: &quot;error&quot;,</span><br><span class="line">      // Mandatory</span><br><span class="line">      message: &quot;Invalid keyword&quot;</span><br><span class="line">      // Optional: the message formatted with source location</span><br><span class="line">      formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.</span><br><span class="line">  sources: &#123;</span><br><span class="line">    &quot;sourceFile.sol&quot;: &#123;</span><br><span class="line">      // Identifier (used in source maps)</span><br><span class="line">      id: 1,</span><br><span class="line">      // The AST object</span><br><span class="line">      ast: &#123;&#125;,</span><br><span class="line">      // The legacy AST object</span><br><span class="line">      legacyAST: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.</span><br><span class="line">  contracts: &#123;</span><br><span class="line">    &quot;sourceFile.sol&quot;: &#123;</span><br><span class="line">      // If the language used has no contract names, this field should equal to an empty string.</span><br><span class="line">      &quot;ContractName&quot;: &#123;</span><br><span class="line">        // The Ethereum Contract ABI. If empty, it is represented as an empty array.</span><br><span class="line">        // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI</span><br><span class="line">        abi: [],</span><br><span class="line">        // See the Metadata Output documentation (serialised JSON string)</span><br><span class="line">        metadata: &quot;&#123;...&#125;&quot;,</span><br><span class="line">        // User documentation (natspec)</span><br><span class="line">        userdoc: &#123;&#125;,</span><br><span class="line">        // Developer documentation (natspec)</span><br><span class="line">        devdoc: &#123;&#125;,</span><br><span class="line">        // Intermediate representation (string)</span><br><span class="line">        ir: &quot;&quot;,</span><br><span class="line">        // EVM-related outputs</span><br><span class="line">        evm: &#123;</span><br><span class="line">          // Assembly (string)</span><br><span class="line">          assembly: &quot;&quot;,</span><br><span class="line">          // Old-style assembly (object)</span><br><span class="line">          legacyAssembly: &#123;&#125;,</span><br><span class="line">          // Bytecode and related details.</span><br><span class="line">          bytecode: &#123;</span><br><span class="line">            // The bytecode as a hex string.</span><br><span class="line">            object: &quot;00fe&quot;,</span><br><span class="line">            // Opcodes list (string)</span><br><span class="line">            opcodes: &quot;&quot;,</span><br><span class="line">            // The source mapping as a string. See the source mapping definition.</span><br><span class="line">            sourceMap: &quot;&quot;,</span><br><span class="line">            // If given, this is an unlinked object.</span><br><span class="line">            linkReferences: &#123;</span><br><span class="line">              &quot;libraryFile.sol&quot;: &#123;</span><br><span class="line">                // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.</span><br><span class="line">                &quot;Library1&quot;: [</span><br><span class="line">                  &#123; start: 0, length: 20 &#125;,</span><br><span class="line">                  &#123; start: 200, length: 20 &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          // The same layout as above.</span><br><span class="line">          deployedBytecode: &#123; &#125;,</span><br><span class="line">          // The list of function hashes</span><br><span class="line">          methodIdentifiers: &#123;</span><br><span class="line">            &quot;delegate(address)&quot;: &quot;5c19a95c&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          // Function gas estimates</span><br><span class="line">          gasEstimates: &#123;</span><br><span class="line">            creation: &#123;</span><br><span class="line">              codeDepositCost: &quot;420000&quot;,</span><br><span class="line">              executionCost: &quot;infinite&quot;,</span><br><span class="line">              totalCost: &quot;infinite&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            external: &#123;</span><br><span class="line">              &quot;delegate(address)&quot;: &quot;25000&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            internal: &#123;</span><br><span class="line">              &quot;heavyLifting()&quot;: &quot;infinite&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // eWASM related outputs</span><br><span class="line">        ewasm: &#123;</span><br><span class="line">          // S-expressions format</span><br><span class="line">          wast: &quot;&quot;,</span><br><span class="line">          // Binary format (hex string)</span><br><span class="line">          wasm: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ol>
<li>JSONError：JSON输入不符合所需格式，例如，输入不是JSON对象，不支持该语言等。</li>
<li>IOError：IO和导入处理错误，例如在提供的源中无法解析的URL或散列不匹配。</li>
<li>ParserError：源代码不符合语言规则。</li>
<li>DocstringParsingError：注释块中的NatSpec标签无法解析。</li>
<li>SyntaxError：语法错误，例如continue在for循环外部使用。</li>
<li>DeclarationError：无效的，无法解析的或冲突的标识符名称。例如Identifier not found</li>
<li>TypeError：类型系统内出错，例如无效类型转换，无效分配等。</li>
<li>UnimplementedFeatureError：编译器不支持该功能，但预计将在未来的版本中受支持。</li>
<li>InternalCompilerError：在编译器中触发的内部错误 - 这应该被报告为一个问题。</li>
<li>Exception：编译期间未知失败 - 应将此报告为问题。</li>
<li>CompilerError：编译器堆栈的使用无效 - 这应该被报告为一个问题。</li>
<li>FatalError：致命错误未正确处理 - 应将此报告为问题。</li>
<li>Warning：警告，并没有停止编译，但应尽可能处理。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity安全考虑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity安全考虑/" itemprop="url">solidity安全考虑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T00:32:17+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然构建可按预期工作的软件通常非常容易，但要检查没有人能够以没有预料到的方式使用它，要困难得多。</p>
<p>在Solidity中，这更加重要，因为您可以使用智能合约来处理代币或可能更有价值的东西。此外，智能合约的每一次执行都在公开场合进行，除此之外，源代码通常是公开的。</p>
<p>当然，你总是需要考虑有多大的风险：你可以将智能合约与对公众开放的Web服务（以及对恶意行为者）以及甚至开放源代码进行比较。如果您只将该购物清单存储在该Web服务上，则可能不必太在意，但如果您使用该Web服务管理您的银行账户，则应该更加小心。</p>
<p>本节将列出一些陷阱和一般安全建议，但当然可能永远不会完整。另外，请记住，即使您的智能合约代码没有缺陷，编译器或平台本身也可能有错误。可以在已知错误列表中找到编译器的一些公开<a href="https://solidity.readthedocs.io/en/v0.4.21/bugs.html#known-bugs" target="_blank" rel="noopener">已知安全相关bug列表</a>，这些bug也是机器可读的。请注意，有一个错误赏金程序涵盖了Solidity编译器的代码生成器。</p>
<p>与往常一样，使用文档开源，请帮助我们扩展本节（特别是，一些不会产生伤害的示例）！</p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><h3 id="私人信息和随机性"><a href="#私人信息和随机性" class="headerlink" title="私人信息和随机性"></a>私人信息和随机性</h3><p>您在智能合同使用的一切是公开可见的，甚至是局部变量和标记<code>private</code>的状态变量。</p>
<p>如果你不希望矿工能够作弊，在智能合同中使用随机数字是相当棘手的。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>合同（A）与另一合同（B）的任何互动以及以太币的任何转让均将控制移交给该合同（B）。这使得在这个交互完成之前B可以回调A. 举一个例子，下面的代码包含一个错误（它只是一个片段而不是一个完整的合约）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.send(shares[msg.sender]))</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的问题不是太严重，因为有限的gas是<code>send</code>其中的一部分，但它仍然暴露出一个弱点：以太币转移总是可以包含代码执行，因此<code>withdraw</code>接收方可以是一个重新回调的合约。这将让它得到多个退款，并基本上检索合同中的所有以太币。特别是，下面的合约将允许攻击者在使用<code>call</code>默认情况下多次退还所有剩余gas：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.call.value(shares[msg.sender])())</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免重新入侵，您可以使用Checks-Effects-Interactions模式，详情如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        var share = shares[msg.sender];</span><br><span class="line">        shares[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，重入不仅是以太币转移的影响，而且是任何其他合约的函数调用的影响。此外，您还必须考虑多合约情况。被调用合约可以修改您依赖的另一份合约的状态。</p>
<h3 id="gas限制和循环"><a href="#gas限制和循环" class="headerlink" title="gas限制和循环"></a>gas限制和循环</h3><p>没有固定迭代次数的循环（例如取决于存储值的循环）必须小心使用：由于区块gas限制，交易只能消耗一定量的gas。无论是明确的还是仅仅由于正常的操作，循环中的迭代次数可能会超出区块gas限制，这会导致整个合约在某个点停滞。这可能不适用于<code>constant</code>仅用于从区块链中读取数据的函数。尽管如此，这些函数可能会被其他合约作为链上操作的一部分进行调用，并将其拖延。请在合约文件中明确说明这些情况。</p>
<h3 id="发送和接收以太币"><a href="#发送和接收以太币" class="headerlink" title="发送和接收以太币"></a>发送和接收以太币</h3><ul>
<li>合约和“外部账户”都不能阻止有人送他们以太币。合约可以作出反应并拒绝定期的转移，但有些方法可以在不创建消息调用的情况下移动以太币。一种方法是简单地“mine to”合约地址和第二种方式是使用<code>selfdestruct(x)</code>。</li>
<li>如果合约收到Ether（没有调用函数），则执行fallback函数。如果它没有fallback函数，Ether将被拒绝（通过抛出异常）。在执行fallback函数时，合约只能依靠当时可用的“gas津贴”（2300 gas）。这笔津贴不足以以任何方式访问存储。为确保您的合约能够以此方式接收Ether，请检查fallback函数的gas要求（例如，在Remix的“详细信息”部分中）。</li>
<li>有一种方法可以使用<code>addr.call.value(x)()</code>给予接收的合约更多的gas。这基本上与<code>addr.transfer(x)</code>相同，只是它转发所有剩余的gas并打开接收方执行更昂贵的操作的能力（并且它仅仅返回失败代码并且不会自动传播错误,即抛异常）。这可能包括回调发起者合约或您可能没有想到的其他状态更改。因此它为诚实用户提供了极大的灵活性，同时也为恶意行为者提供了很大的灵活性</li>
<li>如果你想通过<code>address.transfer</code>发送以太币，有一些细节需要注意：<ol>
<li>如果接收者是合约，它将导致其执行fallback函数，从而可以回调发起者合约。</li>
<li>发送以太币可能会因调用深度超过1024而失败。由于调用者完全控制调用深度，因此可能让转币强制失败; 考虑这种可能性或使用<code>send</code>并确保始终检查其返回值。更好的是，用接受者可以对以太币提现的模式编写你的合约。</li>
<li>发送以太币也可能会失败，因为接收者合约的执行需要比gas的分配金额（显式地使用<code>require</code>， <code>assert</code>，<code>revert</code>，<code>throw</code>或因为操作太昂贵） -它“runs out of gas”（OOG）。如果您使用<code>transfer</code>或<code>send</code>带有返回值检查，这可能为接收者提供阻止发送合约进度的手段。同样，这里的最佳做法是<a href="https://solidity.readthedocs.io/en/v0.4.21/common-patterns.html#withdrawal-pattern" target="_blank" rel="noopener">使用<code>”withdraw“</code>模式而不是<code>“send”</code>模式</a>。</li>
</ol>
</li>
</ul>
<h3 id="栈调用深度"><a href="#栈调用深度" class="headerlink" title="栈调用深度"></a>栈调用深度</h3><p>外部函数调用可能会随时失败，因为它们超出了1024的最大调用堆栈。在这种情况下，Solidity会引发异常。恶意行为者在与你的合约进行交互之前可能会强制调用堆栈的价值很高。</p>
<p>请注意，如果调用堆栈已耗尽，但这种情况<code>.send()</code>返回<code>false</code>，不会抛出异常false。低层次的函数<code>.call()</code>，<code>.callcode()</code>和<code>.delegatecall()</code>以相同的方式表现。</p>
<h3 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a><b style="color:red">tx.origin</b></h3><p>切勿使用tx.origin进行授权。假设你有这样的钱包合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在有人欺骗你将以太币发送到这个攻击钱包的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">如果你的钱包已经检查<code>msg.sender</code>的授权，它将得到攻击钱包的地址，而不是所有者地址。但通过检查<code>tx.origin</code>，它会得到启动交易的原始地址，该交易仍是所有者地址。攻击钱包立即消耗您的所有资金。</b></p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul>
<li>在<code>for (var i = 0; i &lt; arrayName.length; i++) { ... }</code>中，<code>i</code>的类型将是<code>uint8</code>，因为这是保存该值所需的最小类型。如果数组有超过255个元素，则循环不会终止。</li>
<li>函数的<code>constant</code>关键字编译器目前不强制执行。此外，它不是由EVM强制执行的，所以声明为<code>constant</code>的函数可能还是会导致状态的变更。</li>
<li><b style="color:red">不占用完整32字节的类型可能包含“脏高位”。如果您访问<code>msg.data</code>，这一点尤其重要 - 它带来了可扩展性风险：您可以创建调用函数<code>f(uint8 x)</code>的交易，函数有带有<code>0xff000001</code>和<code>0x00000001</code>的raw字节参数。两者都被纳入合同，考虑<code>x</code>的值，两者看起来都像数字<code>1</code>一样，但会有所不同，所以如果您使用<code>keccak256(msg.data)</code>，您将得到不同的结果。</b></li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="限制以太币的数量"><a href="#限制以太币的数量" class="headerlink" title="限制以太币的数量"></a>限制以太币的数量</h3><p>限制可以存储在智能合约中的以太币（或其他令牌）数量。如果您的源代码，编译器或平台有错误，这些资金可能会丢失。如果你想限制你的损失，限制以太币的数量。</p>
<h3 id="保持小型化和模块化"><a href="#保持小型化和模块化" class="headerlink" title="保持小型化和模块化"></a>保持小型化和模块化</h3><p>保持合同规模小，易于理解。在其他合约或库中找出无关的功能。关于源代码质量的一般建议：限制局部变量的数量，函数的长度等等。函数需要写文档注释，以便其他人可以理解你的意图是什么，以及它是否与代码不同。</p>
<h3 id="使用检查-效果-互动（Checks-Effects-Interactions）模式"><a href="#使用检查-效果-互动（Checks-Effects-Interactions）模式" class="headerlink" title="使用检查-效果-互动（Checks-Effects-Interactions）模式"></a>使用检查-效果-互动（Checks-Effects-Interactions）模式</h3><p>大多数函数将首先执行一些检查（谁调用函数，参数是否在范围内，他们是否发送了足够多的Ether，人员是否有令牌等）。这些检查应该先完成。</p>
<p>作为第二步，如果所有检查都通过了，则应该对当前合约的状态变量产生影响。与其他合约的交互应该是任何函数的最后一步。</p>
<p>早期合约延迟了一些效果，并等待外部函数调用以非错误状态返回。由于上面提到的重入问题，这通常是一个严重的错误。</p>
<p>请注意，对已知合约的调用也可能导致对未知合约的调用，所以最好始终应用此模式。</p>
<h3 id="包含安全失败（Fail-Safe）模式"><a href="#包含安全失败（Fail-Safe）模式" class="headerlink" title="包含安全失败（Fail-Safe）模式"></a>包含安全失败（Fail-Safe）模式</h3><p>在使系统完全去中心化的同时将删除任何中介，这可能是一个好主意，特别是对于新代码，可能包含某种故障安全机制：</p>
<p>您可以在智能合约中添加一个函数，该函数执行一些自我检查，例如“有任何以太坊泄露？”，“代币的总和等于合约余额吗？”或类似的事情。请记住，你不能使用太多的gas，所以可能需要脱链计算的帮助。</p>
<p>如果自检失败，合同会自动切换到某种“Fail-Safe”模式，例如，禁用大部分函数，将控制权移交给固定和受信任的第三方，或者仅将合同转换为简单的“把我的钱还给我“的合约。</p>
<h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>使用形式验证，可以执行自动化的数学证明，证明源代码符合特定的正式规范。规范仍然是正式的（就像源代码一样），但通常要简单得多。</p>
<p>请注意，形式验证本身只能帮助你理解你所做的事情（规范）和你如何做（实际实现）之间的差异。您仍然需要检查规格是否是您想要的，并且您没有错过任何意想不到的效果。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/06/blockchain/solidity杂项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/06/blockchain/solidity杂项/" itemprop="url">solidity杂项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-06T00:39:19+08:00">2018-04-06</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<h2 id="Storage中状态变量的布局"><a href="#Storage中状态变量的布局" class="headerlink" title="Storage中状态变量的布局"></a>Storage中状态变量的布局</h2><p>静态大小的变量（除映射和动态大小的数组类型之外的所有变量）都是从位置<code>0</code>开始连续地放置在存储中。如果可能的话，需要少于32个字节的多个项目按照以下规则打包到一个存储槽中：</p>
<ul>
<li>存储槽中的第一项存储在低阶对齐中。</li>
<li>基本类型只使用存储它们所需的那么多字节。</li>
<li>如果基本类型不适合存储槽的其余部分，则将其移动到下一个存储槽。</li>
<li>结构和数组数据总是会启动一个新的槽并占据整个槽（但是根据这些规则，结构或数组内的项会紧紧地压缩）。</li>
</ul>
<p><b style="color:#6ab0de">警告：使用小于32字节的元素时，您合约的gas使用量可能会更高。这是因为EVM一次运行32个字节。因此，如果元素小于此值，则EVM必须使用更多操作才能将元素的大小从32个字节减小到所需的大小。</b></p>
<p><b style="color:red">如果您正在处理存储值，那么只使用减小尺寸的参数是有益的，因为编译器会将多个元素打包到一个存储槽中，从而将多个读取或写入组合到一个操作中。处理函数参数或内存值时，没有固有的好处，因为编译器不会打包这些值。</b></p>
<p><b style="color:red">最后，为了让EVM为此进行优化，请确保您尝试对存储变量和<code>struct</code>成员进行排序，以便它们可以紧密打包。例如，声明你的<code>uint128, uint128, uint256</code>存储变量的顺序，而不是<code>uint128, uint256, uint128</code> ，因为前者将只占用存储的两个槽，而后者将占用三个。</b></p>
<p>结构和数组的元素会相互存储，就像明确地给出的顺序一样。</p>
<p>由于其大小不可预知，映射和动态大小的数组类型使用Keccak-256散列计算来查找值或数组数据的起始位置。这些起始位置总是全堆栈槽。</p>
<p>映射或动态数组本身根据上述规则（或通过将此规则映射到映射或数组阵列）递归地占用存储在某个位置<code>p</code>的（未填充）槽。对于动态数组，此槽存储数组中元素的数量（字节数组和字符串在这里是一个例外，见下文）。对于映射，该槽未被使用（但是这是需要的，使得两个相同的映射在彼此之后将使用不同的散列分布）。数组数据位于<code>keccak256(p)</code>, 对应于映射键<code>k</code>的值位<code>keccak256(k . p)</code>于其中<code>.</code>是级联。如果该值又是非基本类型，则通过添加<code>keccak256(k . p)</code>的偏移量来找到位置。keccak256(k . p).keccak256(k . p)</p>
<p><code>bytes</code>和<code>string</code>存储在相同的槽中，槽中也存储长度。特别地：如果数据长度至多为<code>31</code>字节，则它存储在高位字节（左对齐）中，而最低位字节存储<code>length * 2</code>。如果更长，主要的槽存储<code>length * 2 + 1</code>和数据按常规存储在<code>keccak256(slot)</code>。</p>
<p>因此，对于以下合同片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  struct s &#123; uint a; uint b; &#125;</span><br><span class="line">  uint x;</span><br><span class="line">  mapping(uint =&gt; mapping(uint =&gt; s)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>data[4][9].b</code>的位置是在<code>keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1</code>。</p>
<h2 id="内存中的布局"><a href="#内存中的布局" class="headerlink" title="内存中的布局"></a>内存中的布局</h2><p>Solidity保留三个256位槽：</p>
<ul>
<li>0 - 64：散列方法的暂存空间</li>
<li>64 - 96：当前分配的内存大小（即可用内存指针）</li>
</ul>
<p>语句之间可以使用临时空间（包括在内联程序在内）。</p>
<p>Solidity始终将新对象放置在空闲内存指针上，内存永远不会释放（这可能会在未来发生变化）。</p>
<p><b style="color:#6ab0de">警告：Solidity中有一些操作需要大于64字节的临时内存区域，因此临时内存空间不会不匹配。它们将被放置在空闲内存指针指向的位置，但给予其较短的生命周期，指针不会更新。内存可能会或可能不会被清零。正因为如此，人们不应该期望自由内存被清零。</b></p>
<h2 id="调用方法数据的布局"><a href="#调用方法数据的布局" class="headerlink" title="调用方法数据的布局"></a>调用方法数据的布局</h2><p>当部署Solidity合同并从账户调用时，假定输入数据采用<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi" target="_blank" rel="noopener">ABI规范</a>中的格式。ABI规范要求将参数填充为32个字节的倍数。内部函数调用使用不同的约定。</p>
<h2 id="内部-清理变量"><a href="#内部-清理变量" class="headerlink" title="内部 - 清理变量"></a>内部 - 清理变量</h2><p>当某个值小于256位时，在某些情况下必须清除其余的位。Solidity编译器的设计就是在任何可能受其余位中潜在垃圾影响的操作之前清除这些剩余位。例如，在将值写入内存之前，需要清除其余位，因为内存内容可用于计算散列值或作为消息调用的数据发送。类似地，在将值存储在storage中之前，需要清除其余位，否则就会观察到乱码值。</p>
<p>另一方面，如果紧接着的操作不受影响，我们不清除这些位。例如，由于任何非零值被<code>JUMPI</code>指令认为是<code>true</code>，在值作为<code>JUMPI</code>指令条件之前，我们不会清除布尔值。</p>
<p>除了上面的设计原理外，Solidity编译器还会在输入数据加载到堆栈时清除输入数据。<b style="color:yellow">难道是使用懒清除方式？</b></p>
<p>不同类型的清理无效值的规则有所不同：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>有效值</th>
<th>无效值的意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>n个成员的枚举</td>
<td>0直到n-1</td>
<td>exception</td>
</tr>
<tr>
<td>bool</td>
<td>0或1</td>
<td>1</td>
</tr>
<tr>
<td>有符号整数</td>
<td>符号扩展的字</td>
<td>目前默默地包裹; 将来会有异常情况发生</td>
</tr>
<tr>
<td>无符号整数</td>
<td>更高位清零</td>
<td>目前默默地包裹; 将来会有异常情况发生</td>
</tr>
</tbody>
</table>
<h2 id="内部-优化器"><a href="#内部-优化器" class="headerlink" title="内部 - 优化器"></a>内部 - 优化器</h2><p>Solidity优化器在汇编上操作，所以它可以或者已经被其他语言使用。它在<code>JUMPs</code>和<code>JUMPDESTs</code>指令处分裂指令的序列使成为基本语句块。在这些语句块内部，分析指令，对堆栈、对内存、对storage的每个修改，都被记录为表达式，该表达式包括指令和基本上指向其他表达式的参数列表。现在主要想法是找到始终相等的表达式（在每个输入上）并将它们组合到一个表达式类中。优化器首先尝试在已知表达式的列表中查找每个新表达式。如果这不起作用，则表达式按照规则进行简化，规则像<code>constant + constant = sum_of_constants</code>或者<code>X * 1 = X</code>。由于这是递归完成的，所以如果第二个因子是一个更复杂的表达式，我们知道它总是会评估为1，那么我们也可以应用后一个规则。对存储和内存位置的修改必须删除有关存储和内存位置的认知（knowledge，我怎么翻译），这些认知并不是已知的不同：如果我们先写入位置x，然后写入位置y; 并且<code>x</code>和<code>y</code>都是输入变量，则第二个可能会覆盖第一个，所以我们实际上在我们写y值之后不知道在x处存储了什么。另一方面，如果表达式<code>x - y</code>的简化计算为非零常数，那么我们知道我们可以保存关于x中存储的内容的认知。</p>
<p>在这个过程结束时，我们知道最后哪些表达式必须在堆栈上，并且有一个内存和存储的修改的列表。这些信息与基本语句块一起存储并用于链接（link）它们。此外，关于堆栈，存储和内存配置的知识被转发到下一个语句块。如果我们知道所有<code>JUMP</code>和<code>JUMPI</code>指令的目标，我们可以构建一个完整的程序流程图。如果只有一个我们不知道的目标（原则上这可能发生，跳跃目标可以从输入中计算），我们必须消除关于语句块输入状态的所有认知，因为它可能是未知<code>JUMP</code>指令的目标。如果任何<code>JUMPI</code>指令被发现评估为常数的条件，则将其转换为无条件跳转。</p>
<p>作为最后一步，每个语句块中的代码都会完全重新生成。从语句块的结尾处的表达式创建依赖关系图，并且不是该图的一部分的每个操作都基本上被丢弃。现在生成的代码会按照原始代码中的顺序将修改应用于内存和存储（删除已发现不需要的修改），最后在堆栈中正确的位置生成需要的所有值。</p>
<p>这些步骤适用于每个基本语句块，如果较小，则新生成的代码将用作替换。如果分析过程中在<code>JUMPI</code>指令处分割了一个基本语句块并且条件评估为常量，根据常量的值替换<code>JUMPI</code>指令，因此代码类似于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 7;</span><br><span class="line">data[7] = 9;</span><br><span class="line">if (data[x] != x + 2)</span><br><span class="line">  return 2;</span><br><span class="line">else</span><br><span class="line">  return 1;</span><br></pre></td></tr></table></figure></p>
<p>被简化为也可以编译的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[7] = 9;</span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure></p>
<p>即使指令在开始时包含<code>jump</code>指令。</p>
<h2 id="源映射（就是源码hash）"><a href="#源映射（就是源码hash）" class="headerlink" title="源映射（就是源码hash）"></a>源映射（就是源码hash）</h2><p>作为AST输出的一部分，编译器提供AST中相应节点所代表的源代码范围。这可以用于各种用途，包括基于AST报告错误的静态分析工具和突出显示局部变量及其用途的调试工具。</p>
<p>此外，编译器还可以生成从字节码到生成该指令的源代码范围的映射。对于在字节码级别上运行的静态分析工具以及对于在调试器中显示源代码当前位置或者对于断点处理，这一点同样重要。</p>
<p>这两种源映射都使用整数标识符（其实就是句柄）来引用源文件。这些是通常称为<code>&quot;sourceList&quot;</code>的源文件列表中的常规数组索引，它是组合json(combined-json)和json / npm编译器输出的一部分。</p>
<p><b style="color:#6ab0de">注意: 对于与任何特定源文件没有关联的指令的情况，源映射分配一个整数标识符-1。这可能发生在编译器生成的内联汇编语句的字节代码段中。</b></p>
<p>AST内的源映射使用以下表示法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:l:f</span><br></pre></td></tr></table></figure></p>
<p>其中s是对于源文件的开始位置的字节偏移， l是在字节源范围的长度和f为上述的源索引。</p>
<p>字节码的源映射中的编码更复杂：它是一个由<code>s:l:f:j</code>组成以<code>;</code>分隔的列表。每个元素都对应一条指令，即不能使用字节偏移量，但必须使用指令偏移量（推送指令长于单个字节）。的字段<code>s</code>，<code>l</code>和<code>f</code>如上文，<code>j</code>可以是<code>i</code>，<code>o</code>或<code>-</code>标志着一个跳转指令是否进入函数，从函数返回或是一个例如一个循环一部分的常规跳转。</p>
<p>为了压缩这些源映射，尤其是字节码，使用以下规则：</p>
<ul>
<li>如果一个字段为空，则使用前一个元素的值。</li>
<li>如果缺少<code>:</code>，则以下所有字段均视为空。</li>
</ul>
<p>这意味着以下源映射表示相同的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span><br><span class="line">1:2:1;:9;2:1:2;;</span><br></pre></td></tr></table></figure></p>
<h2 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h2><ul>
<li>在数组上用<code>delete</code>以删除其所有元素。</li>
<li>对结构元素使用较短的类型并对它们进行排序，以便将短类型组合在一起。这可以降低gas成本，因为多种<code>SSTORE</code>操作可能合并为一种（<code>SSTORE</code>成本5000或20000，因此这是您想要优化的）。使用天gas价格估算器（启用优化器）来检查！</li>
<li>让你的状态变量公开 - 编译器会自动为你创建<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#visibility-and-getters" target="_blank" rel="noopener">getters</a>。</li>
<li>如果总是在函数开始的地方检查输入条件或状态，请尝试使用<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#modifiers" target="_blank" rel="noopener">函数修饰符</a>。</li>
<li>如果你的合约有一个调用<code>send</code>的函数，但你想使用内置的send函数，请使用<code>address(contractVariable).send(amount)</code>。</li>
<li>用一个赋值语句初始化storage结构： <code>x = MyStruct({a: 1, b: 2});</code></li>
</ul>
<p>注意：如果存储结构具有压缩打包的属性，请使用单独的赋值对其进行初始化：<code>x.a = 1; x.b = 2;</code>。通过这种方式，优化器可以一次更新存储，从而使赋值更便宜。</p>
<h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><h3 id="操作符的优先顺序"><a href="#操作符的优先顺序" class="headerlink" title="操作符的优先顺序"></a>操作符的优先顺序</h3><p>以下是按评估顺序列出的操作符的优先顺序。</p>
<table>
<thead>
<tr>
<th>优先权</th>
<th>描述</th>
<th>操作者</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>后缀增量和减量</td>
<td><code>++</code>，<code>--</code></td>
</tr>
<tr>
<td></td>
<td>new的表达</td>
<td><code>new &lt;typename&gt;</code></td>
</tr>
<tr>
<td></td>
<td>数组下标</td>
<td><code>&lt;array&gt;[&lt;index&gt;]</code></td>
</tr>
<tr>
<td></td>
<td>成员访问</td>
<td><code>&lt;object&gt;.&lt;member&gt;</code></td>
</tr>
<tr>
<td></td>
<td>函数样式的调用</td>
<td><code>&lt;func&gt;(&lt;args...&gt;)</code></td>
</tr>
<tr>
<td></td>
<td>括号</td>
<td><code>(&lt;statement&gt;)</code></td>
</tr>
<tr>
<td>2</td>
<td>前缀增量和减量</td>
<td><code>++</code>，<code>--</code></td>
</tr>
<tr>
<td></td>
<td>一元正负号</td>
<td><code>+</code>，<code>-</code></td>
</tr>
<tr>
<td></td>
<td>一元操作</td>
<td><code>delete</code></td>
</tr>
<tr>
<td></td>
<td>逻辑NOT</td>
<td><code>!</code></td>
</tr>
<tr>
<td></td>
<td>按位取反</td>
<td><code>~</code></td>
</tr>
<tr>
<td>3</td>
<td>幂</td>
<td><code>**</code></td>
</tr>
<tr>
<td>4</td>
<td>乘法，除法和模</td>
<td><code>*</code>，<code>/</code>，<code>%</code></td>
</tr>
<tr>
<td>5</td>
<td>加减</td>
<td><code>+</code>，<code>-</code></td>
</tr>
<tr>
<td>6</td>
<td>按位移位运算符</td>
<td><code>&lt;&lt;</code>，<code>&gt;&gt;</code></td>
</tr>
<tr>
<td>7</td>
<td>按位与</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>8</td>
<td>按位XOR</td>
<td><code>^</code></td>
</tr>
<tr>
<td>9</td>
<td>按位或</td>
<td>&#124;</td>
</tr>
<tr>
<td>10</td>
<td>不等式操作符</td>
<td><code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code></td>
</tr>
<tr>
<td>11</td>
<td>等于操作符</td>
<td><code>==</code>，<code>!=</code></td>
</tr>
<tr>
<td>12</td>
<td>逻辑AND</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>13</td>
<td>逻辑或</td>
<td>&#124;&#124;</td>
</tr>
<tr>
<td>14</td>
<td>三元操作符</td>
<td><code>&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;</code></td>
</tr>
<tr>
<td>15</td>
<td>赋值运算符</td>
<td><code>=</code>，&#124;=，<code>^=</code>，<code>&amp;=</code>，<code>&lt;&lt;=</code>， <code>&gt;&gt;=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>， <code>%=</code></td>
</tr>
<tr>
<td>16</td>
<td>逗号运算符</td>
<td><code>,</code></td>
</tr>
</tbody>
</table>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的散列 - 仅适用于256个最新块</li>
<li><code>block.coinbase(address)</code>：当前块矿工的地址</li>
<li><code>block.difficulty(uint)</code>：当前区块的困难度</li>
<li><code>block.gaslimit(uint)</code>：当前区块的gaslimit</li>
<li><code>block.number(uint)</code>：当前区块的块高</li>
<li><code>block.timestamp(uint)</code>：当前区块的时间戳</li>
<li><code>gasleft() returns (uint256)</code>：剩余的gas</li>
<li><code>msg.data(bytes)</code>：完成calldata</li>
<li><code>msg.gas(uint)</code>：剩余gas - 在版本0.4.21中弃用并将被替换为<code>gasleft()</code></li>
<li><code>msg.sender(address)</code>：消息的发起者（当前调用者）</li>
<li><code>msg.value(uint)</code>：与消息一起发送的以太币数量（单位：wei）</li>
<li><code>now(uint)</code>：当前块时间戳（别名为<code>block.timestamp</code>）</li>
<li><code>tx.gasprice(uint)</code>：交易的gas价格</li>
<li><code>tx.origin(address)</code>：交易的发起者（完整的调用链）</li>
<li><code>assert(bool condition)</code>：如果条件是<code>false</code>,中止执行并恢复状态更改（用于内部错误）</li>
<li><code>require(bool condition)</code>：如果条件是<code>false</code>中止执行并恢复状态更改（用于格式错误的输入或外部组件中的错误）</li>
<li><code>revert()</code>：中止执行并恢复状态更改</li>
<li><code>keccak256(...) returns (bytes32)</code>：计算（紧密排列）参数的Ethereum-SHA-3（Keccak-256）散列</li>
<li><code>sha3(...) returns (bytes32)</code>：<code>keccak256</code>的别名 </li>
<li><code>sha256(...) returns (bytes32)</code>：计算（紧密排列）参数的SHA-256哈希值</li>
<li><code>ripemd160(...) returns (bytes20)</code>：计算（紧密排列）参数的RIPEMD-160哈希值</li>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：从椭圆曲线签名中恢复与公钥相关的地址，错误时返回零</li>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code>：计算<code>(x + y) % k</code>以任意精度执行加法的位置，并且不会在<code>2**256</code>环绕。断言<code>k != 0</code>从0.5.0版开始。</li>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：计算<code>(x * y) % k</code>以任意精度执行乘法的位置，并且不会在<code>2**256</code>绕回。断言<code>k != 0</code>从0.5.0版开始。</li>
<li><code>this</code>(当前合同的类型)：当前合约，明确转换为address</li>
<li><code>super</code>：继承层次结构高一级的合约</li>
<li><code>selfdestruct(address recipient)</code>：销毁当前的合约，将资金发送到给定的地址</li>
<li><code>suicide(address recipient)</code>：<code>selfdestruct</code>的别名 </li>
<li><code>&lt;address&gt;.balance(uint256)</code>：地址的余额（单位：wei）</li>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：发送指定地址相应数量的以太币，失败时返回false</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>：发送给地址指定数量的以太币，失败抛出异常</li>
</ul>
<h3 id="函数可见性说明符"><a href="#函数可见性说明符" class="headerlink" title="函数可见性说明符"></a>函数可见性说明符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &lt;visibility specifier&gt; returns (bool) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>public</code>：在外部和内部可见（为存储/状态变量创建一个<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#getter-functions" target="_blank" rel="noopener">getter函数</a>）</li>
<li><code>private</code>：只在当前合约中可见</li>
<li><code>external</code>：仅在外部可见（仅用于函数） - 即只能通过消息调用（通过<code>this.func</code>）</li>
<li><code>internal</code>：只在内部可见</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li><code>pure</code> 对于函数：禁止修改或访问状态 - 这还没有强制执行。</li>
<li><code>view</code> 函数：不允许修改状态 - 这还没有强制执行。</li>
<li><code>payable</code> 函数：允许他们在收到调用的同时接收Ether。</li>
<li><code>constant</code> 对于状态变量：禁止分配（初始化除外），不占用存储槽。</li>
<li><code>constant</code> 用于函数：与<code>view</code>相同。</li>
<li><code>anonymous</code> 事件：不将事件签名存储为主题。</li>
<li><code>indexed</code> 用于事件参数：将参数存储为主题。</li>
</ul>
<h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><p>这些关键字保留在Solidity中。它们可能成为未来语法的一部分：</p>
<p><code>abstract</code>，<code>after</code>，<code>case</code>，<code>catch</code>，<code>default</code>，<code>final</code>，<code>in</code>，<code>inline</code>，<code>let</code>，<code>match</code>，<code>null</code>， <code>of</code>，<code>relocatable</code>，<code>static</code>，<code>switch</code>，<code>try</code>，<code>type</code>，<code>typeof</code>。</p>
<h3 id="语言语法"><a href="#语言语法" class="headerlink" title="语言语法"></a>语言语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*</span><br><span class="line"></span><br><span class="line">// Pragma actually parses anything up to the trailing &apos;;&apos; to be fully forward-compatible.</span><br><span class="line">PragmaDirective = &apos;pragma&apos; Identifier ([^;]+) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ImportDirective = &apos;import&apos; StringLiteral (&apos;as&apos; Identifier)? &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; (&apos;*&apos; | Identifier) (&apos;as&apos; Identifier)? &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; &apos;&#123;&apos; Identifier (&apos;as&apos; Identifier)? ( &apos;,&apos; Identifier (&apos;as&apos; Identifier)? )* &apos;&#125;&apos; &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ContractDefinition = ( &apos;contract&apos; | &apos;library&apos; | &apos;interface&apos; ) Identifier</span><br><span class="line">                     ( &apos;is&apos; InheritanceSpecifier (&apos;,&apos; InheritanceSpecifier )* )?</span><br><span class="line">                     &apos;&#123;&apos; ContractPart* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ContractPart = StateVariableDeclaration | UsingForDeclaration</span><br><span class="line">             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition</span><br><span class="line"></span><br><span class="line">InheritanceSpecifier = UserDefinedTypeName ( &apos;(&apos; Expression ( &apos;,&apos; Expression )* &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">StateVariableDeclaration = TypeName ( &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; | &apos;constant&apos; )? Identifier (&apos;=&apos; Expression)? &apos;;&apos;</span><br><span class="line">UsingForDeclaration = &apos;using&apos; Identifier &apos;for&apos; (&apos;*&apos; | TypeName) &apos;;&apos;</span><br><span class="line">StructDefinition = &apos;struct&apos; Identifier &apos;&#123;&apos;</span><br><span class="line">                     ( VariableDeclaration &apos;;&apos; (VariableDeclaration &apos;;&apos;)* )? &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ModifierDefinition = &apos;modifier&apos; Identifier ParameterList? Block</span><br><span class="line">ModifierInvocation = Identifier ( &apos;(&apos; ExpressionList? &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">FunctionDefinition = &apos;function&apos; Identifier? ParameterList</span><br><span class="line">                     ( ModifierInvocation | StateMutability | &apos;external&apos; | &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; )*</span><br><span class="line">                     ( &apos;returns&apos; ParameterList )? ( &apos;;&apos; | Block )</span><br><span class="line">EventDefinition = &apos;event&apos; Identifier EventParameterList &apos;anonymous&apos;? &apos;;&apos;</span><br><span class="line"></span><br><span class="line">EnumValue = Identifier</span><br><span class="line">EnumDefinition = &apos;enum&apos; Identifier &apos;&#123;&apos; EnumValue? (&apos;,&apos; EnumValue)* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ParameterList = &apos;(&apos; ( Parameter (&apos;,&apos; Parameter)* )? &apos;)&apos;</span><br><span class="line">Parameter = TypeName StorageLocation? Identifier?</span><br><span class="line"></span><br><span class="line">EventParameterList = &apos;(&apos; ( EventParameter (&apos;,&apos; EventParameter )* )? &apos;)&apos;</span><br><span class="line">EventParameter = TypeName &apos;indexed&apos;? Identifier?</span><br><span class="line"></span><br><span class="line">FunctionTypeParameterList = &apos;(&apos; ( FunctionTypeParameter (&apos;,&apos; FunctionTypeParameter )* )? &apos;)&apos;</span><br><span class="line">FunctionTypeParameter = TypeName StorageLocation?</span><br><span class="line"></span><br><span class="line">// semantic restriction: mappings and structs (recursively) containing mappings</span><br><span class="line">// are not allowed in argument lists</span><br><span class="line">VariableDeclaration = TypeName StorageLocation? Identifier</span><br><span class="line"></span><br><span class="line">TypeName = ElementaryTypeName</span><br><span class="line">         | UserDefinedTypeName</span><br><span class="line">         | Mapping</span><br><span class="line">         | ArrayTypeName</span><br><span class="line">         | FunctionTypeName</span><br><span class="line"></span><br><span class="line">UserDefinedTypeName = Identifier ( &apos;.&apos; Identifier )*</span><br><span class="line"></span><br><span class="line">Mapping = &apos;mapping&apos; &apos;(&apos; ElementaryTypeName &apos;=&gt;&apos; TypeName &apos;)&apos;</span><br><span class="line">ArrayTypeName = TypeName &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line">FunctionTypeName = &apos;function&apos; FunctionTypeParameterList ( &apos;internal&apos; | &apos;external&apos; | StateMutability )*</span><br><span class="line">                   ( &apos;returns&apos; FunctionTypeParameterList )?</span><br><span class="line">StorageLocation = &apos;memory&apos; | &apos;storage&apos;</span><br><span class="line">StateMutability = &apos;pure&apos; | &apos;constant&apos; | &apos;view&apos; | &apos;payable&apos;</span><br><span class="line"></span><br><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |</span><br><span class="line">            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |</span><br><span class="line">              Throw | EmitStatement | SimpleStatement ) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ExpressionStatement = Expression</span><br><span class="line">IfStatement = &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Statement ( &apos;else&apos; Statement )?</span><br><span class="line">WhileStatement = &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; Statement</span><br><span class="line">PlaceholderStatement = &apos;_&apos;</span><br><span class="line">SimpleStatement = VariableDefinition | ExpressionStatement</span><br><span class="line">ForStatement = &apos;for&apos; &apos;(&apos; (SimpleStatement)? &apos;;&apos; (Expression)? &apos;;&apos; (ExpressionStatement)? &apos;)&apos; Statement</span><br><span class="line">InlineAssemblyStatement = &apos;assembly&apos; StringLiteral? InlineAssemblyBlock</span><br><span class="line">DoWhileStatement = &apos;do&apos; Statement &apos;while&apos; &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">Continue = &apos;continue&apos;</span><br><span class="line">Break = &apos;break&apos;</span><br><span class="line">Return = &apos;return&apos; Expression?</span><br><span class="line">Throw = &apos;throw&apos;</span><br><span class="line">EmitStatement = &apos;emit&apos; FunctionCall</span><br><span class="line">VariableDefinition = (&apos;var&apos; IdentifierList | VariableDeclaration) ( &apos;=&apos; Expression )?</span><br><span class="line">IdentifierList = &apos;(&apos; ( Identifier? &apos;,&apos; )* Identifier? &apos;)&apos;</span><br><span class="line"></span><br><span class="line">// Precedence by order (see github.com/ethereum/solidity/pull/732)</span><br><span class="line">Expression</span><br><span class="line">  = Expression (&apos;++&apos; | &apos;--&apos;)</span><br><span class="line">  | NewExpression</span><br><span class="line">  | IndexAccess</span><br><span class="line">  | MemberAccess</span><br><span class="line">  | FunctionCall</span><br><span class="line">  | &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">  | (&apos;!&apos; | &apos;~&apos; | &apos;delete&apos; | &apos;++&apos; | &apos;--&apos; | &apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression &apos;**&apos; Expression</span><br><span class="line">  | Expression (&apos;*&apos; | &apos;/&apos; | &apos;%&apos;) Expression</span><br><span class="line">  | Expression (&apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression (&apos;&lt;&lt;&apos; | &apos;&gt;&gt;&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;^&apos; Expression</span><br><span class="line">  | Expression &apos;|&apos; Expression</span><br><span class="line">  | Expression (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;) Expression</span><br><span class="line">  | Expression (&apos;==&apos; | &apos;!=&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;||&apos; Expression</span><br><span class="line">  | Expression &apos;?&apos; Expression &apos;:&apos; Expression</span><br><span class="line">  | Expression (&apos;=&apos; | &apos;|=&apos; | &apos;^=&apos; | &apos;&amp;=&apos; | &apos;&lt;&lt;=&apos; | &apos;&gt;&gt;=&apos; | &apos;+=&apos; | &apos;-=&apos; | &apos;*=&apos; | &apos;/=&apos; | &apos;%=&apos;) Expression</span><br><span class="line">  | PrimaryExpression</span><br><span class="line"></span><br><span class="line">PrimaryExpression = BooleanLiteral</span><br><span class="line">                  | NumberLiteral</span><br><span class="line">                  | HexLiteral</span><br><span class="line">                  | StringLiteral</span><br><span class="line">                  | TupleExpression</span><br><span class="line">                  | Identifier</span><br><span class="line">                  | ElementaryTypeNameExpression</span><br><span class="line"></span><br><span class="line">ExpressionList = Expression ( &apos;,&apos; Expression )*</span><br><span class="line">NameValueList = Identifier &apos;:&apos; Expression ( &apos;,&apos; Identifier &apos;:&apos; Expression )*</span><br><span class="line"></span><br><span class="line">FunctionCall = Expression &apos;(&apos; FunctionCallArguments &apos;)&apos;</span><br><span class="line">FunctionCallArguments = &apos;&#123;&apos; NameValueList? &apos;&#125;&apos;</span><br><span class="line">                      | ExpressionList?</span><br><span class="line"></span><br><span class="line">NewExpression = &apos;new&apos; TypeName</span><br><span class="line">MemberAccess = Expression &apos;.&apos; Identifier</span><br><span class="line">IndexAccess = Expression &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">BooleanLiteral = &apos;true&apos; | &apos;false&apos;</span><br><span class="line">NumberLiteral = ( HexNumber | DecimalNumber ) (&apos; &apos; NumberUnit)?</span><br><span class="line">NumberUnit = &apos;wei&apos; | &apos;szabo&apos; | &apos;finney&apos; | &apos;ether&apos;</span><br><span class="line">           | &apos;seconds&apos; | &apos;minutes&apos; | &apos;hours&apos; | &apos;days&apos; | &apos;weeks&apos; | &apos;years&apos;</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*</span><br><span class="line"></span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+ ( &apos;.&apos; [0-9]* )? ( [eE] [0-9]+ )?</span><br><span class="line"></span><br><span class="line">TupleExpression = &apos;(&apos; ( Expression? ( &apos;,&apos; Expression? )*  )? &apos;)&apos;</span><br><span class="line">                | &apos;[&apos; ( Expression  ( &apos;,&apos; Expression  )*  )? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">ElementaryTypeNameExpression = ElementaryTypeName</span><br><span class="line"></span><br><span class="line">ElementaryTypeName = &apos;address&apos; | &apos;bool&apos; | &apos;string&apos; | &apos;var&apos;</span><br><span class="line">                   | Int | Uint | Byte | Fixed | Ufixed</span><br><span class="line"></span><br><span class="line">Int = &apos;int&apos; | &apos;int8&apos; | &apos;int16&apos; | &apos;int24&apos; | &apos;int32&apos; | &apos;int40&apos; | &apos;int48&apos; | &apos;int56&apos; | &apos;int64&apos; | &apos;int72&apos; | &apos;int80&apos; | &apos;int88&apos; | &apos;int96&apos; | &apos;int104&apos; | &apos;int112&apos; | &apos;int120&apos; | &apos;int128&apos; | &apos;int136&apos; | &apos;int144&apos; | &apos;int152&apos; | &apos;int160&apos; | &apos;int168&apos; | &apos;int176&apos; | &apos;int184&apos; | &apos;int192&apos; | &apos;int200&apos; | &apos;int208&apos; | &apos;int216&apos; | &apos;int224&apos; | &apos;int232&apos; | &apos;int240&apos; | &apos;int248&apos; | &apos;int256&apos;</span><br><span class="line"></span><br><span class="line">Uint = &apos;uint&apos; | &apos;uint8&apos; | &apos;uint16&apos; | &apos;uint24&apos; | &apos;uint32&apos; | &apos;uint40&apos; | &apos;uint48&apos; | &apos;uint56&apos; | &apos;uint64&apos; | &apos;uint72&apos; | &apos;uint80&apos; | &apos;uint88&apos; | &apos;uint96&apos; | &apos;uint104&apos; | &apos;uint112&apos; | &apos;uint120&apos; | &apos;uint128&apos; | &apos;uint136&apos; | &apos;uint144&apos; | &apos;uint152&apos; | &apos;uint160&apos; | &apos;uint168&apos; | &apos;uint176&apos; | &apos;uint184&apos; | &apos;uint192&apos; | &apos;uint200&apos; | &apos;uint208&apos; | &apos;uint216&apos; | &apos;uint224&apos; | &apos;uint232&apos; | &apos;uint240&apos; | &apos;uint248&apos; | &apos;uint256&apos;</span><br><span class="line"></span><br><span class="line">Byte = &apos;byte&apos; | &apos;bytes&apos; | &apos;bytes1&apos; | &apos;bytes2&apos; | &apos;bytes3&apos; | &apos;bytes4&apos; | &apos;bytes5&apos; | &apos;bytes6&apos; | &apos;bytes7&apos; | &apos;bytes8&apos; | &apos;bytes9&apos; | &apos;bytes10&apos; | &apos;bytes11&apos; | &apos;bytes12&apos; | &apos;bytes13&apos; | &apos;bytes14&apos; | &apos;bytes15&apos; | &apos;bytes16&apos; | &apos;bytes17&apos; | &apos;bytes18&apos; | &apos;bytes19&apos; | &apos;bytes20&apos; | &apos;bytes21&apos; | &apos;bytes22&apos; | &apos;bytes23&apos; | &apos;bytes24&apos; | &apos;bytes25&apos; | &apos;bytes26&apos; | &apos;bytes27&apos; | &apos;bytes28&apos; | &apos;bytes29&apos; | &apos;bytes30&apos; | &apos;bytes31&apos; | &apos;bytes32&apos;</span><br><span class="line"></span><br><span class="line">Fixed = &apos;fixed&apos; | ( &apos;fixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">Ufixed = &apos;ufixed&apos; | ( &apos;ufixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">InlineAssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">AssemblyItem = Identifier | FunctionalAssemblyExpression | InlineAssemblyBlock | AssemblyLocalBinding | AssemblyAssignment | AssemblyLabel | NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">AssemblyLocalBinding = &apos;let&apos; Identifier &apos;:=&apos; FunctionalAssemblyExpression</span><br><span class="line">AssemblyAssignment = ( Identifier &apos;:=&apos; FunctionalAssemblyExpression ) | ( &apos;=:&apos; Identifier )</span><br><span class="line">AssemblyLabel = Identifier &apos;:&apos;</span><br><span class="line">FunctionalAssemblyExpression = Identifier &apos;(&apos; AssemblyItem? ( &apos;,&apos; AssemblyItem )* &apos;)&apos;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/04/blockchain/solidity汇编/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/blockchain/solidity汇编/" itemprop="url">solidity汇编</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T17:58:04+08:00">2018-04-04</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<p>Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由于EVM是堆栈机，因此通常很难解决正确的堆栈插槽问题，并为堆栈上正确的操作码提供参数。Solidity的内联汇编试图通过以下功能来促进编写手动汇编时出现的问题和其他问题：</p>
<ul>
<li>方法样式的操作码：<code>mul(1, add(2, 3))</code>替换<code>push1 3 push1 2 add push1 1 mul</code>.</li>
<li>装配局部变量：<code>let x := add(2, 3)  let y := mload(0x40)  x := add(x, y)</code></li>
<li>访问外部变量： <code>function f(uint x) public { assembly { x := sub(x, 1) } }</code></li>
<li>标签： <code>let x := 10  repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li>
<li>循环： <code>for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }</code></li>
<li>if语句： <code>if slt(x, 0) { x := sub(0, x) }</code></li>
<li>switch语句： <code>switch x case 0 { y := mul(x, 2) } default { y := 0 }</code></li>
<li>函数调用： <code>function f(x) -&gt; y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) }   }</code></li>
</ul>
<p>我们现在要详细描述内联汇编语言。</p>
<p><b style="color:#6ab0de">警告: 内联汇编是一种在低级别访问以太坊虚拟机的方法。这丢弃了Solidity的几个重要的安全特征。</b></p>
<p><b style="color:#6ab0de">注意: TODO：写下内联汇编的作用域规则如何有点不同并且例如使用库的内部函数时出现的复杂情况。此外，编写有关编译器定义的符号。</b></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例提供了库代码以访问另一个合同的代码并将其加载到bytes变量中。这对于“普通的solidity”来说根本不可能，并且这个想法是用组装库的方式来增强语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">library GetCode &#123;</span><br><span class="line">    function at(address _addr) public view returns (bytes o_code) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // retrieve the size of the code, this needs assembly</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line">            // allocate output byte array - this could also be done without assembly</span><br><span class="line">            // by using o_code = new bytes(size)</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line">            // new &quot;memory end&quot; including padding</span><br><span class="line">            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            // store length in memory</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line">            // actually retrieve the code, this needs assembly</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在优化器无法生成高效代码的情况下，内联汇编也可能有所帮助。请注意，由于编译器不执行检查，所以汇编更难以编写，因此只有在您确实知道自己在做什么时才应该将它用于复杂的事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // This function is less efficient because the optimizer currently fails to</span><br><span class="line">    // remove the bounds checks in array access.</span><br><span class="line">    function sumSolidity(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i)</span><br><span class="line">            o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know that we only access the array in bounds, so we can avoid the check.</span><br><span class="line">    // 0x20 needs to be added to an array because the first slot contains the</span><br><span class="line">    // array length.</span><br><span class="line">    function sumAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Same as above, but accomplish the entire code within inline assembly.</span><br><span class="line">    function sumPureAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">           // Load the length (first 32 bytes)</span><br><span class="line">           let len := mload(_data)</span><br><span class="line"></span><br><span class="line">           // Skip over the length field.</span><br><span class="line">           //</span><br><span class="line">           // Keep temporary variable so it can be incremented in place.</span><br><span class="line">           //</span><br><span class="line">           // NOTE: incrementing _data would result in an unusable</span><br><span class="line">           //       _data variable after this assembly block</span><br><span class="line">           let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">           // Iterate until the bound is not met.</span><br><span class="line">           for</span><br><span class="line">               &#123; let end := add(data, len) &#125;</span><br><span class="line">               lt(data, end)</span><br><span class="line">               &#123; data := add(data, 0x20) &#125;</span><br><span class="line">           &#123;</span><br><span class="line">               o_sum := add(o_sum, mload(data))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h3><p>Assembly会像Solidity一样解析注释，文字和标识符，因此您可以使用常规的<code>//</code>和<code>/* */</code>进行注释。内联汇编集<code>assembly { ... }</code>在这些花括号内标记，并且可以使用以下内容（请参阅后面的章节以获取更多详细信息）。</p>
<ul>
<li>文字，例如<code>0x123</code>，<code>42</code>或<code>&quot;abc&quot;</code>（最多32个字符的字符串）</li>
<li>操作码（在“指令样式”中），例如<code>mload sload dup1 sstore</code>，列表见下文.</li>
<li>方法风格的操作码，例如 <code>add(1, mlod(0))</code></li>
<li>标签，例如 <code>name:</code></li>
<li>变量声明，例如<code>let x := 7</code>，<code>let x := add(y, 3)</code>或<code>let x</code>（被分配初始值空（0））</li>
<li>标识符（如果用作内联汇编，则为标签、汇编局部变量和外部），例如<code>jump(name)</code>，<code>3 x add</code></li>
<li>赋值（以“指令风格”），例如 <code>3 =: x</code></li>
<li>函数风格的赋值，例如 <code>x := add(y, 3)</code></li>
<li>局部变量作用域范围的块，例如 <code>{ let x := 3 { let y := add(x, 1) } }</code></li>
</ul>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>本文档不希望成为以太坊虚拟机的完整描述，但下面的列表可用作其操作码的指南。</p>
<p>如果一个操作码需要参数（总是从栈顶开始），它们会在括号中给出。请注意，参数的顺序可以被看作是在不是函数风格中被颠倒（下面会解释）。<code>-</code>标记的操作码不会向堆上压项目，标记<code>*</code>的操作码是特殊的，所有其他操作符都只能将一个项目压入到堆栈中。标有<code>F</code>，<code>H</code>，<code>B</code>或<code>C</code>的操作码表明自从Frontier，Homestead, Byzantium or Constantinople开始就有了。Constantinople仍处于规划之中，所有标记如此的指令都将导致无效的指令异常。</p>
<p>在下文中，<code>mem[a...b)</code>表示从位置<code>a</code>直到（不包括）位置<code>b</code>的内存字节，<code>storage[p]</code>表示<code>storage</code>在p处的内容。</p>
<p>该操作码<code>pushi</code>和<code>jumpdest</code>不能直接使用。</p>
<p>在语法中，操作码被表示为预定义的标识符。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th></th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop</td>
<td>-</td>
<td>F</td>
<td>停止执行，与<code>return(0,0)</code>相同</td>
</tr>
<tr>
<td>add(x, y)</td>
<td></td>
<td>F</td>
<td>x + y</td>
</tr>
<tr>
<td>sub(x, y)</td>
<td></td>
<td>F</td>
<td>x - y</td>
</tr>
<tr>
<td>mul(x, y)</td>
<td></td>
<td>F</td>
<td>x * y</td>
</tr>
<tr>
<td>div(x, y)</td>
<td></td>
<td>F</td>
<td>x / y</td>
</tr>
<tr>
<td>sdiv(x，y)</td>
<td></td>
<td>F</td>
<td>x / y，用于补码中的有符号数</td>
</tr>
<tr>
<td>mod(x，y)</td>
<td></td>
<td>F</td>
<td>x％y</td>
</tr>
<tr>
<td>smod(x，y)</td>
<td></td>
<td>F</td>
<td>x％y，用于补码中的有符号数</td>
</tr>
<tr>
<td>exp(x，y)</td>
<td></td>
<td>F</td>
<td>x对y的幂</td>
</tr>
<tr>
<td>not(x)</td>
<td></td>
<td>F</td>
<td>〜x，x的每一位都是取反的</td>
</tr>
<tr>
<td>lt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&lt;y,值为1，否则为0</td>
</tr>
<tr>
<td>gt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&gt;y,值为1，否则为0</td>
</tr>
<tr>
<td>slt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>sgt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&gt;y，值为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>eq(x, y)</td>
<td></td>
<td>F</td>
<td>如果x == y, 为1，否则为0</td>
</tr>
<tr>
<td>iszero(x)</td>
<td></td>
<td>F</td>
<td>如果x == 0，为1，否则为0</td>
</tr>
<tr>
<td>and(x, y)</td>
<td></td>
<td>F</td>
<td>x和y按位与</td>
</tr>
<tr>
<td>or(x, y)</td>
<td></td>
<td>F</td>
<td>x和y按位或</td>
</tr>
<tr>
<td>xor(x, y)</td>
<td></td>
<td>F</td>
<td>x和y的按位异或</td>
</tr>
<tr>
<td>byte(n, x)</td>
<td></td>
<td>F</td>
<td>x的第n个字节，其中最高有效字节是第0字节</td>
</tr>
<tr>
<td>shl(x, y)</td>
<td></td>
<td>C</td>
<td>y逻辑左移x位</td>
</tr>
<tr>
<td>shr(x, y)</td>
<td></td>
<td>C</td>
<td>y逻辑右移x位</td>
</tr>
<tr>
<td>sar(x, y)</td>
<td></td>
<td>C</td>
<td>y算术右移x位</td>
</tr>
<tr>
<td>addmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>（x + y）％ m以任意精确算术</td>
</tr>
<tr>
<td>mulmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>（x * y）％m以任意精确算术</td>
</tr>
<tr>
<td>signextend(i, x)</td>
<td></td>
<td>F</td>
<td>符号从最低有效位（i*8 + 7）位开始计数</td>
</tr>
<tr>
<td>keccak256(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>sha3(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>jump(label)</td>
<td>-</td>
<td>F</td>
<td>跳转到标签/代码位置</td>
</tr>
<tr>
<td>jumpi(label, cond)</td>
<td>-</td>
<td>F</td>
<td>如果cond不为零，则跳转到标签</td>
</tr>
<tr>
<td>pc</td>
<td></td>
<td>F</td>
<td>代码中的当前位置</td>
</tr>
<tr>
<td>pop(x)</td>
<td>-</td>
<td>F</td>
<td>弹出x个栈顶元素</td>
</tr>
<tr>
<td>dup1…dup16</td>
<td></td>
<td>F</td>
<td>将第i个堆栈槽复制到顶部（从顶部开始计数）</td>
</tr>
<tr>
<td>swap1…swap16</td>
<td>*</td>
<td>F</td>
<td>交换栈顶和在其下面的第i个栈槽</td>
</tr>
<tr>
<td>mload(p)</td>
<td></td>
<td>F</td>
<td><code>mem[p..(p+32))</code></td>
</tr>
<tr>
<td>mstore(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p..(p+32)) := v</code></td>
</tr>
<tr>
<td>mstore8(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p] := v &amp; 0xff</code>（仅修改单个字节）</td>
</tr>
<tr>
<td>sload(p)</td>
<td></td>
<td>F</td>
<td>storage[p]</td>
</tr>
<tr>
<td>sstore(p, v)</td>
<td>-</td>
<td>F</td>
<td>storage[p] := v</td>
</tr>
<tr>
<td>msize</td>
<td></td>
<td>F</td>
<td>内存大小，即最大的访问内存索引</td>
</tr>
<tr>
<td>gas</td>
<td></td>
<td>F</td>
<td>仍然可以用于执行的gas</td>
</tr>
<tr>
<td>address</td>
<td></td>
<td>F</td>
<td>当前合同/执行上下文的地址</td>
</tr>
<tr>
<td>balance(a)</td>
<td></td>
<td>F</td>
<td>地址a的账户余额（wei）</td>
</tr>
<tr>
<td>caller</td>
<td></td>
<td>F</td>
<td>调用者（不含delegatecall）</td>
</tr>
<tr>
<td>callvalue</td>
<td></td>
<td>F</td>
<td>目前的调用一起发送的以太币（wei）</td>
</tr>
<tr>
<td>calldataload(p)</td>
<td></td>
<td>F</td>
<td>从位置p开始的调用数据（32字节）</td>
</tr>
<tr>
<td>calldatasize</td>
<td></td>
<td>F</td>
<td>调用数据的大小，以字节为单位</td>
</tr>
<tr>
<td>calldatacopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从calldata数据位置f复制s个字节到mem的位置t开始的位置</td>
</tr>
<tr>
<td>codesize</td>
<td></td>
<td>F</td>
<td>当前合同/执行上下文的代码大小</td>
</tr>
<tr>
<td>codecopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从位置f的代码复制s字节到mem的位置t</td>
</tr>
<tr>
<td>extcodesize(a)</td>
<td></td>
<td>F</td>
<td>地址a处代码的大小</td>
</tr>
<tr>
<td>extcodecopy(a, t, f, s)</td>
<td>-</td>
<td>F</td>
<td>像<code>codecopy(t, f, s)</code>，但是从地址a处获取代码</td>
</tr>
<tr>
<td>returndatasize</td>
<td></td>
<td>B</td>
<td>最近一次返回数据的大小</td>
</tr>
<tr>
<td>returndatacopy(t, f, s)</td>
<td>-</td>
<td>B</td>
<td>将返回数据f位置的字节复制到t位置的mem</td>
</tr>
<tr>
<td>create(v, p, s)</td>
<td></td>
<td>F</td>
<td>用代码mem[p..(p + s))创建新的合约并发送v wei以太币并返回新的地址</td>
</tr>
<tr>
<td>create2(v, n, p, s)</td>
<td></td>
<td>C</td>
<td>在地址<code>keccak256(&lt;address&gt; . n . keccak256(mem[p..(p+s)))</code> 创建与代码mem[p..(p + s))的新合约并发送v wei并返回新地址</td>
</tr>
<tr>
<td>call(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>在输入mem[in..(in + insize))时提供g gas和v wei以及输出区mem[out..(out + oversize))，在地址a处调用合约，并在错误时返回0,1代表成功</td>
</tr>
<tr>
<td>callcode(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与<code>call</code>相同，但只能使用地址a的代码，否则保留在当前合约的上下文中</td>
</tr>
<tr>
<td>delegatecall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>H</td>
<td>与<code>callcode</code>相同，但也保持<code>caller</code> 和<code>callvalue</code></td>
</tr>
<tr>
<td>staticcall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>B</td>
<td>与<code>call(g, a, 0, in, insize, out, outsize)</code>相同, 但不允许状态修改</td>
</tr>
<tr>
<td>return(p, s)</td>
<td>-</td>
<td>F</td>
<td>结束执行，返回数据mem[p..(p + s))</td>
</tr>
<tr>
<td>revert(p, s)</td>
<td>-</td>
<td>B</td>
<td>结束执行，恢复状态更改，返回数据mem[p..(p + s))</td>
</tr>
<tr>
<td>selfdestruct(a)</td>
<td>-</td>
<td>F</td>
<td>终止执行，摧毁当前合同并将资金发送给地址a</td>
</tr>
<tr>
<td>invalid</td>
<td>-</td>
<td>F</td>
<td>用无效指令结束执行</td>
</tr>
<tr>
<td>log0(p, s)</td>
<td>-</td>
<td>F</td>
<td>没有主题和mem[p..(p + s))的数据的日志</td>
</tr>
<tr>
<td>log1(p, s, t1)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1和mem[p..(p + s))的数据</td>
</tr>
<tr>
<td>log2(p, s, t1, t2)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>log3(p, s, t1, t2, t3)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2，t3和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>log4(p, s, t1, t2, t3, t4)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2，t3，t4和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>origin</td>
<td></td>
<td>F</td>
<td>交易发送者</td>
</tr>
<tr>
<td>gasprice</td>
<td></td>
<td>F</td>
<td>交易的gas价格</td>
</tr>
<tr>
<td>blockhash(b)</td>
<td></td>
<td>F</td>
<td>块b的散列值 - 仅适用于不包括当前值的最后256个块</td>
</tr>
<tr>
<td>coinbase</td>
<td></td>
<td>F</td>
<td>目前的采矿受益者</td>
</tr>
<tr>
<td>timestamp</td>
<td></td>
<td>F</td>
<td>当前块的时间戳，以秒为单位</td>
</tr>
<tr>
<td>number</td>
<td></td>
<td>F</td>
<td>当前区块高度</td>
</tr>
<tr>
<td>difficulty</td>
<td></td>
<td>F</td>
<td>当前块的难度</td>
</tr>
<tr>
<td>gaslimit</td>
<td></td>
<td>F</td>
<td>当前块的区块gas限制</td>
</tr>
</tbody>
</table>
<h3 id="字面Literals"><a href="#字面Literals" class="headerlink" title="字面Literals"></a>字面Literals</h3><p>您可以使用十进制或十六进制符号键入整数常量，这会自动生成相应的<code>PUSHi</code>指令。下面创建代码，将2和3加起来得到5，然后与字符串“abc”进行按位与计算。字符串存储为左对齐，不能超过32个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; 2 3 add &quot;abc&quot; and &#125;</span><br></pre></td></tr></table></figure></p>
<p>译者注：这个看起来像比特币的脚本语言有木有。（基于堆栈的脚本语言，也就是说solidity的底层实现有点像比特币脚本，只是支持跳转语句而已）。</p>
<h3 id="函数风格"><a href="#函数风格" class="headerlink" title="函数风格"></a>函数风格</h3><p>您可以在操作码之后键入操作码，它们将以字节码结尾。例如将内存中在位置0x80处的数据加3，将是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0x80 mload add 0x80 mstore</span><br></pre></td></tr></table></figure></p>
<p>由于通常很难看到某些操作码的实际参数是什么，所以Solidity内联汇编还提供了一种“函数风格”表示法，其中相同的代码可如下编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(0x80, add(mload(0x80), 3))</span><br></pre></td></tr></table></figure></p>
<p>函数风格表达式不能在内部使用函数风格，例如<code>1 2 mstore(0x80, add)</code>不是有效的程序，它必须写成<code>mstore(0x80, add(2, 1))</code>。对于不带参数的操作码，括号可以省略。</p>
<p><b style="color:red">请注意，参数的顺序在函数风格中与指令风格完全相反</b>。如果使用函数风格，第一个参数将会在堆栈顶部结束。</p>
<h3 id="访问外部变量和函数"><a href="#访问外部变量和函数" class="headerlink" title="访问外部变量和函数"></a>访问外部变量和函数</h3><p><b style="color:red">通过简单地使用它们的名称就可以访问solidity变量和其他标识符。对于内存变量，这会将地址而不是值推入堆栈</b>。<b style="color:red">存储变量不同：存储中的值可能不占用完整的存储槽，因此它们的“地址”由该槽中的槽和字节偏移量组成</b>。要检索变量<code>x</code>指向的槽，你需要使用<code>x_slot</code>并检索您使用的字节偏移量<code>x_offset</code>。</p>
<p>在赋值中（见下文），我们甚至可以使用本地Solidity变量来赋值。</p>
<p>也可以访问内联汇编外部的函数：汇编将推入它们的入口标签（应用虚函数解析）。solidity中可靠的调用语义是：</p>
<ul>
<li>调用者将<code>return label, arg1, arg2, …, argn</code>压入栈中</li>
<li>调用连同<code>ret1, ret2, …, retm</code>返回。</li>
</ul>
<p>这个特性使用起来还是有点麻烦，因为在调用期间堆栈偏移量实际上会发生变化，因此对局部变量的引用将会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    function f(uint x) public returns (uint r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) // ignore the offset, we know it is zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>EVM组装中的另一个问题是，jump和jumpi使用可以轻易改变的绝对地址。Solidity内联汇编提供了标签，以便更容易地使用跳转。请注意，标签是低级特征，只需使用汇编函数，loops，if和switch指令（参见下文），就可以编写无标签的高效汇编。以下代码计算斐波那契数列中的一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let n := calldataload(4)</span><br><span class="line">    let a := 1</span><br><span class="line">    let b := a</span><br><span class="line">loop:</span><br><span class="line">    jumpi(loopend, eq(n, 0))</span><br><span class="line">    a add swap1</span><br><span class="line">    n := sub(n, 1)</span><br><span class="line">    jump(loop)</span><br><span class="line">loopend:</span><br><span class="line">    mstore(0, a)</span><br><span class="line">    return(0, 0x20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，只有汇编器知道当前堆栈高度时，才能自动访问堆栈变量。如果跳转源和目标具有不同的堆栈高度，这将失效。使用这种跳转仍然ok，但在这种情况下，您应该不会访问任何堆栈变量（即使是汇编中的变量）。</p>
<p>此外，堆栈高度分析器通过操作码（而不是根据控制流）执行代码操作码，因此在下列情况下，汇编器对在标签<code>two</code>处的堆栈高度会产生错误印象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 8</span><br><span class="line">    jump(two)</span><br><span class="line">    one:</span><br><span class="line">        // Here the stack height is 2 (because we pushed x and 7),</span><br><span class="line">        // but the assembler thinks it is 1 because it reads</span><br><span class="line">        // from top to bottom.</span><br><span class="line">        // Accessing the stack variable x here will lead to errors.</span><br><span class="line">        x := 9</span><br><span class="line">        jump(three)</span><br><span class="line">    two:</span><br><span class="line">        7 // push something onto the stack</span><br><span class="line">        jump(one)</span><br><span class="line">    three:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>译者注：看来这是堆栈式语言引入jump之后带来的一个大问题，不知道如何解决这个问题，这个问题既有编译器编译逻辑也有机器代码逻辑的表示。</p>
<h3 id="声明汇编本地变量"><a href="#声明汇编本地变量" class="headerlink" title="声明汇编本地变量"></a>声明汇编本地变量</h3><p>您可以使用let关键字来声明仅在内联程序中可见的变量，实际上仅在当前的<code>{...}</code>块中可见。<b style="color:red">该let指令将创建一个为变量保留的新堆栈槽，并在达到语句块末尾时再次自动删除</b>。您需要为变量提供一个初始值0，但它也可以是一个复杂的函数风格表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint x) public view returns (uint b) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let v := add(x, 1)</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line">            &#123;</span><br><span class="line">                let y := add(sload(v), 1)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; // y is &quot;deallocated&quot; here</span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; // v is &quot;deallocated&quot; here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以将汇编局部变量和局部变量赋值给函数。请注意，当您给指向内存或存储的变量赋值时，只会更改指针而不是数据。</p>
<p>有两种赋值方式：函数风格和指令风格。对于函数风格赋值（<code>variable := value</code>），您需要在函数风格表达式中提供一个值，该值可以导致恰好一个堆栈值，对于指令风格赋值（<code>=: variable</code>），该值仅从堆栈顶部获取。对于这两种方式，冒号<code>:</code>指向变量的名称。通过用新值替换堆栈上的变量值来执行赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0 // functional-style assignment as part of variable declaration</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    sload(10)</span><br><span class="line">    =: v // instruction style assignment, puts the result of sload(10) into v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句可以用于有条件地执行代码。没有“else”部分，如果您需要多种选择，请考虑使用“switch”（请参阅​​下文）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if eq(value, 0) &#123; revert(0, 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主体的花括号是必需的。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>你可以使用switch语句作为“if/else”的一个非常基本的版本（由于汇编中if没有else，我们可以使用switch的default代替）。它采用表达式的值并将其与几个常量进行比较，采用与匹配常数对应的分支。与某些编程语言的容易出错的行为相反，控制流不会从一种情况继续下去。可以有一个回退或默认情况称为<code>default</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    switch calldataload(4)</span><br><span class="line">    case 0 &#123;</span><br><span class="line">        x := calldataload(0x24)</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        x := calldataload(0x44)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(0, div(x, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>case可以不用大括号，但case的主体确实需要它们。</p>
<h3 id="循环Loops"><a href="#循环Loops" class="headerlink" title="循环Loops"></a>循环Loops</h3><p>汇编支持一个简单的for-style循环。For-style循环有一个包含初始化部分，条件和后迭代部分的头文件。条件必须是功能式的表达，而另外两个是语句块。如果初始化部分声明了任何变量，则这些变量的作用域被扩展到正文中（包括条件和后迭代部分）。</p>
<p>以下示例计算内存中区域的总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For循环也可以写成像while循环一样：只需将初始化和后迭代部分留空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    let i := 0</span><br><span class="line">    for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123;     // while(i &lt; 0x100)</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, 0x20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>内联汇编允许定义低级函数。这些从堆栈中取出它们的参数（并返回PC），并将结果放入堆栈。调用函数的方式与执行函数风格的操作码相同。</p>
<p>函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在该函数之外定义的局部变量。没有明确的<code>return</code>语句。</p>
<p>如果您调用返回多个值的函数，则必须使用<code>a, b := f(x)</code>或者<code>let a, b := f(x)</code> 将它们分配给元组。</p>
<p>以下示例通过平方和乘法实现幂函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base, exponent) -&gt; result &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0 &#123; result := 1 &#125;</span><br><span class="line">        case 1 &#123; result := base &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">            // 通过递归进行幂值计算。</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2))</span><br><span class="line">            switch mod(exponent, 2)</span><br><span class="line">                case 1 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="要避免的事情"><a href="#要避免的事情" class="headerlink" title="要避免的事情"></a>要避免的事情</h3><p>内联汇编可能具有相当高级的表象，但实际上它是非常低级的。函数调用，loops，ifs和switch通过简单的重写规则进行转换，之后，汇编程序为您做的唯一事情就是重新安排函数风格的操作码，管理跳转标签，计算变量访问的堆栈高度并在到达语句块的末尾时删除堆栈槽中分配的本地变量。特别是对于最后两种情况，<b style="color:red">重要的是要知道，汇编程序仅从上到下计数堆栈高度，而不一定遵循控制流程。而且，swap等操作只会交换堆栈的内容，而不会交换变量的位置。</b></p>
<h3 id="solidity约定"><a href="#solidity约定" class="headerlink" title="solidity约定"></a>solidity约定</h3><p><b style="color:blue">与EVM组装相反，Solidity知道窄于256位的类型，例如uint24。为了使它们更高效，大多数算术运算只将它们视为256位数字，而高位仅在必要时清除，即在它们被写入内存之前或执行比较之前。这意味着如果您从内联汇编中访问这样的变量，则可能必须首先手动清除更高位。</b>这个有助于我们理解solidity的工作机制。</p>
<p>Solidity以一种非常简单的方式管理内存：内存位置<code>0x40</code>处有一个“空闲内存指针”。如果你想分配内存，只需在那个位置使用内存，并相应地更新指针。</p>
<p>在solidity的内存数组元素始终占据32个字节（是的，对于<code>byte[]</code>，这是真实的，而对于<code>bytes</code>和<code>string</code>不是这样）。多维内存数组是指向内存数组的指针。动态数组的长度存储在数组的第一个插槽中，然后跟随数组元素。</p>
<p><b style="color:#6ab0de">警告:静态大小的内存数组没有长度字段，但它很快就会添加，以便在静态和动态大小的数组之间实现更好的可转换性，所以请不要依赖它。</b></p>
<h2 id="独立汇编"><a href="#独立汇编" class="headerlink" title="独立汇编"></a>独立汇编</h2><p>以上内联汇编语言描述的汇编语言也可以单独使用，实际上，计划是将其用作Solidity编译器的中间语言。在这种形式下，它试图实现几个目标：</p>
<ol>
<li>写在其中的程序应该是可读的，即使代码是由Solidity的编译器生成的。</li>
<li>从汇编到字节码的翻译应该包含尽可能少的“surprises”。</li>
<li>控制流应该易于检测，以帮助进行格式验证和优化。</li>
</ol>
<p>为了实现第一个和最后一个目标，汇编提供了高层次的结构，如<code>for</code>循环，<code>if</code>和<code>switch</code>语句和函数调用。它应该能够编写汇编程序不使用明确的<code>SWAP</code>，<code>DUP</code>， <code>JUMP</code>和<code>JUMPI</code>语句，因为前两个模糊的数据流和最后两个模糊处理的控制流。此外，函数语句<code>mul(add(x, y), 7)</code>优于纯操作码语句<code>7 y x add mul</code>， 因为在第一种形式中，更容易看出哪个操作数用于哪个操作码。</p>
<p>第二个目标是通过引入一个desugaring阶段来实现的，该阶段只能以非常规的方式移除较高级别的构造，并且仍然允许检查生成的低级汇编代码。汇编程序执行的唯一非本地操作是用户定义的标识符（函数，变量，…）的名称查找，它遵循非常简单和常规的范围规则以及从堆栈中清除局部变量。</p>
<p>作用域：声明的标识符（标签，变量，函数，汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。跨函数边界访问局部变量是不合法的，即使它们在范围内。阴影是不允许的。局部变量在声明之前不能被访问，但标签，函数和内联汇编可以。assembly是特殊的语句块，用于例如返回运行时代码或创建合约。子assembly中没有可见的外部assembly标识符。</p>
<p>如果控制流经过语句块的末尾，则会插入与该语句块中声明的局部变量数匹配的流行指令。无论何时引用局部变量，代码生成器都需要知道其当前在堆栈中的相对位置，因此需要跟踪当前所谓的堆栈高度。<b style="color:red">由于所有局部变量都在块的末尾被删除，块前后的堆栈高度应该相同。如果情况并非如此，则会发出警告。</b></p>
<p>为什么要使用更高级别的结构类似<code>switch</code>，<code>for</code>和函数：</p>
<p>使用switch，for和函数，它应该有可能编写复杂的代码，而无需手工使用jump或jumpi。这使得分析控制流程变得更加容易，从而可以改进格式验证和优化。</p>
<p>此外，如果允许手动跳转，计算堆栈高度相当复杂。需要知道堆栈中所有局部变量的位置，否则在块结束时既不会自动引用局部变量也不会从堆栈中自动删除局部变量。脱钩机构正确地将操作插入无法访问的语句块，以便在没有持续控制流的跳转情况下正确调整堆栈高度。</p>
<p>例：我们将按照Solidity的示例汇编去装配。我们考虑以下Solidity程序的运行时字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  function f(uint x) public pure returns (uint y) &#123;</span><br><span class="line">    y = 1;</span><br><span class="line">    for (uint i = 0; i &lt; x; i++)</span><br><span class="line">      y = 2 * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将生成以下汇编：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60) // store the &quot;free memory pointer&quot;</span><br><span class="line">  // function dispatcher</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // memory allocator</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // the contract function</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解除阶段后，它看起来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60)</span><br><span class="line">  &#123;</span><br><span class="line">    let $0 := div(calldataload(0), exp(2, 226))</span><br><span class="line">    jumpi($case1, eq($0, 0xb3de648b))</span><br><span class="line">    jump($caseDefault)</span><br><span class="line">    $case1:</span><br><span class="line">    &#123;</span><br><span class="line">      // the function call - we put return label and arguments on the stack</span><br><span class="line">      $ret1 calldataload(4) jump(f)</span><br><span class="line">      // This is unreachable code. Opcodes are added that mirror the</span><br><span class="line">      // effect of the function on the stack height: Arguments are</span><br><span class="line">      // removed and return values are introduced.</span><br><span class="line">      pop pop</span><br><span class="line">      let r := 0</span><br><span class="line">      $ret1: // the actual return point</span><br><span class="line">      $ret2 0x20 jump($allocate)</span><br><span class="line">      pop pop let ret := 0</span><br><span class="line">      $ret2:</span><br><span class="line">      mstore(ret, r)</span><br><span class="line">      return(ret, 0x20)</span><br><span class="line">      // although it is useless, the jump is automatically inserted,</span><br><span class="line">      // since the desugaring process is a purely syntactic operation that</span><br><span class="line">      // does not analyze control-flow</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $caseDefault:</span><br><span class="line">    &#123;</span><br><span class="line">      revert(0, 0)</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $endswitch:</span><br><span class="line">  &#125;</span><br><span class="line">  jump($afterFunction)</span><br><span class="line">  allocate:</span><br><span class="line">  &#123;</span><br><span class="line">    // we jump over the unreachable code that introduces the function arguments</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let size := 0</span><br><span class="line">    $start:</span><br><span class="line">    // output variables live in the same scope as the arguments and is</span><br><span class="line">    // actually allocated.</span><br><span class="line">    let pos := 0</span><br><span class="line">    &#123;</span><br><span class="line">      pos := mload(0x40)</span><br><span class="line">      mstore(0x40, add(pos, size))</span><br><span class="line">    &#125;</span><br><span class="line">    // This code replaces the arguments by the return values and jumps back.</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    // Again unreachable code that corrects stack height.</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  f:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let x := 0</span><br><span class="line">    $start:</span><br><span class="line">    let y := 0</span><br><span class="line">    &#123;</span><br><span class="line">      let i := 0</span><br><span class="line">      $for_begin:</span><br><span class="line">      jumpi($for_end, iszero(lt(i, x)))</span><br><span class="line">      &#123;</span><br><span class="line">        y := mul(2, y)</span><br><span class="line">      &#125;</span><br><span class="line">      $for_continue:</span><br><span class="line">      &#123; i := add(i, 1) &#125;</span><br><span class="line">      jump($for_begin)</span><br><span class="line">      $for_end:</span><br><span class="line">    &#125; // Here, a pop instruction will be inserted for i</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  $afterFunction:</span><br><span class="line">  stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇编发生在以下四个阶段：</p>
<ol>
<li>解析</li>
<li>Desugaring（移除switch，for和函数）</li>
<li>操作码流生成</li>
<li>字节码生成</li>
</ol>
<p>我们将以伪正式的方式指定第一步到第三步。更正式的规格将随之而来。</p>
<h3 id="解析-语法"><a href="#解析-语法" class="headerlink" title="解析/语法"></a>解析/语法</h3><p>解析器的任务如下：</p>
<ul>
<li>将字节流转换为标识符（就是每一个单词）流，丢弃C++风格的注释（对源引用存在特殊注释，但我们不在这里解释）。</li>
<li>根据下面的语法将标识符流转换为AST</li>
<li>使用它们在其定义的语句块中注册标识符（注释到AST节点）并注意从哪个点开始，可以访问变量。</li>
</ul>
<p>汇编词法分析器遵循由Solidity自己定义的那个。</p>
<p>空格用于分隔标识符，它由空格，制表符和换行符组成。评论是常规的JavaScript/C++评论，并且以与Whitespace相同的方式进行解释。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line">AssemblyItem =</span><br><span class="line">    Identifier |</span><br><span class="line">    AssemblyBlock |</span><br><span class="line">    AssemblyExpression |</span><br><span class="line">    AssemblyLocalDefinition |</span><br><span class="line">    AssemblyAssignment |</span><br><span class="line">    AssemblyStackAssignment |</span><br><span class="line">    LabelDefinition |</span><br><span class="line">    AssemblyIf |</span><br><span class="line">    AssemblySwitch |</span><br><span class="line">    AssemblyFunctionDefinition |</span><br><span class="line">    AssemblyFor |</span><br><span class="line">    &apos;break&apos; |</span><br><span class="line">    &apos;continue&apos; |</span><br><span class="line">    SubAssembly</span><br><span class="line">AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral</span><br><span class="line">AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">AssemblyCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;</span><br><span class="line">AssemblyLocalDefinition = &apos;let&apos; IdentifierOrList ( &apos;:=&apos; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = IdentifierOrList &apos;:=&apos; AssemblyExpression</span><br><span class="line">IdentifierOrList = Identifier | &apos;(&apos; IdentifierList &apos;)&apos;</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">AssemblyStackAssignment = &apos;=:&apos; Identifier</span><br><span class="line">LabelDefinition = Identifier &apos;:&apos;</span><br><span class="line">AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &apos;switch&apos; AssemblyExpression AssemblyCase*</span><br><span class="line">    ( &apos;default&apos; AssemblyBlock )?</span><br><span class="line">AssemblyCase = &apos;case&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblyFunctionDefinition = &apos;function&apos; Identifier &apos;(&apos; IdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; &apos;(&apos; IdentifierList &apos;)&apos; )? AssemblyBlock</span><br><span class="line">AssemblyFor = &apos;for&apos; ( AssemblyBlock | AssemblyExpression )</span><br><span class="line">    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock</span><br><span class="line">SubAssembly = &apos;assembly&apos; Identifier AssemblyBlock</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure></p>
<h3 id="Desugaring-去除语法糖"><a href="#Desugaring-去除语法糖" class="headerlink" title="Desugaring(去除语法糖)"></a>Desugaring(去除语法糖)</h3><p>AST转换删除<code>for</code>,<code>switch</code>和函数结构。结果仍然可以由同一个解析器解析，但它不会使用某些结构。如果jumpdests被添加，只跳转到不继续，将添加有关堆栈内容的信息，除非未访问外部作用域的局部变量或堆栈高度与前一条指令相同。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">desugar item: AST -&gt; AST =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyFunctionDefinition(&apos;function&apos; name &apos;(&apos; arg1, ..., argn &apos;)&apos; &apos;-&gt;&apos; ( &apos;(&apos; ret1, ..., retm &apos;)&apos; body) -&gt;</span><br><span class="line">  &lt;name&gt;:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($&lt;name&gt;_start)</span><br><span class="line">    let $retPC := 0 let argn := 0 ... let arg1 := 0</span><br><span class="line">    $&lt;name&gt;_start:</span><br><span class="line">    let ret1 := 0 ... let retm := 0</span><br><span class="line">    &#123; desugar(body) &#125;</span><br><span class="line">    swap and pop items so that only ret1, ... retm, $retPC are left on the stack</span><br><span class="line">    jump</span><br><span class="line">    0 (1 + n times) to compensate removal of arg1, ..., argn and $retPC</span><br><span class="line">  &#125;</span><br><span class="line">AssemblyFor(&apos;for&apos; &#123; init &#125; condition post body) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    init // cannot be its own block because we want variable scope to extend into the body</span><br><span class="line">    // find I such that there are no labels $forI_*</span><br><span class="line">    $forI_begin:</span><br><span class="line">    jumpi($forI_end, iszero(condition))</span><br><span class="line">    &#123; body &#125;</span><br><span class="line">    $forI_continue:</span><br><span class="line">    &#123; post &#125;</span><br><span class="line">    jump($forI_begin)</span><br><span class="line">    $forI_end:</span><br><span class="line">  &#125;</span><br><span class="line">&apos;break&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_end</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_end</span><br><span class="line">    jump($forI_end)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">&apos;continue&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_continue</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_continue</span><br><span class="line">    jump($forI_continue)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">AssemblySwitch(switch condition cases ( default: defaultBlock )? ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find I such that there is no $switchI* label or variable</span><br><span class="line">    let $switchI_value := condition</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: -&gt; jumpi($switchI_caseJ, eq($switchI_value, val))</span><br><span class="line">    &#125;</span><br><span class="line">    if default block present: -&gt;</span><br><span class="line">      &#123; defaultBlock jump($switchI_end) &#125;</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: &#123; body &#125; -&gt; $switchI_caseJ: &#123; body jump($switchI_end) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $switchI_end:</span><br><span class="line">  &#125;</span><br><span class="line">FunctionalAssemblyExpression( identifier(arg1, arg2, ..., argn) ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    if identifier is function &lt;name&gt; with n args and m ret values -&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        // find I such that $funcallI_* does not exist</span><br><span class="line">        $funcallI_return argn  ... arg2 arg1 jump(&lt;name&gt;)</span><br><span class="line">        pop (n + 1 times)</span><br><span class="line">        if the current context is `let (id1, ..., idm) := f(...)` -&gt;</span><br><span class="line">          let id1 := 0 ... let idm := 0</span><br><span class="line">          $funcallI_return:</span><br><span class="line">        else -&gt;</span><br><span class="line">          0 (m times)</span><br><span class="line">          $funcallI_return:</span><br><span class="line">          turn the functional expression that leads to the function call</span><br><span class="line">          into a statement stream</span><br><span class="line">      &#125;</span><br><span class="line">    else -&gt; desugar(children of node)</span><br><span class="line">  &#125;</span><br><span class="line">default node -&gt;</span><br><span class="line">  desugar(children of node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成操作码流"><a href="#生成操作码流" class="headerlink" title="生成操作码流"></a>生成操作码流</h3><p>在操作码流生成期间，我们会跟踪计数器中的当前堆栈高度，以便可以通过名称访问堆栈变量。每个修改堆栈的操作码以及每个用堆栈调整注释的标签都会修改堆栈高度。每次引入一个新的局部变量时，它都会与当前堆栈高度一起注册。如果访问变量（复制其值或赋值），则根据引入变量时当前堆栈高度和堆栈高度之间的差异选择适当的<code>DUP</code>或<code>SWAP</code>指令。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">codegen item: AST -&gt; opcode_stream =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyBlock(&#123; items &#125;) -&gt;</span><br><span class="line">  join(codegen(item) for item in items)</span><br><span class="line">  if last generated opcode has continuing control flow:</span><br><span class="line">    POP for all local variables registered at the block (including variables</span><br><span class="line">    introduced by labels)</span><br><span class="line">    warn if the stack height at this point is not the same as at the start of the block</span><br><span class="line">Identifier(id) -&gt;</span><br><span class="line">  lookup id in the syntactic stack of blocks</span><br><span class="line">  match type of id</span><br><span class="line">    Local Variable -&gt;</span><br><span class="line">      DUPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">    Label -&gt;</span><br><span class="line">      // reference to be resolved during bytecode generation</span><br><span class="line">      PUSH&lt;bytecode position of label&gt;</span><br><span class="line">    SubAssembly -&gt;</span><br><span class="line">      PUSH&lt;bytecode position of subassembly data&gt;</span><br><span class="line">FunctionalAssemblyExpression(id ( arguments ) ) -&gt;</span><br><span class="line">  join(codegen(arg) for arg in arguments.reversed())</span><br><span class="line">  id (which has to be an opcode, might be a function name later)</span><br><span class="line">AssemblyLocalDefinition(let (id1, ..., idn) := expr) -&gt;</span><br><span class="line">  register identifiers id1, ..., idn as locals in current block at current stack height</span><br><span class="line">  codegen(expr) - assert that expr returns n items to the stack</span><br><span class="line">FunctionalAssemblyAssignment((id1, ..., idn) := expr) -&gt;</span><br><span class="line">  lookup id1, ..., idn in the syntactic stack of blocks, assert that they are variables</span><br><span class="line">  codegen(expr)</span><br><span class="line">  for j = n, ..., i:</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(idj)</span><br><span class="line">  POP</span><br><span class="line">AssemblyAssignment(=: id) -&gt;</span><br><span class="line">  look up id in the syntactic stack of blocks, assert that it is a variable</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">  POP</span><br><span class="line">LabelDefinition(name:) -&gt;</span><br><span class="line">  JUMPDEST</span><br><span class="line">NumberLiteral(num) -&gt;</span><br><span class="line">  PUSH&lt;num interpreted as decimal and right-aligned&gt;</span><br><span class="line">HexLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit interpreted as hex and left-aligned&gt;</span><br><span class="line">StringLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit utf-8 encoded and left-aligned&gt;</span><br><span class="line">SubAssembly(assembly &lt;name&gt; block) -&gt;</span><br><span class="line">  append codegen(block) at the end of the code</span><br><span class="line">dataSize(&lt;name&gt;) -&gt;</span><br><span class="line">  assert that &lt;name&gt; is a subassembly -&gt;</span><br><span class="line">  PUSH32&lt;size of code generated from subassembly &lt;name&gt;&gt;</span><br><span class="line">linkerSymbol(&lt;lit&gt;) -&gt;</span><br><span class="line">  PUSH32&lt;zeros&gt; and append position to linker table</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">85</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">82</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
