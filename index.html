<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/06/01/blockchain/corda/Cordapp基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/blockchain/corda/Cordapp基础知识/" itemprop="url">Cordapp基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T10:17:22+08:00">2018-06-01</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CorDapps（Corda分布式应用程序）是在Corda平台上运行的分布式应用程序。CorDapp的目标是允许节点就分类账更新达成一致。他们通过定义Corda节点所有者可以通过RPC调用调用的流程来实现此目标：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/node-diagram.png" alt=""></p>
<p>Cordapps由以下关键组件组成：</p>
<ul>
<li>状态： 达成协议的事实</li>
<li>合约： 定义构成有效分类账更新的内容</li>
<li>服务： 在节点内提供长寿命的工具</li>
<li>序列化白名单： 限制节点从网络线路接收的类型</li>
</ul>
<p>每个Cordapp安装在单节点级别，而不是网络本身。例如，节点所有者可以选择安装Bond Trading CorDapp，并具有以下组件：</p>
<ul>
<li><code>BondState</code>: 用来代表债券，作为账本上的事实</li>
<li><code>BondContract</code>: 用来管理账本有效更新包括<code>BondState</code>状态</li>
<li>三个流程：<ul>
<li><code>IssueBondFlow</code>: 允许新的<code>BondState</code>状态发布到账本上</li>
<li><code>TradeBondFlow</code>: 允许存在的<code>BondState</code>状态在账本上进行买进和卖出。</li>
<li><code>ExitBondFlow</code>: 允许存在的<code>BondState</code>状态从账本上退出</li>
</ul>
</li>
</ul>
<p>安装此CorDapp后，节点所有者将能够使用CorDapp定义的流程来允许与发行，出售，购买和退出债券有关的分类帐更新。</p>
<h2 id="编写一个CorDapp"><a href="#编写一个CorDapp" class="headerlink" title="编写一个CorDapp"></a>编写一个CorDapp</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>每个CorDapp组件都采用JVM类的形式，该JVM类子类或实现Corda库类型：</p>
<ul>
<li>流程子类<code>FlowLogic</code></li>
<li>状态实现 <code>ContractState</code></li>
<li>合约实现 <code>Contract</code></li>
<li>服务子类 <code>SingletonSerializationToken</code></li>
<li>序列化白名单实现：<code>SerializationWhitelist</code></li>
</ul>
<h3 id="Web内容和RPC客户端"><a href="#Web内容和RPC客户端" class="headerlink" title="Web内容和RPC客户端"></a>Web内容和RPC客户端</h3><p>出于测试目的，CorDapps还可能包括：</p>
<ul>
<li>API和静态网页内容：由Corda内置的网络服务器提供。这个网络服务器不是生产就绪的，只能用于测试目的</li>
<li>RPC客户端：这些程序可以自动执行通过RPC与节点进行交互的过程</li>
</ul>
<p>在生产环境中，应该使用生产就绪的网络服务器，这些文件应该移到不同的模块或项目中，以便在构建时不会膨胀CorDapp。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>您应该将项目的结构基于Java或Kotlin模板：</p>
<ul>
<li><a href="https://github.com/corda/cordapp-template-java" target="_blank" rel="noopener">Java模板CorDapp</a></li>
<li><a href="https://github.com/corda/cordapp-template-kotlin" target="_blank" rel="noopener">Kotlin模板CorDapp</a></li>
</ul>
<p>该项目应该分为两个模块：</p>
<ul>
<li><code>cordapp-contracts-states</code>包含合约和状态等类的模块，将作为流程的一部分通过线路发送</li>
<li><code>cordapp</code>含有剩余的类模块</li>
</ul>
<p>每个模块将被编译到它自己的CorDapp中。当节点同意分类帐更新时，这可以最小化必须通过网络发送的JAR的大小。</p>
<h3 id="模块1-cordapp-contracts-states"><a href="#模块1-cordapp-contracts-states" class="headerlink" title="模块1 - cordapp-contracts-states"></a>模块1 - cordapp-contracts-states</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── main</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                ├── TemplateContract.java</span><br><span class="line">                └── TemplateState.java</span><br></pre></td></tr></table></figure>
<h3 id="模块2-cordapp"><a href="#模块2-cordapp" class="headerlink" title="模块2 - cordapp"></a>模块2 - cordapp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── template</span><br><span class="line">│   │           ├── TemplateApi.java</span><br><span class="line">│   │           ├── TemplateClient.java</span><br><span class="line">│   │           ├── TemplateFlow.java</span><br><span class="line">│   │           ├── TemplateSerializationWhitelist.java</span><br><span class="line">│   │           └── TemplateWebPlugin.java</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── META-INF</span><br><span class="line">│       │   └── services</span><br><span class="line">│       │       ├── net.corda.core.serialization.SerializationWhitelist</span><br><span class="line">│       │       └── net.corda.webserver.services.WebServerPluginRegistry</span><br><span class="line">│       ├── certificates</span><br><span class="line">│       └── templateWeb</span><br><span class="line">├── test</span><br><span class="line">│   └── java</span><br><span class="line">│       └── com</span><br><span class="line">│           └── template</span><br><span class="line">│               ├── ContractTests.java</span><br><span class="line">│               ├── FlowTests.java</span><br><span class="line">│               └── NodeDriver.java</span><br><span class="line">└── integrationTest</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                └── DriverBasedTest.java</span><br></pre></td></tr></table></figure>
<p>这里面需要注意的是<code>test</code>是包含示例单元测试，以及用于从IntelliJ运行CorDapp的节点驱动程序. <code>integrationTest</code>是包含一个示例集成测试。这里需要注意两者的区别。</p>
<p>在<code>main</code>中，有以下的几个目录：</p>
<ul>
<li><code>resources/META-INF/services</code> 包含CorDapp的序列化白名单和网页插件的注册管理机构</li>
<li><code>resources/certificates</code> 包含用于测试目的的虚拟证书</li>
<li><code>resources/templateWeb</code> 包含一个虚拟的前端</li>
<li><code>java</code>（或<code>kotlin</code>在Kotlin模板中），其中包括我们的CorDapp的源代码</li>
</ul>
<p>我们的CorDapp的源代码分解如下：</p>
<ul>
<li><code>TemplateFlow.java</code>，其中包含一个虚拟<code>FlowLogic</code>子类</li>
<li><code>TemplateState.java</code>，其中包含一个虚拟<code>ContractState</code>实现</li>
<li><code>TemplateContract.java</code>，其中包含一个虚拟<code>Contract</code>实现</li>
<li><code>TemplateSerializationWhitelist.java</code>，其中包含一个虚拟<code>SerializationWhitelist</code>实现</li>
</ul>
<p>在开发你的CorDapp时，你应该首先修改这些类来定义你的CorDapp的组件。一个单一的CorDapp可以定义多个流程，状态和合同。</p>
<p><b style="color:red">该模板还包含一个Web API和RPC客户端：</b></p>
<ul>
<li><code>TemplateApi.java</code></li>
<li><code>TemplateClient.java</code></li>
<li><code>TemplateWebPlugin.java</code></li>
</ul>
<p>这些用于测试目的，并将在生产CorDapp中删除。</p>
<h3 id="学习的资源"><a href="#学习的资源" class="headerlink" title="学习的资源"></a>学习的资源</h3><p>在编写CorDapp时，您应该查阅以下资源：</p>
<ul>
<li><a href="https://docs.corda.net/releases/release-V3.1/getting-set-up.html" target="_blank" rel="noopener">快速设置</a>来设置你的开发环境</li>
<li>你好，世界！教程来编写你的第一个CorDapp</li>
<li><a href="https://docs.corda.net/releases/release-V3.1/cordapp-build-systems.html" target="_blank" rel="noopener">构建一个CorDapp</a>来构建和运行您的CorDapp</li>
<li>该API文档阅读有关开发CorDapps可用的API<ul>
<li>还有一个<a href="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html" target="_blank" rel="noopener">cheatsheet</a>重新说明关键类型</li>
</ul>
</li>
<li>该<a href="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html" target="_blank" rel="noopener">流程指南</a>看如何执行常见任务流的代码示例</li>
<li><a href="https://www.corda.net/samples/" target="_blank" rel="noopener">CorDapps实例程序</a>显示Corda功能的各个部分</li>
</ul>
<h2 id="构建一个Cordapp"><a href="#构建一个Cordapp" class="headerlink" title="构建一个Cordapp"></a>构建一个Cordapp</h2><h3 id="CorDapp格式"><a href="#CorDapp格式" class="headerlink" title="CorDapp格式"></a>CorDapp格式</h3><p>Cordapp是一个semi-fat的jar包，它包含除 Corda核心库和其它依赖的任何其他CorDapps 之外的所有CorDapp依赖项。</p>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>在下面的说明中，我们假设你正在使用<code>gradle</code>和<code>cordformation</code>插件来构建你的CorDapp。</p>
<h3 id="设置依赖关系"><a href="#设置依赖关系" class="headerlink" title="设置依赖关系"></a>设置依赖关系</h3><h4 id="选择你的Corda，Quasar和Kotlin版本"><a href="#选择你的Corda，Quasar和Kotlin版本" class="headerlink" title="选择你的Corda，Quasar和Kotlin版本"></a>选择你的Corda，Quasar和Kotlin版本</h4><p>CorDapp的build.gradle文件中使用了几个变量来定义用于构建您的CorDapp的版本：</p>
<ul>
<li><code>ext.corda_release_version</code> 定义了Corda的版本</li>
<li><code>ext.corda_gradle_plugins_version</code> 定义了Corda Gradle插件的版本</li>
<li><code>ext.quasar_version</code> 定义了Quasar的版本</li>
<li><code>ext.kotlin_version</code> 定义Kotlin的版本（如果使用Kotlin编写您的CorDapp）</li>
</ul>
<h4 id="Corda依赖"><a href="#Corda依赖" class="headerlink" title="Corda依赖"></a>Corda依赖</h4><p><code>cordformation</code>和<code>cordapp</code>插件添加了两个新的gradle这个配置：</p>
<ul>
<li><code>cordaCompile</code>，这扩展了 <code>compile</code></li>
<li><code>cordaRuntime</code>，这扩展了 <code>runtime</code></li>
</ul>
<p><code>cordaCompile</code>和<code>cordaRuntime</code>指出不应包含在CorDapp JAR中的依赖关系。这些配置应该用于任何Corda依赖（例如corda-core，corda-node），以防止依赖包含两次（一次在CorDapp JAR中，一次在Corda JAR中）。</p>
<p>要针对Corda构建，您必须将以下内容添加到您的build.gradle文件中：</p>
<p>Cordapp插件应该适用于任何将要构建cordapp的项目，并且cordformation插件应该适用于希望在本地创建小型测试网络的项目。</p>
<p>这样做后，确保： net.corda:corda:$corda_release_version被定义为cordaRuntime依赖项，并且所有其他net.corda编译依赖项（例如，net.corda：corda-core：$ corda_release_version）被设置为cordaCompile依赖项。</p>
<p>您可能还想添加：</p>
<ul>
<li><code>net.corda:corda-test-utils:$corda_release_version</code>作为<code>testCompile</code>依赖项，以便使用Corda的测试框架</li>
<li><code>net.corda:corda-webserver:$corda_release_version</code>作为<code>cordaRuntime</code>依赖项，以便使用Corda的内置开发Web服务器</li>
</ul>
<h4 id="依赖其他CorDapps"><a href="#依赖其他CorDapps" class="headerlink" title="依赖其他CorDapps"></a>依赖其他CorDapps</h4><p>您的CorDapp也可能依赖于另一个CorDapp中定义的类，例如状态，合约和流程。有两种方法可以在CorDapp的build.gradle文件中添加另一个CorDapp作为依赖项：</p>
<ul>
<li><code>cordapp project(&quot;:another-cordapp&quot;)</code>（如果在同一个项目中的模块中定义了另一个CorDapp，则使用此方法）</li>
<li><code>cordapp &quot;net.corda:another-cordapp:1.0&quot;</code> （否则使用这个）</li>
</ul>
<p>该cordappgradle这个配置有两个目的：</p>
<ul>
<li>当使用<code>cordformation</code> Gradle插件时，<code>cordapp</code>配置表明该JAR应该作为CorDapp包含在您的节点中</li>
<li>当使用<code>cordapp</code> Gradle插件时，<code>cordapp</code>配置可防止CorDapp JAR中包含依赖项</li>
</ul>
<p>请注意，<code>cordformation</code>和<code>cordapp</code> Gradle插件可以一起使用。</p>
<h4 id="其他依赖关系"><a href="#其他依赖关系" class="headerlink" title="其他依赖关系"></a>其他依赖关系</h4><p>如果您的CorDapps有任何额外的外部依赖关系，可以像Gradle中的正常Kotlin / Java依赖关系那样指定它们。看下面的例子，特别是<code>apache-commons</code>包含。</p>
<p>有关管理依赖关系的更多信息，请参阅<a href="https://docs.gradle.org/current/userguide/dependency_management.html" target="_blank" rel="noopener">Gradle文档</a>。</p>
<p>以下是CorDapp的Gradle依赖关系块的示例：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Corda integration dependencies</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-core:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-finance:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-jackson:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-rpc:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-node-api:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-webserver-impl:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda-webserver:$corda_release_version"</span></span><br><span class="line">    testCompile <span class="string">"net.corda:corda-test-utils:$corda_release_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corda Plugins: dependent flows and services</span></span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its module in the same project.</span></span><br><span class="line">    cordapp <span class="keyword">project</span>(<span class="string">":cordapp-contracts-states"</span>)</span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its fully-qualified name.</span></span><br><span class="line">    cordapp <span class="string">"net.corda:bank-of-corda-demo:1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some other dependencies</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"org.jetbrains.kotlin:kotlin-test:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"junit:junit:$junit_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.apache.commons:commons-lang3:3.6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建CorDapp-Jar"><a href="#创建CorDapp-Jar" class="headerlink" title="创建CorDapp Jar"></a>创建CorDapp Jar</h3><p>一旦您的依赖关系设置正确，您可以使用gradle <code>jar</code>任务来构建您的CorDapp JAR ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradlew jar</span><br></pre></td></tr></table></figure></p>
<p>CorDapp JAR将被输出到<code>build/libs</code>文件夹。</p>
<h3 id="安装CorDapp-JAR"><a href="#安装CorDapp-JAR" class="headerlink" title="安装CorDapp JAR"></a>安装CorDapp JAR</h3><p>在安装CorDapp之前，您必须创建一个或多个节点来安装它。有关说明，请参阅<a href="https://docs.corda.net/releases/release-V3.1/generating-a-node.html" target="_blank" rel="noopener">本地创建节点</a>。</p>
<p>在运行时，节点将加载其<code>cordapps</code>文件夹中存在的任何CorDapps 。因此，为了在节点上安装CorDapp，必须将CorDapp JAR添加到该<code>&lt;node_dir&gt;/cordapps/</code>文件夹中，其中node_dir是存储节点的JAR和配置文件的文件夹。</p>
<h2 id="通过master分支编译"><a href="#通过master分支编译" class="headerlink" title="通过master分支编译"></a>通过master分支编译</h2><p>针对最新的Corda稳定版本开发CorDapps是明智的。但是，如果您使用的是最新功能，或者正在测试主代码库上的PR，则可能需要针对不稳定的Master分支进行构建。</p>
<h2 id="Corda-Api"><a href="#Corda-Api" class="headerlink" title="Corda Api"></a>Corda Api</h2><p>以下是用于开发CorDapps的核心API：</p>
<ul>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-states.html" target="_blank" rel="noopener">API：状态 States</a>  <a href="http://cncorda.com/doc/apis/api-states/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-persistence.html" target="_blank" rel="noopener">API：持久化 Persistence</a>  <a href="http://cncorda.com/doc/apis/api-persistence/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-contracts.html" target="_blank" rel="noopener">API：合约 Contracts</a>  <a href="http://cncorda.com/doc/apis/api-contracts/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html" target="_blank" rel="noopener">API：合约约束 Contract Constraints</a>  <a href="http://cncorda.com/doc/apis/api-contract-constrains/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-vault-query.html" target="_blank" rel="noopener">API：Vault查询</a>  <a href="https://docs.corda.net/releases/release-V3.1/api-vault-query.html" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-transactions.html" target="_blank" rel="noopener">API：交易 Transaction</a>  <a href="http://cncorda.com/doc/apis/api-transactions/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-flows.html" target="_blank" rel="noopener">API：流程 Flows</a>  <a href="http://cncorda.com/doc/apis/api-flows/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-identity.html" target="_blank" rel="noopener">API：身份 Identity</a>  <a href="http://cncorda.com/doc/apis/api-identity/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-service-hub.html" target="_blank" rel="noopener">API：ServiceHub</a> <a href="http://cncorda.com/doc/apis/api-servicehub/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">API：RPC操作 RPC operations</a> <a href="http://cncorda.com/doc/apis/api-rpc-operations/" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a></li>
<li><a href="https://docs.corda.net/releases/release-V3.1/api-testing.html#flow-testing" target="_blank" rel="noopener">API：测试 Testing</a></li>
</ul>
<h3 id="内部API和稳定性保证"><a href="#内部API和稳定性保证" class="headerlink" title="内部API和稳定性保证"></a>内部API和稳定性保证</h3><p>Corda 3.0提供稳定的wire协议并支持数据库升级。因此，您应该能够将持久数据从3.0迁移到未来版本。但是，在我们开始提供ABI稳定性之前，有必要针对未来版本的API重新编译应用程序。</p>
<p>此外，请注意，Corda 3.0版本已经过基本级别的安全审核，为确保节点安全得到维护，应遵循以下最佳做法：</p>
<ul>
<li>应该使用安全密码生成器创建RPC用户、数据库连接和shell用户的凭证，最好从节点主机的命令行创建。</li>
<li>绝不应使用默认或开发模式凭证部署节点。</li>
<li>Corda节点应该使用其中一个受支持的数据库平台，而不是仅用于开发目的的默认H2数据库。Postgres是一个支持的平台。</li>
<li>应该在安全的网络（如DMZ）内操作节点，将入站和出站流量限制为仅需要的端口（就是限定端口做一些事）。具体而言，节点运营商应该致力于允许从互联网上访问点对点流量。RPC和数据库连接应该仅限于内部。</li>
<li>节点Web服务器模块已弃用，因此不应将其部署到生产环境中，因为它不是与Corda节点相同的安全标准。</li>
</ul>
<p>可以从Java 9 Jigsaw模块中获得Corda工件。从<code>module-info.java</code>中可以引用其中一个模块，例如<code>requires net.corda.core;</code>。</p>
<h3 id="Corda稳定的模块"><a href="#Corda稳定的模块" class="headerlink" title="Corda稳定的模块"></a>Corda稳定的模块</h3><p>以下模块具有稳定的API，我们承诺不会在以下版本中中断，除非出于安全原因需要进行不兼容的更改：</p>
<ul>
<li>核心（net.corda.core）：核心Corda函数库，如加密函数、Corda构建模块的类型：状态，合约，交易，附件等，以及用于节点和协议的一些接口</li>
<li>客户端RPC（net.corda.client.rpc）：客户端RPC</li>
<li>客户端Jackson（net.corda.client.jackson）：对客户端应用程序的JSON支持</li>
<li>测试实用程序（net.corda.testing.core）：通用测试实用程序</li>
<li>测试节点驱动程序（net.corda.testing.node，net.corda.testing.driver）：测试实用程序以编程方式运行节点</li>
<li>Http Test Utils（net.corda.testing.http）：一组用于制作HttpCalls的实用程序，旨在演示和测试。</li>
<li>DSL Test Utils（net.corda.testing.dsl）：用于测试目的的用于构建伪交易（与有线协议不同）的简单DSL。</li>
<li>虚拟合约 Dummy Contracts（net.corda.testing.contracts）：用于测试目的的虚拟状态和合约</li>
<li>模拟服务 Mock Services（net.corda.testing.services）：用于测试目的的模拟服务实现</li>
</ul>
<h3 id="Corda孵化模块"><a href="#Corda孵化模块" class="headerlink" title="Corda孵化模块"></a>Corda孵化模块</h3><p>以下模块还没有完全稳定的API，但我们会尽最大努力最大限度地减少开发人员使用它们的中断，直到我们能够将其应用到公共API中：</p>
<ul>
<li>net.corda.confidential.identities：实验性支持分类账上的机密身份</li>
<li>net.corda.finance：一系列基本合同（及相关模式）和协议，如抽象可替代资产，现金，义务和商业票据</li>
<li>net.corda.client.jfx：支持Java FX UI</li>
<li>net.corda.client.mock：客户端模拟实用程序</li>
<li>Cordformation：Gradle集成插件</li>
</ul>
<h3 id="Corda不稳定模块"><a href="#Corda不稳定模块" class="headerlink" title="Corda不稳定模块"></a>Corda不稳定模块</h3><p>以下模块可用，但我们不承诺任何意义上的稳定性或延续性：</p>
<ul>
<li>net.corda.buildSrc：必要的gradle插件来构建Corda</li>
<li>net.corda.node：Corda节点的核心代码（例如节点驱动程序，节点服务，消息传递，持久性）</li>
<li>net.corda.node.api：节点和客户端模块之间共享的数据结构，例如通过RPC发送的类型</li>
<li>net.corda.samples.network.visualiser：一个网络可视化工具，它使用仿真来显示Corda网络上节点之间的交互和消息</li>
<li>net.corda.samples.demos.attachment：演示如何使用附件从一个节点发送一个事务到另一个节点，并且接收节点访问附件</li>
<li>net.corda.samples.demos.bankofcorda：模拟资产发行机构的角色（例如中央银行的现金）</li>
<li>net.corda.samples.demos.irs：展示两家银行之间的利率互换协议</li>
<li>net.corda.samples.demos.notary：一个节点获得多个事务的简单演示，由分布式（Raft或BFT SMaRt）公证人公证</li>
<li>net.corda.samples.demos.simmvaluation：SIMM评估和分布式账本协议的演示</li>
<li>net.corda.samples.demos.trader：演示了四个节点：公证人，现金发行人（Corda银行）和两个彼此进行交易的人，用现金交换商业票据</li>
<li>net.corda.node.smoke.test.utils：测试烟雾测试实用程序</li>
<li>net.corda.node.test.common：通用测试功能</li>
<li>net.corda.tools.demobench：一个GUI工具，允许在本地运行Corda节点进行演示</li>
<li>net.corda.tools.explorer：Corda的GUI前端</li>
<li>net.corda.tools.graphs：用于推断项目依赖性的实用程序</li>
<li>net.corda.tools.loadtest：Corda负载测试</li>
<li>net.corda.verifier：允许节点外交易验证，允许验证水平扩展</li>
<li>net.corda.webserver：是一个用于导出HTTP端点的CorDapps的servlet容器。该服务器是节点的RPC客户端</li>
<li>net.corda.sandbox-creator：沙箱实用程序</li>
<li>net.corda.quasar.hook：代理钩入Quasar并提供类型排除列表</li>
</ul>
<p><b style="color:#6ab0de"><code>net.corda</code>名称空间中包含<code>.internal</code>或<code>net.corda.node</code>仅供内部使用的任何软件包内的代码。未来版本将拒绝任何CorDapps使用这些包中的类型。</b></p>
<h3 id="DoNotImplement-注解"><a href="#DoNotImplement-注解" class="headerlink" title="@DoNotImplement 注解"></a><code>@DoNotImplement</code> 注解</h3><p>Corda API中的某些接口和抽象类已被标注为@DoNotImplement。虽然我们承诺不删除或修改任何这些类的现有功能，但注释是我们可能需要在将来版本的Corda中扩展它们的警告。因此，Cordapp开发人员应该“按原样”使用这些类，而不是试图扩展或实现它们中的任何一个。</p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Corda普遍使用一种自定义形式的安全二进制序列化。这样做的目的是：</p>
<ul>
<li>希望有一个模式（schema）描述与实际数据一起被序列化的内容<ul>
<li>版本控制（以前的序列化数据也能被识别）</li>
<li>为了更容易编写泛型代码，例如可以导航序列化数据形式的用户接口。</li>
<li>支持跨平台（非JVM）交互，其中类文件的格式不容易解释。</li>
</ul>
</li>
<li>希望使用独立于平台并且不受第三方库升级等影响的文档化和静态线路格式。</li>
<li>希望支持开放式多态，其中超类的子类的数量可以随时间扩展并且子类不需要在模式中预先定义。这是很多Corda概念的关键，例如状态。</li>
<li>通过支持的构造函数构造反序列化对象来提高安全性，而不是直接将数据插入到其字段中，而没有机会验证一致性或拦截尝试操纵假定的不变量。</li>
<li>二进制格式比数字签名更适用于基于文本的格式，因为修改语法的范围要小得多，而不是语义。</li>
</ul>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>经典的Java序列化，JVM类路径上的任何类都可以反序列化。通过利用类路径上的大量第三方库作为JVM应用程序依赖关系和精心设计的反序列字节流的一部分，这已被证明是漏洞利用和漏洞的来源。在Corda中，我们通过坚持每个对象的类属于允许的类的白名单中，阻止任何类被反序列化（并在序列化过程中主动）。</p>
<p>类通过三种机制之一进入白名单：</p>
<ul>
<li>通过<code>@CordaSerializable</code>注解。这个注解可能存在接口和超类的注解上。</li>
<li>通过实现<code>SerializationWhitelist</code>接口并指定白名单类别的列表。</li>
<li>通过内置的Corda白名单（见<code>DefaultWhitelist</code>类）。虽然这不是用户可编辑的，但它列出了为方便您而列入白名单的常见JDK类。</li>
</ul>
<p>注解的方式是加入白名单的首选方式。<a href="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html" target="_blank" rel="noopener">Using the client RPC API</a>是一个实例。</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>目前，基于Kryo的格式仍然被客户端和服务器端的RPC框架所使用。但是，计划很快RPC框架将转向AMQP框架。</p>
<p>将序列化方案分离到不同的上下文中使我们能够为该上下文使用最合适的框架，而不是试图强制采取一刀切的方法。Kryo更适合于程序堆栈框架的序列化，因为它比我们的AMQP框架在构建和序列化方面更加灵活。但是，这种灵活性使得安全性变得异常困难。相反，我们的AMQP框架允许我们专注于可以推理的安全框架，从而使安全性更低，安全漏洞更少。</p>
<h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><p>本节介绍AMQP序列化格式支持的类和接口。</p>
<ul>
<li>集合类型</li>
<li>JVM原始类型</li>
<li>数组</li>
<li>JDK类型：支持的类型可以查阅原文</li>
<li>第三方的类型</li>
<li>Corda类型：<code>@CordaSerializable</code>注解的类和接口</li>
</ul>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>您自己的类型必须遵守以下支持的规则：</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h5><ol>
<li>该类必须使用包含在<code>.class</code>文件中的参数名称进行编译。这是Kotlin中的默认设置，但必须使用<code>javac</code>的<code>-parameters</code>命令行选项打开。</li>
<li>这个类必须要用<code>@CordaSerializable</code>注解</li>
<li>必须支持构造函数参数，getter和setter的声明类型，并且在使用泛型时，泛型参数必须是受支持的类型，开放式通配符（*）或有界通配符，该通配符目前被扩展为开放式通配符</li>
<li>任何超类都必须遵守相同的规则，但可以是抽象的</li>
<li>对象引用循环不受支持，因此对象无法直接或间接引用自身</li>
</ol>
<h4 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h4><p>Corda的AMQP序列化框架实例化对象的主要方式是通过指定的构造函数。这用于首先确定对象的哪些属性将被序列化，然后在反序列化时用于使用序列化值实例化对象。</p>
<p>建议Corda中的可序列化对象遵守以下规则，因为它们允许不可变状态对象被反序列化：</p>
<ol>
<li>一个Java Bean getter，用于构造函数中的每个属性，并具有表单的名称<code>getX</code>。</li>
<li>一个构造函数，它采用您希望以序列化形式记录的所有属性。这是序列化框架重建类的一个实例所必需的.</li>
<li>如果提供了多个构造函数，则序列化框架需要知道使用哪一个。<code>@ConstructorForDeserialization</code> 注释可以被用来指示哪一个。对于没有<code>@ConstructorForDeserialization</code>注解的Kotlin类，将选择主构造函数</li>
</ol>
<h4 id="Setter实例化"><a href="#Setter实例化" class="headerlink" title="Setter实例化"></a>Setter实例化</h4><p>作为基于构造函数初始化的替代，Corda还可以通过检查类中存在的getter和setter方法来确定对象的重要元素。如果一个类只有一个默认的构造函数和属性，那么可序列化的属性将由该属性的getter和setter的存在来确定，这些属性都是公开可见的（即该类遵守可变JavaBean 的经典成语）。</p>
<p>在反序列化中，首先会创建一个默认实例，然后调用该对象以使用正确的值填充它。</p>
<h4 id="无法访问的私有属性"><a href="#无法访问的私有属性" class="headerlink" title="无法访问的私有属性"></a>无法访问的私有属性</h4><p>虽然Corda AMQP序列化框架支持私有对象属性，但没有可公开访问的getter方法，但强烈建议不要使用此开发习惯用法。</p>
<h4 id="不匹配的类属性-构造函数参数"><a href="#不匹配的类属性-构造函数参数" class="headerlink" title="不匹配的类属性/构造函数参数"></a>不匹配的类属性/构造函数参数</h4><p>考虑一个例子，您希望确保类型为某种形式容器的类的属性总是按照某些特定条件进行排序，但您希望保持该类的不变性。</p>
<h4 id="可变容器"><a href="#可变容器" class="headerlink" title="可变容器"></a>可变容器</h4><p>因为Java从根本上不提供可以确定类的可变性的机制，所以这给序列化框架带来了问题。当用容器属性（列表，地图等）重新构建对象时，我们必须选择是创建可变对象还是不可变对象。考虑到这些限制，我们决定保留不可变对象的不变性更好，而不是强制推断不可变对象的可变性。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>所有的枚举都支持，只要它们被<code>@CordaSerializable</code>注解。Corda支持枚举类型版本的互操作性。这允许这样的类型随时间改变而不破坏反向（或向前）兼容性。<a href="https://docs.corda.net/releases/release-V3.1/serialization-enum-evolution.html" target="_blank" rel="noopener">Enum Evolution</a>讨论了这样做的规则和机制。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>以下规则适用于受支持的<code>Throwable</code>实现。</p>
<ol>
<li>如果你希望你的异常是可序列化和安全传输的，它应该继承自<code>CordaException</code>或者<code>CordaRuntimeException</code></li>
<li>如果不是，该<code>Throwable</code>遗嘱将反序列化为一个<code>CordaRuntimeException</code>包含其中的原件的详细信息 <code>Throwable</code>，包括原始的类名称<code>Throwable</code></li>
</ol>
<h4 id="Kotlin对象"><a href="#Kotlin对象" class="headerlink" title="Kotlin对象"></a>Kotlin对象</h4><p>略</p>
<h3 id="类合成"><a href="#类合成" class="headerlink" title="类合成"></a>类合成</h3><p>Corda序列化支持在反序列化时从提供的模式动态合成类，而不在类路径中存在支持类。在通用代码可能希望能够对反序列化的数据，在JVM上运行的脚本语言以及确保不在类路径上的类可以反序列化而不加载潜在的恶意代码的情况下，这可能是有用的。</p>
<p>未来可能的增强包括：</p>
<ol>
<li>Java单例支持。我们将添加支持以识别单身人士的类别，并确定负责返回单身人士实例的静态方法</li>
<li>实例内化支持。我们将添加对确定应根据实例映射解析的类的支持，以避免创建许多相同（类似于String.intern()）的重复实例，</li>
</ol>
<h3 id="类型演变"><a href="#类型演变" class="headerlink" title="类型演变"></a>类型演变</h3><p>类型演化是类可以随时间改变的机制，但仍然可以在所有类型的版本中保持序列化和反序列化。这确保了一个对象的序列化，它具有旧类型的“看起来像”类可以被反序列化的版本以及实例化类的当前状态的版本。</p>
<p>更多细节可以在<a href="https://docs.corda.net/releases/release-V3.1/serialization-default-evolution.html" target="_blank" rel="noopener">Default Class Evolution</a>中找到。</p>
<h2 id="安全的编码准则"><a href="#安全的编码准则" class="headerlink" title="安全的编码准则"></a>安全的编码准则</h2><p>该平台通过默认设计确保安全。不幸的是，该平台无法防止各种安全错误。本文档描述了在编写应用程序以阻止各种攻击时需要考虑的问题。尽管假设没有合理的交易对手试图用流程级别的攻击来颠覆您的交易可能会很诱人，但是依靠信任来提高软件安全性会使您很难在稍后想要快速添加对手方并且没有广泛审查的情况下扩展您的业务。</p>
<h3 id="流动"><a href="#流动" class="headerlink" title="流动"></a>流动</h3><p><a href="https://docs.corda.net/releases/release-V3.1/flow-state-machines.html" target="_blank" rel="noopener">编写流程</a>是您的应用程序与网络上的其他各方进行通信的方式。因此，它们是恶意数据进入您应用程序的典型切入点，必须小心处理。</p>
<p>这些<code>receive</code>方法返回包装在<code>UntrustworthyData&lt;T&gt;</code>标记类型中的数据。这种类型不会添加任何功能，它只是提醒您正确验证从网络获得的所有内容。请记住，另一方可能没有运行您提供的用于参与流程的代码：他们被允许执行任何操作！需要注意的事项：</p>
<ul>
<li>例如，如果您建议为资产交易价值100美元的现金状态，并且签署的交易从另一方返回，则该交易与流程中较早建立或建议的部分交易不匹配，您必须检查它指向您实际请求的状态。否则，攻击者可以让你签署一项交易，如果他们知道一个ID的话，那么这笔交易将花费更多的时间给你。</li>
<li>一个不正确类型的交易。有两种交易类型：普通和公证变更。如果您希望获得一种类型，但获得另一种类型，则可能会发现自己签署了一项交易，将您的资产转移到敌对公证人的控制之下。</li>
<li>交易中各状态的意外更改。如果您有权访问所有需要的数据，则可以重新运行构建器逻辑并对结果状态进行比较，以确保它符合您的预期。例如，如果构建下一个状态所需的数据对双方都可用，则计算您想要相互同意的交易的函数可以在实现流程的两端的两个类之间共享。</li>
</ul>
<p>主题应该清楚：签名是一项非常敏感的操作，因此您需要确保您知道您要签名的是什么，并且输出没有任何变化！一旦您通过交易向交易对手提供了您的签名，就不再有任何事情可以阻止他们将其交付给分类账。</p>
<h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><p>合同是JVM沙箱内的任意函数，因此它们有很大的自由度。需要注意的事项：</p>
<ul>
<li>当前状态转换不应允许的状态更改。你会想要检查没有领域正在改变，除了预期的领域！</li>
<li>意外捕获并丢弃可能由验证逻辑抛出的异常。</li>
<li>如果您不知道其他合约是做什么或可能做什么，则通过虚拟方法调用其他合约。</li>
</ul>
<h2 id="流程cookbook"><a href="#流程cookbook" class="headerlink" title="流程cookbook"></a>流程cookbook</h2><p><a href="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html" target="_blank" rel="noopener">该流程</a>展示了如何在Java和Kotlin中使用Corda的API。</p>
<h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><p><a href="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html" target="_blank" rel="noopener">这个网页</a>是Corda知识的备忘单。</p>
<h2 id="Cordapp示例"><a href="#Cordapp示例" class="headerlink" title="Cordapp示例"></a>Cordapp示例</h2><p><a href="https://docs.corda.net/releases/release-V3.1/building-a-cordapp-samples.html" target="_blank" rel="noopener">CorDapp samples</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/31/blockchain/corda/Corda基础学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/31/blockchain/corda/Corda基础学习/" itemprop="url">Corda基础学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T17:40:02+08:00">2018-05-31</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇的博客中，我提到了Corda的一些基础的知识，但是那个版本是比较旧的，这次针对新的版本，写一些笔记来完成相应的更新。</p>
<h2 id="Corda-Network"><a href="#Corda-Network" class="headerlink" title="Corda Network"></a>Corda Network</h2><p>关于Corda的网络，有以下几点：</p>
<ol>
<li>这个网络由运行Corda和CorDapps的节点组成。</li>
<li>网络是授权的，通过doorman控制权限</li>
<li>节点之间的通信是点对点的，不依赖全局广播。</li>
</ol>
<h3 id="Network结构"><a href="#Network结构" class="headerlink" title="Network结构"></a>Network结构</h3><p>主要的组成就是Corda Service和Cordapps。</p>
<p>节点之间的通信是直接的，通过AMQP发送TLS加密的信息。是点对点的，不采用广播的方式。</p>
<p>每个网络存在网络映射服务，可以发布网络上每个节点都可以访问的IP地址，以及这些节点的身份证书和它们提供的服务。</p>
<h3 id="doorman"><a href="#doorman" class="headerlink" title="doorman"></a>doorman</h3><p>Corda网络是半私人的。每个网络都有一个门卫服务，用于执行关于节点必须提供的信息的规则以及他们在被允许进入网络之前必须完成的了解您的客户流程。</p>
<p>要加入网络，节点必须联系门卫并提供所需的信息。如果门卫感到满意，该节点将从网络的许可服务接收根权威机构签署的TLS证书。此证书在与网络上的其他参与者通信时验证节点的身份。</p>
<p><b style="color:red">注：在源码中发现就是发送http请求，而且还要设置一个URL。详细的信息可以参阅源码部分。</b></p>
<p>我们可以将网络可视化如下：</p>
<p><img src="https://docs.corda.net/head/_images/network.png" alt=""></p>
<h3 id="Network中的服务"><a href="#Network中的服务" class="headerlink" title="Network中的服务"></a>Network中的服务</h3><p>节点可以提供几种类型的服务：</p>
<ul>
<li>一个或多个可插式公证服务。公证人保证分类账更新的唯一性和可能性。每个公证服务可以在单个节点上运行，也可以在一组节点上运行。</li>
<li>零个或更多的Oracle服务。Oracle是一个众所周知的服务，如果他们陈述事实并且事实被认为是真实的，那么它就会签署交易。</li>
</ul>
<h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><p>概要</p>
<ul>
<li>分类账从每个同行的角度来看都是主观的</li>
<li>两位同行总是保证看到他们分享的任何分类账事实完全相同的版本</li>
</ul>
<h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在Corda，没有单一的中央数据存储。相反，每个节点都维护一个已知事实的单独数据库。因此，每个同行只能看到分类帐上的一小部分事实，并且没有同行完全知道分类账。</p>
<p>例如，想象一个具有五个节点的网络，其中每个彩色圆圈表示一个共享事实：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/ledger-venn.png" alt=""></p>
<h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><p>概要</p>
<ul>
<li>Corda中的身份可以代表合法身份或服务身份</li>
<li>身份证明由门卫签署的X.509证书或公认的身份证明</li>
<li>众所周知的身份发布在网络地图中（NetworkMapService，这个在源码中我们也可以看到）</li>
<li>机密身份仅在需要了解基础时共享</li>
</ul>
<p>Corda中的身份可以表示：</p>
<ul>
<li>一个组织的法律身份</li>
<li>网络服务的服务标识（该节点只是提供服务而已）</li>
</ul>
<p>法律身份用于交易中的各方，例如现金状态的所有者。服务标识用于提供与交易相关的服务的人员，例如公证人员或oracle。服务身份与合法身份不同，因此分布式服务可以存在于不同组织所拥有的节点上。这种分布式服务身份是基于的<code>CompositeKeys</code>，它描述了服务签名的有效签名者集合。有关CompositeKeys的更多技术细节，请参阅<a href="https://docs.corda.net/releases/release-V3.1/api-core-types.html" target="_blank" rel="noopener">API：核心类型</a>。</p>
<p><b style="color:red">身份是众所周知的还是保密的，取决于他们的X.509证书（和对应的证书路径是否可信的根证书）已发布：</b>.</p>
<ul>
<li>众所周知的身份是法律实体或服务的一般可识别的公钥，这使得它们不适用于需要参与者保密的交易。此证书已发布在网络地图服务中供任何人访问。</li>
<li>机密身份只发布给参与交易身份的人员。公钥可能暴露给第三方（例如公证服务），但名称和X.509证书的分发是有限的。</li>
</ul>
<p>虽然Corda交易隐私模式有几个要素，包括确保交易只与需要查看它们的用户共享以及有计划地使用英特尔SGX，但重要的是要提供深入的防御隐私攻击。机密身份用于确保即使第三方访问未加密的交易，他们也无法在没有附加信息的情况下识别参与者。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>节点必须能够验证使用X.509证书实现的公钥所有者的身份。<b style="color:red">首次运行时，节点生成密钥对并向网络门卫服务提交证书签名请求</b>（请参阅 <a href="https://docs.corda.net/releases/release-V3.1/permissioning.html" target="_blank" rel="noopener">网络许可</a>）。Doorman服务应用适当的身份检查，然后向用作节点认证中心（CA）的节点发放证书。从该初始CA证书中，节点自动创建并签署两个其他证书，一个TLS证书(sslKeyStore)和一个用于该节点众所周知的身份的签名证书(nodeKeyStore)。最后，节点建立包含其地址和众所周知的身份的节点信息记录，并将其注册到网络地图服务。</p>
<p>组织可以从签署证书创建公开和机密身份。众所周知的身份的用例包括代表用于冗余目的的单个身份的节点集群，或者为组织单位创建身份。</p>
<p>组织需要决定他们希望在网络地图服务中发布哪些身份，使其广为人知，并且出于隐私原因（通常是为了避免暴露商业敏感的交易细节），他们希望将其保留为机密身份。在某些情况下，出于操作原因，除了主网络地图服务之外，节点还可能使用专用网络地图服务。使用此类网络地图注册的身份必须被认为是众所周知的，并且将机密身份存储在中央目录中，而不在记录级别应用控制，以确保只有需要访问身份的人才能检索其证书。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>概要：</p>
<ul>
<li>状态代表了分类账事实</li>
<li>通过将当前状态标记为历史并创建更新状态来进行状态演变</li>
<li>每个节点都有一个保管库（Vault，可以是放入数据库中，有相应接口，默认是放在内存中），它在其中存储任何相关的状态</li>
</ul>
<h3 id="概观-1"><a href="#概观-1" class="headerlink" title="概观"></a>概观</h3><p>状态可以包含任意数据，允许它们表示任何种类的事实（例如股票，债券，贷款，KYC数据，身份信息……）。例如，以下状态代表IOU - 爱丽丝欠Bob的协议金额X：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/state.png" alt=""></p>
<p>除了关于事实本身的任何信息外，状态还包含对管理状态演变随时间推移的合约的引用。</p>
<h3 id="状态序列"><a href="#状态序列" class="headerlink" title="状态序列"></a>状态序列</h3><p>共享事实随时间的生命周期由状态序列表示。当一个状态需要更新时，我们创建代表世界新状态的新版本状态，并将现有状态标记为历史状态。</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/state-sequence.png" alt=""></p>
<h3 id="金库-Vault"><a href="#金库-Vault" class="headerlink" title="金库(Vault)"></a>金库(Vault)</h3><p>网络上的每个节点都有一个保管库 - 一个数据库，用于追踪所有当前和历史状态，以及它认为与自身相关的所有当前状态和历史状态.</p>
<h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>概要</p>
<ul>
<li>每个输入和输出状态的合约都必须接受有效的交易</li>
<li>合约是用JVM编程语言（如Java或Kotlin）编写的，</li>
<li>合约执行是确定性的，其对交易的接受仅基于交易的内容</li>
</ul>
<h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><p>回想一下，交易只有在所有必需的签名者都进行了数字签名的情况下才有效。但是，即使交易收集了所有必需的签名，它也仅在合约有效的情况下才有效。</p>
<p>合约有效性定义如下：</p>
<ul>
<li>每个状态都指向一份合约</li>
<li>一个合约需要一个交易作为输入，并指出根据合约的规则的交易是否被认为是有效的</li>
<li>只有当每个输入状态和每个输出状态的合约认为其有效时，交易才有效</li>
</ul>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/tx-validation.png" alt=""></p>
<p>合约代码可以用任何JVM语言编写，并且可以使用该语言的全部功能，包括：</p>
<ul>
<li>检查输入，输出，命令，时间戳和/或附件的数量</li>
<li>检查这些组件的内容</li>
<li>循环构造，变量赋值，函数调用，辅助方法等</li>
<li>将类似的状态分组以验证它们是否为一组（例如，对所有现金状态的总价值施加一个规则）</li>
</ul>
<p>非契约有效的交易不是更新分类帐的有效提案，因此不能提交给分类账。通过这种方式，合约对状态随时间推移的演变规定了独立于所需签名人签署给定交易的意愿的规则。</p>
<h3 id="合约沙箱"><a href="#合约沙箱" class="headerlink" title="合约沙箱"></a>合约沙箱</h3><p>交易验证必须是确定性的 - 合约应始终接受或始终拒绝给定的交易。例如，交易有效性不能取决于进行验证的时间，也不取决于合作伙伴运行合约的信息量。这是确保网络上的所有同行对特定分类帐更新的有效性达成共识的必要条件。</p>
<p><b style="color:red">为了达到这个目的，合约评估确定性沙箱中的交易。沙盒有一个白名单（这就是在源码看到的WhiteList的作用了吧，不过这个白名单是针对附件的），可以防止合约导入可能成为非确定性来源的库</b>。这包括提供当前时间的库，随机数生成器，提供文件系统访问的库或网络库等。最终，验证交易时可用于合约的唯一信息是交易本身中包含的信息。</p>
<h3 id="合约限制"><a href="#合约限制" class="headerlink" title="合约限制"></a>合约限制</h3><p>由于合约无法获得外部信息，它只能检查交易的内部有效性。例如，它不能检查交易是否与最初与交易对手达成一致。</p>
<p>因此，同事在签署交易之前应检查交易内容，即使交易合约有效，以查看他们是否同意提议的分类帐更新。同行没有义务签署一项交易，只是因为它在合约中有效。例如，他们可能不愿意承担过大的贷款，或可能不同意为资产提供的现金数额。</p>
<h3 id="神谕（Oracle）"><a href="#神谕（Oracle）" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h3><p>有时，交易有效性将取决于一些外部信息，例如汇率。在这些情况下，需要一个oracle。有关更多详细信息，请参阅Oracles。</p>
<h3 id="法律散文（legal-prose）"><a href="#法律散文（legal-prose）" class="headerlink" title="法律散文（legal prose）"></a>法律散文（legal prose）</h3><p>每份合约还涉及法律散文文件，其中规定了与传统法律体系兼容的随时间推移的状态演变规则。在法律纠纷的情况下，可以依靠这份文件。</p>
<h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>概要</p>
<ul>
<li>交易是更新分类账的建议</li>
<li>交易提案承诺以下情况：<ul>
<li>它不包含双重花费</li>
<li>这是合约有效的</li>
<li>它由所需方签署</li>
</ul>
</li>
</ul>
<p>Corda使用UTXO（未使用的交易输出）模型。</p>
<h3 id="交易链"><a href="#交易链" class="headerlink" title="交易链"></a>交易链</h3><p>这些输入状态引用（StateRef）将交易连接在一起，形成所谓的交易链。</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/tx-chain.png" alt=""></p>
<h3 id="提交交易"><a href="#提交交易" class="headerlink" title="提交交易"></a>提交交易</h3><p>最初，交易只是更新分类帐的建议.<br><img src="https://docs.corda.net/releases/release-V3.1/_images/uncommitted_tx.png" alt=""></p>
<p>要成为现实，交易必须接收所有必需的签名者的签名（参见下面的命令）。每位必需的签名者将其签名附加到交易中以表明他们批准该提案：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/tx_with_sigs.png" alt=""></p>
<p>如果所有必需的签名都被收集起来，交易将变为承诺：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/committed_tx.png" alt=""></p>
<p>这意味着：</p>
<ul>
<li>交易的输入被标记为历史性的，并且不能用于任何未来的交易</li>
<li>交易的产出成为分类账当前状态的一部分</li>
</ul>
<h3 id="交易有效性"><a href="#交易有效性" class="headerlink" title="交易有效性"></a>交易有效性</h3><p>如果以下两个条件成立，每个必需的签名者只应签署交易：</p>
<ul>
<li>交易有效性：对于提议的交易以及创建当前提议的交易输入的交易链中的每个交易：<ul>
<li>交易由所有必要方进行数字签名</li>
<li>合约验证交易有效</li>
</ul>
</li>
<li>交易唯一性：没有其他交易已经消耗了我们建议交易的任何投入</li>
</ul>
<h3 id="其他交易组件"><a href="#其他交易组件" class="headerlink" title="其他交易组件"></a>其他交易组件</h3><p>除输入状态和输出状态外，交易可能包含：</p>
<ul>
<li>命令</li>
<li>附件</li>
<li>时间戳</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>假设我们有一个以现金状态和债券状态作为输入的交易，以现金状态和债券状态作为输出。该交易可能代表两种不同的情况：</p>
<ul>
<li>债券购买</li>
<li>债券上的息票支付</li>
</ul>
<p>我们可以想象，我们希望对构成有效交易的内容施加不同的规则，具体取决于这是购买还是优惠券付款。例如，在购买的情况下，我们需要改变债券的当前所有者，而在支付息票的情况下，我们会要求债券的所有权不变。</p>
<p>为此，我们有命令。在交易中包含命令可以让我们指出交易的意图，从而影响我们如何检查交易的有效性。</p>
<p>每个命令还与一个或多个签名者列表关联。通过将命令中列出的所有公钥的联合，我们得到交易所需的签名者列表。在我们的例子中，我们可以想象：</p>
<ul>
<li>在债券的息票付款中，只有债券所有者需要签署</li>
<li>在现金支付中，只需要现金的所有者签字</li>
</ul>
<p>我们可以看到这种情况如下：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/commands.png" alt=""></p>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>有时，我们有大量的数据可以在许多不同的交易中重用。一些例子：</p>
<ul>
<li>公众假期日历</li>
<li>支持法律文件</li>
<li>货币代码表</li>
</ul>
<p>对于这个用例，我们有附件。每个交易可以通过哈希引用零个或多个附件。这些附件是包含任意内容的ZIP/JAR文件。这些文件中的信息可以在检查交易的有效性时使用。</p>
<h3 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h3><p>在某些情况下，我们希望建议的交易只能在特定时间段内批准。例如：</p>
<ul>
<li>期权只能在特定日期后执行</li>
<li>债券只能在到期日前赎回</li>
</ul>
<p>在这种情况下，我们可以为交易添加一个时间窗口。时间窗口指定了可以提交事务的时间窗口。我们讨论时间窗口部分的时间窗口。</p>
<h2 id="流程（Flow）"><a href="#流程（Flow）" class="headerlink" title="流程（Flow）"></a>流程（Flow）</h2><p>概要</p>
<ul>
<li>流程自动化了同意分类帐更新的过程</li>
<li>节点之间的通信只发生在这些流程的上下文中，并且是点对点的</li>
<li>提供了内置流程来自动化常见任务</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>Corda网络使用点对点消息而不是全局广播。这意味着协调分类帐更新需要网络参与者准确指定需要发送的信息，交易对手以及以何种顺序。</p>
<p>以下是在Alice和Bob之间就简单分类账更新达成一致的过程的可视化：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/flow.gif" alt=""></p>
<h3 id="流程框架"><a href="#流程框架" class="headerlink" title="流程框架"></a>流程框架</h3><p>Corda不需要手动指定这些步骤，而是使用流程自动化流程。流程是一系列步骤，告诉节点如何实现特定的分类帐更新，例如发放资产或结算交易。</p>
<p>以下是上述简单分类账更新中涉及的流程步骤顺序：<br><img src="https://docs.corda.net/releases/release-V3.1/_images/flow-sequence.png" alt=""></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>一旦给定的业务流程被封装在流中并作为CorDapp的一部分安装在节点上，节点的所有者就可以指示节点随时使用RPC调用启动该业务流程。该流程将所有网络，I / O和并发问题从节点所有者中抽象出来。</p>
<p>节点上的所有活动都发生在这些流程的上下文中。与合约不同，流程不在沙箱中执行，这意味着节点可以执行诸如网络，I/O等操作，并在流程执行过程中使用随机源。</p>
<h4 id="节点间通信"><a href="#节点间通信" class="headerlink" title="节点间通信"></a>节点间通信</h4><p>节点通过在流之间传递消息进行通信。每个节点具有零个或多个流类，它们被注册为响应来自单个其他流的消息。</p>
<p>假设Alice是网络上的一个节点，并希望与另一个网络节点Bob同意分类帐更新。为了与Bob沟通，Alice必须：</p>
<ul>
<li>开始注册Bob回应的流程</li>
<li>在该流程的上下文中向Bob发送消息</li>
<li>鲍勃将开始注册的交易对手流程</li>
</ul>
<p>现在建立了一个连接，Alice和Bob可以通过传递一系列来回传递的消息来同意分类账更新，如流程步骤中所规定的那样。</p>
<h4 id="子流程"><a href="#子流程" class="headerlink" title="子流程"></a>子流程</h4><p>可以通过在另一个流程的上下文中将流程作为子流程启动来组成流程。作为子流程开始的流程称为子流程。父流程将一直等到子流程返回。</p>
<h4 id="流程库"><a href="#流程库" class="headerlink" title="流程库"></a>流程库</h4><p>Corda提供了一个处理常见任务的流程库，这意味着开发人员不必重新定义常见流程背后的逻辑，例如：</p>
<ul>
<li>公证和记录交易</li>
<li>从对手方节点收集签名</li>
<li>验证一系列交易</li>
</ul>
<p>有关可用内置流程的更多信息，请参见<a href="https://docs.corda.net/releases/release-V3.1/flow-library.html" target="_blank" rel="noopener">Flow库</a>。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>流程框架允许节点一次有多个活动流。这些流量可能持续数天，跨节点重启甚至升级。</p>
<p>这是通过将数据流序列化到磁盘来实现的，只要它们进入阻塞状态（例如，当它们正在等待I / O或网络呼叫时）。与其等待流程畅通无阻，节点立即开始处理任何其他计划流程，仅在以后返回到原始流程。</p>
<h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>概要</p>
<ul>
<li>承诺，交易必须达到有效性和唯一性共识</li>
<li>有效性共识需要交易及其所有依赖关系的合约有效性</li>
<li>唯一性共识可以防止双重花费</li>
</ul>
<h3 id="两种共识"><a href="#两种共识" class="headerlink" title="两种共识"></a>两种共识</h3><p>确定提议的交易是否是有效的分类帐更新涉及达成两种类型的共识：</p>
<ul>
<li>有效性共识 - 在签署交易前由每个必需签署者检查</li>
<li>唯一性共识 - 只有公证服务才能检查</li>
</ul>
<p>有效性共识是检查以下条件是否适用于拟议交易以及交易链中为交易提议交易产生输入的每个交易的过程：</p>
<ul>
<li>交易被每个输入和输出状态的合约所接受</li>
<li>交易拥有所有必需的签名</li>
</ul>
<p>验证提议的交易本身是不够的。我们还必须核实导致建立交易建议输入的交易链中的每一笔交易。</p>
<p>这就是所谓的走链。例如，假设网络上的一方提出将我们的国债转让给我们的交易。在下列情况下，我们只能确保债券转移有效：</p>
<ul>
<li>国债是由中央银行在有效的发行交易中发行的</li>
<li>债券交易后的每一次交易都是有效的</li>
</ul>
<h3 id="唯一性共识"><a href="#唯一性共识" class="headerlink" title="唯一性共识"></a>唯一性共识</h3><p>唯一性共识是要求所提议的交易的投入没有一个在另一笔交易中已经消耗。</p>
<p>如果一个或多个输入已经在另一个交易中被使用，这就是所谓的双重支出，并且交易提议被认为是无效的。</p>
<p>公证人提供了唯一性共识。请参阅公证人了解更多详情。</p>
<h2 id="公证人（Notary）"><a href="#公证人（Notary）" class="headerlink" title="公证人（Notary）"></a>公证人（Notary）</h2><p>概要</p>
<ul>
<li>公证人防止“双花”</li>
<li>公证员也可以选择验证交易</li>
<li>一个网络可以有几个公证人，每个公证人都运行不同的共识算法</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个公证是一种网络服务，它提供了独特的共识被证明的是，对于一个给定的交易，它尚未签署消耗任何拟议中的交易的输入状态的其他交易。</p>
<p>在被要求公证交易时，公证人可以：</p>
<ul>
<li>如果交易尚未签署其他消耗建议交易输入状态的交易，请签署交易</li>
<li>拒绝该交易并标记双重支出尝试已经发生</li>
</ul>
<p>这样做，公证人提供了系统中的终点。在获得公证人的签名之前，各方不能确定同等有效但冲突的交易不会被视为花费给定输入状态的“有效”尝试。但是，在获得公证人的签名后，我们可以确定提议的交易的输入状态尚未被先前的交易消耗。因此，公证是系统中的终点。</p>
<p>每个状态都有一个指定的公证人，如果公证人是所有交易输入状态的指定公证人，公证人只会公证一项交易。</p>
<h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>Corda具有“可插入”的共识，允许公证人根据隐私，可扩展性，法律系统兼容性和算法敏捷性的要求选择一致的算法。</p>
<p>特别是，公证人在以下方面可能会有所不同：</p>
<ul>
<li>结构 - 公证可能是单个网络节点，相互信任的节点群或相互不信任的节点群</li>
<li>共识算法 - 公证服务可以选择运行高速，高可信度算法，如RAFT，低速低信任算法（如BFT），或者其他任何其他共识算法</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>公证服务还必须在提交之前通过确认每笔交易来决定是否提供有效性共识。在作出这个决定时，他们面临以下的交易：</p>
<ul>
<li><b style="color:red">如果一个交易没有被检查有效性，它会产生“拒绝状态”攻击的风险，在这种情况下，一个节点明知地建立一个无效的事务，消耗一些现有状态并将其发送给公证人，导致这些状态被标记为已消耗。（这是攻击风险，需要验证交易合法性以抵制这种攻击）</b>.</li>
<li>如果交易被检查的有效性，公证员将需要看到交易及其依赖的全部内容。这泄露了可能的私人数据给公证人</li>
</ul>
<p>在评估这种折衷时，还有几点需要注意。在非验证模型的情况下，Corda的受控数据分布模型意味着关于未消费状态的信息并未广泛共享。此外，Corda的许可网络意味着公证人可以存储创建“拒绝状态”交易的一方的身份，从而使得攻击能够逐个解决。</p>
<p>在验证模型的情况下，使用匿名的，新近生成的公钥而不是法定身份来识别交易中的当事方会限制公证人看到的信息。</p>
<h3 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h3><p>每个Corda网络可以有多个公证员，每个公证员可能运行不同的共识算法。这提供了几个好处：</p>
<ul>
<li>隐私 - 我们可以在同一网络上同时具有验证和非验证公证服务，每个都运行不同的算法。这使得节点能够按照每个交易选择首选公证人</li>
<li>负载平衡 - 通过多个公证处理交易负载可以为整个平台提供更高的交易吞吐量</li>
<li>低等待时间 - 等待时间可以通过选择与交易双方身体接近的公证员来最小化</li>
</ul>
<h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>请记住，如果公证人是所有交易输入状态的指定公证人，则公证人只会签署交易。但是，有些情况下我们可能需要更换状态的指定公证人。这些包括：</p>
<ul>
<li>当单个交易需要消耗具有不同指定公证人的多个状态时</li>
<li>由于隐私或效率问题，节点宁愿为给定的交易使用不同的公证人</li>
</ul>
<p>在这些交易可以创建之前，必须首先将各状态重新命名为全部具有相同的公证人。这是通过使用特殊的公证人更改交易来实现的，该交易需要：</p>
<ul>
<li>单个输入状态</li>
<li><b style="color:red">与输入状态相同的输出状态，但指定的公证人已更改（将输入的公证人更改掉作为输入即可）</b></li>
</ul>
<p>输入状态的指定公证人将签署交易，如果它不构成双重花费，此时一个状态将进入具有旧状态所有财产的存在，但具有不同的指定公证人。</p>
<h2 id="时间窗口-1"><a href="#时间窗口-1" class="headerlink" title="时间窗口"></a>时间窗口</h2><p>概要</p>
<ul>
<li>如果交易包含时间窗口，则只能在该窗口期间提交</li>
<li>公证人是时间戳管理机构，拒绝在该窗口之外提交交易</li>
<li>时间窗口可以有开始和结束时间，也可以在任何一端打开</li>
</ul>
<h3 id="在分布式系统中的时间"><a href="#在分布式系统中的时间" class="headerlink" title="在分布式系统中的时间"></a>在分布式系统中的时间</h3><p>公证人还充当时间戳的权力，验证在公证之前在特定时间窗口发生的交易。</p>
<p>创建交易的一方和公证人之间永远不会有精确的时钟同步。这不仅仅是由于物理和网络延迟的问题，而且还因为在插入命令和获得公证签名之间可能有许多其他步骤（例如将交易发送给交易中涉及的其他方，请求人签字…）。因此交易发送给公证人的时间可能与交易创建时间大不相同。</p>
<p>假设公证人的时间馈送是由美国海军天文台的原子钟定义的GPS / NaviStar时间。这个是非常准确的，全球免费提供。</p>
<h2 id="神谕（Oracle）-1"><a href="#神谕（Oracle）-1" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h2><p>概要</p>
<ul>
<li>事实可以作为命令的一部分包含在交易中</li>
<li>如果包含的事实是真实的，则oracle是一种仅签署交易的服务</li>
</ul>
<h3 id="概观-2"><a href="#概观-2" class="headerlink" title="概观"></a>概观</h3><p>在很多情况下，交易的合约效力取决于一些外部数据，例如当前的汇率。但是，如果我们要让每个参与者根据他们自己对当前汇率的看法来评估交易的有效性，那么合同的执行将是非确定性的：一些签名者会认为交易是有效的，而另一些则认为它是无效的。因此，会在分类账的真实状态上产生分歧。</p>
<p>Corda使用oracles解决了这个问题。神谕（Oracle）是网络服务，根据请求提供封装特定事实（例如，时间x时的汇率）的命令，并将神谕列为必需的签名者。</p>
<p><b style="color:red">如果一个节点希望在交易中使用某个事实，他们会请求一个命令，从oracle中断言这个事实。如果oracle认为事实是真的，他们会发回所需的命令。然后节点将这个命令包含在他们的交易中，并且oracle将签署该交易来断言事实是真实的。</b></p>
<p>如果他们希望将他们的服务货币化，神谕可以选择只签署一笔交易，并证明其收取的费用是有效的。</p>
<h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p><a href="/2018/05/30/blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E4%BA%A4%E6%98%93%E6%8B%86%E5%88%86">交易拆分</a></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>概要</p>
<ul>
<li>节点是JVM运行时间，具有运行Corda软件的唯一网络标识</li>
<li>该节点有两个与外界的接口：<ul>
<li>网络层，用于与其他节点交互</li>
<li>RPC，用于与节点的所有者进行交互</li>
</ul>
</li>
<li>通过在插件注册表中安装CorDapps来扩展节点的功能</li>
</ul>
<h3 id="节点架构"><a href="#节点架构" class="headerlink" title="节点架构"></a>节点架构</h3><p>Corda节点是一个JVM运行时环境，在网络上具有唯一身份，用于承载Corda服务和CorDapps。</p>
<p>我们可以将节点的内部架构可视化如下：</p>
<p><img src="https://docs.corda.net/releases/release-V3.1/_images/node-architecture.png" alt=""></p>
<p>该体系结构的核心要素是：</p>
<ul>
<li>用于存储数据的持久层</li>
<li>用于与其他节点交互的网络接口</li>
<li>用于与节点所有者进行交互的RPC接口</li>
<li>一个服务中心（ServiceHub），用于允许节点的流程调用节点的其他服务</li>
<li>通过安装CorDapps扩展节点的cordapp界面和提供程序</li>
</ul>
<h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p>持久层有两部分：</p>
<ul>
<li>Vault，其中节点存储任何相关的当前和历史状态</li>
<li>存储服务（StorageService），它存储数据，附件和流程检查点（checkpoints）</li>
</ul>
<p>节点的所有者可以使用RPC接口查询节点的存储（见下文）。</p>
<h3 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h3><p>作为运行流程的一部分，与网络中其他节点的所有通信都由节点本身处理。节点的所有者不直接与其他网络节点交互。</p>
<h3 id="RPC接口"><a href="#RPC接口" class="headerlink" title="RPC接口"></a>RPC接口</h3><p>节点的所有者通过远程过程调用（RPC）与节点交互。<a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">API：RPC操作</a>记录了节点公开的关键<a href="https://docs.corda.net/releases/release-V3.1/api-rpc.html" target="_blank" rel="noopener">RPC操作</a>。</p>
<h3 id="服务中心（ServiceHub）"><a href="#服务中心（ServiceHub）" class="headerlink" title="服务中心（ServiceHub）"></a>服务中心（ServiceHub）</h3><p>在内部，节点可以访问在流程执行期间使用的一组丰富的服务，以协调分类帐更新。提供的主要服务是：</p>
<ul>
<li>有关网络上其他节点及其提供的服务的信息</li>
<li>访问保管库（Vault）内容和存储（Storage）服务</li>
<li>访问和生成节点的公钥 - 私钥对</li>
<li>关于节点本身的信息</li>
<li>当前时间，由节点跟踪</li>
</ul>
<h3 id="CorDapp提供商"><a href="#CorDapp提供商" class="headerlink" title="CorDapp提供商"></a>CorDapp提供商</h3><p>CorDapp提供程序是安装新的CorDapps以扩展节点行为的地方。</p>
<p>该节点还默认安装了几个CorDapps来处理常见任务，例如：</p>
<ul>
<li>检索交易对方的交易和附件</li>
<li>升级合同</li>
<li>广播商定的分类账更新以供对手方记录</li>
</ul>
<h4 id="排水模式（Draining-mode）"><a href="#排水模式（Draining-mode）" class="headerlink" title="排水模式（Draining mode）"></a>排水模式（Draining mode）</h4><p>为了使节点能够干净关闭，重要的是没有流程正在运行中，这意味着不应该坚持检查点。该节点能够处于流程排放模式，在此期间：</p>
<ul>
<li>需要通过RPC启动新流程的命令将被拒绝。</li>
<li>预计将要执行将被忽略。（那么这些流程应该如何进行处理呢？）</li>
<li>最初的P2P会话消息将不会被处理，这意味着对等方将无法发起涉及该节点的新流程。</li>
<li>所有其他活动将照常进行，确保机内流程的数量将严格减少。</li>
</ul>
<p>由于它们的数量（可以通过RPC进行监控）达到零，所以关闭节点是安全的。该属性是持久的，这意味着重新启动节点不会将其重置为默认值，并且需要RPC命令。</p>
<h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>概要</p>
<ul>
<li>权限的网络更适合财务用例</li>
<li>点对点通信允许共享需要知道的信息</li>
<li>UTXO模型允许每秒更多的交易处理</li>
</ul>
<h3 id="Permissioned-vs-permissionless"><a href="#Permissioned-vs-permissionless" class="headerlink" title="Permissioned vs. permissionless"></a>Permissioned vs. permissionless</h3><p>传统blockchain网络是permissionless。网络上的各方都是匿名的，可以随意加入和离开。</p>
<p>相比之下，Corda网络获得许可。网络上的每一方都有一个已知的身份，他们在与交易对手进行交流时使用，网络访问由门卫控制。这有几个好处：</p>
<ul>
<li>对于涉及受监管金融机构的大多数情况，匿名方不适用</li>
<li>了解您的交易对手的身份可以使用现有的法律体系，以分类方式解决冲突</li>
<li>如果没有使用诸如工作证明等昂贵的机制，Sybil攻击就可以避免</li>
</ul>
<h3 id="点对点与全球广播"><a href="#点对点与全球广播" class="headerlink" title="点对点与全球广播"></a>点对点与全球广播</h3><p>传统的区块链网络向每个参与者传播每一条消息。其原因有两方面：</p>
<ul>
<li>交易对手身份未知，因此必须将消息发送给每位参与者以确保其到达其预期接收者</li>
<li>让每个参与者意识到每一笔交易都可以让网络防止双重花费</li>
</ul>
<p>缺点是所有参与者都能看到其他人的数据。这在许多使用情况下是不可接受的。</p>
<p>在Corda中，每条消息都会发送给特定的对方，并且不会被任何无关的第三方看到。开发人员可以完全控制发送什么消息，向谁发送消息，以及按照什么顺序。因此，数据仅在需要知道的基础上共享。为了防止这种制度出现双重花费，我们聘请公证人作为工作证明的替代方案。</p>
<p>Corda还使用其他几种技术来最大化网络上的隐私：</p>
<ul>
<li>交易拆分：交易的结构方式允许他们在不公开交易内容的情况下进行数字签名。这是通过使用名为Merkle树的数据结构实现的。你可以在merkle-trees中阅读关于这种技术的更多信息。</li>
<li>密钥随机化：交易双方仅通过其公钥识别，并为每个交易生成新密钥对。因此，旁观者无法确定哪一方参与了某个交易。（公钥大家都可以看到，但是不会公布私钥，但是如何保证通信的安全是个问题）</li>
</ul>
<h3 id="UTXO与账户模式"><a href="#UTXO与账户模式" class="headerlink" title="UTXO与账户模式"></a>UTXO与账户模式</h3><p>Corda使用UTXO（未使用的交易输出）模型。每个交易消耗一组现有状态来产生一组新状态。</p>
<p>替代方案将是一个账户模型。在账户模型中，有状态对象存储在分类账上，事务采取请求的形式来更新这些对象的当前状态。</p>
<p>UTXO模型的主要优点是可以并行应用具有不同输入的交易，极大地增加了网络每秒潜在的交易量。在账户模型中，每秒交易数量受限于对给定对象的更新必须按顺序应用的事实。</p>
<h3 id="Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）"><a href="#Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）" class="headerlink" title="Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）"></a>Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）</h3><p>金融机构需要有能力利用传统的法律制度解决冲突。Corda旨在通过以下方式使其成为可能：</p>
<ul>
<li>拥有许可的网络，意味着参与者知道他们在每次交易中处理的是谁</li>
<li>所有的代码合约都有一份法律文件的支持，这些文件描述了可以依靠解决冲突的合约的预期行为</li>
</ul>
<h3 id="构建与重用"><a href="#构建与重用" class="headerlink" title="构建与重用"></a>构建与重用</h3><p>只要有可能，Corda就会重新使用现有技术，使整个平台更加强健。例如，Corda重复使用：</p>
<ul>
<li>用于开发CorDapps的标准JVM编程语言</li>
<li>现有的SQL数据库</li>
<li>现有的消息队列实现</li>
</ul>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://docs.corda.net/releases/release-V3.1/key-concepts.html" target="_blank" rel="noopener">https://docs.corda.net/releases/release-V3.1/key-concepts.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/blockchain/corda/Corda基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/blockchain/corda/Corda基础知识/" itemprop="url">Corda基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T16:28:29+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/corda/" itemprop="url" rel="index"><span itemprop="name">corda</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>corda是分布式账本技术的一种，另一种大家已经熟知的就是HyperLedger的Fabric。当然这种插件化的开发也有公共链上的石墨烯技术，这种技术也是插件化的挖矿节点的实现，但是石墨烯技术是C++语言的实现，这里我就不做更多的说明了，关于石墨烯更多的介绍可以点击<a href="https://github.com/cryptonomex/graphenes" target="_blank" rel="noopener">这里</a>。<a href="https://steemit.com/blockchain/@robinwen/bts-steem-eos" target="_blank" rel="noopener">这篇文章</a>也做了详细的介绍。</p>
<p>Corda与Fabric的区别，官网的说法是Corda专注于金融这块，而Fabric是基于组织联盟的，但是不管怎样分布式账本技术都是借鉴了区块链的设计思想的；Fabric是插件化的，而Corda是模块化的，我觉得这点在软件设计上有很大的区别。Corda是基于Kotlin开发的，而Fabric主力语言是Python，但是也可以使用其他语言，并不限制。</p>
<p>如果你想了解更多的Corda知识，可以参阅官网的<a href="https://docs.corda.net/releases/release-M7.0/_static/corda-introductory-whitepaper.pdf" target="_blank" rel="noopener">技术白皮书</a>。这个白皮书介绍了，这个系统最终的方案，现在还有很多未实现，正在实现中，当然在实现中可能会有与白皮书不一样的地方。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="包含的实现"><a href="#包含的实现" class="headerlink" title="包含的实现"></a>包含的实现</h3><p>Corda原型机目前包括：</p>
<ul>
<li>具有消息持久性和递送重试的对等网络。</li>
<li>用于定义合同和状态的关键数据结构。</li>
<li>智能合约，您可以在合约目录中找到。</li>
<li>与它们一起工作的算法，如序列化，散列，签名和签名验证。</li>
<li>API文档和教程（您正在阅读的内容）。</li>
<li>业务流程编排框架。</li>
<li>公证基础设施用于精确时间戳，并且在没有区块链的情况下消除双重花费。</li>
<li>一个简单的REST API和一个Web应用程序演示，用它来呈现IRS交易的前端。</li>
</ul>
<p>现在不包括，但是后面会进行实现的部分：</p>
<ul>
<li>沙盒，分销或发布智能合同代码</li>
<li>用于管理的用户界面</li>
</ul>
<p>现在的Corda版本仍然是创意的快速探索，所以为了提高开发的速度，会采取一些捷径，注意以下的一些事项：</p>
<ul>
<li>它使用一个对象映射序列化框架，而不是一个明确的，供应商中立的协议。</li>
<li>目前没有权限框架。（shiro或者Spring auth）</li>
<li>一些隐私技术尚未实施</li>
<li>它使用嵌入式SQL数据库，但尚未支持主流SQL供应商（Oracle，Postgres，MySQL，SQL Server等）的连接。</li>
</ul>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>在corda项目下定义了一些示例程序，这些程序在samples目录下，运行的命令如官网的命令，这里就不做更多说明了。</p>
<p><a href="https://docs.corda.net/releases/release-M7.0/running-the-demos.html" target="_blank" rel="noopener">运行演示</a></p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>这里需要介绍状态（State）、交易（Transaction）和合约（Contract），以及它们之间的交互关系。</p>
<p>首先，交易消费的是状态（State），交易的作用就是将一个状态变换为一个新的状态。分类账被定义为一组不可变状态，由数字签名的交易创建和销毁。每个事务指向一组将要消耗/销毁的状态，这些状态称为输入，并且包含一组将会创建的新状态，这些状态称为 输出。</p>
<p>其次，合约定义了一个验证函数，这是一个纯函数，以交易为输入。要被视为有效，交易必须被输入和输出状态所指向的每个合约的验证功能所接受。</p>
<p>除了输入和输出之外，交易还可能包括命令，小数据包，平台不会自行解释，但可以参数化执行合约。<b style="color:blue">它们可以被认为是验证函数的参数。每个命令都有一个与之关联的公钥列表。该平台确保交易在合约开始执行之前由命令中列出的每个密钥签署。该平台确保交易在合同开始执行之前由命令中列出的每个密钥签署。因此，验证功能可以相信所有列出的密钥都签名了交易，但是负责验证交易从验证功能角度看是否有效所需的任何密钥都包含在列表中.</b></p>
<p><b style="color:red">命令总是嵌入在交易中。有时候，有很多数据可以在许多不同的交易中重复使用。这种使用的例子就是我们的附件。每个交易可以通过哈希引用0个或多个附件。附件始终都是ZIP/JAR文件，可能包含任何内容。这里可以看出命令与附件相关。</b></p>
<p><b style="color:red">请注意交易中可以有输入、输出、命令（Command）和附件（Attachment）。但是这些东西可能有也可能没有。交易中的数据需要合约来进行解释，并确保它们正确地结合在一起。</b></p>
<p><b style="color:red">交易有时可能需要提供带有外界数据的合约。可能包括以下的列子：股票价格、关于事件的事实或者法律实体的状态（例如破产）等等。这些事实的提供者称为神谕（oracles），他们通过签署包含他们已知的命令的交易或通过创建签名附件来为账本提供事实。这些命令包含事实和签名来彰显对此事实的一致。</b></p>
<p>时间也被建模为一个事实，并且有一种称为公证的特殊服务的签名。公证人是一种很有可能的分散式服务，它履行矿工在其他区块链系统中的作用：公证人确保只有一项交易可以消耗任何给定的输出。此外，他们可以验证放置在交易中的时间戳命令，该命令指定交易被认为对公证有效的时间窗口。时间窗口可以是开放式的（即开始但不结束或反之亦然）。通过这种方式，交易可以与公证人的时钟相关联。</p>
<p>一个Corda网络可能有多个竞争公证人。每个状态（State）都指向控制它的公证人。虽然单个交易只有在全部由同一公证人控制的情况下才会消耗状态，但是提供了将一个状态（或一组状态）从一个公证转移到另一个的特殊类型的交易。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Amount"><a href="#Amount" class="headerlink" title="Amount"></a>Amount</h4><p>Amount类是用来表示一些可替代的资产的量。它是一个通用类，它包装用于定义基础产品的类型，称为Token。它可以是JDK的Currency类型，或者Issued，或者是更复杂的类型（例如义务合同签发定义（其中包含用于解决义务的标记定义）。）</p>
<p>使用示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// A quantity of some specific currency like pounds, euros, dollars etc.</span><br><span class="line">Amount&lt;Currency&gt;</span><br><span class="line">// A quantity of currency that is issued by a specific issuer, for instance central bank vs other bank dollars</span><br><span class="line">Amount&lt;Issued&lt;Currency&gt;&gt;</span><br><span class="line">// A quantity of obligations to deliver currency of any issuer.</span><br><span class="line">Amount&lt;Obligation.State&lt;Currency&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>Corda合约由三部分组成; 代表特定交易或资产细节的可执行代码、法律散文（legal prose）和状态对象。<b style="color:red">在关系数据库术语中，状态就像数据库中的一行。</b>分类帐中的状态参考（无论是否已消费）用<code>StateRef</code>对象表示。如果状态引用（state ref）已经能从存储中找到，你将有一个<code>StateAndRef</code>，这是一个简单的<code>StateRef</code>加上数据。</p>
<p><code>ContractState</code>类是所有状态必须实现的接口。<code>TransactionState</code>是一个简单的<code>ContractState</code>容器（一个合约程序使用的自定义数据）和附加的平台级别的状态信息，比如notary指针。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A _participant_ is any party that is able to consume this state in a valid transaction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The list of participants is required for certain types of transactions. For example, when changing the notary</span></span><br><span class="line"><span class="comment">     * for this state, every participant has to be involved and approve the transaction</span></span><br><span class="line"><span class="comment">     * so that they receive the updated state, and don't end up in a situation where they can no longer use a state</span></span><br><span class="line"><span class="comment">     * they possess, since someone consumed that state during the notary change process.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The participants list should normally be derived from the contents of the state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一些接口继承了<code>ContractState</code>，代表常见状态的标准化功能：</p>
<ul>
<li><p><code>OwnableState</code><br>拥有所有者的状态（表示为一个<code>PublicKey</code>，就是状态里面包含拥有者的<code>PublicKey</code>）。公开所有者和用于替换所有者的功能，例如当资产被出售时。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OwnableState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/** There must be a MoveCommand signed by this key to claim the amount. */</span></span><br><span class="line">    <span class="keyword">val</span> owner: AbstractParty</span><br><span class="line">    <span class="comment">/** Copies the underlying data structure, replacing the owner field with this new value and leaving the rest alone. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwner</span><span class="params">(newOwner: <span class="type">AbstractParty</span>)</span></span>: CommandAndState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearState</code><br>一种链接回到其先前状态的状态，随着时间的推移创建一个状态线程。对特定交易或不可拆分资产（如罕见艺术品）进行建模时，线性状态非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LinearState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unique id shared by all LinearState states throughout history within the vaults of all parties.</span></span><br><span class="line"><span class="comment">     * Verify methods should check that one input and one output share the id in a transaction,</span></span><br><span class="line"><span class="comment">     * except at issuance/termination.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> linearId: UniqueIdentifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DealState</code><br>一个<code>LinearState</code>(通过继承实现)表示两方或多方之间的协议。旨在简化实施操纵许多协议类型的通用流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface DealState : LinearState &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Generate a partial transaction representing an agreement (command) to this deal, allowing a general</span><br><span class="line">     * deal/agreement flow to generate the necessary transaction for potential implementations.</span><br><span class="line">     *</span><br><span class="line">     * TODO: Currently this is the &quot;inception&quot; transaction but in future an offer of some description might be an input state ref</span><br><span class="line">     *</span><br><span class="line">     * TODO: This should more likely be a method on the Contract (on a common interface) and the changes to reference a</span><br><span class="line">     * Contract instance from a ContractState are imminent, at which point we can move this out of here.</span><br><span class="line">     */</span><br><span class="line">    fun generateAgreement(notary: Party): TransactionBuilder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FixableDealState</code><br>一个交易状态，进一步的功能暴露以支持固定利率。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FixableDealState</span> : <span class="type">DealState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When is the next fixing and what is the fixing for?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextFixingOf</span><span class="params">()</span></span>: FixOf?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * What oracle service to use for the fixing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> oracle: Party</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a fixing command for this deal and fix.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> This would also likely move to methods on the Contract once the changes to reference</span></span><br><span class="line"><span class="comment">     * the Contract from the ContractState are in.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generateFix</span><span class="params">(ptx: <span class="type">TransactionBuilder</span>, oldState: <span class="type">StateAndRef</span>&lt;*&gt;, fix: <span class="type">Fix</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="NamedByHash和UniqueIdentifier"><a href="#NamedByHash和UniqueIdentifier" class="headerlink" title="NamedByHash和UniqueIdentifier"></a>NamedByHash和UniqueIdentifier</h4><p>散列作为标识的事物（如交易和附件）应该实现<code>NamedByHash</code>接口，这个接口标准化提取ID的操作。请注意，散列不是全局唯一标识符：它总是对基础数据内容的派生摘要。<b style="color:red">有时候这不是你想要的：两个具有完全相同参数并且同时生成但是在逻辑上不同的交易不能通过散列识别，因为它们的内容将是相同的。相反，你会使用<code>UniqueIdentifier</code>。</b> 这是一个（Java）UUID表示一个全球唯一的128位随机数，以及一个可与之配对的任意字符串。例如，为了方便起见，该字符串可以代表现有的“weak”（不保证唯一）标识符。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamedByHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: SecureHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueIdentifier</span></span>(<span class="keyword">val</span> externalId: String? = <span class="literal">null</span>, <span class="keyword">val</span> id: UUID = UUID.randomUUID()) : Comparable&lt;UniqueIdentifier&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用UUID标识，但是可以使用配对的字符串进行拼接</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (externalId != <span class="literal">null</span>) <span class="string">"<span class="subst">$&#123;externalId&#125;</span>_<span class="variable">$id</span>"</span> <span class="keyword">else</span> id.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/** Helper function for unit tests where the UUID needs to be manually initialised for consistency. */</span></span><br><span class="line">        <span class="meta">@VisibleForTesting</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromString</span><span class="params">(name: <span class="type">String</span>)</span></span>: UniqueIdentifier = UniqueIdentifier(<span class="literal">null</span>, UUID.fromString(name))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UniqueIdentifier</span>)</span></span>: <span class="built_in">Int</span> = id.compareTo(other.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (other <span class="keyword">is</span> UniqueIdentifier)</span><br><span class="line">            id == other.id</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = id.hashCode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="FungibleAssets-and-Cash"><a href="#FungibleAssets-and-Cash" class="headerlink" title="FungibleAssets and Cash"></a>FungibleAssets and Cash</h4><p><code>FungibleAsset</code>(可替代资产)是可模拟可替代资产的合约的一个共同的超类，它也为其子类的状态对象提供了一个标准接口来实现。将典型的用例就是<code>Cash</code>，然而<code>FungibleAsset</code>意图是容易扩展到覆盖其它资产，例如商品可以根据需要通过使用一个子类，其状态的对象包括进一步的细节（商品，产地，等级的位置等）进行建模。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FungibleAsset</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">OwnableState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount represents a positive quantity of some issued product which can be cash, tokens, assets, or generally</span></span><br><span class="line"><span class="comment">     * anything else that's quantifiable with integer quantities. See [Issued] and [Amount] for more details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> amount: Amount&lt;Issued&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * There must be an ExitCommand signed by these keys to destroy the amount. While all states require their</span></span><br><span class="line"><span class="comment">     * owner to sign, some (i.e. cash) also require the issuer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> exitKeys: Collection&lt;PublicKey&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies the underlying data structure, replacing the amount and owner fields with the new values and leaving the</span></span><br><span class="line"><span class="comment">     * rest (exitKeys) alone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwnerAndAmount</span><span class="params">(newAmount: <span class="type">Amount</span>&lt;<span class="type">Issued</span>&lt;<span class="type">T</span>&gt;&gt;, newOwner: <span class="type">AbstractParty</span>)</span></span>: FungibleAsset&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里<code>Cash</code>其实是一个<code>Contract</code>，里面包含<code>FungibleAssets</code>的状态子类，由于代码比较长，这里就不展示了。</p>
<h4 id="Transaction-生命周期类型"><a href="#Transaction-生命周期类型" class="headerlink" title="Transaction 生命周期类型"></a>Transaction 生命周期类型</h4><p><code>WireTransaction</code>类包含一个没有签名交易的核心，并带有附件的引用以代表附件本身。一旦对交易签名就封装成<code>SignedTransaction</code>类。为了处理交易（即验证它），它首先被转换为<code>LedgerTransaction</code>，这涉及到验证签名并将它们关联到相关命令，并对附件的引用进行附件解析。具有有效签名的命令被封装在<code>AuthenticatedObject</code>类中(新版中，这个类被重命名为<code>CommandWithParties</code>)。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WireTransaction</span></span>(componentGroups: List&lt;ComponentGroup&gt;, <span class="keyword">val</span> privacySalt: PrivacySalt = PrivacySalt()) : TraversableTransaction(componentGroups) &#123;</span><br><span class="line">    <span class="meta">@Deprecated(<span class="meta-string">"Required only in some unit-tests and for backwards compatibility purposes."</span>, ReplaceWith(<span class="meta-string">"WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)"</span>)</span>, DeprecationLevel.WARNING)</span><br><span class="line">    <span class="keyword">constructor</span>(inputs: List&lt;StateRef&gt;, <span class="comment">// 输入</span></span><br><span class="line">                attachments: List&lt;SecureHash&gt;, <span class="comment">// 附件hash集合</span></span><br><span class="line">                outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, <span class="comment">// 输出，这里我们可以看到TransactionState的意义了</span></span><br><span class="line">                commands: List&lt;Command&lt;*&gt;&gt;, <span class="comment">// 命令集合</span></span><br><span class="line">                notary: Party?,   <span class="comment">// 见证者</span></span><br><span class="line">                timeWindow: TimeWindow?, <span class="comment">// 时间窗口</span></span><br><span class="line">                privacySalt: PrivacySalt = PrivacySalt() <span class="comment">// 私钥密码</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看一下<code>SignedTransaction</code>的定义<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SignedTransaction</span></span>(<span class="keyword">val</span> txBits: SerializedBytes&lt;CoreTransaction&gt;,</span><br><span class="line">                             <span class="keyword">override</span> <span class="keyword">val</span> sigs: List&lt;TransactionSignature&gt;</span><br><span class="line">) : TransactionWithSignatures &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一下LedgerTransaction的定义。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LedgerTransaction</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="comment">/** The resolved input states which will be consumed/invalidated by the execution of this transaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;,           <span class="comment">// 输入</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;,     <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">/** Arbitrary data passed to the program of each input state. */</span></span><br><span class="line">        <span class="keyword">val</span> commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;,             <span class="comment">// 命令（具有有效签名的命令）</span></span><br><span class="line">        <span class="comment">/** A list of [Attachment] objects identified by the transaction that are needed for this transaction to verify. */</span></span><br><span class="line">        <span class="keyword">val</span> attachments: List&lt;Attachment&gt;,                               <span class="comment">// 解析好的附件</span></span><br><span class="line">        <span class="comment">/** The hash of the original serialised WireTransaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> id: SecureHash,                                     <span class="comment">// id，交易的hash</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> notary: Party?,                                     <span class="comment">// 见证者</span></span><br><span class="line">        <span class="keyword">val</span> timeWindow: TimeWindow?,                                     <span class="comment">// 时间窗口</span></span><br><span class="line">        <span class="keyword">val</span> privacySalt: PrivacySalt,                                    <span class="comment">// 密码盐，这个是不是太暴露了</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> networkParameters: NetworkParameters? = <span class="literal">null</span>         <span class="comment">// 网络配置参数</span></span><br><span class="line">) : FullTransaction() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AuthenticatedObject</code>类被重命名为<code>CommandWithParties</code>，这个类比较简单，具体的内容如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandWithParties</span>&lt;<span class="type">out T : CommandData</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> signers: List&lt;PublicKey&gt;,   <span class="comment">// 签署人，其实就是公钥</span></span><br><span class="line">        <span class="comment">/** If any public keys were recognised, the looked up institutions are available here */</span></span><br><span class="line">        <span class="keyword">val</span> signingParties: List&lt;Party&gt;, <span class="comment">// 找到签署人所属的Party</span></span><br><span class="line">        <span class="keyword">val</span> value: T</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#6ab0de">注意：<code>LedgerTransaction</code>没有必要运行它的合约，因此合约可以是无效的（但不是签名无效的）。您可以使用如下所示的verify方法运行合约。</b></p>
<p>可以使用<code>TransactionBuilder</code>构建新的交易，这是一个可修改的交易，一旦内部修改完成，就可以对其进行签名。合约类通常会暴露帮助方法，这些方法对<code>TransactionBuilder</code>会有所帮助。</p>
<p>以下是一个构建交易的例子，该交易创建了bananas的发行（请注意，bananas不是库中真正的合约类型）：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notaryToUse: Party = ... <span class="comment">// 见证者Party</span></span><br><span class="line"><span class="comment">// 创建交易，加入了State</span></span><br><span class="line"><span class="keyword">val</span> txb = TransactionBuilder(notary = notaryToUse).withItems(BananaState(Amount(<span class="number">20</span>, Bananas), fromCountry = <span class="string">"Elbonia"</span>))</span><br><span class="line"><span class="comment">// 使用私钥进行交易签名</span></span><br><span class="line">txb.signWith(myKey)</span><br><span class="line"><span class="comment">// 设置时间窗口</span></span><br><span class="line">txb.setTime(Instant.now(), notaryToUse, <span class="number">30.</span>seconds)</span><br><span class="line"><span class="comment">// We must disable the check for sufficient signatures, because this transaction is not yet notarised.</span></span><br><span class="line"><span class="comment">// 转化为SignedTransaction</span></span><br><span class="line"><span class="keyword">val</span> stx = txb.toSignedTransaction(checkSufficientSignatures = <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// Alternatively, let's just check it verifies pretending it was fully signed. To do this, we get</span></span><br><span class="line"><span class="comment">// a WireTransaction, which is what the SignedTransaction wraps. Thus by verifying that directly we</span></span><br><span class="line"><span class="comment">// skip signature checking.</span></span><br><span class="line">txb.toWireTransaction().toLedgerTransaction(services).verify()</span><br></pre></td></tr></table></figure></p>
<h4 id="Party和PublicKey"><a href="#Party和PublicKey" class="headerlink" title="Party和PublicKey"></a>Party和PublicKey</h4><p>使用网络的实体称为参与方（Party）。各方可以使用密钥签署结构，并且一方可以在其控制下拥有许多密钥。</p>
<p>Party有时候可能被伪名识别，例如，作为监管链的一部分发送给你的节点的交易中，重要的是你可以说服你自己了解交易的有效性，但是同样重要的是，你不知道在那次交易中涉及的是谁。在这些情况下，公钥可能不存在关于谁拥有它的任何标识信息。</p>
<p>参与签署交易的参与方(Party)的身份可以简单地用<code>PublicKey</code>表示，或者通过使用Party类的更多信息（如姓名）来表示。<code>CommandWithParties</code>表示由一组参与方签署的对象（如命令）。</p>
<p><b style="color:#6ab0de">注意: 这些类型是临时的，将来随着身份框架变得更加充实而将发生重大变化。</b></p>
<h4 id="多签名支持"><a href="#多签名支持" class="headerlink" title="多签名支持"></a>多签名支持</h4><p>Corda支持需要多个密钥或参与方授权进行状态对象转换的情况，例如：“首席执行官或其中三分之一的助理都需要提供签名”。</p>
<h5 id="CompositeKey-复合键"><a href="#CompositeKey-复合键" class="headerlink" title="CompositeKey(复合键)"></a>CompositeKey(复合键)</h5><p>这是通过使用树结构的公钥组合来实现的<code>CompositeKey</code>。<code>CompositeKey</code>是一棵树，<b style="color:red">它将密码公钥基元存储在其树叶中，并在中间节点中存储组合逻辑。每个中间节点指定它需要多少个孩子签名的阈值。</b></p>
<p>“Alice和Bob或Charlie”组合键的例证：</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/composite-key.png" alt=""></p>
<p>为了提供更大的灵活性，每个子节点都可以有一个相关的自定义权重（默认值为1）。该阈值 然后指定所需的所有子节点的最小总权重。我们之前的例子也可以表示为：</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/composite-key-2.png" alt=""></p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>签名验证分两个阶段进行：</p>
<ol>
<li>给定一个签名列表，每个签名都会根据预期的内容进行验证。</li>
<li>将与签名相对应的公钥与所讨论的组合密钥树的树叶进行匹配，并且针对每个中间节点计算所有孩子的总组合权重。如果所有阈值都满足，则认为组合密钥要求得到满足。</li>
</ol>
<h4 id="日期支持"><a href="#日期支持" class="headerlink" title="日期支持"></a>日期支持</h4><p>有许多支持接口和类供合约处理日期（特别是在截止日期范围内）使用。由于合约谈判通常涉及诸如“overnight”，“T+3”等期限的最后期限，因此希望允许将这些条款转换为相应的截止日期。<code>Tenor</code>在截止日期之前（例如3天等）对间隔进行建模，同时<code>DateRollConvention</code>描述如何修改最后期限以考虑银行假期或修改正常工作日的其他事件。</p>
<p>根据工作日计算期限的延期需要有关所涉银行假期的信息（以及合同各方在不同的国家/地区，例如，这可能涉及多套不同的银行假期）。<code>BusinessCalendar</code>类模拟这些商业假期的日历; 目前它从磁盘上的文件加载这些文件，但将来这可能涉及参考数据库，以确保所用日期的一致性。</p>
<h4 id="加密和数学支持"><a href="#加密和数学支持" class="headerlink" title="加密和数学支持"></a>加密和数学支持</h4><p><code>SecureHash</code>类代表未知算法的安全散列。我们目前只定义一个子类，<code>SecureHash.SHA256</code>。有实用的方法来创建它们，解析它们等等。</p>
<p>我们还提供了一些数学实用工具，特别是一组插值器和用于样条线的类。这些可以在<a href="https://docs.corda.net/releases/release-M7.0/api/net.corda.core.math/index.html" target="_blank" rel="noopener">数学包</a>中找到。</p>
<h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p>我们平台的基本数据结构之一就是交易。它可以通过签名和验证，也可以由第三方进行验证。交易的构建假定它们构成一个具有输入和输出状态，命令和附件的完整实体。但是，所有敏感数据都不应该透露给参与验证级别交易创建的其他节点（这种情况的一个很好的例子是只验证嵌入式命令的Oracle）。如何以一种让对方信服他们获得签名数据的方式来实现这一点，确实构成了交易的一部分？</p>
<p>我们决定使用众所周知的密码方案来提供包含和数据完整性的证明。Merkle树广泛用于点对点网络，区块链系统和git。</p>
<h4 id="Corda的Merkle树"><a href="#Corda的Merkle树" class="headerlink" title="Corda的Merkle树"></a>Corda的Merkle树</h4><p>交易分为叶子，每个叶子都包含输入，输出，命令或附件。计算中不使用时间戳或签名者等其他字段。接下来，Merkle树以正常方式构建，方法是将当前节点下方的节点散列连接在一起。它在下面的示例图像中可见，其中<code>H</code>表示sha256函数，“+” – 级联。</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/merkleTree.png" alt=""></p>
<p>该交易有一个输入状态，一个输出和三个命令。如果树不是完整的二叉树，则在散列计算（虚线）中重复最右边的节点。</p>
<p><b style="color:blue">最后，根的散列是交易的标识符，它也用于数据完整性的签名和验证。每个叶级别的更改都会改变交易的标识符。</b></p>
<h4 id="隐藏数据"><a href="#隐藏数据" class="headerlink" title="隐藏数据"></a>隐藏数据</h4><p><b style="color:red">隐藏数据并提供它构成交易一部分的证据通过构建部分Merkle树（或Merkle分支）来完成。</b>Merkle分支是一组散列，根据叶子的数据来计算根的散列。然后将该散列与整个交易的散列进行比较，如果它们匹配，则意味着我们获得的数据属于该特定交易。</p>
<p><img src="https://docs.corda.net/releases/release-M7.0/_images/partialMerkle.png" alt=""></p>
<p>在上面的例子中，红色节点是持有Oracle服务签名数据的节点。蓝色节点的哈希形成部分梅克尔树，不包括虚线的哈希。有了应该在红色节点位置和分支中的命令，我们可以计算这棵树的根，并将它与原始交易标识符进行比较 - 我们证明此命令属于此交易。</p>
<h3 id="共识模型"><a href="#共识模型" class="headerlink" title="共识模型"></a>共识模型</h3><p>Corda的基本共识单位是状态。共识的概念可以分为两部分：</p>
<ol>
<li>对状态有效性达成共识 - 各方可以确定定义输出状态的交易被各状态指定的合约接受并具有所有必需的签名。这是通过各方独立运行相同的合约代码和验证逻辑来​​实现的。</li>
<li>关于状态唯一性的共识 - 各方可以确定交易中创建的输出状态是该交易消耗的输入状态的唯一继承者（换句话说 - 一个状态未被用作多个交易的输入）</li>
</ol>
<h4 id="公证人"><a href="#公证人" class="headerlink" title="公证人"></a>公证人</h4><p>我们介绍了公证人（notary）的概念，该公证人是负责证明对于给定的交易没有签署另一个消耗其任何输入状态的交易的机构。数据模型被扩展，以便每个状态都有一个指定的公证人：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class TransactionState&lt;out T : ContractState&gt;(</span><br><span class="line">        /** The custom contract state */</span><br><span class="line">        val data: T,</span><br><span class="line">        /** Identity of the notary that ensures the state is not used as an input to a transaction more than once */</span><br><span class="line">        val notary: Party) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有交易都必须由其输入状态公证人签名，以使输出状态有效（除了发行交易，不包含输入状态）。</p>
<p>当公证人被要求签署交易时，它要么签署交易，证明输出是输入的唯一后继者，要么提供已经被之前签署的另一个交易消耗的任何输入状态的冲突信息。这样做，公证人提供了系统中的终点。在获得公证人签名之前，各方不能确定同等有效但冲突的交易不会被视为确认。获得签名后，双方知道该交易的输入已被该交易独有消耗。因此，这是我们可以说终结发生的地步。</p>
<h4 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h4><p>网络中可以存在一个以上的公证人。这提供了以下好处：</p>
<ol>
<li>自定义行为。我们可以同时拥有验证和隐私保护公证人 - 各方可以根据他们的具体要求做出选择</li>
<li>负载平衡。将事务处理负载分摊到多个公证处将会在整个平台中实现更高的事务吞吐量</li>
<li>低延迟。通过选择公证员与交易方更接近，延迟时间可以缩短</li>
</ol>
<p><b style="color:blue">如果一个交易的所有输入状态指向一个交易，交易只能由公证人签名。在交易涉及由多个公证人控制的状态的情况下，各状态首先必须被重新委托给同一公证人。这是通过使用一种特殊类型的交易来实现的，该交易不会修改任何内容，而是修改状态的公证指针。确保所有投入状态都指向同一公证人是每个相关方的责任（这是交易输出状态有效的另一个条件）</b></p>
<h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>要更改输入状态的公证，请使用NotaryChangeFlow。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Suspendable</span><br><span class="line">fun changeNotary(originalState: StateAndRef&lt;ContractState&gt;,</span><br><span class="line">                 newNotary: Party): StateAndRef&lt;ContractState&gt; &#123;</span><br><span class="line">    val flow = NotaryChangeFlow.Instigator(originalState, newNotary)</span><br><span class="line">    return subFlow(flow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>流程如下：</p>
<ol>
<li>将旧状态作为输入，将新状态作为输出进行构建</li>
<li>从所有参与者获取签名（参与者是能够在有效交易中消费此状态的任何一方，如由状态本身定义的那样）</li>
<li>获得旧的公证人签名</li>
<li>记录并向参与者分发最终交易，以便每个人都拥有新的状态</li>
</ol>
<h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>公证人的设计决定之一是在提交输入状态之前是否验证交易。</p>
<p>如果一个交易没有被检查有效性，它会打开平台进行“拒绝状态”攻击，任何人都可以建立一个无效的交易，消耗其他人的状态并将其提交给公证员以使状态“被阻止”。但是，对交易的验证需要公证人能够看到有问题交易的全部内容及其依赖关系。这是一个明显的隐私泄露。</p>
<p>我们的平台非常灵活，目前我们支持验证和非验证公证实施 - 一方可以根据自己的隐私要求选择使用哪一个。</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>在这个模型中，公证人还充当时间戳机构，验证交易时间戳命令。</p>
<h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><h3 id="corda网站"><a href="#corda网站" class="headerlink" title="corda网站"></a>corda网站</h3><p>这里是corda的<a href="https://www.corda.net/zh-hant/" target="_blank" rel="noopener">官方网站</a>。<br><a href="https://github.com/corda" target="_blank" rel="noopener">这个网站</a>是corda的github主页，你可在里面找到我们的corda项目，入门的cordapp example也可以在这里找到，还是比较实用的。</p>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>最后这里列一下Kotlin的学习的一些资料。</p>
<p>最棒的就是<a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Strings/Task.kt" target="_blank" rel="noopener">这个网站</a>的在线练习，做的的确棒极了。</p>
<p>当然对于Kotlin，我们不得不研究一下它的<a href="http://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">官方指南</a>. 你可以在这里查询文档和Api的说明文档，另外里面还做了一个全局的搜索，不管是文档，博客还是Api文档，你都可以一键搜索，很是方便。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>这个是志愿者翻译的<a href="https://dongchuan.gitbooks.io/gradle-user-guide-/content/overview/features.html" target="_blank" rel="noopener">Gradle User Guide中文版</a></p>
<p>当然如果你想自定义Gradle插件的话，就不得不研究<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure" target="_blank" rel="noopener">Gradle的文档</a>)，里面有相关的Api和概念。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.corda.net/releases/release-M7.0/index.html" target="_blank" rel="noopener">Corda API reference</a><br><a href="https://medium.com/corda/peer-to-peer-enterprise-blockchain-networking-with-the-corda-firewall-4f6a427ebd97" target="_blank" rel="noopener">Peer-to-Peer Enterprise Blockchain Networking with the Corda Firewall.</a><br><a href="http://cncorda.com/" target="_blank" rel="noopener">Corda中文网</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/ProcessBuilder简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/ProcessBuilder简介/" itemprop="url">ProcessBuilder简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:54:47+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学过C语言的都知道如何开启一个新的进行。自从我们学习了java之后，很少会开启新的进程，因为我们绝大部分的使用都是开启线程，以至于线程池的知识成了现在java面试的宝典了。</p>
<p>最近在研究Corda的源码，发现里面的启动都是通过相应的ProcessBuilder，这个类开启了若干进程，当然进程都是执行的shell代码，这里就不做更多说明了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ProcessBuilder类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由Process类处理实现进程的控制管理。每个 ProcessBuilder 实例管理一个进程属性集。它的start() 方法利用这些属性创建一个新的 Process 实例。start() 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p>
<p>每个进程生成器（即ProcessBuilder对象）管理这些进程属性： </p>
<ul>
<li><p>命令 command<br>是一个字符串列表，它表示要调用的外部程序文件及其参数（如果有）。在此，表示有效的操作系统命令的字符串列表是依赖于系统的。例如，每一个总体变量，通常都要成为此列表中的元素，但有一些操作系统，希望程序能自己标记命令行字符串——在这种系统中，Java 实现可能需要命令确切地包含这两个元素。</p>
</li>
<li><p>环境 environment<br>是从变量 到值 的依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅 System.getenv()）。</p>
</li>
<li><p>工作目录 working directory<br>默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</p>
</li>
<li><p>redirectErrorStream属性<br>最初，此属性为 false，意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 Process.getInputStream() 和 Process.getErrorStream() 方法来访问。如果将值设置为 true，标准错误将与标准输出合并。这使得关联错误消息和相应的输出变得更容易。在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</p>
</li>
</ul>
<h2 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h2><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p>
<p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p>
<p>Process抽象类有以下6个抽象方法： </p>
<ul>
<li>destroy()<br>杀掉子进程。 </li>
<li>exitValue()<br>返回子进程的出口值。 </li>
<li>InputStream getErrorStream()<br>获得子进程的错误流。 </li>
<li>InputStream getInputStream()<br>获得子进程的输入流。 </li>
<li>OutputStream getOutputStream()<br>获得子进程的输出流。 </li>
<li>waitFor()<br>导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止。</li>
</ul>
<h3 id="如何创建Process对象？"><a href="#如何创建Process对象？" class="headerlink" title="如何创建Process对象？"></a>如何创建Process对象？</h3><p>一般有两种方法：</p>
<ol>
<li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象。</li>
<li>Runtime.exec() 方法创建一个本机进程，并返回 Process 子类的一个实例。</li>
</ol>
<h2 id="Runtime-exec"><a href="#Runtime-exec" class="headerlink" title="Runtime.exec()"></a>Runtime.exec()</h2><p>ProcessBuilder与Runtime.exec()的区别? </p>
<p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。 </p>
<p>ProcessBuilder.start() 和 Runtime.exec()传递的参数有所不同，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u013256816/article/details/54603910" target="_blank" rel="noopener">浅析ProcessBuilder</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/java线程状态的分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/java线程状态的分析/" itemprop="url">java线程状态的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:35:06+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近阅读了《深入理解Linux内核》这本书，对于线程和进程的知识有了比较深入的理解，这里我就不做更多的介绍了，如果你想了解更多的知识可以阅读一下这本书，虽然阅读起来比较麻烦，但是确实是一本比较不错的书籍，里面的很多知识都是值得深入学习的。做好攻坚的准备就是了。</p>
<h2 id="关于线程的状态"><a href="#关于线程的状态" class="headerlink" title="关于线程的状态"></a>关于线程的状态</h2><p>以下是java的线程状态：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NEW</td>
<td style="text-align:center">初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td style="text-align:center">RUNNABLE</td>
<td style="text-align:center">运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td style="text-align:center">BLOCKED</td>
<td style="text-align:center">阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td style="text-align:center">WAITING</td>
<td style="text-align:center">等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td style="text-align:center">TIMED_WAITING</td>
<td style="text-align:center">超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<h2 id="改变线程状态"><a href="#改变线程状态" class="headerlink" title="改变线程状态"></a>改变线程状态</h2><p>大家都知道Thread类内部提供了几个方法可以改变线程的状态。</p>
<p>当然Future里面也有不少的改变线程状态的实现。</p>
<p>但是这些基础知识就不做更多的介绍了，这也不是我要说明的重点。</p>
<h2 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h2><p>今天主要是来说明这个类的作用的。这个类里面有很多的内容，今天就重点介绍里面的park方法。</p>
<p>因为park方法可以改变线程的状态，这种改变时操作系统级别的，这种调用一定是使用了系统调用，主要是你要明白这一点才能里面AQS里面的实现，这里就是简单的记录一下。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/05/30/java/缓存行与计算机缓存结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/java/缓存行与计算机缓存结构/" itemprop="url">缓存行与计算机缓存结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T15:18:20+08:00">2018-05-30</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/base/" itemprop="url" rel="index"><span itemprop="name">base</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在读《深入理解Linux内核》读了不少关于计算机缓存的体系结构设计，这里就不做更多的说明，下面我们来看看这里面的知识吧！</p>
<p>计算机分为多级缓存，但是主要的还是要从内存条说起。</p>
<p>其实系统会在系统内存上单独开一片cache，而且这片的cache和普通的内存管理策略不同。这应该算是第一级缓存，但是这种提升不是很大。下面我们来讲高速缓存块cache。</p>
<p>对于高速缓存块cache也是有多种分法。一是主板级别的高速cache，这种是多CPU共享的。再上面一层就是CPU专用的高速cache块了。再上一层就是每个CPU核共享的高速cache。再上面一层就是寄存器了。</p>
<p>这就是背景知识。</p>
<h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>高速缓存块不是按照每一个字节进行缓存，而是按照一个内存块进行缓存。可是一旦这块中任何一个内容改变，都会导致整个块的Refresh。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里主要是指程序的改进，比如说你定义一个对象。以前这个对象在一个缓存行中，但是对象中改变的字段就是一个两个频繁改变，这样每次refresh的块比较大。所以方法就是将可变的属性放入一个缓存块中，将不可变的放入另一个缓存块中，这样刷新的少了，速度自然提升了。这就是缓存块的具体说明，具体可以查看具体的引用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://geek.csdn.net/news/detail/114619" target="_blank" rel="noopener">认识CPU Cache</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/理解Java的AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/理解Java的AQS/" itemprop="url">理解Java的AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T19:48:46+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/aqs/" itemprop="url" rel="index"><span itemprop="name">aqs</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一提到java的锁机制，大家都会想到AQS（AbstractQueuedSynchronizer），意思就是抽象的同步队列，感觉就是使用队列来进行同步操作而已。（Java8版本）</p>
<h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>AbstractQueuedSynchronizer是继承自AbstractOwnableSynchronizer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 独占模式同步的当前所有者。</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个说明还是比较简单的，就是说这个同步独占这个线程而已。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>当然AbstractOwnableSynchronizer是队列，所以里面有内部类表示节点（Node），其实就是一个双向链表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标记以指示节点正在以共享模式等待</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标记以指示节点正在以独占模式等待</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // 表示线程已取消的waitStatus值</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    // waitStatus值指示后继者的线程需要暂停</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    // waitStatus值指示线程正在等待状态</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    // waitStatus值指示下一个acquireShared应无条件传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Status field, taking on only the values:</span><br><span class="line">    *   SIGNAL: 值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="line">    *   CANCELLED:  值为1，表示当前的线程被取消；</span><br><span class="line">    *   CONDITION:  值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="line">    *   PROPAGATE:  值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="line">    *   0:        None of the above 表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter; // 存储condition队列中的后继节点。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Returns true if node is waiting in shared mode.</span><br><span class="line">    */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">首先这是一个双向链表，从这里我们可以看出AQS的功能可以分为两类：独占功能和共享功能</b>。另外，排队的节点有5中状态，就是<code>waitStatus</code>的值，Node需要记录排队的线程和下一个等待的节点（线程）。</p>
<p>## </p>
<p>未完待续！！！！！</p>
<h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a><br><a href="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90" target="_blank" rel="noopener">java中线程的状态以及线程栈分析</a><br><a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）</a><br><a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer" target="_blank" rel="noopener">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/java/深入java类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/java/深入java类加载器/" itemprop="url">深入java类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T17:41:35+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk/" itemprop="url" rel="index"><span itemprop="name">jdk</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>对于java的类加载机制，我想大家一定都知道双亲委派模型和JDK类中的加载器。主要有Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader和User Defined ClassLoader。这些基础知识就不多说了。</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)：<br>这个类加载器使用C++语言实现，并非ClassLoader的子类。主要负责加载存放在<code>JAVA_HOME/jre/lib/rt.jar</code>里面所有的class文件，或者被<code>-Xbootclasspath</code>参数所指定路径中以rt.jar命名的文件。</li>
<li>扩展类加载器(Extension ClassLoader)：<br>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>JAVA_HOME/lib/ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li>
<li>应用程序类加载器(Application ClassLoader)：<br>这个加载器由sun.misc.Launcher$AppClassLoader实现，它负责加载<code>classpath</code>对应的jar及目录。一般情况下这个就是程序中默认的类加载器。</li>
<li>自定义类加载器(User Defined ClassLoader)：<br>开发人员继承ClassLoader抽象类自行实现的类加载器，基于自行开发的ClassLoader可用于并非加载classpath中(例如从网络上下载的jar或二进制字节码)、还可以在加载class文件之前做些小动作 如：加密等。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>类加载器(ClassLoader)用来加载 class字节码到 Java 虚拟机中，并转换成 java.lang.Class 类的一个实例。当然class字节码的来源可能有多种，一种就是自己拼写class文件的内容。</p>
<p>Java中如何比较两个类相等呢？这里所指的“相等”包括代表类的Class对象的equal方法、isAssignableFrom()、isInstance()方法及instance关键字返回的结果。</p>
<p>其实在Java中，一个类是否是相同的，主要取决于类加载器和包名+类名，只有以上条件都满足了，我们才说这两个类是相等的。我并没有在class文件中发现equals方法，这说明类加载的去重完全是在definedClass方法中，调用了底层的一些C代码实现的。也就是说，我们无法自己实例化一个Class实例，这需要JVM底层帮我们处理，每个Class实例的去重，完全是JVM的底层代码帮忙处理的。但是我们可以在class类中发现一个ClassLoader类的成员。</p>
<h2 id="ParallelLoaders"><a href="#ParallelLoaders" class="headerlink" title="ParallelLoaders"></a>ParallelLoaders</h2><p>这是ClassLoader里面的一个内部类，用来封装一组并行能力的加载器类型。这个一般是用不到的，有兴趣可以先看一下。但是需要知道ClassLoader是支持并行加载的。</p>
<h2 id="类加载过程与双亲委派"><a href="#类加载过程与双亲委派" class="headerlink" title="类加载过程与双亲委派"></a>类加载过程与双亲委派</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123; // 获得要用的锁</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); // 检查这个类有没有被加载</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime(); // 时间</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123; // 如果父类加载器，就用父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 默认的父类加载器是启动类加载器</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123; // 如果最终没有加载到这个类</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime(); // 取得系统时间</span><br><span class="line">                c = findClass(name); // 如果没有父类加载器就自己加载</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很清楚，就不用过多解释了。双亲委派不是基于继承实现的，而是基于组合的方式实现的，默认使用启动类加载器作为父类加载器。如果类加器的父类加载器没有帮助我们加载到相应的类，那么就会调用findClass这个方法，所以为啥我们定义类加载器的时候需要重写findClass方法的原因就在这里。</p>
<p>默认的findClass实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，如果加载不了类就抛异常，我们进行重写的时候，也应该注意这点（这是典型的模板方法模式）。</p>
<p>其次我们发现loadClass不是final方法，也就是说我们可以打破双亲委派的模型，直接使用自己的类加载器，但这样会出现无法使用系统类的问题了，这个只是我的猜测，但是如果我想ClassLoader中会不会相应的信息，也许需要以后研究JVM底层的时候，才会有答案了。</p>
<h2 id="重写findClass"><a href="#重写findClass" class="headerlink" title="重写findClass"></a>重写findClass</h2><p>我们可以发现重写findClass完全达不到自己生成Class的目的。然后你会发现defineClass也是返回Class类型的，所以我们需要在方法中调用这个方法进行相应的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    // 从codeSource中获取类所在文件路径</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有趣发现这里也有模板方法模式，如果你想前后处理一些事情，可以重写preDefineClass、postDefineClass这两个方法，但是注意原来的方法时private的，你无法调用super里面的方法，这会带来很多的问题。</p>
<p>当然defineClass本省就是一个重载方法，所以详细的信息请查看源码，这里就不多说明了，其实用到才关注，一般的时候是不用管的。</p>
<h2 id="resolveClass方法"><a href="#resolveClass方法" class="headerlink" title="resolveClass方法"></a>resolveClass方法</h2><p>resolveClass 此方法负责完成Class对象的链接，如果链接过，则直接返回。</p>
<h2 id="findLibrary-loadLiberay"><a href="#findLibrary-loadLiberay" class="headerlink" title="findLibrary/loadLiberay"></a>findLibrary/loadLiberay</h2><p>这两个方法其实是为了加载动态链接库使用的，以前我也分析过里面的代码，有些印象，这里就不做更多的解释了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/18/编译原理/LLVM语言参考手册(类型系统到其他值)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/编译原理/LLVM语言参考手册(类型系统到其他值)/" itemprop="url">LLVM语言参考手册(类型系统到其他值)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-18T12:34:05+08:00">2018-04-18</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>LLVM类型系统是中间表示的最重要的特征之一。类型化使得可以直接对中间表示执行许多优化，而不必在转换之前在侧面进行额外的分析。强大的类型系统使读取生成的代码变得更加容易，并且支持新的分析和转换，这些分析和转换在普通的三个地址代码表示上不可行。</p>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>概述：void类型不代表任何值并且没有大小。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void</span><br></pre></td></tr></table></figure></p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>概述：    函数类型可以被认为是函数签名。它由一个返回类型和一个形式参数类型列表组成。函数类型的返回类型是void类型或第一类类型 - <a href="http://llvm.org/docs/LangRef.html#t-label" target="_blank" rel="noopener">标签</a>和<a href="http://llvm.org/docs/LangRef.html#t-metadata" target="_blank" rel="noopener">元数据</a>类型除外。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;returntype&gt; (&lt;parameter list&gt;)</span><br></pre></td></tr></table></figure></p>
<p>…其中<code>&lt;parameter list&gt;</code>是逗号分隔的类型说明符列表。可选地，参数列表可以包括类型…，该类型指示该函数采用可变数目的参数。变量参数函数可以通过<a href="http://llvm.org/docs/LangRef.html#int-varargs" target="_blank" rel="noopener">处理内部函数的变量参数</a>来访问它们的参数。<code>&lt;returntype&gt;</code>是除<a href="http://llvm.org/docs/LangRef.html#t-label" target="_blank" rel="noopener">标签</a>和<a href="http://llvm.org/docs/LangRef.html#t-metadata" target="_blank" rel="noopener">元数据</a>之外的任何类型。</p>
<p>例子：<br><code>i32 (i32)</code>    函数接受i32，返回一个i32<br><code>float (i16, i32 *) *</code>    指针，以接受一个函数i16和一个i32指针来返回float。<br><code>i32 (i8*, ...)</code>    可变参数函数，它有至少一个指针到i8（在C中是char），它返回一个整数。LLVM中这是printf的签名。<br><code>{i32, i32} (i32)</code>    一个函数i32，返回一个包含两个i32值的<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构</a></p>
<h2 id="第一类类型（First-Class-Types）"><a href="#第一类类型（First-Class-Types）" class="headerlink" title="第一类类型（First Class Types）"></a>第一类类型（First Class Types）</h2><p>第一类的类型可能是最重要的。这些类型的值是唯一可以通过指令产生的类型。</p>
<h3 id="单值类型"><a href="#单值类型" class="headerlink" title="单值类型"></a>单值类型</h3><p>这些是从CodeGen的角度来看在寄存器中有效的类型。</p>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>概述：    整数类型是一个非常简单的类型，它简单地为所需的整数类型指定一个任意的位宽。可以指定从1位到2<sup>23</sup>-1（约8百万）的任何位宽。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iN</span><br></pre></td></tr></table></figure></p>
<p>整数将占据的位数由该<code>N</code>值指定。</p>
<p>例子：<br><code>i1</code>    一个单位整数。<br><code>i32</code>    一个32位整数。<br><code>i1942652</code>    一个超过100万位的大整数。</p>
<h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>half</td>
<td>16位浮点值</td>
</tr>
<tr>
<td>float</td>
<td>32位浮点值</td>
</tr>
<tr>
<td>double</td>
<td>64位浮点值</td>
</tr>
<tr>
<td>fp128</td>
<td>128位浮点值（112位尾数）</td>
</tr>
<tr>
<td>x86_fp80</td>
<td>80位浮点值（X87）</td>
</tr>
<tr>
<td>ppc_fp128</td>
<td>128位浮点值（两个64位）</td>
</tr>
</tbody>
</table>
<p>half，float，double和fp128的二进制格式分别对应于binary16，binary32，binary64和binary128的IEEE-754-2008规范。</p>
<h4 id="X86-mmx类型"><a href="#X86-mmx类型" class="headerlink" title="X86_mmx类型"></a>X86_mmx类型</h4><p>概述：    x86_mmx类型表示在x86机器上的MMX寄存器中保存的值。允许的操作相当有限：参数和返回值，load和store以及bitcast。用户指定的<code>MMX</code>指令表示为具有参数<code>and/or</code>此类型结果的内部调用或asm调用。没有这种类型的数组、向量或常量。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_mmx</span><br></pre></td></tr></table></figure></p>
<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>概述：    指针类型用于指定内存位置。指针通常用于引用内存中的对象。</p>
<p>指针类型可能有一个可选的地址空间属性，用于定义指向对象所在的编号地址空间。默认地址空间是数字零。非零地址空间的语义是特定于目标的。</p>
<p>请注意，LLVM不允许指向<code>void（void*）</code>的指针，也不允许指向标签<code>（label*）</code>的指针。改为使用<code>i8*</code>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; *</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>[4 x i32]*</code>    4个的i32值数组的指针。<br><code>i32 (i32*) *</code>    函数指针，它接受一个<code>i32*</code>，并返回i32。<br><code>i32 addrspace(5)*</code>    i32值的指针，驻留在地址空间<code>#5</code>中的值。</p>
<h4 id="矢量类型"><a href="#矢量类型" class="headerlink" title="矢量类型"></a>矢量类型</h4><p>概述：    矢量类型是表示元素矢量的简单派生类型。当使用单个指令（SIMD）并行操作多个原始数据时，使用矢量类型。矢量类型需要大小（元素数量）和基础原始数据类型。矢量类型被认为是<a href="http://llvm.org/docs/LangRef.html#t-firstclass" target="_blank" rel="noopener">第一类</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; &lt;# elements&gt; x &lt;elementtype&gt; &gt;</span><br></pre></td></tr></table></figure></p>
<p>元素的数量是一个大于0的常数整数值; <code>elementtype</code>可以是任何整数、浮点或指针类型。大小为零的矢量是不允许的。</p>
<p>例子：<br><code>&lt;4 x i32&gt;</code>    4个32位整数值的向量。<br><code>&lt;8 x float&gt;</code>    8个32位浮点值的向量。<br><code>&lt;2 x i64&gt;</code>    2个64位整数值的向量。<br><code>&lt;4 x i64*&gt;</code>    4个64位整数值指针的向量。</p>
<h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><p>概述：    标签类型代表代码标签。<br>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label</span><br></pre></td></tr></table></figure></p>
<h3 id="令牌-token-类型"><a href="#令牌-token-类型" class="headerlink" title="令牌(token)类型"></a>令牌(token)类型</h3><p>概述：    当值与指令相关联时使用token类型，但该值的所有用法不得试图反思或模糊它。因此，具有<a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">phi</a>或<a href="http://llvm.org/docs/LangRef.html#i-select" target="_blank" rel="noopener">select</a>类型令牌是不合适的。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token</span><br></pre></td></tr></table></figure></p>
<h3 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h3><p>概述：    元数据类型表示嵌入的元数据。除函数参数外，不得从元数据创建派生类型。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metadata</span><br></pre></td></tr></table></figure></p>
<h3 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h3><p>聚合类型是派生类型的一个子集，可以包含多个成员类型。<a href="http://llvm.org/docs/LangRef.html#t-array" target="_blank" rel="noopener">数组</a>和<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构</a>是聚合类型。<a href="http://llvm.org/docs/LangRef.html#t-vector" target="_blank" rel="noopener">向量</a>不被视为聚合类型。</p>
<h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>概述：    数组类型是一种非常简单的派生类型，它将元素按顺序排列在内存中。数组类型需要大小（元素数量）和基础数据类型。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;# elements&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure></p>
<p>元素的数量是一个常数整数值; <code>elementtype</code>可以是任何尺寸的类型。</p>
<p>例子：<br><code>[40 x i32]</code>    包含40个32位整数值的数组。<br><code>[41 x i32]</code>    41个32位整数值的数组。<br><code>[4 x i8]</code>    包含4个8位整数值的数组。<br>以下是多维数组的一些示例：<br><code>[3 x [4 x i32]]</code>    3x4 32位整数值数组。<br><code>[12 x [10 x float]]</code>    单精度浮点值的12×10数组。<br><code>[2 x [3 x [4 x i16]]]</code>    2x3x4的16位整数值数组。</p>
<p>除了静态类型隐含的数组末尾之外，没有对索引的限制（尽管在某些情况下索引超出了分配对象的范围）。这意味着可以在零长度数组类型的LLVM中实现单维“可变大小数组”。例如，在LLVM中实现“pascal样式数组”可以使用类型“<code>{ i32, [0 x float]}</code>”。</p>
<h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>概述：    结构类型用于在内存中一起表示数据成员的集合。结构的元素可以是任何具有大小的类型。</p>
<p>使用’<code>load</code>‘和’<code>store</code>‘通过使用’<code>getelementptr</code>‘指令获取指向字段的指针来访问内存中的结构。使用’<code>extractvalue</code>‘和’<code>insertvalue</code>‘指令访问寄存器中的结构。</p>
<p>结构可以选择是“压缩”结构，其指示结构的对齐是一个字节，并且元素之间没有填充。在非压缩结构中，字段类型之间的填充按照DataLayout字符串在模块中定义的方式插入，该模块需要与基础代码生成器的预期匹配。</p>
<p>结构可以是“文字”或“识别符”。字面结构与其他类型（例如<code>{i32, i32}*</code>）内联定义，而标识类型始终在顶层使用名称定义。文字类型被其内容所独占，因为没有办法编写它们，所以永远不会递归或不透明。识别符的类型可以是递归的，可以是不透明的，并且永远不会被分离。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 = type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 = type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>{ i32, i32, i32 }</code>    三个i32值的结构<br><code>{ float, i32 (i32) * }</code>    一对，其中第一个元素是a float，第二个元素是一个指向函数的指针，该函数接受一个i32返回值i32。<br><code>&lt;{ i8, i32 }&gt;</code>    一个已知为5字节大小的打包结构。</p>
<h4 id="不透明结构类型"><a href="#不透明结构类型" class="headerlink" title="不透明结构类型"></a>不透明结构类型</h4><p>概述：    不透明结构类型用于表示没有指定主体的命名结构类型。这符合（例如）正向声明结构的C概念。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%X = type opaque</span><br><span class="line">%52 = type opaque</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><code>opaque</code>    一种不透明的类型。</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>LLVM有几种不同的基本类型的常量。本节介绍它们的全部和它们的语法。</p>
<h2 id="简单常量"><a href="#简单常量" class="headerlink" title="简单常量"></a>简单常量</h2><ul>
<li>布尔常量: 两个字符串’ true’和’ false’都是该i1类型的有效常量。</li>
<li>整型常量: 标准整数（如’4’）是整数类型的常量 。负数可能与整数类型一起使用。</li>
<li>浮点常量: 浮点常量使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e + 2）或更精确的十六进制表示法（请参见下文）。汇编器需要浮点常量的精确十进制值。例如，汇编程序接受1.25，但拒绝1.3，因为1.3是二进制中的重复小数。浮点常量必须具有 浮点类型。</li>
<li>空指针常量: 标识符’<code>null</code>‘被识别为空指针常量，并且必须是指针类型。</li>
<li>令牌(Token)常量: 标识符’none’被识别为空的标记常量，并且必须是标记类型。</li>
</ul>
<p>常量的一个非直观符号是浮点常量的十六进制形式。例如，形式为’<code>double    0x432ff973cafa8000</code>‘等同于（但难以阅读）’<code>double 4.5e+15</code>‘。唯一需要十六进制浮点常量（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能用合理数目的十进制浮点数表示的浮点常量数字。例如，<code>NaN&#39;s</code>，<code>infinities</code>和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位发生更改。</p>
<p>当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字形式表示（与IEEE754表示符合double）; 然而，half和float值必须分别精确表示为IEEE 754的半精度和单精度。十六进制格式总是用于长双，并有三种形式的长双。x86使用的80位格式表示0xK后跟20个十六进制数字。PowerPC使用的128位格式（两个相邻的双精度） 0xM由32个十六进制数字表示。IEEE 128位格式0xL由32个十六进制数字表示。长双打只有在你的目标上的长双重格式匹配时才有效。IEEE 16位格式（半精度）由表示0xH 后跟4个十六进制数字。所有的十六进制格式都是big-endian（左边的符号位）。</p>
<p>没有<code>x86_mmx</code>类型的常量。</p>
<h2 id="复杂（Complex）常量"><a href="#复杂（Complex）常量" class="headerlink" title="复杂（Complex）常量"></a>复杂（Complex）常量</h2><p>复杂常量是简单常量和较小复常量的（可能递归）组合。</p>
<h3 id="结构常数"><a href="#结构常数" class="headerlink" title="结构常数"></a>结构常数</h3><p>结构常量用类似于结构类型定义的符号表示（逗号分隔的元素列表，用大括号（{}）括起来）。例如：“<code>{ i32 4, float 17.0, i32* @G }</code>”，其中“<code>@G</code>”被声明为“<code>@G = external global i32</code>”。结构常量必须具有<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构类型</a>，并且元素的数量和类型必须与该类型指定的类型匹配。</p>
<h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号（[]）括起来）。例如：“<code>[ i32 42, i32 11, i32 74 ]</code>”。数组常量必须具有<a href="http://llvm.org/docs/LangRef.html#t-array" target="_blank" rel="noopener">数组类型</a>，并且元素的数量和类型必须与该类型指定的数量和类型相匹配。作为一种特殊情况，字符数组常量也可以用 前缀表示为双引号字符串。例如：“c<code>&quot;Hello World\0A\00&quot;</code>”。</p>
<h3 id="矢量-Vector-常量"><a href="#矢量-Vector-常量" class="headerlink" title="矢量(Vector)常量"></a>矢量(Vector)常量</h3><p>向量常量用类似于向量类型定义的符号表示（逗号分隔的元素列表，由小于/大于（（&lt;&gt;））围绕）。例如：“<code>&lt; i32 42, i32 11, i32 74, i32 100 &gt;</code>”。向量常量必须具有向量类型，并且元素的数量和类型必须与该类型指定的类型匹配。</p>
<h3 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h3><p>字符串“<code>zeroinitializer</code>‘可用于将零值初始化为任何类型的零，包括标量和<a href="http://llvm.org/docs/LangRef.html#t-aggregate" target="_blank" rel="noopener">聚合类型</a>。这通常用于避免必须打印大型零初始化器（例如，用于大型数组），并且始终完全等同于使用显式零初始化器。</p>
<h3 id="元数据节点"><a href="#元数据节点" class="headerlink" title="元数据节点"></a>元数据节点</h3><p>元数据节点是一个没有类型的常量元组。例如：“<code>!{!0, !{!2, !0}, !&quot;test&quot;}</code>”。元数据可以引用常量值，例如：“<code>!{!0, i32 0, i8* @global, i64 (i64)* @function, !&quot;str&quot;}</code>”。与其他类型化的常量不同，它们被解释为指令流的一部分，元数据是附加附加信息的地方，例如调试信息。</p>
<h2 id="全局变量和函数地址"><a href="#全局变量和函数地址" class="headerlink" title="全局变量和函数地址"></a>全局变量和函数地址</h2><p><a href="http://llvm.org/docs/LangRef.html#globalvars" target="_blank" rel="noopener">全局变量</a>和 <a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数</a>总是隐式有效（链接时间）常量。当使用<a href="http://llvm.org/docs/LangRef.html#identifiers" target="_blank" rel="noopener">全局标识符</a>并且总是有指针类型时，这些常量被明确引用。例如，以下是合法的LLVM文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@X = global i32 17</span><br><span class="line">@Y = global i32 42</span><br><span class="line">@Z = global [2 x i32*] [ i32* @X, i32* @Y ]</span><br></pre></td></tr></table></figure></p>
<h2 id="未定义的值"><a href="#未定义的值" class="headerlink" title="未定义的值"></a>未定义的值</h2><p>字符串’<code>undef</code>‘可以用于任何需要常量的地方，并且表示该值的用户可能会收到未指定的位模式。未定义的值可以是任何类型（除了’<code>label</code>‘或’<code>void</code>‘），并且可以在任何允许常量的地方使用。</p>
<p>未定义的值非常有用，因为它们向编译器指出，无论使用什么值，该程序都已定义良好。这为编译器提供了更多的优化自由度。下面是一些有效的（可能令人惊讶的）转换的例子（在伪IR中）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  %A = add %X, undef</span><br><span class="line">  %B = sub %X, undef</span><br><span class="line">  %C = xor %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure></p>
<p>这是安全的，因为所有的输出位都受<code>undef</code>位的影响。任何输出位都可以有一个零或一个依赖的输入位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = or %X, undef</span><br><span class="line">  %B = and %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = -1</span><br><span class="line">  %B = 0</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X  ;; By choosing undef as 0</span><br><span class="line">  %B = %X  ;; By choosing undef as -1</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br></pre></td></tr></table></figure></p>
<p>这些逻辑操作的位不总是受输入的影响。例如，如果%X有一个零位，那么“<code>and</code>‘操作的输出将始终为该位的零，而不管”<code>undef</code>‘ 的相应位是什么。因此，优化或假设<code>and</code>的结果是<code>undef</code>是不安全的。但是，假设<code>undef</code>的所有位都可以是0，并且将’<code>and</code>‘优化为0是安全的。同样，假设可以设置<code>undef</code>的<code>or</code>操作的所有位是安全的，允许’<code>or</code>‘被折叠为-1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = select undef, %X, %Y</span><br><span class="line">  %B = select undef, 42, %Y</span><br><span class="line">  %C = select %X, %Y, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X     (or %Y)</span><br><span class="line">  %B = 42     (or %Y)</span><br><span class="line">  %C = %Y</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure></p>
<p>这组例子表明，未定义的’<code>select</code>‘（和条件分支）条件可以采取任何方式，但它们必须来自两个操作数中的一个。在<code>%A</code>例子中，如果<code>%X</code>和<code>%Y</code>是两个已知具有明显的低位，那么<code>%A</code>就必须有一个清除低位。然而，在这个<code>%C</code>例子中，优化器被允许假设’<code>undef</code>‘操作可以是和<code>%Y</code>相同的，允许整个’<code>select</code>‘被消除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  %A = xor undef, undef</span><br><span class="line"></span><br><span class="line">  %B = undef</span><br><span class="line">  %C = xor %B, %B</span><br><span class="line"></span><br><span class="line">  %D = undef</span><br><span class="line">  %E = icmp slt %D, 4</span><br><span class="line">  %F = icmp gte %D, 4</span><br><span class="line"></span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br><span class="line">  %D = undef</span><br><span class="line">  %E = undef</span><br><span class="line">  %F = undef</span><br></pre></td></tr></table></figure></p>
<p>这个例子指出两个<code>undef</code>操作不一定相同。这对于人们来说可能是令人惊讶的（并且也匹配C语义），他们认为“<code>X^X</code>”总是零，即使 X未定义也是如此。由于多种原因，这是不正确的，但简单的答案是，一个<code>undef</code>“变量”可以在其“生存范围”内随意改变它的值。这是真的，因为这个变量实际上并没有生存范围。相反，该值是从任意寄存器中逻辑读取的，这些寄存器恰好在需要时发生变化，因此该值不一定随时间变化。事实上，<code>%A</code>和<code>%C</code>需要有相同的语法或核心LLVM“全部替换与使用”的概念将不成立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = sdiv undef, %X</span><br><span class="line">  %B = sdiv %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = 0</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure></p>
<p>这些示例显示了未定义的值 和未定义的行为之间的关键区别。一个未定义的值（如’<code>undef</code>‘）允许有一个任意的位模式。这意味着<code>%A</code>操作可以不断折叠为’0’，因为’<code>undef</code>‘可能为零，并且零除以任何值为零。但是，在第二个例子中，我们可以做一个更积极的假设：因为<code>undef</code>允许它是一个任意值，我们可以假设它可能为零。由于被零除以具有未定义的行为，我们被允许假设该操作根本不执行。这允许我们删除分割和所有代码。由于未定义的操作“不可能发生”，因此优化器可以假定它发生在死代码中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:  store undef -&gt; %X</span><br><span class="line">b:  store %X -&gt; undef</span><br><span class="line">Safe:</span><br><span class="line">a: &lt;deleted&gt;</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure></p>
<p>存储的未定义的值可以被假设为不具有任何影响; 我们可以假设这个值被恰好与已经存在的相匹配的位覆盖。然而，一个存储到一个未定义的位置可能破坏任意的内存，因此，它具有未定义行为。</p>
<h2 id="毒药（Poison）值"><a href="#毒药（Poison）值" class="headerlink" title="毒药（Poison）值"></a>毒药（Poison）值</h2><p>毒性（Poison）值与undef值相似，但它们也表示这样的事实，即不能引起副作用的指令或常量表达式已经检测到导致未定义行为的条件。</p>
<p>目前在IR中无法表示毒物值; 它们只存在于某些操作的调用，如带有<code>nsw</code>标志的<code>add</code>操作。</p>
<p>毒药值行为是根据值依赖来定义的：</p>
<ul>
<li><a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">phi</a>节点以外的值取决于它们的操作数。</li>
<li><a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">Phi</a>节点取决于对应于其动态前驱基本块的操作数。</li>
<li>函数参数取决于其函数的动态调用者中相应的实际参数值。</li>
<li>调用(<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener">call</a>)指令取决于将控制动态传回给它们的<a href="http://llvm.org/docs/LangRef.html#i-ret" target="_blank" rel="noopener">ret</a>指令。</li>
<li>调用(<a href="http://llvm.org/docs/LangRef.html#i-invoke" target="_blank" rel="noopener">invoke</a>)指令取决于ret， <a href="http://llvm.org/docs/LangRef.html#i-resume" target="_blank" rel="noopener">resume</a>或异常抛出调用指令，动态地将控制权交还给它们。</li>
<li>非易失性加载和存储取决于所有引用的内存地址的最新存储，遵循IR中的命令（包括由<a href="mailto:`@llvm.memcpy" target="_blank" rel="noopener">`@llvm.memcpy</a>`等内在函数隐含的加载和存储）。</li>
<li>具有外部可见副作用的指令取决于最近的先前的指令，其具有外部可见的副作用，遵循IR中的顺序。（这包括易失性操作。）</li>
<li>指令控制依赖于一个终止指令，如果终止子指令有多个后继者和指令总是被执行时控制转移到后继的一个，并且当控制被转移到另一个可以不执行。</li>
<li>此外，指令也是控制 - 取决于终止指令，如果终止指令已将控制权转移给不同的后继者，则其所依赖的指令集将会不​​同。</li>
<li>依赖性是传递性的。</li>
</ul>
<p>Poison值具有与undef值相同的行为，另外的效果是任何依赖poison值的指令都具有未定义的行为。</p>
<p>这里有些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  %poison = sub nuw i32 0, 1           ; Results in a poison value.</span><br><span class="line">  %still_poison = and i32 %poison, 0   ; 0, but also poison.</span><br><span class="line">  %poison_yet_again = getelementptr i32, i32* @h, i32 %still_poison</span><br><span class="line">  store i32 0, i32* %poison_yet_again  ; memory at @h[0] is poisoned</span><br><span class="line"></span><br><span class="line">  store i32 %poison, i32* @g           ; Poison value stored to memory.</span><br><span class="line">  %poison2 = load i32, i32* @g         ; Poison value loaded back from memory.</span><br><span class="line"></span><br><span class="line">  store volatile i32 %poison, i32* @g  ; External observation; undefined behavior.</span><br><span class="line"></span><br><span class="line">  %narrowaddr = bitcast i32* @g to i16*</span><br><span class="line">  %wideaddr = bitcast i32* @g to i64*</span><br><span class="line">  %poison3 = load i16, i16* %narrowaddr ; Returns a poison value.</span><br><span class="line">  %poison4 = load i64, i64* %wideaddr  ; Returns a poison value.</span><br><span class="line"></span><br><span class="line">  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.</span><br><span class="line">  br i1 %cmp, label %true, label %end  ; Branch to either destination.</span><br><span class="line"></span><br><span class="line">true:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This is control-dependent on %cmp, so</span><br><span class="line">                                       ; it has undefined behavior.</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  %p = phi i32 [ 0, %entry ], [ 1, %true ]</span><br><span class="line">                                       ; Both edges into this PHI are</span><br><span class="line">                                       ; control-dependent on %cmp, so this</span><br><span class="line">                                       ; always results in a poison value.</span><br><span class="line"></span><br><span class="line">  store volatile i32 0, i32* @g        ; This would depend on the store in %true</span><br><span class="line">                                       ; if %cmp is true, or the store in %entry</span><br><span class="line">                                       ; otherwise, so this is undefined behavior.</span><br><span class="line"></span><br><span class="line">  br i1 %cmp, label %second_true, label %second_end</span><br><span class="line">                                       ; The same branch again, but this time the</span><br><span class="line">                                       ; true block doesn&apos;t have side effects.</span><br><span class="line"></span><br><span class="line">second_true:</span><br><span class="line">  ; No side effects!</span><br><span class="line">  ret void</span><br><span class="line"></span><br><span class="line">second_end:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This time, the instruction always depends</span><br><span class="line">                                       ; on the store in %end. Also, it is</span><br><span class="line">                                       ; control-equivalent to %end, so this is</span><br><span class="line">                                       ; well-defined (ignoring earlier undefined</span><br><span class="line">                                       ; behavior in this example).</span><br></pre></td></tr></table></figure></p>
<h2 id="基本块的地址"><a href="#基本块的地址" class="headerlink" title="基本块的地址"></a>基本块的地址</h2><p><code>blockaddress(@function, %block)</code></p>
<p>在“<code>blockaddress</code>”常数计算在指定函数指定的基本块的地址，并总是有一个<code>i8*</code>类型。取出输入块的地址是非法的。</p>
<p>当用作’<code>indirectbr</code>‘指令的操作指令时，或者用于与空值进行比较时，该值仅具有已定义的行为。标签地址之间的指针相等测试会导致未定义的行为 - 但是，再次，与null进行比较是可以的，并且没有标签等于空指针。只要这些位未被检查，这可以作为不透明的指针大小值传递。ptrtoint只要原始值在indirectbr 指令之前重新构成，就允许和计算这些值。</p>
<p>最后，有些目标可能会在使用该值作为内联程序集的操作数时提供定义的语义，但这是目标特定的。</p>
<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式用于允许涉及其他常量的表达式用作常量。常量表达式可以是任何<a href="http://llvm.org/docs/LangRef.html#t-firstclass" target="_blank" rel="noopener">第一类类型</a>，并且可能涉及没有副作用的任何LLVM操作（例如，不支持加载和调用）。以下是常量表达式的语法：</p>
<ul>
<li><code>trunc (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-trunc" target="_blank" rel="noopener">trunc操作</a>。</li>
<li><code>zext (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-zext" target="_blank" rel="noopener">zext操作</a>。</li>
<li><code>sext (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-sext" target="_blank" rel="noopener">sext操作</a>。</li>
<li><code>fptrunc (CST to TYPE)</code>: 将浮点常量截断为另一个浮点类型。CST的大小必须大于TYPE的大小。这两种类型都必须是浮点型。</li>
<li><code>fpext (CST to TYPE)</code>: 浮点将常量扩展为另一种类型。CST的大小必须小于或等于TYPE的大小。这两种类型都必须是浮点型。</li>
<li><code>fptoui (CST to TYPE)</code>: 将浮点常量转换为相应的无符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li>
<li><code>fptosi (CST to TYPE)</code>: 将浮点常量转换为相应的有符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li>
<li><code>uitofp (CST to TYPE)</code>: 将无符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li>
<li><code>sitofp (CST to TYPE)</code>: 将有符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li>
<li><code>ptrtoint (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-ptrtoint" target="_blank" rel="noopener">ptrtoint操作</a>。</li>
<li><code>inttoptr (CST to TYPE)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-inttoptr" target="_blank" rel="noopener">inttoptr操作</a>。这个真的很危险！</li>
<li><code>bitcast (CST to TYPE)</code>: 将常数CST转换为另一个TYPE。操作数的限制与<a href="http://llvm.org/docs/LangRef.html#i-bitcast" target="_blank" rel="noopener">bitcast指令</a>的限制相同 。</li>
<li><code>addrspacecast (CST to TYPE)</code>: 将指针CST的常量指针或常量向量转换为另一个地址空间中的另一个TYPE。操作数的约束与<a href="http://llvm.org/docs/LangRef.html#i-addrspacecast" target="_blank" rel="noopener">addrspacecast指令</a>的约束相同。</li>
<li><code>getelementptr (TY, CSTPTR, IDX0, IDX1, ...)， getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr操作</a>。与<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a> 指令一样，索引列表可能有一个或多个索引，这些索引对于“指向TY的指针”类型是有意义的。</li>
<li><code>select (COND, VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-select" target="_blank" rel="noopener">选择操作</a>。</li>
<li><code>icmp COND (VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-icmp" target="_blank" rel="noopener">icmp操作</a>。</li>
<li><code>fcmp COND (VAL1, VAL2)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-fcmp" target="_blank" rel="noopener">fcmp操作</a>。</li>
<li><code>extractelement (VAL, IDX)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-extractelement" target="_blank" rel="noopener">extractelement操作</a>。</li>
<li><code>insertelement (VAL, ELT, IDX)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-insertelement" target="_blank" rel="noopener">insertelement操作</a>。</li>
<li><code>shufflevector (VEC1, VEC2, IDXMASK)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-shufflevector" target="_blank" rel="noopener">shufflevector操作</a>。</li>
<li><code>extractvalue (VAL, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-extractvalue" target="_blank" rel="noopener">extractvalue操作</a>。索引列表的解释方式与“<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a>”操作中的索引类似。至少必须指定一个索引值。</li>
<li><code>insertvalue (VAL, ELT, IDX0, IDX1, ...)</code>: 对常量执行<a href="http://llvm.org/docs/LangRef.html#i-insertvalue" target="_blank" rel="noopener">insertvalue操作</a>。索引列表的解释方式与“<a href="http://llvm.org/docs/LangRef.html#i-getelementptr" target="_blank" rel="noopener">getelementptr</a>”操作中的索引类似。至少必须指定一个索引值。</li>
<li><code>OPCODE (LHS, RHS)</code>: 执行LHS和RHS常量的指定操作。操作码可以是任何<a href="http://llvm.org/docs/LangRef.html#binaryops" target="_blank" rel="noopener">二进制</a>或<a href="http://llvm.org/docs/LangRef.html#bitwiseops" target="_blank" rel="noopener">按位二进制</a>操作。操作数的限制与相应指令的限制相同（例如，不允许对浮点值进行按位操作）。</li>
</ul>
<h1 id="其他值"><a href="#其他值" class="headerlink" title="其他值"></a>其他值</h1><h2 id="内嵌汇编表达式"><a href="#内嵌汇编表达式" class="headerlink" title="内嵌汇编表达式"></a>内嵌汇编表达式</h2><p>LLVM 通过使用特殊值支持内联汇编表达式（与模块级内联汇编相反）。该值表示内联汇编程序作为模板字符串（包含要发出的指令），操作数约束列表（存储为字符串），指示内联asm表达式是否具有副作用的标志以及指示是否包含asm的函数需要保守地调整堆栈。</p>
<p>模板字符串支持使用<code>$</code>后跟一个数字的参数替换，以指示由约束字符串指定的给定寄存器/内存位置的替换。“<code>${NUM:MODIFIER}</code>”也可以使用，其中MODIFIER是如何打印操作数的特定于目标的注释（请参阅<a href="http://llvm.org/docs/LangRef.html#inline-asm-modifiers" target="_blank" rel="noopener">Asm模板参数修饰符</a>）。</p>
<p>字符<code>$</code>可以在模板中使用“<code>$$</code>”。要在输出中包含其他特殊字符，可以使用通常的“<code>\XX</code>”转义符，就像在其他字符串中一样。请注意，在模板替换之后，生成的汇编字符串将由LLVM的集成汇编器进行分析，除非它被禁用 - 即使发出<code>.s</code>文件 - 也必须包含LLVM已知的汇编语法。</p>
<p>LLVM还支持一些有用的内联汇编代码：</p>
<ul>
<li><code>${:uid}</code>：扩展为这个内联汇编blob唯一的十进制整数。在声明本地标签时，这种替换很有用。许多标准的编译器优化（如内联）可能会复制内联asm blob。添加blob唯一标识符可确保这两个标签在装配过程中不会发生冲突。这用于实现<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">GCC的％=特殊格式字符串</a>。</li>
<li><code>${:comment}</code>：扩展为当前目标的汇编方言的注释字符。这通常是<code>#</code>，但很多指标使用其他字符串，例如<code>;</code>，<code>//</code>或<code>!</code>。</li>
<li><code>${:private}</code>：扩展为汇编器专用标签前缀。带有此前缀的标签不会出现在组装对象的符号表中。通常前缀是<code>L</code>，但目标可能使用其他字符串。<code>.L</code>是比较受欢迎的。</li>
</ul>
<p>LLVM对inline asm的支持与Clang的GCC兼容的inline-asm支持的要求紧密相关。因此，这里列出的特征集以及约束和修饰符代码与GCC内联asm支持中的代码类似或相同。然而，要清楚的是，这里描述的模板和约束字符串的语法与GCC和Clang所接受的语法并不相同，并且尽管大多数约束字母是通过Clang原样传递的，但当从C源代码转换为LLVM程序集时，有些字符会被转换为其他代码。</p>
<p>一个内联汇编表达式的例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i32 (i32) asm &quot;bswap $0&quot;, &quot;=r,r&quot;</span><br></pre></td></tr></table></figure></p>
<p>内联汇编程序表达式只能用作调用(call)或调用(invoke)指令的被调用者操作数。因此，通常我们有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%X = call i32 asm &quot;bswap $0&quot;, &quot;=r,r&quot;(i32 %Y)</span><br></pre></td></tr></table></figure></p>
<p>带有在约束列表中不可见的副作用的内联asms必须标记为具有副作用。这是通过使用’sideeffect’关键字完成的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下，内联asms将包含无法工作的代码，除非堆栈以某种方式对齐，例如x86上的调用或SSE指令，但不会包含在asm中执行对齐的代码。编译器应该对asm可能包含的内容做出保守的假设，并且如果’alignstack’关键字存在，应该在序言中生成其通常的堆栈对齐代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm alignstack &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>内联asms也支持使用非标准汇编方言。假定的方言是ATT。当’<code>inteldialect</code>‘关键字存在时，内联asm使用英特尔方言。目前，ATT和Intel是唯一支持的方言。一个例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm inteldialect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure></p>
<p>如果出现多个关键字，则’<code>sideeffect</code>‘关键字必须首先出现，’<code>alignstack</code>‘关键字第二关键字和’<code>inteldialect</code>‘关键字最后出现。</p>
<h3 id="内联汇编约束字符串"><a href="#内联汇编约束字符串" class="headerlink" title="内联汇编约束字符串"></a>内联汇编约束字符串</h3><p>约束列表是逗号分隔的字符串，每个元素包含一个或多个约束代码。</p>
<p>对于约束列表中的每个元素，将选择一个适当的寄存器或内存操作数，并且将对<code>$0</code>列表中的第一个约束，<code>$1</code>第二个等将使其可用于组件模板字符串扩展。</p>
<p>有三种不同类型的约束，它们通过约束代码前面的前缀符号进行区分：输出，输入和Clobber。必须始终按照以下顺序给出约束：先输出，然后输入，然后是clobbers。他们不能混在一起。</p>
<p>还有三种不同类型的约束代码：</p>
<ul>
<li>注册约束。这是一个寄存器类，或者是一个固定的物理寄存器。这种约束将分配一个寄存器，并且如果必要的话，将该参数或结果进行bitcast到适当的类型。</li>
<li>内存约束。这种约束用于获取内存操作数的指令。不同的约束允许目标使用不同的寻址模式。</li>
<li>立即值限制。这种约束是针对整数或其他立即值的，它可以直接渲染到指令中。各种特定于目标的约束条件允许为您希望使用的指令选择合适范围内的值。</li>
</ul>
<h4 id="输出约束"><a href="#输出约束" class="headerlink" title="输出约束"></a>输出约束</h4><p>输出约束由“<code>=</code>”前缀（例如“<code>=r</code>”）指定。这表示程序集将写入此操作数，然后操作数将作为asm表达式的返回值提供。输出约束不会消耗调用指令中的参数。（除了下面关于间接输出的内容）。</p>
<p>通常，在读取所有输入之前，预计没有输出位置被汇编表达式写入。因此，LLVM可以将相同的寄存器分配给输出和输入。如果这不安全（例如，如果程序集包含两条指令，其中第一条写入一个输出，第二条读取输入并写入第二条输出），则必须使用“<code>&amp;</code>”修饰符（例如“<code>=&amp;r</code>”）来指定输出是“早期破坏”输出。将输出标记为“<code>early-clobber</code>”可确保LLVM不会对任何输入（除了与此输出关联的输入）使用相同的寄存器。</p>
<h4 id="输入约束"><a href="#输入约束" class="headerlink" title="输入约束"></a>输入约束</h4><p><b style="color:green">输入约束没有前缀 - 只是约束代码。每个输入约束将从调用指令中消耗一个参数。asm不允许写入任何输入寄存器或存储单元（除非该输入连接到输出）。还要注意，如果LLVM可以确定它们必然都包含相同的值，则可以将多个输入全部分配给相同的寄存器。</b></p>
<p>通过提供一个整数作为约束字符串，输入约束可以将它们自己绑定到输出约束，而不是提供约束代码。被绑定的输入仍然会从调用指令中消耗一个参数，并且按照通常的方式在asm模板编号中占据一个位置 - 它们将被简单地限制为始终使用与其绑定的输出相同的寄存器。例如，一个约束字符串“<code>=r,0</code>”表示为输出分配一个寄存器，并将该寄存器用作输入（它是第<code>0</code>个约束）。</p>
<p>允许将输入连接到“早期破坏(early-clobber)”输出。在这种情况下，没有 其他输入可能与连接到早期触发器的输入共享相同的寄存器（即使其他输入具有相同的值）。</p>
<p>您只能将输入绑定到具有寄存器约束但不受内存约束的输出。只有一个输入可能与输出相关联。</p>
<p>还有一个“有趣”的特性，值得一点解释：如果寄存器类约束分配的寄存器对于作为输入提供的值类型操作数来说太小，则输入值将被分成多个寄存器，并且所有寄存器传递给内联asm。</p>
<p>但是，此功能通常不如您想象的那么有用。</p>
<p>首先，寄存器不保证连续。因此，在那些具有多条连续指令操作指令的体系结构上，这不是支持它们的适当方式。（例如，32位SparcV8具有64位加载，该指令只需要一个32位寄存器，然后硬件将加载到指定的寄存器和下一个寄存器中。内联asm的此功能对于此的支持将不会有用。）</p>
<p>几个目标提供了一个模板字符串修改，允许两寄存器操作数的第二个寄存器明确的访问（例如MIPS L，M和 D）。在这样的体系结构中，您实际上可以访问第二个已分配的寄存器（但是，仍然没有任何后续的寄存器）。但是，在这种情况下，为了清晰起见，将这个值简化为两个独立的操作数仍然可能更好。（例如，请参阅AX86 上的约束描述，尽管该特性仅用于此功能，但使用并不是一个好主意）</p>
<h4 id="间接投入和产出"><a href="#间接投入和产出" class="headerlink" title="间接投入和产出"></a>间接投入和产出</h4><p>间接输出或输入约束可以由“<code>*</code>”修饰符（在输出的情况下在“<code>=</code>”之后）指定。这表明asm将写入或读取作为输入参数提供的地址的内容。（注意，在这种方式，间接输出更像一个输入而不是输出：只是像输入，它们消耗的调用表达式的参数，而不是产生一个返回值。间接输出约束是“输出”仅是希望在asm可以写入输入内存位置的内容，而不是从中读取）。</p>
<p><b style="color:green">这通常用于内存约束，例如“<code>=*m</code>”，以将变量的地址作为值传递。</b></p>
<p>也可以使用间接寄存器约束，但仅限于输出（例如“<code>=*r</code>”）。这会导致LLVM正常地为输出值分配一个寄存器，然后在提供的内联asm之后，单独发送一个存储到作为输入提供的地址。（与在asm语句后明确写入store相比，此功能提供了什么值尚不清楚，而且它只能生成更糟糕的代码，因为它绕过了许多优化过程，我建议不要使用它。）</p>
<h4 id="Clobber约束"><a href="#Clobber约束" class="headerlink" title="Clobber约束"></a>Clobber约束</h4><p>一个clobber约束由一个“<code>~</code>”前缀表示。clobber不会消耗输入操作数，也不会生成输出。Clobbers不能使用任何一般的约束代码字母 - 它们可能只使用明确的寄存器约束，例如“<code>~{eax}</code>”。一个例外是，“<code>~{memory}</code>” 的clobber字符串表示程序集写入任意未声明的内存位置 - 不仅是由声明的间接输出指向的内存。</p>
<p>请注意，输出约束中也存在的clobbering命名寄存器是不合法的。</p>
<h4 id="约束代码"><a href="#约束代码" class="headerlink" title="约束代码"></a>约束代码</h4><p>潜在的前缀来了约束代码或代码之后。</p>
<p>约束代码可以是单个字母（例如“<code>r</code>”），“<code>^</code>”字符后跟两个字母（例如“<code>^wc</code>”）或“<code>{”寄存器名称“ }</code>”（例如“<code>{eax}</code>”）。</p>
<p>通常选择单字母和双字母约束代码与GCC的约束代码相同。</p>
<p>一个约束可能包含一个或多个约束代码，而让LLVM选择使用哪一个约束代码。这主要包括与来自clang的GCC inline asm的翻译兼容。</p>
<p>有两种方式可以指定替代方案，并且可以在内联asm约束列表中使用其中之一或两者。</p>
<ol>
<li>相互追加代码，制作约束代码集。例如“<code>im</code>”或“ <code>{eax}m</code>”。这意味着“选择集合中的任何选项”。对约束列表中的每个约束独立进行约束的选择。</li>
<li>在约束代码集之间使用“<code>|</code>”，创建替代方案。约束列表中的每个约束都必须具有相同数量的备选集。使用这种语法，约束列表中所有项目中的相同备选项将一起选择。</li>
</ol>
<p>把它们放在一起，你可能会有两个操作数约束字符串,像”<code>rm|r,ri|rm</code>“。这表明如果操作数0是r或m，则操作数1可以是r或i。如果操作数0是r，则操作数1可以是r或m。但是，操作数0和1不能都是m类型。</p>
<p>但是，不推荐使用其中任何一种替代功能，因为LLVM无法对使用哪种替代功能做出明智选择。（在当前需要选择的时候，没有足够的信息可以用聪明的方式来实现。）因此，它只是试图做出最有可能编译的选择，而不是最优性能的选择。（例如，给定“rm”，它总是选择使用内存，而不是寄存器）。而且，如果给定多个寄存器或多个寄存器类，它将简单地选择第一个。（实际上，目前它甚至不确保明确指定的物理寄存器是唯一的，因此指定多个物理寄存器作为替代，例如 {r11}{r12},{r11}{r12}，将r11分配给两个操作数，而不是所有打算的。）</p>
<h4 id="支持的约束代码列表"><a href="#支持的约束代码列表" class="headerlink" title="支持的约束代码列表"></a>支持的约束代码列表</h4><p>一般来说，约束代码的行为与GCC中的一样。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p>
<p>所有目标通常都支持一些约束代码：</p>
<ul>
<li>r：目标通用寄存器类中的寄存器。</li>
<li>m：存储器地址操作数。它支持哪些寻址模式，典型的例子是寄存器，寄存器+寄存器偏移量，或寄存器+直接偏移量（某些目标特定的大小）。</li>
<li>i：一个整数常量（目标特定宽度）。允许简单的即时或可重定位的值。</li>
<li>n：一个整数常量 - 不包括可重定位值。</li>
<li>s：一个整数常量，但只允许重定位值。</li>
<li>X：允许任何类型的操作数，不受任何限制。通常用于为asm分支或call传递标签。</li>
<li>{register-name}：需要完整的指定物理寄存器。</li>
</ul>
<p>其他约束是针对具体目标的：</p>
<p>AArch64：</p>
<ul>
<li>z：一个立即数整数0.输出WZR或者XZR视情况而定。</li>
<li>I：对一个ADD或SUB指令有效的立即整数，即0到4095，可选的移位12。</li>
<li>J：一个立即数，取反时对一个ADD或 SUB指令有效，即-1到-4095，可选左移12。</li>
<li>K：一个直接整数，它是有效的“位掩码即时32”的逻辑指令等AND，EOR或ORR与32位寄存器。</li>
<li>L：一个直接整数，它是有效的“位掩码即时64”的逻辑指令等AND，EOR或ORR与64位寄存器。</li>
<li>M：与MOV32位寄存器上的程序集别名一起使用的立即整数。这是一个超集K：除了bitmask立即数，还允许立即可以装载单个MOVZ或MOVL指令的整数 。</li>
<li>N：用于MOV64位寄存器上的程序集别名的立即整数。这是一个超集L。</li>
<li>Q：存储器地址操作数必须位于单个寄存器中（无偏移量）。（但是，LLVM目前也为m约束做了这个。）</li>
<li>r：32位或64位整数寄存器（W <em>或X </em>）。</li>
<li>w：一个32,64或128位浮点/ SIMD寄存器。</li>
<li>x：较低的128位浮点/ SIMD寄存器（V0至V15）。</li>
</ul>
<p>AMDGPU：</p>
<ul>
<li>r：32位或64位整数寄存器。</li>
<li>[0-9]v：32位VGPR寄存器，编号0-9。</li>
<li>[0-9]s：32位SGPR寄存器，编号0-9。</li>
</ul>
<p>所有ARM模式：</p>
<ul>
<li>Q，Um，Un，Uq，Us，Ut，Uv，Uy：内存地址的操作数。目前处理方式与操作数相同m。</li>
</ul>
<p>ARM和ARM的Thumb2模式：</p>
<ul>
<li>j：0到65535之间的一个立即数（有效MOVW）</li>
<li>I：对数据处理指令有效的立即整数。</li>
<li>J：一个介于-4095和4095之间的直接整数。</li>
<li>K：一个立即数，它的位反转对数据处理指令有效。（可以与模板修饰符“ B”一起使用以打印反转的值）。</li>
<li>L：一个立即整数，其否定对数据处理指令有效。（可以与模板修饰符“ n”一起使用以打印否定值）。</li>
<li>M：2的幂或0到32之间的整数。</li>
<li>N：无效的即时约束。</li>
<li>O：无效的即时约束。</li>
<li>r：一个通用的32位整数寄存器（r0-r15）。</li>
<li>l：在Thumb2模式下，低32位GPR寄存器（r0-r7）。在ARM模式下，与r。</li>
<li>h：在Thumb2模式下，一个高32位的GPR寄存器（r8-r15）。在ARM模式下，无效。</li>
<li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li>
<li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li>
<li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li>
</ul>
<p>ARM的Thumb1模式：</p>
<ul>
<li>I：0到255之间的立即数。</li>
<li>J：-255和-1之间的立即数。</li>
<li>K：0到255之间的直接整数，可选左移一定数量。</li>
<li>L：-7和7之间的立即数。</li>
<li>M：0到1020之间的整数，是4的倍数。</li>
<li>N：0到31之间的立即数。</li>
<li>O：在-508和508之间的立即数，是4的倍数。</li>
<li>r：一个低32位的GPR寄存器（r0-r7）。</li>
<li>l：一个低32位的GPR寄存器（r0-r7）。</li>
<li>h：高GPR寄存器（r0-r7）。</li>
<li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li>
<li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li>
<li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li>
</ul>
<p>Hexagon：</p>
<ul>
<li>o，v：此时存储器地址操作数，与约束一样对待m。</li>
<li>r：一个32位或64位寄存器。</li>
</ul>
<p>MSP430：</p>
<ul>
<li>r：一个8位或16位寄存器。</li>
</ul>
<p>MIPS：</p>
<ul>
<li>I：一个直接带符号的16位整数。</li>
<li>J：一个立即整数零。</li>
<li>K：一个直接无符号的16位整数。</li>
<li>L：一个直接的32位整数，其中低16位是0。</li>
<li>N：-65535和-1之间的立即数。</li>
<li>O：一个立即有符号的15位整数。</li>
<li>P：1到65535之间的立即数。</li>
<li>m：存储器地址操作数。在MIPS-SE模式下，允许一个基址寄存器加上16位立即数偏移量。在MIPS模式下，只需一个基址寄存器。</li>
<li>R：存储器地址操作数。在MIPS-SE模式下，允许一个基地址寄存器加上一个9位有符号偏移量。在MIPS模式下，与约束相同 m。</li>
<li>ZC：一个存储器地址操作数，适用于使用pref，ll或 sc在给定的子目标指令（细节有所不同）。</li>
<li>r，d， y：一个32位或64位GPR寄存器。</li>
<li>f：一个32位或64位FPU寄存器（F0-F31）或一个128位MSA寄存器（W0-W31）。在MSA寄存器的情况下，建议使用w 参数修饰符与GCC兼容。</li>
<li>c：适用于间接跳转（始终25）的32位或64位GPR寄存器 。</li>
<li>l：lo寄存器，32或64位。</li>
<li>x：无效。</li>
</ul>
<p>NVPTX：</p>
<ul>
<li>b：1位整数寄存器。</li>
<li>c或者h：一个16位整数寄存器。</li>
<li>r：一个32位整数寄存器。</li>
<li>l或者N：一个64位整数寄存器。</li>
<li>f：一个32位浮点寄存器。</li>
<li>d：一个64位的浮点寄存器。</li>
</ul>
<p>PowerPC的：</p>
<ul>
<li>I：一个直接带符号的16位整数。</li>
<li>J：直接无符号的16位整数，左移16位。</li>
<li>K：一个直接无符号的16位整数。</li>
<li>L：立即带符号的16位整数，左移16位。</li>
<li>M：大于31的立即数。</li>
<li>N：是2的精确幂的立即数。</li>
<li>O：立即整数常量0。</li>
<li>P：一个立即整型常量，其否定是一个有符号的16位常量。</li>
<li>es，o，Q，Z，Zy：一个存储器地址操作数，目前一样对待m。</li>
<li>r：32位或64位整数寄存器。</li>
<li>b：32位或64位整数寄存器，不包括R0（即 ：）R1-R31。</li>
<li>f：32位或64位浮点寄存器（F0-F31）或QPX使能时，128位或256位QPX寄存器（Q0-Q31;用于别名F寄存器）。</li>
<li>v：对于或类型，当启用QPX时，为128或256位QPX寄存器（），否则为128位altivec向量寄存器（）。4 x f324 x f64Q0-Q31V0-V31</li>
<li>y：条件寄存器（CR0-CR7）。</li>
<li>wc：CR寄存器中的单独CR位。</li>
<li>wa，wd，wf：任何128位VSX向量寄存器，从全VSX寄存器组（重叠两个浮点和向量寄存器文件）。</li>
<li>ws：来自完整的VSX寄存器组的32位或64位浮点寄存器。</li>
</ul>
<p>SPARC：</p>
<ul>
<li>I：一个立即的13位有符号整数。</li>
<li>r：一个32位整数寄存器。</li>
<li>f：SparcV8上的任何浮点寄存器或SparcV9上“低”一半寄存器中的浮点寄存器。</li>
<li>e：任何浮点寄存器。（与fSparcV8 相同。）</li>
</ul>
<p>SystemZ：</p>
<ul>
<li>I：直接无符号的8位整数。</li>
<li>J：直接无符号的12位整数。</li>
<li>K：一个直接带符号的16位整数。</li>
<li>L：一个直接签名的20位整数。</li>
<li>M：立即整数0x7fffffff。</li>
<li>Q：具有基地址和12位立即无符号位移的存储器地址操作数。</li>
<li>R：一个带有基地址的内存地址操作数，一个12位立即无符号位移和一个索引寄存器。</li>
<li>S：一个内存地址操作数，带有一个基址和一个20位立即带符号的位移。</li>
<li>T：一个带有基地址的内存地址操作数，一个20位立即带符号位移和一个索引寄存器。</li>
<li>r或者d：一个32位，64位或128位整数寄存器。</li>
<li>a：32,64或128位整数地址寄存器（不包括地址上下文中评估为0的R0）。</li>
<li>h：64位数据寄存器高位部分的32位值（LLVM专用）</li>
<li>f：一个32,64或128位浮点寄存器。</li>
</ul>
<p>X86：</p>
<ul>
<li>I：0到31之间的立即数。</li>
<li>J：0到64之间的立即数。</li>
<li>K：一个立即有符号的8位整数。</li>
<li>L：立即整数，0xff或0xffff或（仅在64位模式下）0xffffffff。</li>
<li>M：0到3之间的立即数。</li>
<li>N：直接无符号的8位整数。</li>
<li>O：0到127之间的立即数。</li>
<li>e：一个立即的32位有符号整数。</li>
<li>Z：一个立即的32位无符号整数。</li>
<li>o，v：目前处理方式与此相同m。</li>
<li>q：一个8,16,32或64位寄存器，可以作为8位 l整数寄存器访问。在X86-32，这是a，b，c，和d 寄存器，以及X86-64，它是所有的整数寄存器。</li>
<li>Q：一个8,16,32或64位寄存器，可以作为8位 h整数寄存器访问。这是a，b，c，和d寄存器。</li>
<li>r或者l：8,16,32或64位整数寄存器。</li>
<li>R：8,16,32或64位“传统”整数寄存器 - 自i386以来一直存在，并且可以在没有REX前缀的情况下访问。</li>
<li>f：一个32,64或80位’387 FPU堆栈伪寄存器。</li>
<li>y：如果启用MMX，则为64位MMX寄存器。</li>
<li>x：如果启用SSE：SSE寄存器中的32位或64位标量操作数或128位向量操作数。如果AVX也被使能，也可以是AVX寄存器中的256位向量操作数。如果AVX-512也被使能，也可以是AVX512寄存器中的512位向量操作数，否则会出错。</li>
<li>Y：同x，如果SSE2被启用，否则会出现错误。</li>
<li>A：特殊情况：首先为EAX分配EAX，然后再为EDX分配单个操作数（在32位模式下，64位整数操作数将分成两个寄存器）。不建议使用此约束，因为在64位模式下，64位操作数只会分配给RAX - 如果需要两个32位操作数，则最好在将其分配给它之前自行分割asm声明。</li>
</ul>
<p>XCore：</p>
<ul>
<li>r：一个32位整数寄存器。</li>
</ul>
<h3 id="Asm模板参数修饰符"><a href="#Asm模板参数修饰符" class="headerlink" title="Asm模板参数修饰符"></a>Asm模板参数修饰符</h3><p>在asm模板字符串中，可以在操作数引用上使用修饰符，如“<code>${0:n}</code>”。</p>
<p>一般来说，修饰符的行为与GCC中的相同。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p>
<p>目标无关的：</p>
<ul>
<li>c：不带目标特定的直接标点符号（例如无$前缀）打印一个立即的整数常量。</li>
<li>n：取消并打印立即数整数常量，不带目标特定的直接标点符号（例如无$前缀）。</li>
<li>l：打印为无标签的标签，没有特定于目标的标签标点（例如无$前缀）。</li>
</ul>
<p>AArch64：</p>
<ul>
<li>w：用w<em>名称而不是x</em>名称打印GPR寄存器。例如，而不是x30打印w30。</li>
<li>x：用x*名称打印GPR寄存器。（无论如何，这是默认的）。</li>
<li>b，h，s，d，q：打印浮点/ SIMD寄存器有 b<em>，h</em>，s<em>，d</em>，或q<em>名称，而不是默认的 v</em>。</li>
</ul>
<p>AMDGPU：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>ARM：</p>
<ul>
<li>a：打印操作数作为一个地址（[和]周围的寄存器）。</li>
<li>P： 没有效果。</li>
<li>q： 没有效果。</li>
<li>y：将VFP单精度寄存器作为索引双精度打印（例如打印d4[1]而不是s9）</li>
<li>B：按位反转并打印不带# 前缀的立即整数常量。</li>
<li>L：打印立即整数常量的低16位。</li>
<li>M：打印为适合ldm / stm的寄存器组。同时打印 指定的一个（！）后面的所有寄存器操作数，请谨慎使用。</li>
<li>Q：打印寄存器对的低位寄存器或双寄存器操作数的低位寄存器。</li>
<li>R：打印寄存器对的高位寄存器或双寄存器操作数的高位寄存器。</li>
<li>H：打印寄存器对的第二个寄存器。（在大端系统上， H相当于Q小端系统，H相当于R。）</li>
<li>e：打印NEON四路寄存器的低双字寄存器。</li>
<li>f：打印NEON四路寄存器的高位双字寄存器。</li>
<li>m：打印没有[和] 装饰的内存操作数的基址寄存器。</li>
</ul>
<p>Hexagon：</p>
<ul>
<li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li>
<li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li>
</ul>
<p>MSP430：</p>
<ul>
<li>没有额外的修饰符。</li>
</ul>
<p>MIPS：</p>
<ul>
<li>X：以十六进制形式打印一个立即数</li>
<li>x：以十六进制形式打印立即数的低16位。</li>
<li>d：以小数形式打印一个立即数。</li>
<li>m：减去一个并以十进制形式打印一个立即数。</li>
<li>z：如果立即为零，则打印$ 0，否则正常打印。</li>
<li>L：打印双寄存器操作数的低位寄存器，或打印双字存储器操作数的低位字的地址。</li>
<li>M：打印双寄存器操作数的高位寄存器，或者打印双字存储器操作数的高位字的地址。</li>
<li>D：打印双寄存器操作数的第二个寄存器，或打印双字存储器操作数的第二个字。（在大端系统上，D相当于L小端系统，D相当于 M。）</li>
<li>w： 没有效果。为了与需要此修饰符的GCC兼容才能打印W0-W31具有f 约束条件的MSA寄存器（）。</li>
</ul>
<p>NVPTX：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>PowerPC的：</p>
<ul>
<li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li>
<li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li>
<li>y：对于内存操作数，打印双寄存器X-form指令的格式化程序。（目前始终打印r0,OPERAND）。</li>
<li>U：如果内存操作数是更新形式，则打印’u’，否则不打印。（注意：LLVM不支持更新表单，所以它现在总是不会打印任何内容）</li>
<li>X：如果内存操作数是索引形式，则打印’x’。（注意：LLVM不支持索引形式，所以目前这总是不会打印任何东西）</li>
</ul>
<p>SPARC：</p>
<ul>
<li>r： 没有效果。</li>
</ul>
<p>SystemZ：</p>
<ul>
<li>SystemZ仅实现n，并且也不会支持任何其他目标无关的改性剂。</li>
</ul>
<p>X86：</p>
<ul>
<li>c：打印一个无用的整数或符号名称。（后者是这个典型的与目标无关的修饰符的目标特定行为）。</li>
<li>A：*在它之前用一个“ ‘ 打印一个注册名称。</li>
<li>b：打印一个8位寄存器名称（例如al）; 内存操作数不做任何事情。</li>
<li>h：打印上面的8位寄存器名称（例如ah）; 内存操作数不做任何事情。</li>
<li>w：打印16位寄存器名称（例如ax）; 内存操作数不做任何事情。</li>
<li>k：打印32位寄存器名称（例如eax）; 内存操作数不做任何事情。</li>
<li>q：打印64位寄存器名称（例如rax），如果64位寄存器可用，则返回32位寄存器名称; 内存操作数不做任何事情。</li>
<li>n：取反并打印一个未修饰的整数，或者，对于非立即整数的操作数（例如可重定位符号表达式），在操作数前面打印一个’ - ‘。（可重定位符号表达式的行为是针对此通常与目标无关的修饰符的目标特定行为）</li>
<li>H：用额外的偏移量+8打印存储器引用。</li>
<li>P：打印内存引用或操作数以用作调用指令的参数。（例如(rip)，即使它是PC相对的，也省略。）</li>
</ul>
<p>XCore：</p>
<ul>
<li>没有额外的修饰符。</li>
</ul>
<h3 id="内联Asm元数据"><a href="#内联Asm元数据" class="headerlink" title="内联Asm元数据"></a>内联Asm元数据</h3><p>包装内联asm节点的调用指令可能会附加一个“<code>!srcloc</code>”MDNode，它包含一个常量整数列表。如果存在，则当通过LLVMContext 错误报告机制报告错误时，代码生成器将使用该整数作为位置cookie值。这允许前端将内联asm中发生的后端错误与产生它的源代码关联起来。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;something bad&quot;, &quot;&quot;(), !srcloc !42</span><br><span class="line">...</span><br><span class="line">!42 = !&#123; i32 1234567 &#125;</span><br></pre></td></tr></table></figure></p>
<p>直到前端才能理解它在IR中的神奇数字。如果MDNode包含多个常量，则代码生成器将使用与发生错误的asm行相对应的那个常量。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/12/编译原理/LLVM语言参考手册(开始至高级结构)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/编译原理/LLVM语言参考手册(开始至高级结构)/" itemprop="url">LLVM语言参考手册(开始至高级结构)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T17:38:40+08:00">2018-04-12</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文档是LLVM汇编语言的参考手册。LLVM是一种基于<a href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F" target="_blank" rel="noopener">静态单赋值</a>（SSA）的表现形式的语言。它提供类型安全、底层指令、灵活性以及干净地表示“所有”高级语言的能力。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><b style="color:green">LLVM代码表示被设计为以三种不同的形式使用：作为内存中编译器IR（中间码），作为磁盘上的位代码表示（适用于即时编译器进行快速加载）以及作为人可读汇编语言表达。这允许LLVM为有效的编译器的转换和分析提供强大的中间表示，同时提供调试和可视化转换的自然方式。LLVM的三种不同形式都是等价的。本文档描述了人类可读的表示形式和符号。</b></p>
<p>LLVM表示旨在轻量级和低级别，同时具有表现力，类型化和可扩展性。它的目标是成为一种“通用的IR”，通过处于足够低的水平，可以将高层次的想法清晰地映射到它（类似于微处理器是“通用IR”），允许将许多源语言映射到它们）。通过提供类型信息，LLVM可以用作优化的目标：例如，通过指针分析，可以证明C自动变量从不在当前函数之外访问，从而允许将它提升为简单的SSA值而不是一个内存位置。</p>
<h2 id="良好的格式"><a href="#良好的格式" class="headerlink" title="良好的格式"></a>良好的格式</h2><p>重要的是要注意，本文档描述了“良好格式”的LLVM汇编语言。 解析器接受什么和被认为是“良好格式”之间是有区别。例如，下面的指令在语法上没问题，但不是良好形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%x = add i32 1, %x</span><br></pre></td></tr></table></figure></p>
<p>因为<code>％x</code>的定义并不控制它的所有用途。 LLVM基础架构提供了一个验证过程，可用于验证LLVM模块是否格式良好。在解析输入的汇编程序之后和优化程序在输出bitcode之前，该过程由解析器自动运行。验证程序验证过程中指出的违规暗示转换过程中的错误或输入到解析器中的错误。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>LLVM标识符有两种基本类型：全局和本地。全局标识符（函数，全局变量）以<code>&#39;@&#39;</code>字符开头。本地标识符（寄存器名称，类型）以<code>&#39;%&#39;</code>字符开头 。此外，有三种不同的标识符格式，用于不同的目的：</p>
<ol>
<li>命名值用一串字符和前缀表示。例如<code>%foo</code>，<code>@DivisionByZero</code>， <code>%a.really.long.identifier</code>。实际使用的正则表达式是 <code>&#39;[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*&#39;</code>。在名称中需要其他字符的标识符可以用引号包裹起来。通过使用<code>&quot;\xx&quot;</code>，特殊字符可以被转义，<code>xx</code>是ASCII代码的十六进制字符的表示。这样，任何字符都可以用于名称值，甚至可以引用它们自己。全局变量可以使用前缀”\01”来阻止截断。</li>
<li>未命名的值用前缀表示为无符号数值。例如<code>%12</code>，<code>@2</code>，<code>%44</code>。</li>
<li>常量，在下面的<a href="http://llvm.org/docs/LangRef.html#constants" target="_blank" rel="noopener">常量</a>章节中进行了介绍。</li>
</ol>
<p>LLVM要求值以一个前缀开始，原因有两个：编译器不需要担心名称与保留字的冲突，并且保留字的集合可能在将来被扩展而不会产生什么不利。此外，未命名标识符允许编译器快速创建临时变量，而不必设法避免符号表冲突。</p>
<p>LLVM中的保留字与其他语言中的保留字非常相似。对于不同的操作码（<code>&#39;add&#39;</code>，<code>&#39;bitcast&#39;</code>，<code>&#39;ret&#39;</code>等等），对于原始类型名称（<code>&#39;void&#39;</code>，<code>&#39;i32&#39;</code>等等），以及其他的关键字。这些保留字不能与变量名冲突，因为它们都没有以前缀字符（<code>&#39;%&#39;</code>或<code>&#39;@&#39;</code>）开始。</p>
<p>以下是将整数变量“%X’乘以8的LLVM代码示例：<br>简单的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = mul i32 %X, 8</span><br></pre></td></tr></table></figure></p>
<p>减少强度之后（也是最推荐的方式）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = shl i32 %X, 3</span><br></pre></td></tr></table></figure></p>
<p>最复杂的方式是(很有意思)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = add i32 %X, %X           ; yields i32:%0</span><br><span class="line">%1 = add i32 %0, %0           ; yields i32:%1</span><br><span class="line">%result = add i32 %1, %1</span><br></pre></td></tr></table></figure></p>
<p><code>%X</code>乘以8的最后一种方式说明了LLVM的几个重要的词法特征：</p>
<ol>
<li>注释用分号<code>&#39;;&#39;</code>分隔，直到行尾。</li>
<li>当计算结果未分配给指定命名值时，将创建未命名的临时对象。</li>
<li>未命名的临时对象按序号进行编号（使用预处理函数递增计数器，从0开始）。<b style="color:green">请注意，此编号中包含基本块和未命名的函数参数。例如，如果基本块入口没有给出标签名称并且所有函数参数都被命名，则它将得到编号0。</b></li>
</ol>
<p>它也显示了我们在本文件中遵循的惯例。在展示说明时，我们将按照说明书的注释来说明所产生值的类型和名称。</p>
<h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>LLVM程序由<code>Module&#39;s</code>组成，每个模块都是输入程序的翻译单元。每个模块由函数，全局变量和符号表入口（symbol table entries）组成。模块可以与LLVM链接器组合在一起，LLVM链接器合并函数（和全局变量）定义，解析前置声明并合并符号表入口。以下是“hello world”模块的示例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Declare the string constant as a global constant.</span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; External declaration of the puts function</span></span><br><span class="line"><span class="comment">declare i32 @puts(i8* nocapture) nounwind</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Definition of main function</span></span><br><span class="line"><span class="comment">define i32 @main() &#123;   ; i32()*</span></span><br><span class="line"><span class="comment">  ; Convert [13 x i8]* to i8*...</span></span><br><span class="line"><span class="comment">  %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ; Call puts function to write out the string to stdout.</span></span><br><span class="line"><span class="comment">  call i32 @puts(i8* %cast210)</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Named metadata</span></span><br><span class="line"><span class="comment">!0 = !&#123;i32 42, null, !"string"&#125;</span></span><br><span class="line"><span class="comment">!foo = !&#123;!0&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子由一个名为<code>.str</code>的<a href="http://llvm.org/docs/LangRef.html#globalvars" target="_blank" rel="noopener">全局变量</a>，<code>“puts”</code>函数的外部声明，<code>&quot;main&quot;</code>的<a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数定义</a>和<code>”foo“</code>的<a href="http://llvm.org/docs/LangRef.html#namedmetadatastructure" target="_blank" rel="noopener">命名元数据</a>组成。</p>
<p><b style="color:green">通常，模块由全局值列表组成（其中函数和全局变量都是全局值）。全局值由指向内存位置的指针表示（在本例中，指向char数组的指针和指向函数的指针），并且具有以下<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>之一。</b></p>
<h3 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a><a href="https://msdn.microsoft.com/zh-cn/library/0yw6at8e.aspx" target="_blank" rel="noopener">链接类型</a></h3><p>所有全局变量和函数都具有以下链接类型之一：</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>具有<code>“private”</code>连接的全局值只能由当前模块中的对象直接访问。特别是，将代码链接到具有private全局值的模块中可能会导致private变量重新命名以避免冲突。由于符号对模块是私有的，因此所有引用都可以更新。这不会在对象文件的任何符号表中显示。</p>
<h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>与私有类似，但该值在对象文件中显示为本地符号（STB_LOCAL在ELF的情况下）。这就像<code>C</code>中的<code>&#39;static&#39;</code>关键字。</p>
<h4 id="available-externally"><a href="#available-externally" class="headerlink" title="available_externally"></a>available_externally</h4><p>具有<code>“available_externally”</code>链接的全局程序永远不会被发送到对应于LLVM模块的目标文件中。从链接器的角度来看，<code>available_externally</code>全局相当于external声明。它们的存在是为了允许内联和其他优化在知道全局变量（函数或语句块）的定义的情况下发生，这被称为模块之外的某个地方。具有<code>available_externally</code>链接的全局值可以随意丢弃，并允许内联和其他优化。这种连接类型只允许定义，而不允许声明。</p>
<h4 id="linkonce"><a href="#linkonce" class="headerlink" title="linkonce"></a>linkonce</h4><p><code>linkonce</code>连接的全局值在链接发生时，可以与其他同名的全局值合。这可以用来实现某些形式的内联函数，模板（templates）或其他代码，这些代码必须在使用它的每个翻译单元中生成，但是稍后可能会在更明确的定义中覆盖正文。未引用的<code>linkonce</code>全局变量允许被丢弃。请注意，<code>linkonce</code>链接实际上并不允许优化器将此函数的主体内联到调用者中，因为它不知道该函数的定义是否是程序中的权威定义，或者是否会被更强的定义覆盖。要启用内联和其他优化器，请使用<code>“linkonce_odr”</code>链接。</p>
<h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><p><code>“weak”</code>链接具有与<code>linkonce</code>链接相同的合并语义，除了未引用<code>weak</code>链接的全局可能不会被丢弃。这用于在C源代码中声明为<a href="http://www.cnblogs.com/hgfrzh/p/4064098.html" target="_blank" rel="noopener"><code>weak</code></a>的全局变量。</p>
<h4 id="common"><a href="#common" class="headerlink" title="common"></a>common</h4><p><code>common</code>连接与<code>weak</code>连接最为相似，但它们用于C中的临时定义，例如：全局作用域的<code>int x</code>。带有<code>common</code>连接的符号与<code>weak</code>是相同的方式合并；如果未引用<code>common</code>符号，它们可能不会被删除。<code>common</code>符号可能没有明确的部分，必须具有零初始化器，并且可能未被标记为“<code>constant</code>”。函数和别名可能没有共同的连接。</p>
<h4 id="appending"><a href="#appending" class="headerlink" title="appending"></a>appending</h4><p>“<code>appending</code>”链接可能只适用于指向数组类型的全局变量。当两个具有appending链接的全局变量链接在一起时，这两个全局数组被附加在一起。这是LLVM类型安全的，当<code>.o</code>文件被链接时，系统链接器将具有相同的名称的<code>“sections”</code>附加在一起。</p>
<p>不幸的是，这不符合<code>.o</code>文件中的任何特性，所以它只能用于像<code>llvm.global_ctors</code>的变量，<code>llvm</code>专门解释这样的变量。</p>
<h4 id="extern-weak"><a href="#extern-weak" class="headerlink" title="extern_weak"></a>extern_weak</h4><p>这个链接的语义遵循<code>ELF</code>目标文件模型：符号在链接之前是弱的，如果不链接，符号变为空，而不是未定义的引用。</p>
<h4 id="linkonce-odr，-weak-odr"><a href="#linkonce-odr，-weak-odr" class="headerlink" title="linkonce_odr， weak_odr"></a><code>linkonce_odr</code>， <code>weak_odr</code></h4><p>有些语言允许合并不同的全局变量，比如两个具有不同语义的函数。其他语言，例如C++，确保只有等效的全局变量被合并（“一个定义规则(one definition rule)” - “ODR”）。这些语言可以使用<code>linkonce_odr</code>和<code>weak_odr</code>连接类型来表示全局将仅与等效的全局变量合并。对于其他不支持<code>ODR</code>的语言，这些链接类型与其<code>非odr</code>的链接相同。</p>
<h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>如果没有使用上述标识符，则全局变量是外部可见的，这意味着它参与链接并可用于解析外部符号引用。</p>
<p><b style="color:red">对于函数声明，除<code>external</code>或<code>extern_weak</code>之外的任何链接类型都是非法的。</b></p>
<h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">调用约定</a></h3><p>LLVM<a href="http://llvm.org/docs/LangRef.html#functionstructure" target="_blank" rel="noopener">函数(functions)</a>，<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener">调用(calls)</a>和 <a href="http://llvm.org/docs/LangRef.html#i-invoke" target="_blank" rel="noopener">调用(invokes)</a>都可以为该调用指定一个可选的调用约定。任何一对动态<code>调用者(caller)/被调用者(callee)</code>的调用约定都必须匹配，否则程序的行为是未定义的。<b style="color:green">LLVM支持以下调用约定，未来还可能添加更多调用约定：</b></p>
<h4 id="ccc-C调用约定"><a href="#ccc-C调用约定" class="headerlink" title="ccc - C调用约定"></a><code>ccc</code> - <a href="https://blog.csdn.net/fly2k5/article/details/544112" target="_blank" rel="noopener">C调用约定</a></h4><p>这个调用约定（如果没有指定其他调用约定，则默认是这个调用约定）匹配目标C调用约定。这个调用约定支持可变参数函数调用，并且允许在声明的原型和实现的函数声明中存在一些不匹配（就像普通的C一样）。</p>
<h4 id="“fastcc”-快速调用约定"><a href="#“fastcc”-快速调用约定" class="headerlink" title="“fastcc” - 快速调用约定"></a>“<code>fastcc</code>” - 快速调用约定</h4><p>这个调用约定试图尽可能快地进行调用（例如通过在寄存器中传递参数）。这个调用约定允许目标使用任何想要为目标生成快速代码的技巧，而不必遵守外部指定的<code>ABI</code>（应用程序二进制接口）。<a href="http://llvm.org/docs/CodeGenerator.html#id80" target="_blank" rel="noopener">只有在使用此调用约定、<code>GHC</code>调用约定或<code>HiPE</code>调用约定时，才能<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener"><b style="color:red">优化尾部调用</b></a></a>。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。</p>
<h4 id="“coldcc”-冷调用约定"><a href="#“coldcc”-冷调用约定" class="headerlink" title="“coldcc” - 冷调用约定"></a>“<code>coldcc</code>” - 冷调用约定</h4><p>这个调用约定尝试在调用不是共同执行的条件下尽可能高效地在调用者中编写代码。因此，这些调用通常会保留所有的寄存器，以便调用不会破坏调用方的任何实时范围（live range）。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。此外，内联器不考虑这种内联函数调用。</p>
<h4 id="“cc-10”-GHC约定"><a href="#“cc-10”-GHC约定" class="headerlink" title="“cc 10” - GHC约定"></a>“<code>cc 10</code>” - <code>GHC</code>约定</h4><p>这个调用约定专门供<a href="http://www.haskell.org/ghc" target="_blank" rel="noopener">格拉斯哥Haskell编译器（GHC）</a>使用。它在寄存器中的传递所有内容，通过禁用被调用者保存寄存器来达到极限。这种调用约定不应该被轻率使用，而只能用于特定情况下，例如替代实现函数式编程语言时经常使用的寄存器锁定性能技术。目前只有X86支持这种约定，它有以下限制：</p>
<ul>
<li>在X86-32上最多只支持4位类型参数。不支持浮点类型。</li>
<li>在X86-64上最多只支持10位类型参数和6个浮点参数。</li>
</ul>
<p>这种调用约定支持<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾部调用优化</a>，但要求主调方和被调方都在使用它。</p>
<h4 id="“cc-11”-HiPE调用约定"><a href="#“cc-11”-HiPE调用约定" class="headerlink" title="“cc 11” - HiPE调用约定"></a>“<code>cc 11</code>” - <code>HiPE</code>调用约定</h4><p>该调用约定专门用于<a href="http://www.it.uu.se/research/group/hipe/" target="_blank" rel="noopener">高性能Erlang（HiPE）</a>编译器，即<a href="http://www.erlang.org/download.shtml" target="_blank" rel="noopener">爱立信开源Erlang/OTP系统</a>的本地代码编译器。它比通常的C调用约定使用更多的寄存器进行参数传递，并且不定义被调者使用的保存寄存器。调用约定正确支持<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾部调用优化</a>，但要求调用者和被调用者都使用它。它使用寄存器固定机制，与<code>GHC</code>调用约定类似，用于将频繁访问的运行时组件固定到特定的硬件寄存器。目前只有X86支持这种约定（32位和64位）。</p>
<h4 id="“webkit-jscc”-WebKit的JavaScript调用约定"><a href="#“webkit-jscc”-WebKit的JavaScript调用约定" class="headerlink" title="“webkit_jscc” - WebKit的JavaScript调用约定"></a>“<code>webkit_jscc</code>” - WebKit的JavaScript调用约定</h4><p>此调用约定已针对<a href="https://trac.webkit.org/wiki/FTLJIT" target="_blank" rel="noopener">WebKit FTL JIT</a>实施。它将堆栈上的参数从右向左传递（如<code>cdecl</code>那样），并在平台的惯用返回寄存器中返回一个值。</p>
<h4 id="“anyregcc”-代码修补的动态调用约定"><a href="#“anyregcc”-代码修补的动态调用约定" class="headerlink" title="“anyregcc” - 代码修补的动态调用约定"></a>“<code>anyregcc</code>” - 代码修补的动态调用约定</h4><p>这是一个特殊的约定，它支持在调用点增补任意代码序列。这个约定强制调用参数进入寄存器，但允许它们动态分配。目前只能用于调用<code>llvm.experimental.patchpoint</code>，因为只有这个内部函数将其参数的位置记录在旁边表中。请参阅<a href="http://llvm.org/docs/StackMaps.html" target="_blank" rel="noopener">LLVM中的堆栈映射和修补程序点</a>。</p>
<h4 id="“preserve-mostcc”-PreserveMost调用约定"><a href="#“preserve-mostcc”-PreserveMost调用约定" class="headerlink" title="“preserve_mostcc” - PreserveMost调用约定"></a>“<code>preserve_mostcc</code>” - <code>PreserveMost</code>调用约定</h4><p>此调用约定会尽可能使调用方中的代码尽可能是非侵入性的。该约定的行为与C 调用约定的参数和返回值的传递方式相同，但它使用了一组不同的调用方/被调用方保存的寄存器。<b style="color:green">这减轻了在调用者调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</b></p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。浮点寄存器（<code>XMMs/YMMs</code>）不会保留，需要由调用者保存。</li>
</ul>
<p>这个约定背后的想法是支持对具有热路径和冷路径的运行时（Runtime）函数调用。<b style="color:green">热路径通常是一小段不使用多个寄存器的代码。冷路径可能需要调用另一个函数，因此只需要保留调用者保存的寄存器，这些寄存器还未被调用者保存</b>。就调用者/被调用者保存的寄存器方面，<code>PreserveMost</code>调用约定是与冷（cold）调用约定非常相似的，但它们用于不同类型的函数调用。<code>coldcc</code>适用于很少执行的函数调用，而<code>preserve_mostcc</code>函数调用旨在处于热路径上，并且相对执行更多一些。此外<code>preserve_mostcc</code>不会阻止内联器的内联函数调用。</p>
<p>这个调用约定将被未来版本的ObjectiveC运行时使用，因此此时应该仍被认为是实验性的。虽然此惯例是为了优化对ObjectiveC运行时的某些运行时调用而创建的，但它并不局限于此运行时，并且在将来也可能会被其他运行时使用。目前的实现只支持X86-64，但其目的是在未来支持更多架构。</p>
<h4 id="“preserve-allcc”-PreserveAll调用约定"><a href="#“preserve-allcc”-PreserveAll调用约定" class="headerlink" title="“preserve_allcc” - PreserveAll调用约定"></a>“<code>preserve_allcc</code>” - <code>PreserveAll</code>调用约定</h4><p>此调用约定会尝试使调用方中的代码比<code>PreserveMost</code>调用约定更不具侵入性。此调用约定的行为与C调用约定的参数和返回值的传递方式相同，但它使用一组不同的调用方/被调用方保存的寄存器。这消除了在调用者的调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。此外，它还保留所有浮点寄存器（<code>XMM/YMM</code>）。</li>
</ul>
<p>这个约定背后的想法是支持对不需要调用任何其他函数的运行时(Runtime)函数的调用。</p>
<p>此调用约定与<code>PreserveMost</code>调用约定一样，将被未来版本的ObjectiveC运行时使用，此时应视为实验性的。</p>
<h4 id="“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定"><a href="#“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定" class="headerlink" title="“cxx_fast_tlscc” - 访问函数的CXX_FAST_TLS调用约定"></a>“<code>cxx_fast_tlscc</code>” - 访问函数的<code>CXX_FAST_TLS</code>调用约定</h4><p>Clang生成一个访问函数来访问C++风格的TLS。访问函数通常有一个入口块，一个出口块和一个初次运行的初始化块。入口和出口块可以访问一些TLS IR变量，每个访问将被降低到平台特定的序列。</p>
<p>此调用约定旨在通过保留尽可能多的寄存器（所有寄存器保存在快速路径中，由入口和出口块组成）来尽量减少调用者的开销。</p>
<p>这个调用约定的行为与C调用约定在参数和返回值的传递方式上是一样的，但它使用了一组不同的调用者/被调用者保存的寄存器。</p>
<p>鉴于每个平台都有自己的降序序列，因此它有自己的一组保存的寄存器，所以我们不能使用现有的<code>PreserveMost</code>。</p>
<ul>
<li>在X86-64上，被调用方保存所有通用寄存器，<code>RDI</code>和<code>RAX</code>除外。</li>
</ul>
<h4 id="“swiftcc”-这个调用约定用于Swift语言。"><a href="#“swiftcc”-这个调用约定用于Swift语言。" class="headerlink" title="“swiftcc” - 这个调用约定用于Swift语言。"></a>“<code>swiftcc</code>” - 这个调用约定用于Swift语言。</h4><ul>
<li>在X86-64上，<code>RCX</code>和<code>R8</code>可用于额外的整数返回，并且<code>XMM2</code>和<code>XMM3</code>可用于其他<code>FP/vector</code>返回。</li>
<li>在iOS平台上，我们使用<code>AAPCS-VFP</code>调用约定。<br>“<code>cc &lt;n&gt;</code>” - 编号调用约定<br>任何调用约定都可以用数字指定，从而允许使用特定于目标的调用约定。目标特定调用约定从64开始。</li>
</ul>
<p>可以根据需要添加/定义更多调用约定，以支持<code>Pascal</code>约定或任何其他众所周知的目标独立的调用约定。</p>
<h3 id="可见性风格"><a href="#可见性风格" class="headerlink" title="可见性风格"></a>可见性风格</h3><p>所有全局变量和函数都具有以下可见性样式之一：</p>
<h4 id="“default”-默认风格"><a href="#“default”-默认风格" class="headerlink" title="“default” - 默认风格"></a>“<code>default</code>” - 默认风格</h4><p>在使用<a href="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html" target="_blank" rel="noopener">ELF（Executable and Linking Format,可执行文件）</a>对象文件格式的目标上，默认可见性意味着该声明对其他模块可见，并且在共享库中，意味着声明的实体可能被覆盖。在Darwin上，default可见性意味着该声明对其他模块可见。default可见性对应于语言中的“外部链接”。</p>
<h4 id="“hidden”-隐藏的风格"><a href="#“hidden”-隐藏的风格" class="headerlink" title="“hidden” - 隐藏的风格"></a>“<code>hidden</code>” - 隐藏的风格</h4><p>具有隐藏可见性的对象的两个声明指向同一个对象，如果它们在同一个共享对象中。通常，隐藏的可见性表示该符号不会被放入动态符号表中，因此其他模块（可执行文件或共享库）不能直接引用它。</p>
<h4 id="“protected”-受保护的风格"><a href="#“protected”-受保护的风格" class="headerlink" title="“protected” - 受保护的风格"></a>“<code>protected</code>” - 受保护的风格</h4><p>在<a href="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html" target="_blank" rel="noopener">ELF</a>上，protected可见性表示该符号将被放置在动态符号表中，但定义的模块内的引用将绑定到本地符号。也就是说，该符号不能被另一个模块覆盖。</p>
<p>带有<code>internal</code>或<code>private</code>链接类型的符号必须具有<code>default</code>可见性。</p>
<h3 id="DLL存储类"><a href="#DLL存储类" class="headerlink" title="DLL存储类"></a>DLL<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B1%BB/10420072" target="_blank" rel="noopener">存储类</a></h3><p>所有全局变量，函数和别名都可以具有以下DLL存储类之一：</p>
<h4 id="dllimport"><a href="#dllimport" class="headerlink" title="dllimport"></a><a href="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx" target="_blank" rel="noopener"><code>dllimport</code></a></h4><p>“<code>dllimport</code>”会导致编译器通过全局指针引用函数或变量，该全局指针指向由导出符号的DLL设置的指针。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。</p>
<h4 id="dllexport"><a href="#dllexport" class="headerlink" title="dllexport"></a><a href="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx" target="_blank" rel="noopener"><code>dllexport</code></a></h4><p>“<code>dllexport</code>”会导致编译器提供一个指向DLL中的指针的全局指针，以便它可以引用<code>dllimport</code>属性。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。由于这个存储类是为了定义dll接口而存在，因此编译器，汇编器和链接器知道它是从外部引用的，并且不会删除该符号。</p>
<p>其实这个指令是用来加载动态链接库，相关的信息可以查看：<a href="https://stackoverflow.com/questions/3586023/dllimport-doesnt-work-as-advertised-in-mono-linux-c" target="_blank" rel="noopener">DllImport doesn’t work as advertised in Mono (Linux, C#)</a></p>
<h3 id="线程局部存储-TLS-模型"><a href="#线程局部存储-TLS-模型" class="headerlink" title="线程局部存储(TLS)模型"></a>线程局部存储(TLS)模型</h3><p><b style="color:green">一个变量可以被定义为<a href="http://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener"><code>thread_local</code></a>，这意味着它不会被线程共享（每个线程将有一个变量的分离副本）</b>。并非所有的目标机都支持线程局部变量。可选地，可以指定<a href="https://docs.oracle.com/cd/E19253-01/819-7050/6n918j8o0/index.html" target="_blank" rel="noopener">TLS模型</a>：</p>
<ul>
<li><code>localdynamic</code>: 对于仅在当前共享库中使用的变量。</li>
<li><code>initialexec</code>: 对于模块中不会动态加载的变量。</li>
<li><code>localexec</code>: 对于在可执行文件中定义的变量，只能在其中使用。</li>
</ul>
<p>如果没有给出显式模型，则使用“general dynamic”模型。</p>
<p>这些模型对应于ELF TLS模型; 请参阅<a href="http://people.redhat.com/drepper/tls.pdf" target="_blank" rel="noopener">ELF对thread_local存储的处理</a>获取更多信息，在这篇文章中提到的不同的场景下可能使用不同的模型。如果指定的TLS模型不受支持，或者可以选择一个更好的模型，则目标机可能会选择不同的TLS模型。</p>
<p>模型也可以在别名中指定，但它只能控制别名的访问方式。这对使用别名的地方不会有任何影响。</p>
<p>对于没有ELF TLS模型链接器支持的平台，<code>-femulated-tls</code>标志可用于生成GCC兼容的模拟TLS代码。</p>
<h3 id="运行时抢占说明"><a href="#运行时抢占说明" class="headerlink" title="运行时抢占说明"></a>运行时抢占说明</h3><p>全局变量，函数和别名可以有一个可选的运行时抢占说明符。如果没有明确给出抢先说明符，则假定符号是<code>dso_preemptable</code>。</p>
<h4 id="dso-preemptable"><a href="#dso-preemptable" class="headerlink" title="dso_preemptable"></a><code>dso_preemptable</code></h4><p>表示在运行时，可以用链接单元外部的符号替换该函数或变量。</p>
<h4 id="dso-local"><a href="#dso-local" class="headerlink" title="dso_local"></a><code>dso_local</code></h4><p>编译器可以假定标记为<code>dso_local</code>的函数或变量将解析为相同链接单元中的符号。即使定义不在此编译单元中，也会生成直接访问。</p>
<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>LLVM IR（中间码）允许您指定“可识别（identified）”和“文字（Literal）”<a href="http://llvm.org/docs/LangRef.html#t-struct" target="_blank" rel="noopener">结构类型</a>。文字类型在结构上是独一无二的，但是identified类型从来都不是独一无二的。一个<a href="http://llvm.org/docs/LangRef.html#t-opaque" target="_blank" rel="noopener">不透明的结构类型</a>也可以用来向前声明一个还不能使用的类型。</p>
<p>identified（可识别的）结构规范的一个例子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mytype = type &#123; %mytype*, i32 &#125;</span><br></pre></td></tr></table></figure></p>
<p>在LLVM 3.0发布之前，identified类型在结构上是独一无二的。在最新版本的LLVM中，只有文字类型是唯一的。</p>
<h3 id="非整型指针类型"><a href="#非整型指针类型" class="headerlink" title="非整型指针类型"></a>非整型指针类型</h3><p>注意：非整型指针类型是正在进行的工作，并且此时它们应该被认为是实验性的。</p>
<p>LLVM IR可选地允许前端通过<a href="http://llvm.org/docs/LangRef.html#langref-datalayout" target="_blank" rel="noopener">数据布局字符串</a>将某些地址空间中的指针表示为“非整数” 。非整型指针类型表示具有未指定的按位表示的指针; 也就是说，完整性表示可能是目标机相关的或不稳定（不由固定整数支持）。</p>
<p><code>inttoptr</code>指令将整数转换为非整型指针类型的ptrtoint指令是错误类型(ill-typed)的，<code>ptrtoint</code>指令将非整型指针类型的值转换为整数。所述指令的矢量版本也是不正确的(ill-typed)。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量定义了编译时分配的内存区域，而不是运行期。</p>
<p>全局变量定义必须被初始化。</p>
<p>其他编译单元中的全局变量也可以声明，在这种情况下，它们没有初始化程序。</p>
<p>无论是全局变量定义还是声明都可以有一个显式的部分放在里面，并且可以有一个可选的显式对齐。如果变量声明的显式或推断区段信息与其定义之间存在不匹配，则结果行为未定义。</p>
<p>一个变量可以被定义为一个全局<code>constant</code>，它表示变量的内容永远不会被修改（开启更好的优化，允许全局数据被放置在可执行文件的只读部分等）。请注意，需要运行时初始化的变量不能标记<code>constant</code>,因为变量在存储区中。</p>
<p>LLVM明确允许将全局变量的声明标记为常量，即使全局变量的定义中没有指定。此功能可用于对程序进行稍微更好的优化，但需要语言定义以保证基于“constantness”的优化对于在定义中不包含<code>constant</code>的编译单元有效。</p>
<p>作为SSA（静态单赋值）值，全局变量定义了程序中所有基本块的范围内的指针值（即它们是可控的）。全局变量总是定义一个指向其“内容”类型的指针，因为它们描述了一个内存区域，并且LLVM中的所有内存对象都是通过指针访问的。</p>
<p>全局变量可以用<code>unnamed_addr</code>来标记，表示地址不重要，只有内容。如果它们具有相同的初始化程序，标记为<code>unnamed_addr</code>的常量可以与其他常量合并。请注意，一个具有显着地址的常量可以与一个<code>unnamed_addr</code>常量合并，结果是一个地址明确的(significant)常量。</p>
<p>如果给出<code>local_unnamed_addr</code>属性，则这个属性的地址在模块内是不明确的。</p>
<p>全局变量可能被声明为驻留在特定目标机的编号地址空间中。对于支持它们的目标机，地址空间可能会影响优化的执行方式，可能也会影响使用什么目标机指令访问变量。默认地址空间为零。地址空间限定符必须在任何其他属性之前。</p>
<p>LLVM允许为全局指定显式部分（section）。如果目标机支持它，它会将globals发送到指定的section。此外，如果目标机有必要的支持，全局变量可以放在一个comdat中。</p>
<p>外部声明可能有明确的section指定。对于使用此信息的目标机器，section信息保留在LLVM IR中。将section信息附加到外部声明是一个断言，其定义位于指定的section。如果定义位于不同的section，则行为是未定义的。</p>
<p>默认情况下，全局初始化器通过假设在全局初始化器开始之前在模块内定义的全局变量未从其初始值修改而得到优化。即使对于可能从模块外部访问的变量（包括具有外部链接的或者出现在<code>@llvm.used</code>或<code>dllexported</code>中的变量）也是如此。这个假设可以通过将变量标记为<code>externally_initialized</code>来消除。</p>
<p>可以为全局变量指定明确的<a href="http://www.cnblogs.com/bakari/archive/2012/10/23/2734772.html" target="_blank" rel="noopener">对齐方式</a>，它必须是2的幂。如果不存在，或者如果对齐方式设置为零，则全局对齐由目标机器设置为任何方便的方式。如果指定了明确的对齐，则全局被强制完全按照指定的对齐方式。如果全局变量具有分配的section，则不允许目标机和优化器过度对齐（over-align）全局变量。在这种情况下，额外的对齐方式可以被观察到：例如，代码可以假定全局变量被密集包装在它们的section中，并尝试将它们作为数组进行迭代，对齐填充将会破坏这个迭代。最大对齐是<code>1 &lt;&lt; 29</code>.</p>
<p>全局变量还可以具有<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时抢占说明符</a>，可选的<a href="http://llvm.org/docs/LangRef.html#glattrs" target="_blank" rel="noopener">全局属性</a>和可选的附加<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>列表。</p>
<p>变量和别名可以有一个<a href="http://llvm.org/docs/LangRef.html#tls-model" target="_blank" rel="noopener">线程本地存储模型</a>。</p>
<p><b style="color:red">句法(这个例子要好好学习，也包含了上面的知识)：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@&lt;GlobalVarName&gt; = [Linkage] [PreemptionSpecifier] [Visibility]</span><br><span class="line">                   [DLLStorageClass] [ThreadLocal]</span><br><span class="line">                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]</span><br><span class="line">                   [ExternallyInitialized]</span><br><span class="line">                   &lt;global | constant&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]</span><br><span class="line">                   [, section &quot;name&quot;] [, comdat [($name)]]</span><br><span class="line">                   [, align &lt;Alignment&gt;] (, !name !N)*</span><br></pre></td></tr></table></figure></p>
<p>例如，下面在带有初始值设定项，节(section)和对齐的编号地址空间中定义全局变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = addrspace(5) constant float 1.0, section &quot;foo&quot;, align 4</span><br></pre></td></tr></table></figure></p>
<p>以下示例仅声明一个全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = external global i32</span><br></pre></td></tr></table></figure></p>
<p><b style="color:green">以下示例使用<code>initialexec</code>TLS模型定义了一个thread-local全局变量：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = thread_local(initialexec) global i32 0, align 4</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>LLVM函数定义包括了“的define”关键字，可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时间抢占标识符</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见风格</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#callingconv" target="_blank" rel="noopener">调用约定</a>，一个可选的<code>unnamed_addr</code>属性，返回类型，可选的返回类型<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>，函数名称，（可能为空的）参数列表（每个参数都带有可选的<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>），可选的<a href="http://llvm.org/docs/LangRef.html#fnattrs" target="_blank" rel="noopener">函数属性</a>，可选的section(节)，可选的对齐，可选的<a href="http://llvm.org/docs/LangRef.html#langref-comdats" target="_blank" rel="noopener">comdat</a>，可选的<a href="http://llvm.org/docs/LangRef.html#gc" target="_blank" rel="noopener">垃圾收集器名称</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prefixdata" target="_blank" rel="noopener">前缀</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prologuedata" target="_blank" rel="noopener">序言</a>，可选的<a href="http://llvm.org/docs/LangRef.html#personalityfn" target="_blank" rel="noopener">个性</a>，附加<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>的可选列表，开启大括号，基本块列表以及关闭大括号。</p>
<p>LLVM函数声明由“<code>declare</code>”关键字，可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>，可选的<a href="http://llvm.org/docs/LangRef.html#callingconv" target="_blank" rel="noopener">调用约定</a>，可选的<code>unnamed_addr</code>或<code>local_unnamed_addr</code>属性，返回类型，返回类型的可选<a href="http://llvm.org/docs/LangRef.html#paramattrs" target="_blank" rel="noopener">参数属性</a>，函数名称，可能为空的参数列表，可选的对齐方式，可选的<a href="http://llvm.org/docs/LangRef.html#gc" target="_blank" rel="noopener">垃圾收集器名称</a>，可选的<a href="http://llvm.org/docs/LangRef.html#prefixdata" target="_blank" rel="noopener">前缀</a>以及可选的<a href="http://llvm.org/docs/LangRef.html#prologuedata" target="_blank" rel="noopener">序言</a>。</p>
<p>一个函数定义包含一个基本块列表，形成该函数的<code>CFG</code>（控制流图）。每个基本块可以有选择地以一个标签开始（赋予基本块一个符号表入口），包含指令列表，并以<a href="http://llvm.org/docs/LangRef.html#terminators" target="_blank" rel="noopener">终止</a>指令（如分支或函数返回）结束。如果未提供显式标签，一个块被赋值给一个隐含的编号标签，编号使用从计数器中返回下一个值，就像用于未命名的临时对象那样（<a href="http://llvm.org/docs/LangRef.html#identifiers" target="_blank" rel="noopener">参见上文</a>）。例如，如果函数入口块没有明确的标签，则会分配标签“<code>％0</code>”，那么该块中的第一个未命名的临时块将为“<code>％1</code>”，以此类推。</p>
<p>函数中的第一个基本块在两个方面是特殊的：在函数入口时立即执行，并且不允许有祖先基本块（即不能有任何分支到函数的入口块）。由于该块可以没有前驱，它也不能有任何<a href="http://llvm.org/docs/LangRef.html#i-phi" target="_blank" rel="noopener">PHI节点</a>。</p>
<p>LLVM允许为函数指定显式section。如果目标机支持它，它将函数发送给指定的section。另外，该函数可以放置在COMDAT中。</p>
<p>可以为函数指定明确的对齐方式。如果不存在，或者如果对齐方式设置为零，则函数的对齐由目标机设置为任何感觉方便的方式。如果指定了明确的对齐方式，则该函数被强制至少具有那么多的对齐。所有对齐必须是2的幂。</p>
<p>如果<code>unnamed_addr</code>给出该属性，则知道该地址不重要，并且可以合并两个相同的函数。</p>
<p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内是不明显的。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [fn Attrs] [section &quot;name&quot;]</span><br><span class="line">       [comdat [($name)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>参数列表是逗号分隔的参数序列，其中每个参数具有以下形式：</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; [parameter Attrs] [name]</span><br></pre></td></tr></table></figure></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>与函数或变量不同，别名不会创建任何新数据。它们只是现有位置的新符号和元数据。</p>
<p>别名有一个名称和别名，可以是全局值或常量表达式。</p>
<p>别名可能具有可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>，可选的<a href="http://llvm.org/docs/LangRef.html#runtime-preemption-model" target="_blank" rel="noopener">运行时抢占说明符</a>，可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>，可选的<a href="http://llvm.org/docs/LangRef.html#dllstorageclass" target="_blank" rel="noopener">DLL存储类</a>和可选的<a href="http://llvm.org/docs/LangRef.html#tls-model" target="_blank" rel="noopener">tls模型</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias &lt;AliaseeTy&gt;, &lt;AliaseeTy&gt;* @&lt;Aliasee&gt;</span><br></pre></td></tr></table></figure></p>
<p>链接必须是一个<code>private</code>，<code>internal</code>，<code>linkonce</code>，<code>weak</code>，<code>linkonce_odr</code>，<code>weak_odr</code>，<code>external</code>。请注意，某些系统链接器可能无法正确处理丢弃具有别名的弱符号(就是内存溢出的问题)。</p>
<p>不是<code>unnamed_addr</code>的别名保证具有与别名表达式相同的地址。<code>unnamed_addr</code>只保证指向相同的内容。</p>
<p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内不显著。</p>
<p>由于别名只是第二个名称，因此有些限制适用，其中一些只能在生成对象文件时进行检查：</p>
<ul>
<li>定义别名的表达式必须在汇编时可计算。因为它只是一个名字，不能使用重定位。</li>
<li>表达式中的别名不会很弱，因为中间别名被覆盖的可能性无法在对象文件中表示。</li>
<li>表达式中的全局值不能是一个声明，因为这需要重定位，这是不可能的。</li>
</ul>
<h3 id="IFuncs"><a href="#IFuncs" class="headerlink" title="IFuncs"></a>IFuncs</h3><p>IFuncs就像别名一样，不会创建任何新的数据或func。它们只是动态链接器通过调用解析器函数在运行时解析的一个新符号。</p>
<p>IFuncs有一个名称和一个解析器，它是动态链接器调用的函数，它返回与该名称关联的另一个函数的地址。</p>
<p>IFunc可能具有可选的<a href="http://llvm.org/docs/LangRef.html#linkage" target="_blank" rel="noopener">链接类型</a>和可选的<a href="http://llvm.org/docs/BitCodeFormat.html#visibility" target="_blank" rel="noopener">可见性样式</a>。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [Visibility] ifunc &lt;IFuncTy&gt;, &lt;ResolverTy&gt;* @&lt;Resolver&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Comdats"><a href="#Comdats" class="headerlink" title="Comdats"></a>Comdats</h3><p>Comdat IR提供对COFF和ELF目标文件COMDAT功能的访问。</p>
<p><b style="color:red">关于什么是COMDAT，在<a href="https://zhuanlan.kanxue.com/article-4299.htm" target="_blank" rel="noopener">这篇文章</a>中提到<code>COMDAT</code>，即<code>common data</code>. 编译器将一些函数（具体是哪些函数，编译器自行决定）打包放到单独的section中，这有个专有名词叫COMDAT,即common data，意思是打包的函数或者打包的数据。按微软大拿Raymond Chen的说法，COMDAT这个概念最早来自FORTRAN语言。gcc和llvm对COMDAT都有对应的支持。链接器在链接阶段，可以对COMDAT中重复的函数进行消重（folding，折叠）。如果编译器不把函数打包成COMDAT项，链接器是不敢贸然优化掉对应的函数的，因为缺少这些函数的引用信息。</b></p>
<p>Comdats有一个代表COMDAT键的名称。如果链接器选择了某个其他键的键，则指定的这个键的所有全局对象只会在最终的对象文件中结束。如果有别名，别名将放置在相同的COMDAT中以及进行别名计算。</p>
<p>Comdats有一种选择类型来提供关于链接器如何在两个不同对象文件中的键之间进行选择的输入。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&lt;Name&gt; = comdat SelectionKind</span><br></pre></td></tr></table></figure></p>
<p>选择种类必须是以下之一：</p>
<ul>
<li><code>any</code>: 链接器可以选择任何COMDAT键，选择是任意的。</li>
<li><code>exactmatch</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同的数据。</li>
<li><code>largest</code>: 链接器将选择包含最大值COMDAT键的section。</li>
<li><code>noduplicates</code>: 链接器要求只有具有此COMDAT密钥的section存在。</li>
<li><code>samesize</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同数量的数据。</li>
</ul>
<p>请注意，Mach-O平台不支持COMDAT key，而ELF和WebAssembly仅支持<code>any</code>作为选择类型。</p>
<p><b style="color:green">这里是<code>COMDAT</code>组的一个例子，其中只有当COMDAT键的section最大时才会选择一个函数：</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat largest</span><br><span class="line">@foo = global i32 2, comdat($foo)</span><br><span class="line"></span><br><span class="line">define void @bar() comdat($foo) &#123;</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为一个语法糖，$name如果名称与全局名称相同，则可以省略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">@foo = global i32 2, comdat</span><br></pre></td></tr></table></figure></p>
<p>在COFF对象文件中，这将创建一个COMDAT section，它的选择类型是<code>IMAGE_COMDAT_SELECT_LARGEST</code>，包含<code>@foo</code>符号的内容和另一个COMDAT section；这个section的选择类型是<code>IMAGE_COMDAT_SELECT_ASSOCIATIVE</code>,这个选择类型与第一个COMDAT section相关并包含在<code>@bar</code>符号的内容。</p>
<p>全局对象的属性有一些限制。它或它的别名在定位COFF时必须与COMDAT组具有相同的名称。COFF对象的内容和大小可以在链接期间使用，根据选择种类确定选择哪个COMDAT组。因为对象的名称必须与COMDAT组的名称相匹配，所以全局对象的链接不能是本地的; 如果符号表中发生冲突，则可以重命名本地符号。</p>
<p>组合使用COMDATS和段(section)属性可能会产生令人惊讶的结果。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">$bar = comdat any</span><br><span class="line">@g1 = global i32 42, section &quot;sec&quot;, comdat($foo)</span><br><span class="line">@g2 = global i32 42, section &quot;sec&quot;, comdat($bar)</span><br></pre></td></tr></table></figure></p>
<p>从对象文件的角度来看，这需要创建具有相同名称的两个段（section）。这是必要的，因为全局变量属于不同的COMDAT组，在对象文件级别，COMDAT由段（section）表示。</p>
<p>请注意，除了使用COMDAT IR指定的内容之外，某些IR结构（如全局变量和函数）可能会在对象文件中创建COMDAT。当代码生成器配置为在各个段（section）中发出全局变量时（例如， 向llc提供<code>-data-sections</code>或<code>-function-sections</code>选项时），就会出现这种情况。</p>
<h3 id="命名元数据"><a href="#命名元数据" class="headerlink" title="命名元数据"></a>命名元数据</h3><p>命名的元数据是元数据的集合。<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据节点</a>（但不是元数据字符串）是命名元数据的唯一有效操作数。</p>
<ol>
<li>命名的元数据被表示为一个带有元数据前缀的字符串。元数据名称的规则与标识符相同，但引用的名称不被允许。”\xx”类型转义仍然有效，它允许任何字符成为名称的一部分。</li>
</ol>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; Some unnamed metadata nodes, which are referenced by the named metadata.</span><br><span class="line">!0 = !&#123;!&quot;zero&quot;&#125;</span><br><span class="line">!1 = !&#123;!&quot;one&quot;&#125;</span><br><span class="line">!2 = !&#123;!&quot;two&quot;&#125;</span><br><span class="line">; A named metadata.</span><br><span class="line">!name = !&#123;!0, !1, !2&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>返回类型和函数类型的每个参数都可能具有一组与其关联的参数属性。参数属性用于传递有关函数结果或参数的附加信息。参数属性被认为是函数的一部分，而不是函数类型，所以具有不同参数属性的函数可以具有相同的函数类型。</p>
<p>参数属性是遵循指定类型的简单关键字。如果需要多个参数属性，则它们是空格分隔的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @printf(i8* noalias nocapture, ...)</span><br><span class="line">declare i32 @atoi(i8 zeroext)</span><br><span class="line">declare signext i8 @returns_signed_char()</span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>function result (nounwind, readonly)</code>的任何属性都会立即出现在参数列表之后。</p>
<p>目前，仅定义了以下参数属性：</p>
<ul>
<li><code>zeroext</code>: 这向代码生成器指示参数或返回值应该被调用者（对于参数）或被调用者（对于返回值）被零扩展到目标机ABI所需的范围。</li>
<li><code>signext</code>: 这向代码生成器指示参数或返回值应该由调用方（对于参数）或被调用方（对于返回值）进行符号扩展到目标机的ABI（通常为32位）所需的范围内。</li>
<li><code>inreg</code>: 这表明这个参数或返回值应该以特定的与目标机相关的方式处理，同时为函数调用或返回发送代码（通常通过将其放入寄存器而不是内存中，尽管有些目标机使用它来区分两个不同类型的寄存器）。使用此属性是特定于目标机的。</li>
<li><code>byval</code>: 这表明指针参数应该真的按值传递给函数。该属性意味着指向者的隐藏拷贝在调用者和被调用者之间建立，所以被调用者无法修改调用者中的值。该属性仅对LLVM指针参数有效。它通常用于按值传递结构和数组，但在指向标量的指针上也是有效的。复制被认为属于调用者而不是被调用者（例如，readonly函数不应写入byval参数）。这不是返回值的有效属性。<br>byval属性还支持使用align属性指定对齐方式。它指示要形成的堆栈槽的对齐以及指定给调用点的指针的已知对齐。如果未指定对齐，则代码生成器会进行特定于目标机的假设。</li>
<li><code>inalloca</code>: inalloca参数属性允许调用者采取传出栈参数的地址。一个inalloca参数必须是堆栈内存指针，<code>alloca</code>指令生成堆栈内存。alloca或参数分配也必须使用<code>inalloca</code>关键字进行标记。只有最后一个参数可能具有该<code>inalloca</code>属性，并且该参数保证在内存中传递。<br>参数分配最多可以由一个调用使用一次，因为调用可能会释放它。影响参数存储的属性，象<code>inreg</code>，<code>nest</code>，<code>sret</code>，或<code>byval</code>，<code>inalloca</code>属性不能结合这些属性一起使用。<code>inalloca</code>属性还禁止LLVM隐式降低大型聚合返回值，这意味着前端作者必须用<code>sret</code>指针降低它们(意思就是不要直接返回大型的值，改用返回指针)。<br>到达呼叫点时，参数分配必须是最新的还存活的堆栈分配，否则结果未定义。可以在参数分配之后、其调用点之前分配额外的堆栈空间，但必须使用<code>[llvm.stackrestore](http://llvm.org/docs/LangRef.html#int-stackrestore)</code>清除它。<br>有关如何使用此属性的更多信息，请参阅<a href="http://llvm.org/docs/InAlloca.html" target="_blank" rel="noopener">InAlloca属性的设计和使用</a>。</li>
<li><code>sret</code>: 这表明指针参数指定了作为源程序中函数返回值的结构地址。该指针必须由调用者保证是有效的：加载和存储到结构可以由被调用者假定不要陷入并且被正确对齐。这不是返回值的有效属性。</li>
<li><code>align &lt;n&gt;</code>: 这表明优化器可能会假定指针值具有指定的对齐方式。<br>请注意，该属性在与<code>byval</code>属性组合时具有额外的语义 。</li>
<li><code>noalias</code>: 这表明，通过<a href="http://llvm.org/docs/LangRef.html#pointeraliasing" target="_blank" rel="noopener">基于</a>所述参数或返回值的指针值访问的对象不可以访问，该函数的执行过程中，通过不基于所述参数或返回值的指针值。返回值的属性也具有下面描述的附加语义。调用方与被调用方分担责任，确保满足这些要求。有关更多详细信息，请参阅<a href="http://llvm.org/docs/AliasAnalysis.html#must-may-or-no" target="_blank" rel="noopener">别名分析</a>中 NoAlias回应的讨论。<br>请注意，这个<code>noalias</code>定义有意地类似于C99中用于函数参数的<a href="https://www.zhihu.com/question/41653775" target="_blank" rel="noopener"><code>restrict</code></a>定义。<br>对于函数返回值，C99的restrict意义不大，而对LLVM的<code>noalias</code>是有意义的。此外，在函数参数上使用时，返回值上的<code>noalias</code>属性的语义强于该属性的语义。在函数返回值上，<code>noalias</code>属性指示该函数的作用类似于系统内存分配函数，它返回一个指针，指向调用者可访问的任何其他对象的存储器的已分配存储空间。</li>
<li><code>nocapture</code>: 这表明被调用者不会创建超出被调用者本身的指针的任何副本。这不是返回值的有效属性。在易变的操作中使用的地址被认为是被捕获的。</li>
<li><code>nest</code>: 这表明指针参数可以使用弹性（trampoline）内联函数删除 。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>returned</code>: 这表明函数总是返回参数作为其返回值。这是在生成调用者时使用的优​​化器和代码生成器的提示，允许值传播，尾部调用优化以及在某些情况下省略寄存器保存和恢复; 在生成被调用者时不检查或强制执行。该参数和函数返回类型必须是<a href="http://llvm.org/docs/LangRef.html#i-bitcast" target="_blank" rel="noopener">bitcast指令</a>的有效操作数 。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>nonnull</code>: 这表明参数或返回指针不为null。该属性可能只适用于指针型参数。这不是LLVM检查或执行的，调用者必须确保传入的指针非空，或者被调用者必须确保返回的指针非空。</li>
<li><code>dereferenceable(&lt;n&gt;)</code>: 这表明参数或返回指针是可逆向引用的(dereferenceable，就是用*pr引用值)。该属性可能只适用于指针型参数。一个可逆向引用的指针可以从投机加载而没有陷入的风险。已知可逆向引用的字节数必须在括号中提供。字节数小于指点人类型的大小是合法的。该nonnull属性并不意味着可引用性（考虑一个指向数组末尾的一个元素的指针），但是<code>dereferenceable(&lt;n&gt;)</code>暗含<code>nonnull</code>在 <code>addrspace(0)</code>中（这是默认地址空间）。</li>
<li><code>dereferenceable_or_null(&lt;n&gt;)</code>: 这表明参数或返回值不能同时为非空和不可逆向引用(达到<code>&lt;n&gt;</code>字节）。标记为<code>dereferenceable_or_null(&lt;n&gt;)</code>的所有非空指针是<code>dereferenceable(&lt;n&gt;)</code>。对于地址空间0 <code>dereferenceable_or_null(&lt;n&gt;)</code>意味着一个指针是正好一个<code>dereferenceable(&lt;n&gt;)</code>或null; 在其它的地址空间<code>dereferenceable_or_null(&lt;n&gt;)</code> 意味着一个指针中的至少一个<code>dereferenceable(&lt;n&gt;)</code>或<code>null</code>（它也可以是<code>null</code>和<code>dereferenceable(&lt;n&gt;)</code>）。该属性可能只适用于指针型参数。</li>
<li><code>swiftself</code>: 这表明该参数是<code>self/context</code>参数。这不是返回值的有效属性，只能应用于一个参数。</li>
<li><code>swifterror</code>: 这个属性被激发来模拟和优化Swift错误处理。它可以应用于指针指向指针类型或指针大小的alloca的参数。在调用点，与参数相对应的实际<code>swifterror</code>参数必须来自<code>swifterroralloca</code>或<code>swifterror</code>调用者的参数。甲swifterror值（参数或ALLOCA）只能加载和存储的，或用作一个swifterror参数。这不是返回值的有效属性，只能应用于一个参数。<br>这些约束允许调用约定swifterror通过将它们与在调用边界的特定寄存器相关联来优化对变量的访问， 而不是将它们放置在内存中。由于这确实改变了调用约定，所以swifterror在参数上使用属性的函数不是ABI兼容的。<br>这些约束条件还允许LLVM假定swifterror参数不会在函数swifterror中使其他内存可见，并且作为参数传递的 alloca不会转义。</li>
</ul>
<h3 id="垃圾收集器策略的名称"><a href="#垃圾收集器策略的名称" class="headerlink" title="垃圾收集器策略的名称"></a>垃圾收集器策略的名称</h3><p>每个函数都可以指定一个垃圾收集器策略名称，它只是一个字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() gc &quot;name&quot; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>名称的支持值包括<a href="http://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies" target="_blank" rel="noopener">LLVM内置的</a>值以及由加载的插件提供的值。指定GC策略将导致编译器更改其输出以支持指定的垃圾回收算法。请注意，LLVM本身不包含垃圾收集器，此功能仅限于生成可与外部提供的收集器互操作的机器代码。</p>
<h3 id="前缀数据"><a href="#前缀数据" class="headerlink" title="前缀数据"></a>前缀数据</h3><p>前缀数据是与函数关联的数据，代码生成器在函数入口点之前立即发出的。此功能的目的是允许前端（frontends）将语言特定的运行时元数据与特定函数相关联，并通过函数指针使其可用，同时仍允许调用函数指针。</p>
<p>要访问给定函数的数据，程序可以将函数指针bitcast到指向常量类型和取消逆向引用索引(dereference index，可能是指内容-1处的索引)-1的指针。这意味着IR符号刚刚超过前缀数据的末尾。例如，以单个<code>i32</code>注释的函数为例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prefix i32 123 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>前缀数据可以被引用为，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = bitcast void* () @f to i32*</span><br><span class="line">%a = getelementptr inbounds i32, i32* %0, i32 -1</span><br><span class="line">%b = load i32, i32* %a</span><br></pre></td></tr></table></figure></p>
<p>前缀数据的布局就好像它是前缀数据类型的全局变量的初始化程序。该函数将被放置为使得前缀数据的开始对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点不会对齐。如果需要对齐函数的入口点，则必须将填充添加到前缀数据中。</p>
<p>一个函数可能有前缀数据但没有主体。这与available_externally链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标机文件中发送数据。</p>
<h3 id="序言（Prologue）资料"><a href="#序言（Prologue）资料" class="headerlink" title="序言（Prologue）资料"></a>序言（Prologue）资料</h3><p>该prologue属性允许在函数体之前插入任意代码（以字节编码）。这可以用于启用函数热修补和仪器。</p>
<p>为了保持普通函数调用的语义，序言数据必须有特定的格式。具体来说，它必须以一系列字节开始，该字节序列解码为一系列机器指令，对模块的目标代码有效，将控制转移到紧接在序言数据之后的位置，而不执行任何其他可见动作。这允许内联和其他传递推理函数定义的语义，而不需要推理序言数据。显然这使得序言数据的格式高度依赖于目标。</p>
<p>x86体系结构的有效序言数据的一个简单示例是<code>i8 144</code>, 对指令<code>nop</code>进行编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prologue i8 144 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，可以通过对跳过元数据的相对分支指令进行编码来形成序言数据，如x86_64体系结构的有效序言数据的示例，其中前两个字节编码为：<code>jmp .+10</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = type &lt;&#123; i8, i8, i8* &#125;&gt;</span><br><span class="line"></span><br><span class="line">define void @f() prologue %0 &lt;&#123; i8 235, i8 8, i8* @md&#125;&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>一个函数可能有序言数据，但没有主体。这与<code>available_externally</code>链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标文件中发送数据。</p>
<h3 id="Personality功能"><a href="#Personality功能" class="headerlink" title="Personality功能"></a>Personality功能</h3><p>该<code>personality</code>属性允许函数指定用于异常处理的函数。</p>
<h3 id="属性组"><a href="#属性组" class="headerlink" title="属性组"></a>属性组</h3><p>属性组是由IR内的对象引用的属性组。它们对于保持<code>.ll</code>文件可读性很重要，因为许多函数将使用同一组属性。在与单个.c文件相对应的<code>.ll</code>文件的退化(degenerative)情况下，单个属性组将捕获用于构建该文件的重要命令行标志。</p>
<p>一个属性组是一个模块级别的对象。要使用属性组，对象引用属性组的ID（例如<code>#37</code>）。一个对象可能涉及多个属性组。在这种情况下，来自不同组的属性被合并。</p>
<p>下面是一个应该总是内联的函数的属性组的示例，其堆栈对齐方式为4，不应使用SSE指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Target-independent attributes:</span><br><span class="line">attributes #0 = &#123; alwaysinline alignstack=4 &#125;</span><br><span class="line"></span><br><span class="line">; Target-dependent attributes:</span><br><span class="line">attributes #1 = &#123; &quot;no-sse&quot; &#125;</span><br><span class="line"></span><br><span class="line">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span><br><span class="line">define void @f() #0 #1 &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><p>函数属性被设置为传递关于函数的附加信息。函数属性被认为是函数的一部分，而不是函数类型的一部分，因此具有不同函数属性的函数可以具有相同的函数类型。</p>
<p>函数属性是遵循指定类型的简单关键字。如果需要多个属性，它们是空格分隔的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define void @f() noinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline optsize &#123; ... &#125;</span><br><span class="line">define void @f() optsize &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>alignstack(&lt;n&gt;)</code>: 这个属性表明，当发布序言和尾声(epilogue)时，后端应该强制堆栈指针对齐。在圆括号中指定所需的对齐方式，该对齐方式必须是2的幂。</li>
<li><code>allocsize(&lt;EltSizeParam&gt;[, &lt;NumEltsParam&gt;])</code>: 该属性指示注释的函数将始终返回至少给定数量的字节（或null）。它的参数是零索引参数号; 如果提供了一个参数，则假定至少有<code>CallSite.Args[EltSizeParam]</code>字节在返回的指针处可用。如果提供了两个参数，则假定<code>CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]</code>字节可用。引用的参数必须是整数类型。没有关于返回的内存块的内容的假设。</li>
<li><code>alwaysinline</code>: 该属性表示内联器应尽可能将该函数内联到调用者中，而忽略此调用者的任何活动内联大小阈值。</li>
<li><code>builtin</code>: 这表明，即使函数的声明使用<code>nobuiltin</code>属性，调用点上的被调用函数也应该被识别为内置函数。这仅在调用点有效，才能直接调用<code>nobuiltin</code>属性声明的函数。</li>
<li><code>cold</code>: 这个属性表明这个函数很少被调用。在计算边权重时，由冷函数调用后支配的基本块也被认为是冷的; 因此，轻量级。</li>
<li><code>convergent</code>: 在一些并行执行模型中，存在无法根据任何附加值进行控制的操作。我们称之为这样的操作<code>convergent</code>，并用这个属性标记它们。<br><code>convergent</code>属性可能出现在函数或<code>call/invoke</code>指令上。当它出现在一个函数上时，它表示对这个函数的调用不应该取决于附加值的控制。例如，内在的<code>llvm.nvvm.barrier0</code>是<code>convergent</code>，所以对这个内在的调用不能取决于附加值的控制。<br>当它出现在一个<code>call/invoke</code>中时，<code>convergent</code>属性表明我们应该把这个调用看作是我们正在调用一个收敛函数。这对间接调用特别有用; 没有这个，我们可以把这样的调用视为目标不收敛。<br>当可以证明函数不执行任何收敛操作时，优化器可以删除函数的<code>convergent</code>属性。同样，优化程序可以在<code>call/invoke</code>不能调用收敛函数时删除<code>calls/invokes</code>上的<code>convergent</code>。</li>
<li><code>inaccessiblememonly</code>: 该属性表明该函数只能访问正在编译的模块而无法访问的内存。这是一种较弱的<code>readnone</code>形式。</li>
<li><code>inaccessiblemem_or_argmemonly</code>: 该属性表明该函数只能访问被编译的模块而无法访问的内存，或者其指针参数指向的内存。这是一种较弱的<code>argmemonly</code>形式。</li>
<li><code>inlinehint</code>: 这个属性表明源代码包含一个暗示这个函数内联的提示是可取的（比如C / C ++中的“inline”关键字）。这只是一个暗示; 它对内联没有要求。</li>
<li><code>jumptable</code>: 该属性表示应该在代码生成时将函数添加到跳转指令表中，并且应将所有对此函数的地址引用引用替换为对相应的跳转指令表函数指针的引用。请注意，这会为原始函数创建一个新指针，这意味着依赖于函数指针标识的代码可能会中断。所以，<code>jumptable</code>注解的任何函数也必须是<code>unnamed_addr</code>。</li>
<li><code>minsize</code>: 此属性表明，优化途径（passes）和代码生成器途径之间进行选择，以使该函数的代码大小尽可能小，并执行可能牺牲运行时性能的优化，以最小化生成的代码的大小。</li>
<li><code>naked</code>: 该属性禁用该函数的序言/尾声(prologue/epilogue)发射。这可能会导致系统特定的后果。</li>
<li><code>no-jump-tables</code>: 当此属性设置为true时，可以从生成的跳转表和查找表被禁用。这些表都是会转换为小写的字母。</li>
<li><code>nobuiltin</code>: 这表明调用点的被调用方函数不被识别为内置函数。除非调用点使用该<code>builtin</code>属性，否则LLVM将保留原始调用并且不会使用基于内置函数的语义的等效代码替换它。这在调用点以及函数声明和定义中是有效的。</li>
<li><code>noduplicate</code>: 此属性表示对函数的调用不能重复。对<code>noduplicate</code>函数的调用可能会在其父函数内移动，但不能在其父函数内复制。<br>包含<code>noduplicate</code>调用的函数可能仍然是内联候选人，前提是调用不通过内联复制。这意味着该功能具有内部链接功能，并且只有一个调用点，所以原始调用在内联后死亡。</li>
<li><code>noimplicitfloat</code>: 该属性禁用隐式浮点指令。</li>
<li><code>noinline</code>: 该属性表示内联器在任何情况下都不应该内联该函数。该属性不能与<code>alwaysinline</code>属性一起使用。</li>
<li><code>nonlazybind</code>: 该属性禁止该函数的延迟符号绑定。如果在程序启动期间未调用该函数，则可能会以更多的程序启动时间为代价来更快地调用该函数。</li>
<li><code>noredzone</code>: 该属性指示代码生成器不应使用红色区域，即使目标特定的ABI通常允许它。</li>
<li><code>noreturn</code>: 该函数属性指示函数永远不会正常返回。如果函数在动态返回时会在运行时产生未定义的行为。</li>
<li><code>norecurse</code>: 该函数属性指示该函数不会直接或间接地调用自己的任何可能的调用路径。如果该函数执行递归，这会在运行时产生未定义的行为。</li>
<li><code>nounwind</code>: 该函数属性指示该函数不会引发异常。如果该函数确实引发异常，则其运行时行为未定义。但是，标记为<code>nounwind</code>的函数仍可能陷入或生成异步异常。由LLVM识别以处理异步异常（如SEH）的异常处理方案仍将提供其实现定义的语义。</li>
<li><code>optforfuzzing</code>: 该属性表示该函数应该针对最大模糊信号进行优化。</li>
<li><code>optnone</code>: 该函数属性指示大多数优化过程将跳过此函数，但过程间优化过程除外。代码生成默认为“<code>fast</code>”指令选择器。该属性不能与<code>alwaysinline</code>属性一起使用; 此属性也与<code>minsize</code>属性和<code>optsize</code>属性不兼容。<br>这个属性需要在<code>noinline</code>函数中指定属性，所以函数不会被内联到任何调用者中。只有具有该<code>alwaysinline</code>属性的函数才是用于内联到此函数主体中的有效候选项。</li>
<li><code>optsize</code>: 此属性表明，优化传递(passes)和代码生成器传递之间进行选择，以保持此函数的代码大小较低，否则，只要不会显着影响运行时性能，就会专门减少代码大小进行优化。</li>
<li>“<code>patchable-function</code>“: 这个属性告诉代码生成器，为这个函数生成的代码需要遵循特定的约定，以便运行时函数稍后可以修补它。该属性本身并不意味着对程序间优化的限制。所有修补语义效应可能必须通过连接类型单独传送。该属性的确切效果取决于其字符串值，目前有一个合法的可能性：<ul>
<li>“<code>prologue-short-redirect</code>“ - 这种类型的可修补函数旨在支持修补函数序言，以线程安全的方式将控制权重定向到函数之外。它保证函数的第一条指令足够大以容纳短跳转指令，并且将被充分对齐以允许通过原子比较和交换指令进行完全更改。尽管可以通过插入足够大的<code>NOP</code>来满足第一个要求，但LLVM可以并且将尝试将现有指令（即，不得不被发射的指令）重新用作大于短跳跃的可修改指令。<br>“<code>prologue-short-redirect</code>“目前仅在x86-64上受支持。</li>
</ul>
</li>
<li>“<code>probe-stack</code>“: 该属性表明该函数将在堆栈的末尾触发一个防护区域。它确保对堆栈的访问必须不会远离保护区域的大小，保护域是堆栈的先前访问。它需要一个必需的字符串值，即将被调用的堆栈探测函数的名称。<br>如果具有”<code>probe-stack</code>“属性的函数内联到另一个”<code>probe-stack</code>“属性的函数中，对调用者而言，则结果函数具有”<code>probe-stack</code>“属性。如果具有”<code>probe-stack</code>“属性的函数被内联到完全没有”<code>probe-stack</code>“属性的函数中，则结果函数具有”<code>probe-stack</code>“被调用者的属性。</li>
<li><code>readnone</code>: 在一个函数上，这个属性表明函数严格基于它的参数来计算它的结果（或者决定展开一个异常），而不需要逆向引用任何指针参数或者访问任何对调用者函数可见的可变状态（例如内存，控制寄存器等）。它不写任何指针参数（包括<code>byval</code>参数），也不会改变调用者可见的任何状态。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在参数上，该属性指示该函数不会对指针参数进行逆向引用，即使它可以读取或写入指针指向的内存（如果通过其他指针访问的话）。</li>
<li><code>readonly</code>: 在一个函数中，这个属性表明函数不会通过任何指针参数（包括<code>byval</code>参数）进行写入，也不会修改调用者函数可见的任何状态（例如内存，控制寄存器等）。它可能会逆向引用（就是*号操作）指针参数并读取调用者可能设置的状态。readonly函数在调用相同的参数集和全局状态时始终返回相同的值（或者展开相同的异常）。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在一个参数上，这个属性表明函数不会通过这个指针参数写入，即使它可能写入指针指向的内存。</li>
<li>“<code>stack-probe-size</code>“: 该属性控制堆栈探测器的行为：”<code>probe-stack</code>“属性或ABI所需的堆栈探测器（如果有的话）。它定义了防护区的大小。它确保如果函数可能会使用比保护区大小更多的堆栈空间，则会发出堆栈探测序列。它需要一个必需的整数值，默认为<code>4096</code>。<br>如果具有”<code>stack-probe-size</code>“属性的函数内联到另一个”<code>stack-probe-size</code>“属性函数中，则生成的函数具有”<code>stack-probe-size</code>“数值较小的属性。如果具有”<code>stack-probe-size</code>“属性的函数被内联到完全没有”stack-probe-size”属性的函数中，则结果函数具有”<code>stack-probe-size</code>“被调用者的属性。</li>
<li>“<code>no-stack-arg-probe</code>“: 该属性禁用ABI所需的堆栈探测器（如果有的话）。</li>
<li><code>writeonly</code>: 在一个函数上，这个属性表明函数可以写入但不从内存中读取。<br>在一个参数上，这个属性表明函数可以写入但不读取这个指针参数（即使它可以从指针指向的内存中读取）。</li>
<li><code>argmemonly</code>: 这个属性表明函数内部唯一的内存访问是加载并存储指针类型参数所指向的对象的任意偏移量。换句话说，函数中的所有内存操作都可以仅使用基于其函数参数的指针来引用内存。请注意，<code>argmemonly</code>可以与<code>readonly</code>属性一起使用，以便指定该函数只从其参数中读取。</li>
<li><code>returns_twice</code>: 该属性表示该函数可以返回两次。C的<a href="https://zh.wikipedia.org/wiki/Setjmp.h" target="_blank" rel="noopener"><code>setjmp</code></a>（<a href="http://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html" target="_blank" rel="noopener">这里</a>有一个更好的例子）是这种功能的一个例子。编译器在这些函数的调用者中禁用某些优化（如tail调用）。</li>
<li><code>safestack</code>: 此属性表示已为此函数启用<a href="http://clang.llvm.org/docs/SafeStack.html" target="_blank" rel="noopener">SafeStack</a>保护。<br>如果具有<code>safestack</code>属性的函数被内联到一个函数，这个函数不具有<code>safestack</code>属性或具有一个<code>ssp</code>，<code>sspstrong</code>或<code>sspreq</code>属性，然后将所得的函数将有一个<code>safestack</code>属性。</li>
<li><code>sanitize_address</code>: 此属性表明已为此函数启用<code>AddressSanitizer</code>检查（动态地址安全分析）。</li>
<li><code>sanitize_memory</code>: 此属性表示对此函数启用<code>MemorySanitizer</code>检查（对未初始化内存的访问的动态检测）。</li>
<li><code>sanitize_thread</code>: 此属性表示为此函数启用了<code>ThreadSanitizer</code>检查（动态线程安全分析）。</li>
<li><code>sanitize_hwaddress</code>: 此属性表示为此函数启用了<code>HWAddressSanitizer</code>检查（基于标记指针的动态地址安全分析）。</li>
<li><code>speculatable</code>: 这个函数属性表明函数除了计算结果之外没有任何影响，并且没有未定义的行为。请注意，这<code>speculatable</code>还不足以断定沿着任何特定的执行路径，对此函数的调用次数不会在外部可观察到。该属性仅适用于函数和声明，而不适用于单个调用点。如果一个函数被错误地标记为<code>speculatable</code>，并且确实表现出未定义的行为，即使该调用点是死代码，也可能会观察到未定义的行为。</li>
<li><p><code>ssp</code>: 该属性表示该函数应该发出一个<a href="https://blog.csdn.net/mantis_1984/article/details/72119575" target="_blank" rel="noopener">堆栈溢出保护器(stack smashing detected)</a>。它的形式是“canary” - 在从函数返回时检查局部变量以查看它是否被覆盖之前放置在堆栈上的随机值。启发式用于确定函数是否需要堆栈保护器。使用的启发式将使保护器具有以下特性的函数：</p>
<ul>
<li>大于<code>ssp-buffer-size</code>（默认8）的字符数组。</li>
<li>包含大于<code>ssp-buffer-size</code>的字符数组的聚合。</li>
<li>大小大于<code>ssp-buffer-size</code>的变量或者常量调用<code>alloca()</code>.</li>
</ul>
<p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。<br>如果一个具有<code>ssp</code>属性的函数被内联到一个没有<code>ssp</code>属性的函数中，那么结果函数将具有一个<code>ssp</code>属性。</p>
</li>
<li><p><code>sspreq</code>: 该属性表示该函数应该始终发出堆栈溢出保护器。这覆盖了<code>ssp</code>函数属性。<br>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p>
<ol>
<li>大型数组和包含大型数组（&gt;= ssp-buffer-size）的结构最接近堆栈保护器。</li>
<li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li>
<li>已经取得地址的变量是第三接近保护者。</li>
</ol>
<p>如果其具有<code>sspreq</code>属性的函数被内联到一个函数，它不具有<code>sspreq</code>属性或具有一个<code>ssp</code>或<code>sspstrong</code>属性，然后将所得的函数将有一个<code>sspreq</code>属性。</p>
</li>
<li><p><code>sspstrong</code>: 该属性表示该函数应该发出一个堆栈溢出保护器。该属性在确定函数是否需要堆栈保护器时会使用强启发式。强大的启发式功能可以为以下函数提供保护：</p>
<ul>
<li>任何大小和类型的阵列</li>
<li>包含任何大小和类型的数组的聚合。</li>
<li>调用alloca（）。</li>
<li>已经取得地址的局部变量。</li>
</ul>
<p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p>
<ol>
<li>大型数组和包含大型数组的结构（&gt;= ssp-buffer-size）最接近堆栈保护器。</li>
<li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li>
<li>已经取得地址的变量是第三接近保护者。</li>
</ol>
<p>这覆盖了<code>ssp</code>函数属性。<br>如果一个具有<code>sspstrong</code>属性的函数被内联到一个没有<code>sspstrong</code>属性的函数中，那么结果函数将具有一个<code>sspstrong</code>属性。</p>
</li>
<li><code>strictfp</code>: 该属性指示该函数是从需要严格浮点语义的作用域调用的。LLVM不会尝试任何需要假设浮点舍入模式的优化，或者可能会改变可能通过调用此函数来设置或清除的浮点状态标志的状态。</li>
<li>“<code>thunk</code>“: 该属性表示该函数将通过尾部调用委托给某个其他函数。不应将<code>thunk</code>的原型用于优化目的。预计调用者将投掷<code>thunk</code>原型以匹配<code>thunk</code>目标原型。</li>
<li><code>uwtable</code>: 这个属性表明被定位的ABI需要为这个函数生成一个展开的表入口，即使我们能够证明没有异常通过它。这通常适用于ELF x86-64 abi，​​但对于某些编译单元可以禁用它。</li>
<li><code>nocf_check</code>: 此属性表示不会对属性实体执行控制流检查。它会禁用特定实体的<code>-fcf-protection = &lt;&gt;</code>以细化HW控制流保护机制。该标志是目标独立的，并且当前属于函数或函数指针。</li>
<li><code>shadowcallstack</code>: 此属性表示为该函数启用了<code>ShadowCallStack</code>检查。仪器检查（instrumentation checks）函数的返回地址在函数<code>prolog</code>和<code>eiplog</code>之间没有改变。它目前是x86_64特定的。</li>
</ul>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>可以设置属性来传达关于全局变量的附加信息。与<a href="http://llvm.org/docs/LangRef.html#fnattrs" target="_blank" rel="noopener">函数属性</a>不同，全局变量上的属性被分组到单个<a href="http://llvm.org/docs/LangRef.html#attrgrp" target="_blank" rel="noopener">属性组中</a>。</p>
<h3 id="操作数捆绑-Operand-Bundles"><a href="#操作数捆绑-Operand-Bundles" class="headerlink" title="操作数捆绑(Operand Bundles)"></a>操作数捆绑(Operand Bundles)</h3><p>操作数捆绑是可与某些LLVM指令相关联的SSA值的标签set集（当前仅包含calls和invokes）。在某种程度上，它们就像元数据，但删除它们是不正确的，并且会改变程序的语义。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operand bundle set ::= &apos;[&apos; operand bundle (, operand bundle )* &apos;]&apos;</span><br><span class="line">operand bundle ::= tag &apos;(&apos; [ bundle operand ] (, bundle operand )* &apos;)&apos;</span><br><span class="line">bundle operand ::= SSA value</span><br><span class="line">tag ::= string constant</span><br></pre></td></tr></table></figure></p>
<p>操作数绑定不是函数签名的一部分，并且可以从具有不同类型操作数绑定的多个位置调用给定函数。这反映了操作数绑定在概念上是call（或invoke）的一部分，而不是被调度的被调用者。</p>
<p>操作数绑定是一种通用机制，旨在支持托管语言的类似运行时自反功能。虽然操作数绑定的确切语义取决于绑定标记，但操作数绑定的存在可以影响程序的语义有一定的限制。这些限制被描述为“unknown”操作数绑定的语义。只要操作数绑定的行为可以在这些限制内进行描述，LLVM就不需要对操作数绑定有特殊的了解，就不会错误地编译包含它的程序。</p>
<ul>
<li>未知操作数绑定的捆绑操作数在控制权转移给被调用者或调用者之前以未知方式转义。</li>
<li>使用操作数绑定进行调用和调用对入口和出口处的堆（即使调用目标是readnone或readonly）在堆上具有未知的读/写效果 ，除非它们被特定于调用点的属性覆盖。</li>
<li>调用点的操作数绑定不能更改被调用函数的实现。只要它们考虑到头两个属性，程序间优化就像往常一样工作。</li>
</ul>
<p>下面描述了更具体的操作数绑定类型。</p>
<h4 id="逆优化（Deoptimization）操作数绑定"><a href="#逆优化（Deoptimization）操作数绑定" class="headerlink" title="逆优化（Deoptimization）操作数绑定"></a>逆优化（Deoptimization）操作数绑定</h4><p>逆优化（Deoptimization）操作数绑定由”<code>deopt</code>“操作数绑定标签表征。这些操作数绑定表示它们所连接的调用点的替代“安全”延续，并且可以由适当的运行时使用，以便在指定的调用点对编译后的帧进行去优化。最多可以有一个”<code>deopt</code>“操作数绑定附加到调用点。逆优化（Deoptimization）的确切细节超出了语言参考的范围，但它通常涉及将编译帧重写为一组解释帧。</p>
<p>从编译器的角度来看，逆优化（Deoptimization）操作数绑定使得它们所连接的调用点至少是<code>readonly</code>。他们通读他们所有的指针类型操作数（即使它们没有被转义）和整个可见的堆。逆优化操作数绑定不会捕获它们的操作数，除非在逆优化过程中，在这种情况下，控制将不会返回到编译帧。</p>
<p>内联器知道如何通过具有逆优化操作数绑定的调用进行内联。就像通过一个正常的调用点进行内联，包括构成正常的和特殊的延续一样，通过调用点内联去耦优化操作数捆绑定需要适当地组成“安全”去优化延续。内联器通过在内联体中对每个逆优化延续预先实现父代的逆优化延续。例如内联<code>@f</code>到<code>@g</code>在下面的例子中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define void @f() &#123;</span><br><span class="line">  call void @x()  ;; no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @g() &#123;</span><br><span class="line">  call void @f() [ &quot;deopt&quot;(i32 20) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会导致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define void @g() &#123;</span><br><span class="line">  call void @x()  ;; still no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前端(frontend)的责任是以句法上将调用者的逆最优化状态预先加入到被调用者的逆最优化状态的方式来构造或编码逆最优化状态，这在语义上等同于在被调用者的逆最佳化延续之后构成调用者的逆最佳化延续。</p>
<h4 id="Funclet操作数捆绑"><a href="#Funclet操作数捆绑" class="headerlink" title="Funclet操作数捆绑"></a>Funclet操作数捆绑</h4><p>Funclet操作数绑定由”<code>funclet</code>“操作数绑定标签表征。这些操作数绑定表明调用点位于特定<code>funclet</code>内。最多可以有一个”<code>funclet</code>“操作数绑定附加到调用点，并且它必须只有一个捆绑操作数。</p>
<p>如果任何<code>funclet</code> EH焊盘(pads)已被“entered”但不是“exited”（根据<a href="http://llvm.org/docs/ExceptionHandling.html#wineh-constraints" target="_blank" rel="noopener">EH文档中的描述</a>），则对下面的执行一个call或者invoke是未定义的行为：</p>
<ul>
<li>没有”<code>funclet</code>“捆绑，并且不是对nounwind intrinsic的call，或者</li>
<li>有一个”<code>funclet</code>绑定，它的操作数不是最近输入的尚未退出funclet EH板（pad）。</li>
</ul>
<p>类似地，如果没有funclet EH焊盘（pads）进入但尚未退出，在一个”<code>funclet</code>“bundle中执行一个call或invoke是未定义的行为。</p>
<h4 id="GC转换操作数绑定"><a href="#GC转换操作数绑定" class="headerlink" title="GC转换操作数绑定"></a>GC转换操作数绑定</h4><p>GC转换操作数绑定由”gc-transition”操作数绑定标记表征。这些操作数绑定将一个调用标记为具有一个GC策略的函数与具有不同GC策略的函数之间的过渡。如果协调GC策略之间的转换需要在调用点生成额外的代码，则这些软件绑定可能包含生成的代码所需的任何值。有关更多详细信息，请参阅<a href="http://llvm.org/docs/Statepoints.html#gc-transition-args" target="_blank" rel="noopener">GC转场</a>。</p>
<h3 id="模块级内联汇编"><a href="#模块级内联汇编" class="headerlink" title="模块级内联汇编"></a>模块级内联汇编</h3><p>模块可能包含“模块级内联asm”块，它对应于GCC“文件范围inline asm”块。这些块由LLVM内部连接并作为一个单元进行处理，但如果需要可以在<code>.ll</code>文件中分开。语法非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module asm &quot;inline asm code goes here&quot;</span><br><span class="line">module asm &quot;more can go here&quot;</span><br></pre></td></tr></table></figure></p>
<p>字符串可以通过转义不可打印的字符来包含任何字符。使用的转义序列只是“\xx”，其中“xx”是数字的两位十六进制代码。</p>
<p>请注意，汇编字符串必须由LLVM的集成汇编程序解析（除非它被禁用），即使在发送<code>.s</code>文件时也是如此。</p>
<h3 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h3><p>模块可以指定目标特定数据布局字符串，该字符串指定数据如何布置在内存中。数据布局的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target datalayout = &quot;layout specification&quot;</span><br></pre></td></tr></table></figure></p>
<p>该布局规范包括规范用减号字符分隔（“-”）的列表中。每个规范都以字母开头，并可能在字母后包含其他信息以定义数据布局的某些方面。接受的规格如下：</p>
<ul>
<li><code>E</code>: 指定目标以big-endian格式显示数据。也就是说，最重要的位具有最低的地址位置。</li>
<li><code>e</code>: 指定目标以little-endian形式显示数据。也就是说，具有最低重要性的位具有最低的地址位置。</li>
<li><code>S&lt;size&gt;</code>: 指定堆栈的自然对齐位数。堆栈变量的对齐提升仅限于自然堆栈对齐，以避免动态堆栈重新对齐。堆栈对齐必须是8位的倍数。如果省略，则自然堆栈对齐默认为“未指定”，这不会阻止任何对齐升级。</li>
<li><code>P&lt;address space&gt;</code>: 指定对应于程序内存的地址空间。哈佛（Harvard）体系结构可以使用它来指定LLVM应该在哪些空间放置诸如函数之类的东西。如果省略，程序存储器空间默认为默认地址空间0，这对应于具有相同空间中的代码和数据的冯诺依曼体系结构。</li>
<li><code>A&lt;address space&gt;</code>: 指定由’<code>alloca</code>‘创建的对象的地址空间。默认为默认地址空间0。</li>
<li><code>p[n]:&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;:&lt;idx&gt;</code>: 这将指定大小的指针和它的<code>&lt;abi&gt;</code>和 <code>&lt;pref&gt;</code>错误的地址的空间对齐n。第四个参数<code>&lt;idx&gt;</code>是用于地址计算的索引大小。如果未指定，则默认索引大小等于指针大小。所有尺寸都是位。地址空间n是可选的，如果未指定，则表示默认地址空间0.值n必须在<code>[1,2^23)</code>范围内。</li>
<li><code>i&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的整数类型的对齐方式。值<code>&lt;size&gt;</code>必须在<code>[1,2^23)</code>范围内。</li>
<li><code>v&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的向量类型的对齐方式。</li>
<li><code>f&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的浮点类型的对齐方式。只有目标支持的<code>&lt;size&gt;</code>值才有效。所有目标都支持32（浮动）和64（双）。一些目标也支持80或128（不同长度的双重版本）。</li>
<li><code>a:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了聚合类型对象的对齐方式。</li>
<li><code>m:&lt;mangling&gt;</code>: 如果存在，则指定llvm名称在输出中被损坏。以mangling转义字符作为前缀的符号<code>\01</code>直接传递给汇编器而不使用转义字符。mangling风格选项是<ul>
<li><code>e</code>：ELF mangling：专用符号获取<code>.L</code>前缀。</li>
<li><code>m</code>：Mips mangling：私有符号获取<code>$</code>前缀。</li>
<li><code>o</code>：Mach-O修改：专用符号获取<code>L</code>前缀。其他符号会得到一个<code>_</code>前缀。</li>
<li><code>x</code>：Windows x86 COFF mangling：私有符号获取通常的前缀。普通的C符号会得到一个<code>_</code>前缀。带有<code>__stdcall</code>，<code>__fastcall</code>，和<code>__vectorcall</code>的函数具有附加的自定义修剪(mangling)，<code>@N</code>其中N是用于传递参数的字节数。以<code>?</code>开头的C++符号不会以任何方式的变形（mangling）。</li>
<li><code>w</code>：Windows COFF mangling：类似于<code>x</code>，除了普通的C符号不接受<code>_</code>前缀。</li>
</ul>
</li>
<li><code>n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</code>: 这为位目标CPU指定了一组本地整数宽度。例如，它可能包含32位PowerPC的n32，对于PowerPC 64是<code>n32:64</code>或对于X86-64是<code>n8:16:32:64</code>。这组元素被认为可以有效地支持大多数一般的算术运算。</li>
<li><code>ni:&lt;address space0&gt;:&lt;address space1&gt;:&lt;address space2&gt;...</code>: 这指定具有指定地址空间的指针类型作为<a href="http://llvm.org/docs/LangRef.html#nointptrtype" target="_blank" rel="noopener">非整体指针类型</a>。该<code>0</code>地址空间不能被指定为非积分(non-integral)。</li>
</ul>
<p>在每个采用的<code>&lt;abi&gt;:&lt;pref&gt;</code>规范上，指定<code>&lt;pref&gt;</code>对齐是可选的。如果省略，则前面的内容也应该省略, 并且<code>&lt;pref&gt;</code>等于<code>&lt;abi&gt;</code>。</p>
<p>在为给定目标构建数据布局时，LLVM从默认的一组规范开始，然后（可能）由<code>datalayout</code>关键字中的规范覆盖。默认规格在此列表中给出：</p>
<ul>
<li><code>E</code> - 大端</li>
<li><code>p:64:64:64</code> - 与64位对齐的64位指针。</li>
<li><code>p[n]:64:64:64</code> - 其他地址空间被假定为与默认地址空间相同。</li>
<li><code>S0</code> - 自然堆栈对齐未指定</li>
<li><code>i1:8:8</code> - i1是8位（字节）对齐</li>
<li><code>i8:8:8</code> - i8是8位（字节）对齐</li>
<li><code>i16:16:16</code> - i16是16位对齐的</li>
<li><code>i32:32:32</code> - i32是32位对齐的</li>
<li><code>i64:32:64</code> - i64具有32位的ABI对齐，但优选对齐64位</li>
<li><code>f16:16:16</code> - 一半是16位对齐的</li>
<li><code>f32:32:32</code> - 浮点数是32位对齐的</li>
<li><code>f64:64:64</code> - 双是64位对齐</li>
<li><code>f128:128:128</code> - 四位是128位对齐</li>
<li><code>v64:64:64</code> - 64位向量是64位对齐的</li>
<li><code>v128:128:128</code> - 128位向量是128位对齐的</li>
<li><code>a:0:64</code> - 聚合是64位对齐</li>
</ul>
<p>当LLVM确定给定类型的对齐时，它使用以下规则：</p>
<ol>
<li>如果所寻找的类型与其中一个规格完全匹配，则使用该规格。</li>
<li>如果未找到匹配项，并且所查找的类型是整数类型，则使用大于所查找类型的位宽的最小整数类型。如果没有任何规格大于位宽，则使用最大的整数类型。例如，给定上面的默认规格，<code>i7</code>类型将使用<code>i8</code>（次大）的对齐，而<code>i65</code>和<code>i256</code>将使用<code>i64</code>（最大指定）的对齐。</li>
<li>如果找不到匹配，并且所寻找的类型是矢量类型，那么将使用小于所寻找的矢量类型的最大矢量类型作为回退。发生这种情况是因为<code>&lt;128 x double&gt;</code>可以用<code>64 &lt;2 x double&gt;</code>来实现，例如。</li>
</ol>
<p>数据布局字符串的功能可能不是您所期望的。值得注意的是，这不是来自代码生成器应该使用的对齐前端(frontend)的规范。</p>
<p>相反，如果指定，则需要目标数据布局来匹配最终代码生成器所期望的内容。这个字符串被中级优化器用来改进代码，这只有在它与最终的代码生成器使用的匹配时才有效。没有办法生成IR，这并不会将这个特定于目标的细节嵌入到IR中。如果您未指定字符串，则将使用默认规格来生成数据布局，并且优化阶段将相应地运行，并针对这些默认规格向IR中引入目标特异性。</p>
<h3 id="目标机三重表示法-Target-Triple"><a href="#目标机三重表示法-Target-Triple" class="headerlink" title="目标机三重表示法(Target Triple)"></a>目标机三重表示法(Target Triple)</h3><p>模块可以指定描述目标主机的目标机三元字符串。目标三元组的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target triple = &quot;x86_64-apple-macosx10.7.0&quot;</span><br></pre></td></tr></table></figure></p>
<p>该目标机三重串包括由减号（“<code>-</code>”）字符分隔的一系列标识符。规范形式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM</span><br><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT</span><br></pre></td></tr></table></figure></p>
<p>这些信息被传递到后端，以便为适当的架构生成代码。可以使用<code>-mtriple</code>命令行选项在命令行上覆盖它。</p>
<h3 id="指针别名规则"><a href="#指针别名规则" class="headerlink" title="指针别名规则"></a>指针别名规则</h3><p>任何内存访问都必须通过与内存访问的地址范围关联的指针值来完成，否则行为是不确定的。根据以下规则，指针值与地址范围相关联：</p>
<ul>
<li>指针值与关联基于任何值的地址相关联。（这其实是比较绕口的废话）</li>
<li>全局变量的地址与变量存储的地址范围相关联。</li>
<li>分配指令的结果值与分配的存储器的地址范围相关联。</li>
<li>默认地址空间中的空指针与无地址相关联。</li>
<li>一个非零整数常量或从未在LLVM中定义的函数返回的指针值可能与通过LLVM提供的机制以外的机制分配的地址范围关联。这些范围不得与由LLVM提供的机制分配的任何地址范围重叠。</li>
</ul>
<p>根据以下规则，指针值基于另一个指针值：</p>
<ul>
<li>由标量<code>getelementptr</code>操作符形成的指针值基于指针类型的操作符<code>getelementptr</code>。</li>
<li>在车道(lane)中的指针/升的矢量的结果的<code>getelementptr</code>操作是基于对车道(lane)指针升的的类型的载体的指针操作符<code>getelementptr</code>。</li>
<li><code>bitcast</code>的结果值是基于操作符<code>bitcast</code>。</li>
<li>由<code>inttoptr</code>形成的指针值是基于对造成（直接或间接）到指针的值的计算中的所有指针值。</li>
<li>“基于”的关系是传递性的。</li>
</ul>
<p>请注意，这个“based”的定义有意地类似于C99 中“based”的定义，尽管它稍微弱一些。</p>
<p>LLVM IR不会将类型与内存相关联。<code>load</code>的结果类型仅指示要加载的内存的大小和对齐方式，以及对值的解释。类似的第一个操作数类型store仅指示存储的大小和对齐方式。</p>
<p>因此，基于类型的别名分析，又名TBAA，也就是说<code>-fstrict-aliasing</code>，不适用于通用的非LLVM IR。<a href="http://llvm.org/docs/LangRef.html#metadata" target="_blank" rel="noopener">元数据</a>可用于编码额外的信息，专门的优化过程可用于实现基于类型的别名分析。</p>
<h3 id="易失性-volatile-内存访问"><a href="#易失性-volatile-内存访问" class="headerlink" title="易失性(volatile)内存访问"></a>易失性(volatile)内存访问</h3><p>某些内存访问，如<a href="http://llvm.org/docs/LangRef.html#i-load" target="_blank" rel="noopener">load</a>‘s，<a href="http://llvm.org/docs/LangRef.html#i-store" target="_blank" rel="noopener">store</a>‘s和<a href="http://llvm.org/docs/LangRef.html#int-memcpy" target="_blank" rel="noopener">llvm.memcpy</a>‘s可能被标记<code>volatile</code>。优化器不得更改易失性操作的数量或更改其相对于其他volatile操作的执行顺序。优化器可以改变相对于非volatile操作的易失性操作的顺序。<b style="color:red">这不是Java的“volatile”，并且没有跨线程同步行为。</b></p>
<p>即使那些内部函数被标记为<code>volatile</code>，IR级别的volatile加载和存储也不能安全地优化到<code>llvm.memcpy</code>或<code>llvm.memmove</code>内在函数中。同样，后端不应该拆分或合并目标机器合法的易失性加载/存储指令。</p>
<table>
<thead>
<tr>
<th>合理</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台可能依赖volatile加载，并且本地支持的数据宽度存储将作为单条指令执行。例如，在C中，这适用于具有本地硬件支持的易失性基本类型的l值，但不一定适用于聚合类型。前端支持这些预期，这在IR中是故意没有说明的。上述规则确保IR转换不会违反前端（应该是前置的语言）与该语言的合同。</td>
</tr>
</tbody>
</table>
<h3 id="并发操作的内存模型"><a href="#并发操作的内存模型" class="headerlink" title="并发操作的内存模型"></a>并发操作的内存模型</h3><p>LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有特定于平台的方式来创建它们，并且我们定义LLVM IR他们存在的行为。该模型受C++ 0x内存模型的启发。</p>
<p>有关此模型的更多非正式介绍，请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">LLVM原子指令和并发指南</a>。</p>
<p>我们将发生之前的偏序定义为最小偏序(partial order).</p>
<ul>
<li>是单线程程序顺序的超集，并且</li>
<li>当同步<code>b</code>时，包含一个从<code>a</code>到<code>b</code>的边缘。通过特定于平台的技术（如pthread锁，线程创建，线程连接等）以及原子指令引入同步对。（另请参<a href="http://llvm.org/docs/LangRef.html#ordering" target="_blank" rel="noopener">阅原子内存排序约束</a>）。</li>
</ul>
<p>请注意，程序顺序不会在线程和该线程内执行的信号之间引入边界之前发生的事件。</p>
<p>每个（定义的）读取操作（加载指令，memcpy，原子加载/读取-修改-写入等）<code>R</code>读取由（定义的）写入操作写入的一系列字节（存储指令，原子存储/读取-修改-写入，memcpy等）。就本节而言，已初始化的全局变量被认为是写入了初始化程序，它是原子化的，并且在任何其他读或写有问题的内存之前发生。对于读R的每个字节，R<sub>byte</sub> 可能会看到对相同字节的任何写入，除了：</p>
<ul>
<li>如果write<sub>1</sub> 发生在write<sub>2</sub>之前，并且write<sub>2</sub>发生在R<sub>byte</sub>之前，则R<sub>byte</sub>不会看到Write<sub>1</sub>。</li>
<li>如果R<sub>byte</sub>在write<sub>3</sub>之前发生，则R<sub>byte</sub>不会看到write<sub>3</sub>。</li>
</ul>
<p>鉴于该定义，R<sub>byte</sub>定义如下：</p>
<ul>
<li>如果R是volatile的，则结果与目标相关。（Volatile应该提供可以在C/C++中支持<code>sig_atomic_t</code>的保证，并且可以用于访问不像正常内存那样行为的地址，它通常不会提供跨线程同步。）</li>
<li>否则，如果没有写入R<sub>byte</sub>发生之前的相同字节，则R<sub>byte</sub>会对该字节返回<code>undef</code>。</li>
<li>否则，如果R<sub>byte</sub>可能只看到一次写入，则R<sub>byte</sub>将返回该写入写入的值。</li>
<li>否则，如果R是原子的，并且所有写入的R<sub>byte</sub>可能看到的都是原子的，它将选择其中一个写入的值。请参阅<a href="http://llvm.org/docs/LangRef.html#ordering" target="_blank" rel="noopener">原子内存排序约束</a>部分了解如何进行选择的其他限制条件。</li>
<li>否则R<sub>byte</sub>返回undef。</li>
</ul>
<p>R返回由它读取的一系列字节组成的值。这意味着该值内的一些字节可能是<code>undef</code>，没有整个值的<code>undef</code>。请注意，这只定义了操作的语义; 这并不意味着目标将发出多个指令来读取一系列字节。</p>
<p>请注意，在没有使用任何原子内在函数的情况下，此模型仅对单线程执行所需的IR转换放置一个限制：将store引入可能不会被存储的字节一般是不允许的。（具体来说，在另一个线程可以写入和读取地址的情况下，引入一个store可以改变一个load，可以看到只有一个写入可能看到多个写入的load。）</p>
<h3 id="原子内存排序约束"><a href="#原子内存排序约束" class="headerlink" title="原子内存排序约束"></a>原子内存排序约束</h3><p>原子指令（<a href="http://llvm.org/docs/LangRef.html#i-cmpxchg" target="_blank" rel="noopener">cmpxchg</a>，<a href="http://llvm.org/docs/LangRef.html#i-atomicrmw" target="_blank" rel="noopener">atomicrmw</a>，<a href="http://llvm.org/docs/LangRef.html#i-fence" target="_blank" rel="noopener">fence</a>，<a href="http://llvm.org/docs/LangRef.html#i-load" target="_blank" rel="noopener">atomic load</a>和<a href="http://llvm.org/docs/LangRef.html#i-store" target="_blank" rel="noopener">atomic store</a>）使用排序参数来确定与它们同步的同一地址上的其他原子指令。这些语义是从Java和C ++ 0x中借用的，但是更通俗一点。如果这些描述不够精确，请检查这些规格（请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">Atomic指南</a>中的规格参考）。<a href="http://llvm.org/docs/LangRef.html#i-fence" target="_blank" rel="noopener">fence</a>指令对待这些排序有些不同，因为他们没有收到地址。有关详细信息，请参阅该说明文档。</p>
<p>有关排序约束的更简单介绍，请参阅<a href="http://llvm.org/docs/Atomics.html" target="_blank" rel="noopener">LLVM原子指令和并发指南</a>。</p>
<ul>
<li><code>unordered</code>: 可以读取的一组值由发生前的部分顺序决定。除非某些操作写入，否则无法读取值。这旨在提供足够强大的保证来模拟Java的非volatile共享变量。此顺序不能指定为读取-修改-写入操作; 它不足以使它们以任何有趣的方式成为原子。</li>
<li><code>monotonic</code>: 除了保证<code>unordered</code>之外，每个地址上的<code>monotonic</code>操作都有单个总顺序。所有修改顺序都必须与先发生的订单兼容。不能保证修改顺序可以合并到整个程序的全局总顺序中（而这通常是不可能的）。原子读取-修改-写入操作（<code>cmpxchg</code>和<code>atomicrmw</code>）中的读取会在写入值之前立即读取修改顺序中的值。如果在同一地址的另一个原子读取之前发生一次原子读取，则稍后的读取必须在地址的修改顺序中看到相同的值或更高的值。这不允许重新排序<code>monotonic</code>（或更强大）的操作。如果地址是由一个线程<code>monotonic-ally</code>写入和其他线程monotonic-ally读取的 - 反复读取该地址，其他线程最终必须看到写入。这对应于C++ 0x/C1x的<code>memory_order_relaxed</code>。</li>
<li><code>acquire</code>: 除了<code>monotonic</code>的保障，一个进行同步边缘可以与形成release操作。这是为了模拟C++的<code>memory_order_acquire</code>。</li>
<li><code>release</code>: 除了保证<code>monotonic</code>，如果此操作写入随后由<code>acquire</code>操作读取的值，则与该操作同步。（这不是一个完整的描述;请参阅发布序列的C++0x定义。）这对应于C ++ 0x/C1x的<code>memory_order_release</code>。</li>
<li><code>acq_rel （获取+释放）</code>: <code>acquire</code>和<code>release</code>操作作为地址的一部分。这对应于C ++ 0x / C1x <code>memory_order_acq_rel</code>。</li>
<li><code>seq_cst （顺序一致）</code>: 除了保证<code>acq_rel</code>（<code>acquire</code>对于仅读取的操作，<code>release</code>对于仅写入的操作），对于所有地址上的所有顺序一致的操作，存在全局总顺序，这与在部分顺序之前发生的以及与所有受影响地址的修改顺序一致。每个按顺序一致的读取将按照此全局顺序查看最后一个先前写入相同地址的内容。这对应于C ++ 0x / C1x <code>memory_order_seq_cst</code>和Java <code>volatile</code>。</li>
</ul>
<p>如果标记了一个原子操作<code>syncscope(&quot;singlethread&quot;)</code>，它只会同步并仅参与在同一线程中运行的其他操作（例如，在信号处理程序中）的<code>seq_cst</code>总排序。</p>
<p>如果标记了一个原子操作<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>，其中 <code>&lt;target-scope&gt;</code>是目标特定的同步范围，那么它与目标相关，如果它与其他操作的<code>seq_cst</code>总排序同步并参与其中。</p>
<p>否则，未标记的原子操作<code>syncscope(&quot;singlethread&quot;)</code> 或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code> 与同步和参与未标记<code>syncscope(&quot;singlethread&quot;)</code>或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>的其它操作的<code>seq_cst</code>总排序 。</p>
<h3 id="浮点环境"><a href="#浮点环境" class="headerlink" title="浮点环境"></a>浮点环境</h3><p>默认的LLVM浮点环境假定浮点指令没有副作用。结果假设为舍入到舍入模式。此环境中不保留浮点异常状态。因此，在这些示例中，不会尝试创建或保留无效操作（SNaN）或零除异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = fdiv 0x7ff0000000000001, %X  ; 64-bit SNaN hex value</span><br><span class="line">  %B = fdiv %X, 0.0</span><br><span class="line">Safe:</span><br><span class="line">  %A = NaN</span><br><span class="line">  %B = NaN</span><br></pre></td></tr></table></figure></p>
<p>这种无异常假设的好处是可以自由推测浮点运算，而无需对浮点模型进行任何其他快速数学放松(fast-math relaxations)。</p>
<p>需要与此不同的行为的代码应使用<a href="http://llvm.org/docs/LangRef.html#constrainedfp" target="_blank" rel="noopener">约束浮点内部函数</a>。</p>
<h3 id="快速数学标志"><a href="#快速数学标志" class="headerlink" title="快速数学标志"></a>快速数学标志</h3><p>LLVM IR浮点运算（<a href="http://llvm.org/docs/LangRef.html#i-fadd" target="_blank" rel="noopener"><code>fadd</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fsub" target="_blank" rel="noopener"><code>fsub</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fmul" target="_blank" rel="noopener"><code>fmul</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fdiv" target="_blank" rel="noopener"><code>fdiv</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-frem" target="_blank" rel="noopener"><code>frem</code></a>，<a href="http://llvm.org/docs/LangRef.html#i-fcmp" target="_blank" rel="noopener"><code>fcmp</code></a>）和<a href="http://llvm.org/docs/LangRef.html#i-call" target="_blank" rel="noopener"><code>call</code></a>可以使用以下标志来启用其他不安全的浮点转换。</p>
<ul>
<li><code>nnan</code>: 没有NaNs - 允许优化假设参数和结果不是NaN。需要进行这样的优化才能在NaN上保留已定义的行为，但结果的值未定义。</li>
<li><code>ninf</code>: 无Infs - 允许优化假设参数和结果不是<code>+/-Inf</code>。需要进行这样的优化才能在<code>+/-Inf</code>上保留已定义的行为，但结果的值未定义。</li>
<li><code>nsz</code>: 无签名零 - 允许优化将零参数或结果的符号视为无关紧要。</li>
<li><code>arcp</code>: 允许互惠(Reciprocal) - 允许优化使用参数的倒数而不是执行除法。</li>
<li><code>contract</code>: 允许浮点收缩（例如，融合乘法，然后将加法融合为融合乘加）。</li>
<li><code>afn</code>: 近似函数 - 允许用近似计算代替函数（<code>sin</code>，<code>log</code>，<code>sqrt</code>等）。有关可应用于LLVM的内在数学函数的位置，请参阅浮点内在定义。</li>
<li><code>reassoc</code>: 允许重新关联转换为浮点指令。这可能会显着改变浮点结果。</li>
<li><code>fast</code>: 这个标志暗示其他所有的。</li>
</ul>
<h3 id="使用列表顺序指令"><a href="#使用列表顺序指令" class="headerlink" title="使用列表顺序指令"></a>使用列表顺序指令</h3><p>使用列表指令对每个使用列表的内存顺序进行编码，从而允许重新创建订单。<code>&lt;order-indexes&gt;</code>是分配给引用值用途的索引的逗号分隔列表。引用值的使用列表会立即按这些索引排序。</p>
<p>Use-List指令可能出现在函数作用域或全局作用域中。它们不是指令，对IR的语义没有影响。当它们在函数范围内时，它们必须出现在最终基本块的终止符之后。</p>
<p>如果基本块的地址是通过<code>blockaddress()</code>表达式获取的， <code>uselistorder_bb</code>则可用于从其函数范围之外对其使用列表重新排序。</p>
<p>句法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uselistorder &lt;ty&gt; &lt;value&gt;, &#123; &lt;order-indexes&gt; &#125;</span><br><span class="line">uselistorder_bb @function, %block &#123; &lt;order-indexes&gt; &#125;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define void @foo(i32 %arg1, i32 %arg2) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line">bb:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line"></span><br><span class="line">  ; At function scope.</span><br><span class="line">  uselistorder i32 %arg1, &#123; 1, 0, 2 &#125;</span><br><span class="line">  uselistorder label %bb, &#123; 1, 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; At global scope.</span><br><span class="line">uselistorder i32* @global, &#123; 1, 2, 0 &#125;</span><br><span class="line">uselistorder i32 7, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder i32 (i32) @bar, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder_bb @foo, %bb, &#123; 5, 1, 3, 2, 0, 4 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h3><p>源文件名字符串设置为原来的模块标识符，当通过clang前端从源代码编译时，例如，这将是编译的源文件的名称。然后通过IR和比特码进行保存。</p>
<p>目前，这对于为配置文件数据中使用的本地函数生成一致的唯一全局标识符是非常必要的，该配置文件将源文件名预先设置为本地函数名称。</p>
<p>源文件名的语法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_filename = &quot;/path/to/source.c&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章，翻译起来的确是非常麻烦，由于没有通读全文，里面应该有不少错误的地方，日后会重新修改。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">97</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">92</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
