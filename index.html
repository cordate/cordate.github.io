<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="柳絮纷飞">
<meta property="og:url" content="http://cordate.github.io/index.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柳絮纷飞">
<meta name="twitter:description" content="一个孤独的开发者，正在互联网公司踩坑邮箱：zlcgavin@gmail.com">






  <link rel="canonical" href="http://cordate.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>柳絮纷飞 - 成牛之路 </title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">柳絮纷飞</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Gavin的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity应用程序二进制接口规范（ABI）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity应用程序二进制接口规范（ABI）/" itemprop="url">solidity应用程序二进制接口规范（ABI）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T14:17:18+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>应用程序二进制接口（ABI）是与区块链以外的以太坊生态系统中的合约进行交互的标准方式，也是合约到合约交互的标准方式。数据根据其类型进行编码，如本规范中所述。编码不是自描述的，因此需要一个模式才能解码。</p>
<p>我们假设合约的接口函数是强类型的，在编译时和静态时都是已知的。不会提供自检机制。我们假设所有合约都将具有编译时可用的任何合约的接口定义。</p>
<p>本规范不涉及其接口是动态的或仅在运行时才知道的合约。如果这些情况变得重要，那么它们可以作为以太坊生态系统内的设施进行充分处理。</p>
<h2 id="函数选择器"><a href="#函数选择器" class="headerlink" title="函数选择器"></a>函数选择器</h2><p>函数调用的调用数据的前四个字节指定要调用的函数。它是函数签名的Keccak（SHA-3）哈希中的前面（左边，高位在大端）四个字节。签名被定义为基本原型的规范表达式，即带有括号括起来的参数类型列表的函数名称。参数类型由一个逗号分隔 - 不使用空格。</p>
<p><b style="color:#6ab0de">注意：函数的返回类型不是此签名的一部分。在Solidity的函数中，不考虑<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#overload-function" target="_blank" rel="noopener">重载</a>类型。原因是保持函数调用的解析与上下文无关。然而，ABI的JSON描述包含输入和输出。请参阅（<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-json" target="_blank" rel="noopener">JSON ABI</a>）</b></p>
<h2 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h2><p>从第五个字节开始，是编码的参数。这种编码也用于其他地方，例如返回值和事件参数都以相同的方式编码，而不用四个字节指定函数。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>存在以下基本类型：</p>
<ul>
<li><code>uint&lt;M&gt;</code>：<code>M</code>位的无符号整数类型，<code>0 &lt; M &lt;= 256</code>, <code>M % 8 == 0</code>。例如<code>uint32</code>，<code>uint8</code>，<code>uint256</code>。</li>
<li><code>int&lt;M&gt;</code>：<code>M</code>位的二进制补码有符号整数类型，<code>0 &lt; M &lt;= 256</code>, <code>M % 8 == 0</code>。</li>
<li><code>address</code>：相当于<code>uint160</code>，除了假设的解释和语言类型。为了计算函数选择器，使用<code>address</code>。</li>
<li><code>uint</code>，<code>int</code>：同义词<code>uint256</code>，<code>int256</code>分别。为了计算函数选择器，<code>uint256</code>和<code>int256</code>必须使用。</li>
<li><code>bool</code>：等同于<code>uint8</code>限制为0和1的值。为了计算函数选择器，bool被使用。</li>
<li><code>fixed&lt;M&gt;x&lt;N&gt;</code>：<code>M</code>位有符号的定点小数，<code>8 &lt;= M &lt;= 256</code>，<code>M % 8 ==0</code>和<code>0 &lt; N &lt;= 80</code>，其表示的值<code>v</code>作为<code>v / (10 ** N)</code>。</li>
<li><code>fixed</code>，<code>ufixed</code>：同义词<code>fixed128x19</code>，<code>ufixed128x19</code>分别。用于计算函数选择器，<code>fixed128x19</code>和<code>ufixed128x19</code>必须使用。</li>
<li><code>bytes&lt;M&gt;</code>：M位字节类型，<code>0 &lt; M &lt;= 32</code>。</li>
<li><code>function</code>：由函数选择器（4字节）填充的地址（20字节）。编码与<code>bytes24</code>完全相同。</li>
</ul>
<p>存在以下（固定大小）数组类型：</p>
<ul>
<li><code>&lt;type&gt;[M]</code>：给定类型的固定长度为<code>M</code>个元素的数组。<code>M &gt; 0</code>.</li>
</ul>
<p>存在以下非固定大小类型：</p>
<ul>
<li><code>bytes</code>：动态大小的字节序列。</li>
<li><code>string</code>：动态大小的unicode字符串，假定UTF-8编码。</li>
<li><code>&lt;type&gt;[]</code>：给定类型的元素的可变长度数组。</li>
</ul>
<p>类型可以通过在圆括号内包含一个有限的非负数的数字来组合成一个元组，用逗号分隔：</p>
<ul>
<li><code>(T1,T2,...,Tn)</code>：由类型<code>T1，... Tn</code>，<code>n &gt;= 0</code>组成的元组</li>
</ul>
<p>可以形成元组的元组，元组数组等等。</p>
<p><b style="color:#6ab0de">注意: 除了元组之外，Solidity支持上面提到的所有同名的类型。ABI元组类型用于编码Solidity<code>structs</code>。</b></p>
<h2 id="编码的形式规范"><a href="#编码的形式规范" class="headerlink" title="编码的形式规范"></a>编码的形式规范</h2><p>我们现在将正式指定编码，以便它具有以下属性，如果某些参数是嵌套数组，则这些属性特别有用：</p>
<p>属性：</p>
<ol>
<li>访问一个值所需的读取次数至多是参数数组结构中值的深度，即需要四次读取才能检索<code>a_i[k][l][r]</code>。在以前版本的ABI中，读数的数量与最坏情况下动态参数的总数成线性关系。</li>
<li>变量或数组元素的数据不与其他数据交织，并且可重定位，即它只使用相对“地址”</li>
</ol>
<p>我们区分静态和动态类型。静态类型就地编码，动态类型在当前语句块之后的位置，单独分配的位置进行编码。</p>
<p>定义：以下类型称为“动态类型”：</p>
<ul>
<li><code>bytes</code></li>
<li><code>string</code></li>
<li><code>T[]</code> 为任何类型 <code>T</code></li>
<li><code>T[k]</code>任何动态<code>T</code>和任何<code>k &gt; 0</code></li>
<li><code>(T1,...,Tk)</code>如果有的话<code>Ti</code>是动态的<code>1 &lt;= i &lt;= k</code>。</li>
</ul>
<p>所有其他类型被称为“静态的”。</p>
<p>定义：len(a)是二进制字符串<code>a</code>中的字节数。len(a)假定的类型是uint256。</p>
<p>我们将<code>enc</code>实际编码定义为ABI类型值与二进制字符串的映射关系，当且仅当<code>X</code>的类型是动态的，len(enc(X))取决于<code>X</code>的值。</p>
<p>定义：对于任何ABI值<code>X</code>，我们递归定义<code>enc(X)</code>，根据<code>X</code>类型是</p>
<ul>
<li><b style="color:red"><code>(T1,...,Tk)</code></b>对于<code>k&gt;=0</code>并且任何类型，<code>T1</code>, …,<code>Tk</code><br><code>enc(X) = head(X(1)) ... head(X(k-1)) tail(X(0)) ... tail(X(k-1))</code><br><code>X(i)</code>是<code>ith</code>值的组成部分， <code>head</code>和<code>tail</code>是为<code>Ti</code>静态类型定义的，<code>head(X(i)) = enc(X(i))</code>和<code>tail(X(i)) = &quot;&quot;</code>（空字符串）。<br>并作为<code>head(X(i)) = enc(len(head(X(0)) ... head(X(k-1)) tail(X(0)) ... tail(X(i-1))))</code>和<code>tail(X(i)) = enc(X(i))</code><br>否则，即如果<code>Ti</code>是动态类型。<br>请注意，在动态情况下，<code>head(X(i))</code>由于头部长度仅取决于类型而非值，因此定义良好(well-defined)。它的值是<code>tail(X(i))</code>开始相对于<code>enc(X)</code>开始的偏移量。</li>
<li><code>T[k]</code>对于任何<code>T</code>和<code>k</code>：<br><code>enc(X) = enc((X[0], ..., X[k-1]))</code><br>即它被编码为它是具有<code>k</code>相同类型元素的元组。</li>
<li><code>T[]</code>其中<code>X</code>有<code>k</code>个元素（<code>k</code>假定是类型<code>uint256</code>）：<br><code>enc(X) = enc(k) enc([X[1], ..., X[k]])</code><br>即它被编码，就好像它是一个静态大小的数组k，以元素的数量为前缀。</li>
<li><code>bytes</code>，长度<code>k</code>（假定为类型<code>uint256</code>）：<br><code>enc(X) = enc(k) pad_right(X)</code>，即bytes的数字被编码为<code>uint256</code>接着是<code>X</code>作为字节序列的实际值，接着是零字节的最小数目，例如<code>len(enc(X))</code>是32的倍数。</li>
<li><code>string</code>：<code>enc(X) = enc(enc_utf8(X))</code>即<code>X</code>是utf-8编码，并且该值被解释为bytes类型并被进一步编码。请注意，此后续编码中使用的长度是utf-8编码字符串的字节数，而不是其字符数。</li>
<li><code>uint&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>的大端编码，用零字节填充在高阶（左侧），长度为32字节。</li>
<li><code>address</code>：这和<code>uint160</code>一样</li>
<li><code>int&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>的大端的二进制补码编码，对于负数<code>X</code>在较高阶（左侧）填充<code>0xff</code>，对于正数<code>X</code>为使用零字节，<code>X</code>长度为32字节。</li>
<li><code>bool</code>：如同在这种<code>uint8</code>下的情况，<code>1</code>用于<code>true</code>和<code>0</code>用于<code>false</code></li>
<li><code>fixed&lt;M&gt;x&lt;N&gt;</code>：当<code>X * 10**N</code>被解读为<code>uint256</code>,<code>enc(X)</code>是<code>enc(X * 10**N)</code>。</li>
<li><code>fixed</code>：就像<code>fixed128x19</code>这样</li>
<li><code>ufixed&lt;M&gt;x&lt;N&gt;</code>：当<code>X * 10**N</code>被解读为<code>uint256</code>,<code>enc(X)</code>是<code>enc(X * 10**N)</code>。</li>
<li><code>ufixed</code>：就像<code>ufixed128x19</code>这样</li>
<li><code>bytes&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>填充后的零字节长度为32个字节的字节序列。</li>
</ul>
<p>请注意，对于任何<code>X</code>，<code>len(enc(X))</code>是32的倍数。</p>
<h2 id="函数选择器和参数编码"><a href="#函数选择器和参数编码" class="headerlink" title="函数选择器和参数编码"></a>函数选择器和参数编码</h2><p>总而言之，通过参数<code>a_1, ..., a_n</code>调用函数<code>f</code>被编码为<code>function_selector(f) enc((a_1, ..., a_n))</code>; <code>f</code>的返回值<code>v_1, ..., v_k</code>被编码为：<code>enc((v_1, ..., v_k))</code>；即这些值被组合成一个元组并被编码。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>给出下面的合同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，对于我们的<code>Foo</code>例子，如果我们想调用<code>baz</code>,参数为<code>69</code>和<code>true</code>，我们将传递总计68个字节消息，可细分为：</p>
<ul>
<li><code>0xcdcd77c0</code>：函数ID。这是作为签名<code>baz(uint32,bool)</code>的ASCII形式的Keccak散列的前4个字节而得出的。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个uint32值<code>69</code>填充的32个字节。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数 - 布尔值true，填充为32个字节</li>
</ul>
<p>总计：<code>0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</code><br>它返回一个单一的<code>bool</code>。例如，如果它要返回<code>false</code>，它的输出将是单个字节数组<code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，单个布尔值。</p>
<p>如果我们用参数<code>[&quot;abc&quot;, &quot;def&quot;]</code>来调用<code>bar</code>方法，我们将总共传递68个字节，分解为：</p>
<ul>
<li><code>0xfce353f6</code>：方法ID。这是从<code>bar(bytes3[2])</code>的签名派生。</li>
<li><code>0x6162630000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第一部分，一个bytes3值”abc”（左对齐）。</li>
<li><code>0x6465660000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第二部分，一个bytes3值”def”（左对齐）。</li>
</ul>
<p>总共：<code>0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000</code></p>
<p>如果我们想用参数<code>&quot;dave&quot;</code>, <code>true</code>和<code>[1, 2, 3]</code>调用<code>sam</code>，我们将总共传递292个字节，分解为：</p>
<ul>
<li><code>0xa5643bf2</code>：方法ID。这是从<code>sam(bytes,bool,uint256[])</code>签名派生的。请注意，它将<code>uint</code>被其规范<code>uint256</code>表示所取代。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000060</code>：第一个参数（动态类型）的数据部分的位置，从参数块的开始字节开始测量。在这种情况下，<code>0x60</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数：boolean true。</li>
<li><code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>：第三个参数（动态类型）的数据部分的位置，以字节为单位。在这种情况下，<code>0xa0</code>。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000004</code>：<b style="color:red">第一个参数的数据部分，它以元素中字节数组的长度开始，在本例中为4</b>。</li>
<li><code>0x6461766500000000000000000000000000000000000000000000000000000000</code>：第一个参数的内容：UTF-8（在这种情况下等于ASCII）的编码”dave”，在右边填充到32个字节。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：<b style="color:red">第三个参数的数据部分，它以元素中数组的长度开始，在本例中为3。</b></li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第三个参数的第一个条目。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>：第三个参数的第二个条目。</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的第三个条目。</li>
</ul>
<p>总共：<br><code>0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</code></p>
<h2 id="动态类型的使用"><a href="#动态类型的使用" class="headerlink" title="动态类型的使用"></a>动态类型的使用</h2><p>通过签名<code>f(uint,uint32[],bytes10,bytes)</code>连同参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>来调用一个函数，按以下方式进行编码：</p>
<p>我们采取<code>sha3(&quot;f(uint256,uint32[],bytes10,bytes)&quot;)</code>前四个字节，即<code>0x8be65246</code>。然后我们对所有四个参数的头部分进行编码。对于静态类型<code>uint256</code>和<code>bytes10</code>，这些是直接我们想要传递的值，而对于动态类型<code>uint32[]</code>和<code>bytes</code>，我们使用在字节偏移到它们的数据区的开始，从值编码开始测量（即，不计数前四个字节包含函数签名的散列）。这些是：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000123</code>（<code>0x123</code>填充到32个字节）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000080</code> （偏移到第二个参数的数据部分的开始，4 * 32个字节，正好是头部的大小）</li>
<li><code>0x3132333435363738393000000000000000000000000000000000000000000000</code>（”1234567890”填充到右侧的32个字节）</li>
<li><code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>（第四个参数的数据部分的起始偏移量=第一个动态参数的数据部分的起始偏移量+第一个动态参数的数据部分的大小= 4 <em> 32 + 3 </em> 32（见下文））</li>
</ul>
<p>在此之后，第一个动态参数的数据部分<code>[0x456, 0x789]</code>,如下所示：</p>
<ul>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code> （阵列元素的数量，2）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000456</code> （第一元素）</li>
<li><code>0x0000000000000000000000000000000000000000000000000000000000000789</code> （第二元素）</li>
</ul>
<p>最后，我们编码第二个动态参数的数据部分：<code>&quot;Hello, world!&quot;</code></p>
<ul>
<li><code>0x000000000000000000000000000000000000000000000000000000000000000d</code> （元素数量（在这种情况下是字节数）：13）</li>
<li><code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>（填充到右侧的32个字节）”Hello, world!”</li>
</ul>
<p>总的来说，编码是（为了清晰起见,每32字节换行显示）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span><br></pre></td></tr></table></figure></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是以太坊日志/事件监听协议的抽象。日志条目提供合约的地址，一系列最多四个主题（其实就是索引）和一些任意长度的二进制数据。事件利用现有的ABI函数来解释这个（与一个接口规范一起）为一个正确类型的结构。</p>
<p>给定一个事件名称和一系列事件参数，我们将它们分成两个子系列：索引的和不是索引的。<b style="color:red">那些被编入索引的，最多可达3个，与事件签名的Keccak散列一起使用，以形成日志条目的主题</b>。那些没有索引的事件形成事件的字节数组。</p>
<p>实际上，使用这个ABI的日志条目被描述为：</p>
<ul>
<li><code>address</code>：合同地址（本质上由以太坊提供）;</li>
<li><code>topics[0]</code>：<code>keccak(EVENT_NAME+&quot;(&quot;+EVENT_ARGS.map(canonical_type_of).join(&quot;,&quot;)+&quot;)&quot;)</code>（<code>canonical_type_of</code>就是简单地返回所述规范类型给定的参数的函数，例如对于<code>uint indexed foo</code>，它会返回<code>uint256</code>）。如果该事件被声明为<code>anonymous</code>，<code>topics[0]</code>不会生成;</li>
<li><code>topics[n]</code>：<code>EVENT_INDEXED_ARGS[n - 1]</code>（<code>EVENT_INDEXED_ARGS</code>是<code>EVENT_ARGS</code>被索引的序列;</li>
<li><code>data</code>：<code>abi_serialise(EVENT_NON_INDEXED_ARGS)</code>（<code>EVENT_NON_INDEXED_ARGS</code>是该系列的<code>EVENT_ARGS</code>未索引的部分，<code>abi_serialise</code>用于从函数返回的一系列类型的值的ABI序列化的功能，如上文所述）。</li>
</ul>
<p>对于所有固定长度的Solidity类型，<code>EVENT_INDEXED_ARGS</code>数组直接包含32字节的编码值。然而，对于动态长度的类型，包括<code>string</code>，<code>bytes</code>和数组，<code>EVENT_INDEXED_ARGS</code>将包含Keccak散列的编码值，而不是直接对值进行编码。这允许应用程序高效地查询动态长度类型的值（通过将编码值的散列设置为主题），但是应用程序无法解码他们没有查询的索引值。对于动态长度类型，应用程序开发人员需要在快速搜索预定值（如果参数为索引）和任意值的易读性（这要求参数不被索引）之间进行权衡。开发人员可以通过定义具有两个参数的事件（一个索引，一个不打算保持相同的值）来克服这种折衷并实现有效搜索和任意易读性。</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>合约接口的JSON格式由一组函数和/或事件描述给出。函数描述是一个带有如下字段的JSON对象：</p>
<ul>
<li><code>type</code>：<code>&quot;function&quot;</code>，<code>&quot;constructor&quot;</code>或<code>&quot;fallback&quot;</code>（未命名的“默认”函数）;</li>
<li><code>name</code>：函数的名称;</li>
<li><code>inputs</code>：一个对象数组，每个对象都包含：<ul>
<li><code>name</code>：参数的名称;</li>
<li><code>type</code>：参数的规范类型（下面更多）。</li>
<li><code>components</code>：用于元组类型（下面会介绍）。</li>
</ul>
</li>
<li><code>outputs</code>：类似于<code>inputs</code>对象的数组，如果函数不返回任何东西，则可以省略它;</li>
<li><code>payable</code>：如果函数接受ether为<code>true</code>，则默认为false;</li>
<li><code>stateMutability</code>：具有以下值之一的字符串：<code>pure</code>（指定为不读blockchain状态）， <code>view</code>（指定为不修改blockchain状态），<code>nonpayable</code>和<code>payable</code>（同上述<code>payable</code>）。</li>
<li><code>constant</code>：如果函数是<code>pure</code>或者<code>view</code>, 则为true。</li>
</ul>
<p><code>type</code>可以省略，默认为<code>&quot;function&quot;</code>。</p>
<p>构造函数和fallback函数从来没有<code>name</code>或<code>outputs</code>。fallback函数也没有<code>inputs</code>。</p>
<p>发送非零以太币到没有<code>payable</code>的函数将抛出异常。不要这样做。</p>
<p>事件描述是一个具有如下相似字段的JSON对象：</p>
<ul>
<li><code>type</code>：总是<code>&quot;event&quot;</code></li>
<li><code>name</code>：事件的名称;</li>
<li><code>inputs</code>：一个对象数组，每个对象都包含：<ul>
<li><code>name</code>：参数的名称;</li>
<li><code>type</code>：参数的规范类型（下面更多）。</li>
<li><code>components</code>：用于元组类型（下面更多）。</li>
</ul>
</li>
<li><code>indexed</code>：如果该字段是日志主题的一部分为true，false的话，那么它是日志数据段中的一个。</li>
<li><code>anonymous</code>：如果事件被声明为<code>anonymous</code>为true。</li>
</ul>
<p>例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  function Test() public &#123; b = 0x12345678901234567890123456789012; &#125;</span><br><span class="line">  event Event(uint indexed a, bytes32 b);</span><br><span class="line">  event Event2(uint indexed a, bytes32 b);</span><br><span class="line">  function foo(uint a) public &#123; Event(a, b); &#125;</span><br><span class="line">  bytes32 b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会生成如下json结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">&quot;type&quot;:&quot;event&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes32&quot;,&quot;indexed&quot;:false&#125;],</span><br><span class="line">&quot;name&quot;:&quot;Event&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;type&quot;:&quot;event&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes32&quot;,&quot;indexed&quot;:false&#125;],</span><br><span class="line">&quot;name&quot;:&quot;Event2&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;type&quot;:&quot;function&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],</span><br><span class="line">&quot;name&quot;:&quot;foo&quot;,</span><br><span class="line">&quot;outputs&quot;: []</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<h3 id="处理元组类型"><a href="#处理元组类型" class="headerlink" title="处理元组类型"></a>处理元组类型</h3><p>尽管这些名称不是ABI编码的一部分，但它们确实在JSON中包含很多意义，以便将其显示给最终用户。该结构以如下方式嵌套：</p>
<p>包含<code>name</code>,<code>type</code>和可能的<code>components</code>成员的对象描述类型化变量。规范类型被确定，直到达到一个元组类型和字符串描述到这一点被存储在<code>type</code>,以<code>tuple</code>为前缀，即，其将在<code>tuple</code>随后的序列<code>[]</code>和<code>[k]</code>连同整数<code>k</code>。然后将元组的元素存储在成员<code>components</code>中，该成员是数组类型的，并且具有与顶级对象相同的结构，除非在那里<code>indexed</code>不允许。</p>
<p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  struct S &#123; uint a; uint[] b; T[] c; &#125;</span><br><span class="line">  struct T &#123; uint x; uint y; &#125;</span><br><span class="line">  function f(S s, T t, uint a) public &#123; &#125;</span><br><span class="line">  function g() public returns (S s, T t, uint a) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会生成如下的JSON：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;f&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;function&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;s&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;b&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256[]&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;tuple[]&quot;,</span><br><span class="line">            &quot;components&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;t&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outputs&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="非标准打包模式"><a href="#非标准打包模式" class="headerlink" title="非标准打包模式"></a>非标准打包模式</h2><p>Solidity支持非标准打包模式，其中：</p>
<ul>
<li>没有<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-function-selector" target="_blank" rel="noopener">函数选择器</a>被编码，</li>
<li>短于32字节的类型既不填零也不签名扩展</li>
<li>动态类型就地编码并且没有长度。</li>
</ul>
<p>使用值<code>-1, 0x42, 0x2424, &quot;Hello, world!&quot;</code>进行编码<code>int1, bytes1, uint16, string</code>的示例结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xff42242448656c6c6f2c20776f726c6421</span><br><span class="line">  ^^                                 int1(-1)</span><br><span class="line">    ^^                               bytes1(0x42)</span><br><span class="line">      ^^^^                           uint16(0x2424)</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(&quot;Hello, world!&quot;) without a length field</span><br></pre></td></tr></table></figure></p>
<p>更具体地说，每个静态大小的类型占用其范围所具有的字节数量，以及动态大小的类型<code>string</code>，<code>bytes</code>或者<code>uint[]</code>在不使用其长度字段的情况下进行编码。这意味着只要有两个动态大小的元素，编码就不明确。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity合约元数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity合约元数据/" itemprop="url">solidity合约元数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T13:32:47+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Solidity编译器自动生成JSON文件，即合约元数据，其中包含有关当前合约的信息。它可以用于查询编译器版本，使用的源代码，ABI和NatSpec文档，以便更安全地与合约进行交互并验证其源代码。</p>
<p>编译器会将元数据文件的Swarm哈希值附加到每个合约的字节码末尾（详情请参阅下文），以便您可以以认证的方式检索文件，而不必求助于集中式数据提供者。（swarm是和ipfs一样的服务吗？还是文件去中心化的一种规范？）</p>
<p>当然，您必须将元数据文件发布到Swarm（或其他服务），以便其他人可以访问它。该文件可以通过使用<code>solc --metadata</code>输出，文件<code>solc --metadataContractName_meta.json</code>将被调用。它将包含Swarm对源代码的引用，因此您必须上传所有源文件和元数据文件。</p>
<p><b style="color:blue">元数据文件具有以下格式。下面的例子以可读的方式呈现。正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的关键字进行排序以得到唯一的格式。注释当然也是不允许的，这里仅用于解释目的。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Required: The version of the metadata format</span><br><span class="line">  version: &quot;1&quot;,</span><br><span class="line">  // Required: Source code language, basically selects a &quot;sub-version&quot;</span><br><span class="line">  // of the specification</span><br><span class="line">  language: &quot;Solidity&quot;,</span><br><span class="line">  // Required: Details about the compiler, contents are specific</span><br><span class="line">  // to the language.</span><br><span class="line">  compiler: &#123;</span><br><span class="line">    // Required for Solidity: Version of the compiler</span><br><span class="line">    version: &quot;0.4.6+commit.2dabbdf0.Emscripten.clang&quot;,</span><br><span class="line">    // Optional: Hash of the compiler binary which produced this output</span><br><span class="line">    keccak256: &quot;0x123...&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Compilation source files/source units, keys are file names</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;myFile.sol&quot;: &#123;</span><br><span class="line">      // Required: keccak256 hash of the source file</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x123...&quot;,</span><br><span class="line">      // Required (unless &quot;content&quot; is used, see below): Sorted URL(s)</span><br><span class="line">      // to the source file, protocol is more or less arbitrary, but a</span><br><span class="line">      // Swarm URL is recommended</span><br><span class="line">      &quot;urls&quot;: [ &quot;bzzr://56ab...&quot; ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mortal&quot;: &#123;</span><br><span class="line">      // Required: keccak256 hash of the source file</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x234...&quot;,</span><br><span class="line">      // Required (unless &quot;url&quot; is used): literal contents of the source file</span><br><span class="line">      &quot;content&quot;: &quot;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Compiler settings</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // Required for Solidity: Sorted list of remappings</span><br><span class="line">    remappings: [ &quot;:g/dir&quot; ],</span><br><span class="line">    // Optional: Optimizer settings (enabled defaults to false)</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: File and name of the contract or library this</span><br><span class="line">    // metadata is created for.</span><br><span class="line">    compilationTarget: &#123;</span><br><span class="line">      &quot;myFile.sol&quot;: &quot;MyContract&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: Addresses for libraries used</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      &quot;MyLib&quot;: &quot;0x123123...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Generated information about the contract.</span><br><span class="line">  output:</span><br><span class="line">  &#123;</span><br><span class="line">    // Required: ABI definition of the contract</span><br><span class="line">    abi: [ ... ],</span><br><span class="line">    // Required: NatSpec user documentation of the contract</span><br><span class="line">    userdoc: [ ... ],</span><br><span class="line">    // Required: NatSpec developer documentation of the contract</span><br><span class="line">    devdoc: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:#6ab0de">注意:注意上面的ABI定义没有固定的顺序。它可以随编译器版本改变。</b></p>
<p><b style="color:#6ab0de">注意:由于生成的合约的字节码包含元数据散列，因此对元数据的任何更改都会导致字节码的更改。此外，由于元数据包含所有使用的源的散列，所以任何源代码中的单个空白变化将导致不同的元数据，并随后产生不同的字节代码。</b></p>
<h2 id="编码字节码中的元数据散列"><a href="#编码字节码中的元数据散列" class="headerlink" title="编码字节码中的元数据散列"></a>编码字节码中的元数据散列</h2><p>由于我们可能会支持其他方式来检索未来的元数据文件，因此映射<code>{&quot;bzzr0&quot;: &lt;Swarm hash&gt;}</code>将存储为<a href="https://tools.ietf.org/html/rfc7049" target="_blank" rel="noopener">CBOR</a>编码。由于该编码的开始不容易找到，因此其长度以两字节大端编码添加。Solidity编译器的当前版本因此将以下内容添加到部署的字节码的末尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xa1 0x65 &apos;b&apos; &apos;z&apos; &apos;z&apos; &apos;r&apos; &apos;0&apos; 0x58 0x20 &lt;32 bytes swarm hash&gt; 0x00 0x29</span><br></pre></td></tr></table></figure></p>
<p>因此，为了恢复数据，可以检查部署的字节码的末尾以匹配该模式，并使用Swarm哈希来取回文件。</p>
<h2 id="自动接口生成和NatSpec的用法"><a href="#自动接口生成和NatSpec的用法" class="headerlink" title="自动接口生成和NatSpec的用法"></a>自动接口生成和NatSpec的用法</h2><p>元数据以下列方式使用：想要与合约交互的组件（例如Mist）从合并代码中检索合约代码，然后从该文件的Swarm散列中检索合约代码。该文件被JSON解码成上述结构。</p>
<p>然后该组件可以使用ABI自动生成合同的基本用户界面。</p>
<p>此外，Mist可以使用userdoc在用户与合约交互时向用户显示确认消息。</p>
<p>关于以太坊自然规范（NatSpec）的更多信息可以在<a href="https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format" target="_blank" rel="noopener">这里</a>找到。(这里面其实讲得是以太坊solidity文档注释的规范。)</p>
<h2 id="源代码验证的用法"><a href="#源代码验证的用法" class="headerlink" title="源代码验证的用法"></a>源代码验证的用法</h2><p>为了验证编译，可以通过元数据文件中的链接从Swarm中检索源代码。使用指定的设置在该输入上调用正确版本的编译器（将其选中为“官方”编译器的一部分）。得到的字节码与创建交易或CREATE操作码数据的数据进行比较。这会自动验证元数据，因为它的散列是字节码的一部分。过多的数据对应于构造函数的输入数据，应该根据接口将其解码并呈现给用户。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity编译器使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity编译器使用/" itemprop="url">solidity编译器使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T11:45:19+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用命令行编译器"><a href="#使用命令行编译器" class="headerlink" title="使用命令行编译器"></a>使用命令行编译器</h2><p><b style="color:#6ab0de">注意：本篇不适用于<a href="https://solidity.readthedocs.io/en/v0.4.21/installing-solidity.html#solcjs" target="_blank" rel="noopener">solcjs</a>。</b></p>
<p>Solidity库的构建目标之一是solidity<code>solc</code>命令行编译器。使用<code>solc --help</code>为您提供了所有选项的解释。编译器可以生成各种输出，范围从简单的二进制文件和汇编到抽象语法树（解析树），以估计gas的使用情况。如果你只想编译一个文件，你可以运行<code>solc --bin sourceFile.sol</code>，它会打印出二进制信息。在部署合约之前，在使用<code>solc --optimize --bin sourceFile.sol</code>编译时激活优化器。如果您想获得一些更高级的<code>solc</code>输出变体，最好告诉它使用<code>solc -o outputDirectory --bin --ast --asm sourceFile.sol</code>将所有内容输出到单独使用的文件中。</p>
<p>命令行编译器将读取自动从文件系统中导入的文件，但也可以使用以下<code>prefix=path</code>的方式提供路径重定向：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol</span><br></pre></td></tr></table></figure></p>
<p>这实质上指示编译器来搜索任何以<code>github.com/ethereum/dapp-bin/</code>开始的东西，可以在<code>/usr/local/lib/dapp-bin</code>目录下找，如果没有找到该文件，它会在<code>/usr/local/lib/fallback</code>（空格前缀始终匹配）下继续搜索。<code>solc</code>将不会从位于重映射目标之外和显式指定的源文件所在目录之外的文件系统读取文件，因此<code>import &quot;/etc/passwd&quot;;</code>只有在添加为重映射<code>=/</code>时才会起作用。</p>
<p>如果由于重映射而存在多个匹配，则选择具有最长公共前缀的那个匹配。(这个类似于java的双亲委派模型了)</p>
<p>出于安全原因，编译器限制了它可以访问的目录。在命令行中指定的源文件的路径（及其子目录）和通过重映射定义的路径可用于导入语句，但其他所有内容都被拒绝。额外的路径（及其子目录）可以通过<code>--allow-paths /sample/path,/another/sample/path</code>切换。</p>
<p>如果您的合约使用<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#libraries" target="_blank" rel="noopener">库</a>，您会注意到该字节码包含表单<code>__LibraryName______</code>的子字符串。您可以将<code>solc</code>用作链接器，这意味着它将在这些位置为您插入库地址.</p>
<p>无论是添加<code>--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;</code>到您的命令提供的每个库地址或是储存在一个文件中的字符串（每行一个库），并运行<code>--libraries fileName</code>。</p>
<p>如果<code>solc</code>使用该选项<code>--link</code>调用，所有在上面提到的<code>__LibraryName____</code>-格式输入文件将被解释为未链接的二进制文件（十六进制编码），并就地链接（如果输入从stdin读取，写入stdout）。在这种情况下，所有的选项除了<code>--libraries</code>将被忽略（包括<code>-o</code>）。</p>
<p>如果<code>solc</code>使用该选项调用<code>--standard-json</code>，则会在标准输入上使用JSON输入（如下所述），并在标准输出上返回JSON输出。</p>
<h2 id="编译器输入和输出JSON描述"><a href="#编译器输入和输出JSON描述" class="headerlink" title="编译器输入和输出JSON描述"></a>编译器输入和输出JSON描述</h2><p>这些JSON格式由编译器API使用，也可以通过<code>solc</code>。这些可能会发生变化，有些字段是可选的（如上所述），但其目的仅在于进行向后兼容的更改。</p>
<p>编译器API需要JSON格式的输入，并以JSON格式的输出编译结果。</p>
<p><b style="color:blue">注释当然是不允许的，这里仅用于解释目的。</b></p>
<h3 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Required: 源码的语言, 比如&quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc.</span><br><span class="line">  language: &quot;Solidity&quot;,</span><br><span class="line">  // Required</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    // 这里的keys是源文件的“global”名称，</span><br><span class="line">    // 导入可以通过重新映射使用其他文件（参见下文）。</span><br><span class="line">    &quot;myFile.sol&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: 源文件的keccak256散列值，它用于验证通过URL导入的检索内容。</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x123...&quot;,</span><br><span class="line">      // Required（除非使用“content”，见下文）：源文件的URL。</span><br><span class="line">      // URL应该以下面的顺序被导入，并且需要使用keccak256散列检查结果（如果可用）。如果哈希值不匹配或者没有任何一个URL导致成功，则应该引发错误。</span><br><span class="line">      &quot;urls&quot;:</span><br><span class="line">      [</span><br><span class="line">        &quot;bzzr://56ab...&quot;,</span><br><span class="line">        &quot;ipfs://Qma...&quot;,</span><br><span class="line">        &quot;file:///tmp/path/to/file.sol&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mortal&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: 源文件的keccak256 hash</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x234...&quot;,</span><br><span class="line">      // Required(除非urls被使用)：源文件的文字内容</span><br><span class="line">      &quot;content&quot;: &quot;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Optional</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // Optional: Sorted list of remappings</span><br><span class="line">    remappings: [ &quot;:g/dir&quot; ],</span><br><span class="line">    // Optional: 优化器设置 (enabled的默认值是false)</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500</span><br><span class="line">    &#125;,</span><br><span class="line">    evmVersion: &quot;byzantium&quot;, // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople</span><br><span class="line">    // Metadata settings (optional)</span><br><span class="line">    metadata: &#123;</span><br><span class="line">      // Use only literal content and not URLs (false by default)</span><br><span class="line">      useLiteralContent: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      // The top level key is the the name of the source file where the library is used.</span><br><span class="line">      // If remappings are used, this source file should match the global path after remappings were applied.</span><br><span class="line">      // If this key is an empty string, that refers to a global level.</span><br><span class="line">      &quot;myFile.sol&quot;: &#123;</span><br><span class="line">        &quot;MyLib&quot;: &quot;0x123123...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // The following can be used to select desired outputs.</span><br><span class="line">    // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.</span><br><span class="line">    // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,</span><br><span class="line">    // while the star refers to all of the contracts.</span><br><span class="line">    //</span><br><span class="line">    // The available output types are as follows:</span><br><span class="line">    //   abi - ABI</span><br><span class="line">    //   ast - AST of all source files</span><br><span class="line">    //   legacyAST - legacy AST of all source files</span><br><span class="line">    //   devdoc - Developer documentation (natspec)</span><br><span class="line">    //   userdoc - User documentation (natspec)</span><br><span class="line">    //   metadata - Metadata</span><br><span class="line">    //   ir - New assembly format before desugaring</span><br><span class="line">    //   evm.assembly - New assembly format after desugaring</span><br><span class="line">    //   evm.legacyAssembly - Old-style assembly format in JSON</span><br><span class="line">    //   evm.bytecode.object - Bytecode object</span><br><span class="line">    //   evm.bytecode.opcodes - Opcodes list</span><br><span class="line">    //   evm.bytecode.sourceMap - Source mapping (useful for debugging)</span><br><span class="line">    //   evm.bytecode.linkReferences - Link references (if unlinked object)</span><br><span class="line">    //   evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode)</span><br><span class="line">    //   evm.methodIdentifiers - The list of function hashes</span><br><span class="line">    //   evm.gasEstimates - Function gas estimates</span><br><span class="line">    //   ewasm.wast - eWASM S-expressions format (not supported atm)</span><br><span class="line">    //   ewasm.wasm - eWASM binary format (not supported atm)</span><br><span class="line">    //</span><br><span class="line">    // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every</span><br><span class="line">    // target part of that output. Additionally, `*` can be used as a wildcard to request everything.</span><br><span class="line">    //</span><br><span class="line">    outputSelection: &#123;</span><br><span class="line">      // Enable the metadata and bytecode outputs of every single contract.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the abi and opcodes output of MyContract defined in file def.</span><br><span class="line">      &quot;def&quot;: &#123;</span><br><span class="line">        &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.bytecode.opcodes&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the source map output of every single contract.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;*&quot;: [ &quot;evm.bytecode.sourceMap&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the legacy AST output of every single file.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;&quot;: [ &quot;legacyAST&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Optional: not present if no errors/warnings were encountered</span><br><span class="line">  errors: [</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: Location within the source file.</span><br><span class="line">      sourceLocation: &#123;</span><br><span class="line">        file: &quot;sourceFile.sol&quot;,</span><br><span class="line">        start: 0,</span><br><span class="line">        end: 100</span><br><span class="line">      ],</span><br><span class="line">      // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc.</span><br><span class="line">      // See below for complete list of types.</span><br><span class="line">      type: &quot;TypeError&quot;,</span><br><span class="line">      // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc.</span><br><span class="line">      component: &quot;general&quot;,</span><br><span class="line">      // Mandatory (&quot;error&quot; or &quot;warning&quot;)</span><br><span class="line">      severity: &quot;error&quot;,</span><br><span class="line">      // Mandatory</span><br><span class="line">      message: &quot;Invalid keyword&quot;</span><br><span class="line">      // Optional: the message formatted with source location</span><br><span class="line">      formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.</span><br><span class="line">  sources: &#123;</span><br><span class="line">    &quot;sourceFile.sol&quot;: &#123;</span><br><span class="line">      // Identifier (used in source maps)</span><br><span class="line">      id: 1,</span><br><span class="line">      // The AST object</span><br><span class="line">      ast: &#123;&#125;,</span><br><span class="line">      // The legacy AST object</span><br><span class="line">      legacyAST: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.</span><br><span class="line">  contracts: &#123;</span><br><span class="line">    &quot;sourceFile.sol&quot;: &#123;</span><br><span class="line">      // If the language used has no contract names, this field should equal to an empty string.</span><br><span class="line">      &quot;ContractName&quot;: &#123;</span><br><span class="line">        // The Ethereum Contract ABI. If empty, it is represented as an empty array.</span><br><span class="line">        // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI</span><br><span class="line">        abi: [],</span><br><span class="line">        // See the Metadata Output documentation (serialised JSON string)</span><br><span class="line">        metadata: &quot;&#123;...&#125;&quot;,</span><br><span class="line">        // User documentation (natspec)</span><br><span class="line">        userdoc: &#123;&#125;,</span><br><span class="line">        // Developer documentation (natspec)</span><br><span class="line">        devdoc: &#123;&#125;,</span><br><span class="line">        // Intermediate representation (string)</span><br><span class="line">        ir: &quot;&quot;,</span><br><span class="line">        // EVM-related outputs</span><br><span class="line">        evm: &#123;</span><br><span class="line">          // Assembly (string)</span><br><span class="line">          assembly: &quot;&quot;,</span><br><span class="line">          // Old-style assembly (object)</span><br><span class="line">          legacyAssembly: &#123;&#125;,</span><br><span class="line">          // Bytecode and related details.</span><br><span class="line">          bytecode: &#123;</span><br><span class="line">            // The bytecode as a hex string.</span><br><span class="line">            object: &quot;00fe&quot;,</span><br><span class="line">            // Opcodes list (string)</span><br><span class="line">            opcodes: &quot;&quot;,</span><br><span class="line">            // The source mapping as a string. See the source mapping definition.</span><br><span class="line">            sourceMap: &quot;&quot;,</span><br><span class="line">            // If given, this is an unlinked object.</span><br><span class="line">            linkReferences: &#123;</span><br><span class="line">              &quot;libraryFile.sol&quot;: &#123;</span><br><span class="line">                // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.</span><br><span class="line">                &quot;Library1&quot;: [</span><br><span class="line">                  &#123; start: 0, length: 20 &#125;,</span><br><span class="line">                  &#123; start: 200, length: 20 &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          // The same layout as above.</span><br><span class="line">          deployedBytecode: &#123; &#125;,</span><br><span class="line">          // The list of function hashes</span><br><span class="line">          methodIdentifiers: &#123;</span><br><span class="line">            &quot;delegate(address)&quot;: &quot;5c19a95c&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          // Function gas estimates</span><br><span class="line">          gasEstimates: &#123;</span><br><span class="line">            creation: &#123;</span><br><span class="line">              codeDepositCost: &quot;420000&quot;,</span><br><span class="line">              executionCost: &quot;infinite&quot;,</span><br><span class="line">              totalCost: &quot;infinite&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            external: &#123;</span><br><span class="line">              &quot;delegate(address)&quot;: &quot;25000&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            internal: &#123;</span><br><span class="line">              &quot;heavyLifting()&quot;: &quot;infinite&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // eWASM related outputs</span><br><span class="line">        ewasm: &#123;</span><br><span class="line">          // S-expressions format</span><br><span class="line">          wast: &quot;&quot;,</span><br><span class="line">          // Binary format (hex string)</span><br><span class="line">          wasm: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ol>
<li>JSONError：JSON输入不符合所需格式，例如，输入不是JSON对象，不支持该语言等。</li>
<li>IOError：IO和导入处理错误，例如在提供的源中无法解析的URL或散列不匹配。</li>
<li>ParserError：源代码不符合语言规则。</li>
<li>DocstringParsingError：注释块中的NatSpec标签无法解析。</li>
<li>SyntaxError：语法错误，例如continue在for循环外部使用。</li>
<li>DeclarationError：无效的，无法解析的或冲突的标识符名称。例如Identifier not found</li>
<li>TypeError：类型系统内出错，例如无效类型转换，无效分配等。</li>
<li>UnimplementedFeatureError：编译器不支持该功能，但预计将在未来的版本中受支持。</li>
<li>InternalCompilerError：在编译器中触发的内部错误 - 这应该被报告为一个问题。</li>
<li>Exception：编译期间未知失败 - 应将此报告为问题。</li>
<li>CompilerError：编译器堆栈的使用无效 - 这应该被报告为一个问题。</li>
<li>FatalError：致命错误未正确处理 - 应将此报告为问题。</li>
<li>Warning：警告，并没有停止编译，但应尽可能处理。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/08/blockchain/solidity安全考虑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/blockchain/solidity安全考虑/" itemprop="url">solidity安全考虑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T00:32:17+08:00">2018-04-08</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然构建可按预期工作的软件通常非常容易，但要检查没有人能够以没有预料到的方式使用它，要困难得多。</p>
<p>在Solidity中，这更加重要，因为您可以使用智能合约来处理代币或可能更有价值的东西。此外，智能合约的每一次执行都在公开场合进行，除此之外，源代码通常是公开的。</p>
<p>当然，你总是需要考虑有多大的风险：你可以将智能合约与对公众开放的Web服务（以及对恶意行为者）以及甚至开放源代码进行比较。如果您只将该购物清单存储在该Web服务上，则可能不必太在意，但如果您使用该Web服务管理您的银行账户，则应该更加小心。</p>
<p>本节将列出一些陷阱和一般安全建议，但当然可能永远不会完整。另外，请记住，即使您的智能合约代码没有缺陷，编译器或平台本身也可能有错误。可以在已知错误列表中找到编译器的一些公开<a href="https://solidity.readthedocs.io/en/v0.4.21/bugs.html#known-bugs" target="_blank" rel="noopener">已知安全相关bug列表</a>，这些bug也是机器可读的。请注意，有一个错误赏金程序涵盖了Solidity编译器的代码生成器。</p>
<p>与往常一样，使用文档开源，请帮助我们扩展本节（特别是，一些不会产生伤害的示例）！</p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><h3 id="私人信息和随机性"><a href="#私人信息和随机性" class="headerlink" title="私人信息和随机性"></a>私人信息和随机性</h3><p>您在智能合同使用的一切是公开可见的，甚至是局部变量和标记<code>private</code>的状态变量。</p>
<p>如果你不希望矿工能够作弊，在智能合同中使用随机数字是相当棘手的。</p>
<h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>合同（A）与另一合同（B）的任何互动以及以太币的任何转让均将控制移交给该合同（B）。这使得在这个交互完成之前B可以回调A. 举一个例子，下面的代码包含一个错误（它只是一个片段而不是一个完整的合约）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.send(shares[msg.sender]))</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的问题不是太严重，因为有限的gas是<code>send</code>其中的一部分，但它仍然暴露出一个弱点：以太币转移总是可以包含代码执行，因此<code>withdraw</code>接收方可以是一个重新回调的合约。这将让它得到多个退款，并基本上检索合同中的所有以太币。特别是，下面的合约将允许攻击者在使用<code>call</code>默认情况下多次退还所有剩余gas：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.call.value(shares[msg.sender])())</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免重新入侵，您可以使用Checks-Effects-Interactions模式，详情如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        var share = shares[msg.sender];</span><br><span class="line">        shares[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，重入不仅是以太币转移的影响，而且是任何其他合约的函数调用的影响。此外，您还必须考虑多合约情况。被调用合约可以修改您依赖的另一份合约的状态。</p>
<h3 id="gas限制和循环"><a href="#gas限制和循环" class="headerlink" title="gas限制和循环"></a>gas限制和循环</h3><p>没有固定迭代次数的循环（例如取决于存储值的循环）必须小心使用：由于区块gas限制，交易只能消耗一定量的gas。无论是明确的还是仅仅由于正常的操作，循环中的迭代次数可能会超出区块gas限制，这会导致整个合约在某个点停滞。这可能不适用于<code>constant</code>仅用于从区块链中读取数据的函数。尽管如此，这些函数可能会被其他合约作为链上操作的一部分进行调用，并将其拖延。请在合约文件中明确说明这些情况。</p>
<h3 id="发送和接收以太币"><a href="#发送和接收以太币" class="headerlink" title="发送和接收以太币"></a>发送和接收以太币</h3><ul>
<li>合约和“外部账户”都不能阻止有人送他们以太币。合约可以作出反应并拒绝定期的转移，但有些方法可以在不创建消息调用的情况下移动以太币。一种方法是简单地“mine to”合约地址和第二种方式是使用<code>selfdestruct(x)</code>。</li>
<li>如果合约收到Ether（没有调用函数），则执行fallback函数。如果它没有fallback函数，Ether将被拒绝（通过抛出异常）。在执行fallback函数时，合约只能依靠当时可用的“gas津贴”（2300 gas）。这笔津贴不足以以任何方式访问存储。为确保您的合约能够以此方式接收Ether，请检查fallback函数的gas要求（例如，在Remix的“详细信息”部分中）。</li>
<li>有一种方法可以使用<code>addr.call.value(x)()</code>给予接收的合约更多的gas。这基本上与<code>addr.transfer(x)</code>相同，只是它转发所有剩余的gas并打开接收方执行更昂贵的操作的能力（并且它仅仅返回失败代码并且不会自动传播错误,即抛异常）。这可能包括回调发起者合约或您可能没有想到的其他状态更改。因此它为诚实用户提供了极大的灵活性，同时也为恶意行为者提供了很大的灵活性</li>
<li>如果你想通过<code>address.transfer</code>发送以太币，有一些细节需要注意：<ol>
<li>如果接收者是合约，它将导致其执行fallback函数，从而可以回调发起者合约。</li>
<li>发送以太币可能会因调用深度超过1024而失败。由于调用者完全控制调用深度，因此可能让转币强制失败; 考虑这种可能性或使用<code>send</code>并确保始终检查其返回值。更好的是，用接受者可以对以太币提现的模式编写你的合约。</li>
<li>发送以太币也可能会失败，因为接收者合约的执行需要比gas的分配金额（显式地使用<code>require</code>， <code>assert</code>，<code>revert</code>，<code>throw</code>或因为操作太昂贵） -它“runs out of gas”（OOG）。如果您使用<code>transfer</code>或<code>send</code>带有返回值检查，这可能为接收者提供阻止发送合约进度的手段。同样，这里的最佳做法是<a href="https://solidity.readthedocs.io/en/v0.4.21/common-patterns.html#withdrawal-pattern" target="_blank" rel="noopener">使用<code>”withdraw“</code>模式而不是<code>“send”</code>模式</a>。</li>
</ol>
</li>
</ul>
<h3 id="栈调用深度"><a href="#栈调用深度" class="headerlink" title="栈调用深度"></a>栈调用深度</h3><p>外部函数调用可能会随时失败，因为它们超出了1024的最大调用堆栈。在这种情况下，Solidity会引发异常。恶意行为者在与你的合约进行交互之前可能会强制调用堆栈的价值很高。</p>
<p>请注意，如果调用堆栈已耗尽，但这种情况<code>.send()</code>返回<code>false</code>，不会抛出异常false。低层次的函数<code>.call()</code>，<code>.callcode()</code>和<code>.delegatecall()</code>以相同的方式表现。</p>
<h3 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a><b style="color:red">tx.origin</b></h3><p>切勿使用tx.origin进行授权。假设你有这样的钱包合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在有人欺骗你将以太币发送到这个攻击钱包的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">如果你的钱包已经检查<code>msg.sender</code>的授权，它将得到攻击钱包的地址，而不是所有者地址。但通过检查<code>tx.origin</code>，它会得到启动交易的原始地址，该交易仍是所有者地址。攻击钱包立即消耗您的所有资金。</b></p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul>
<li>在<code>for (var i = 0; i &lt; arrayName.length; i++) { ... }</code>中，<code>i</code>的类型将是<code>uint8</code>，因为这是保存该值所需的最小类型。如果数组有超过255个元素，则循环不会终止。</li>
<li>函数的<code>constant</code>关键字编译器目前不强制执行。此外，它不是由EVM强制执行的，所以声明为<code>constant</code>的函数可能还是会导致状态的变更。</li>
<li><b style="color:red">不占用完整32字节的类型可能包含“脏高位”。如果您访问<code>msg.data</code>，这一点尤其重要 - 它带来了可扩展性风险：您可以创建调用函数<code>f(uint8 x)</code>的交易，函数有带有<code>0xff000001</code>和<code>0x00000001</code>的raw字节参数。两者都被纳入合同，考虑<code>x</code>的值，两者看起来都像数字<code>1</code>一样，但会有所不同，所以如果您使用<code>keccak256(msg.data)</code>，您将得到不同的结果。</b></li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="限制以太币的数量"><a href="#限制以太币的数量" class="headerlink" title="限制以太币的数量"></a>限制以太币的数量</h3><p>限制可以存储在智能合约中的以太币（或其他令牌）数量。如果您的源代码，编译器或平台有错误，这些资金可能会丢失。如果你想限制你的损失，限制以太币的数量。</p>
<h3 id="保持小型化和模块化"><a href="#保持小型化和模块化" class="headerlink" title="保持小型化和模块化"></a>保持小型化和模块化</h3><p>保持合同规模小，易于理解。在其他合约或库中找出无关的功能。关于源代码质量的一般建议：限制局部变量的数量，函数的长度等等。函数需要写文档注释，以便其他人可以理解你的意图是什么，以及它是否与代码不同。</p>
<h3 id="使用检查-效果-互动（Checks-Effects-Interactions）模式"><a href="#使用检查-效果-互动（Checks-Effects-Interactions）模式" class="headerlink" title="使用检查-效果-互动（Checks-Effects-Interactions）模式"></a>使用检查-效果-互动（Checks-Effects-Interactions）模式</h3><p>大多数函数将首先执行一些检查（谁调用函数，参数是否在范围内，他们是否发送了足够多的Ether，人员是否有令牌等）。这些检查应该先完成。</p>
<p>作为第二步，如果所有检查都通过了，则应该对当前合约的状态变量产生影响。与其他合约的交互应该是任何函数的最后一步。</p>
<p>早期合约延迟了一些效果，并等待外部函数调用以非错误状态返回。由于上面提到的重入问题，这通常是一个严重的错误。</p>
<p>请注意，对已知合约的调用也可能导致对未知合约的调用，所以最好始终应用此模式。</p>
<h3 id="包含安全失败（Fail-Safe）模式"><a href="#包含安全失败（Fail-Safe）模式" class="headerlink" title="包含安全失败（Fail-Safe）模式"></a>包含安全失败（Fail-Safe）模式</h3><p>在使系统完全去中心化的同时将删除任何中介，这可能是一个好主意，特别是对于新代码，可能包含某种故障安全机制：</p>
<p>您可以在智能合约中添加一个函数，该函数执行一些自我检查，例如“有任何以太坊泄露？”，“代币的总和等于合约余额吗？”或类似的事情。请记住，你不能使用太多的gas，所以可能需要脱链计算的帮助。</p>
<p>如果自检失败，合同会自动切换到某种“Fail-Safe”模式，例如，禁用大部分函数，将控制权移交给固定和受信任的第三方，或者仅将合同转换为简单的“把我的钱还给我“的合约。</p>
<h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>使用形式验证，可以执行自动化的数学证明，证明源代码符合特定的正式规范。规范仍然是正式的（就像源代码一样），但通常要简单得多。</p>
<p>请注意，形式验证本身只能帮助你理解你所做的事情（规范）和你如何做（实际实现）之间的差异。您仍然需要检查规格是否是您想要的，并且您没有错过任何意想不到的效果。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/06/blockchain/solidity杂项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/06/blockchain/solidity杂项/" itemprop="url">solidity杂项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-06T00:39:19+08:00">2018-04-06</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<h2 id="Storage中状态变量的布局"><a href="#Storage中状态变量的布局" class="headerlink" title="Storage中状态变量的布局"></a>Storage中状态变量的布局</h2><p>静态大小的变量（除映射和动态大小的数组类型之外的所有变量）都是从位置<code>0</code>开始连续地放置在存储中。如果可能的话，需要少于32个字节的多个项目按照以下规则打包到一个存储槽中：</p>
<ul>
<li>存储槽中的第一项存储在低阶对齐中。</li>
<li>基本类型只使用存储它们所需的那么多字节。</li>
<li>如果基本类型不适合存储槽的其余部分，则将其移动到下一个存储槽。</li>
<li>结构和数组数据总是会启动一个新的槽并占据整个槽（但是根据这些规则，结构或数组内的项会紧紧地压缩）。</li>
</ul>
<p><b style="color:#6ab0de">警告：使用小于32字节的元素时，您合约的gas使用量可能会更高。这是因为EVM一次运行32个字节。因此，如果元素小于此值，则EVM必须使用更多操作才能将元素的大小从32个字节减小到所需的大小。</b></p>
<p><b style="color:red">如果您正在处理存储值，那么只使用减小尺寸的参数是有益的，因为编译器会将多个元素打包到一个存储槽中，从而将多个读取或写入组合到一个操作中。处理函数参数或内存值时，没有固有的好处，因为编译器不会打包这些值。</b></p>
<p><b style="color:red">最后，为了让EVM为此进行优化，请确保您尝试对存储变量和<code>struct</code>成员进行排序，以便它们可以紧密打包。例如，声明你的<code>uint128, uint128, uint256</code>存储变量的顺序，而不是<code>uint128, uint256, uint128</code> ，因为前者将只占用存储的两个槽，而后者将占用三个。</b></p>
<p>结构和数组的元素会相互存储，就像明确地给出的顺序一样。</p>
<p>由于其大小不可预知，映射和动态大小的数组类型使用Keccak-256散列计算来查找值或数组数据的起始位置。这些起始位置总是全堆栈槽。</p>
<p>映射或动态数组本身根据上述规则（或通过将此规则映射到映射或数组阵列）递归地占用存储在某个位置<code>p</code>的（未填充）槽。对于动态数组，此槽存储数组中元素的数量（字节数组和字符串在这里是一个例外，见下文）。对于映射，该槽未被使用（但是这是需要的，使得两个相同的映射在彼此之后将使用不同的散列分布）。数组数据位于<code>keccak256(p)</code>, 对应于映射键<code>k</code>的值位<code>keccak256(k . p)</code>于其中<code>.</code>是级联。如果该值又是非基本类型，则通过添加<code>keccak256(k . p)</code>的偏移量来找到位置。keccak256(k . p).keccak256(k . p)</p>
<p><code>bytes</code>和<code>string</code>存储在相同的槽中，槽中也存储长度。特别地：如果数据长度至多为<code>31</code>字节，则它存储在高位字节（左对齐）中，而最低位字节存储<code>length * 2</code>。如果更长，主要的槽存储<code>length * 2 + 1</code>和数据按常规存储在<code>keccak256(slot)</code>。</p>
<p>因此，对于以下合同片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  struct s &#123; uint a; uint b; &#125;</span><br><span class="line">  uint x;</span><br><span class="line">  mapping(uint =&gt; mapping(uint =&gt; s)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>data[4][9].b</code>的位置是在<code>keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1</code>。</p>
<h2 id="内存中的布局"><a href="#内存中的布局" class="headerlink" title="内存中的布局"></a>内存中的布局</h2><p>Solidity保留三个256位槽：</p>
<ul>
<li>0 - 64：散列方法的暂存空间</li>
<li>64 - 96：当前分配的内存大小（即可用内存指针）</li>
</ul>
<p>语句之间可以使用临时空间（包括在内联程序在内）。</p>
<p>Solidity始终将新对象放置在空闲内存指针上，内存永远不会释放（这可能会在未来发生变化）。</p>
<p><b style="color:#6ab0de">警告：Solidity中有一些操作需要大于64字节的临时内存区域，因此临时内存空间不会不匹配。它们将被放置在空闲内存指针指向的位置，但给予其较短的生命周期，指针不会更新。内存可能会或可能不会被清零。正因为如此，人们不应该期望自由内存被清零。</b></p>
<h2 id="调用方法数据的布局"><a href="#调用方法数据的布局" class="headerlink" title="调用方法数据的布局"></a>调用方法数据的布局</h2><p>当部署Solidity合同并从账户调用时，假定输入数据采用<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi" target="_blank" rel="noopener">ABI规范</a>中的格式。ABI规范要求将参数填充为32个字节的倍数。内部函数调用使用不同的约定。</p>
<h2 id="内部-清理变量"><a href="#内部-清理变量" class="headerlink" title="内部 - 清理变量"></a>内部 - 清理变量</h2><p>当某个值小于256位时，在某些情况下必须清除其余的位。Solidity编译器的设计就是在任何可能受其余位中潜在垃圾影响的操作之前清除这些剩余位。例如，在将值写入内存之前，需要清除其余位，因为内存内容可用于计算散列值或作为消息调用的数据发送。类似地，在将值存储在storage中之前，需要清除其余位，否则就会观察到乱码值。</p>
<p>另一方面，如果紧接着的操作不受影响，我们不清除这些位。例如，由于任何非零值被<code>JUMPI</code>指令认为是<code>true</code>，在值作为<code>JUMPI</code>指令条件之前，我们不会清除布尔值。</p>
<p>除了上面的设计原理外，Solidity编译器还会在输入数据加载到堆栈时清除输入数据。<b style="color:yellow">难道是使用懒清除方式？</b></p>
<p>不同类型的清理无效值的规则有所不同：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>有效值</th>
<th>无效值的意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>n个成员的枚举</td>
<td>0直到n-1</td>
<td>exception</td>
</tr>
<tr>
<td>bool</td>
<td>0或1</td>
<td>1</td>
</tr>
<tr>
<td>有符号整数</td>
<td>符号扩展的字</td>
<td>目前默默地包裹; 将来会有异常情况发生</td>
</tr>
<tr>
<td>无符号整数</td>
<td>更高位清零</td>
<td>目前默默地包裹; 将来会有异常情况发生</td>
</tr>
</tbody>
</table>
<h2 id="内部-优化器"><a href="#内部-优化器" class="headerlink" title="内部 - 优化器"></a>内部 - 优化器</h2><p>Solidity优化器在汇编上操作，所以它可以或者已经被其他语言使用。它在<code>JUMPs</code>和<code>JUMPDESTs</code>指令处分裂指令的序列使成为基本语句块。在这些语句块内部，分析指令，对堆栈、对内存、对storage的每个修改，都被记录为表达式，该表达式包括指令和基本上指向其他表达式的参数列表。现在主要想法是找到始终相等的表达式（在每个输入上）并将它们组合到一个表达式类中。优化器首先尝试在已知表达式的列表中查找每个新表达式。如果这不起作用，则表达式按照规则进行简化，规则像<code>constant + constant = sum_of_constants</code>或者<code>X * 1 = X</code>。由于这是递归完成的，所以如果第二个因子是一个更复杂的表达式，我们知道它总是会评估为1，那么我们也可以应用后一个规则。对存储和内存位置的修改必须删除有关存储和内存位置的认知（knowledge，我怎么翻译），这些认知并不是已知的不同：如果我们先写入位置x，然后写入位置y; 并且<code>x</code>和<code>y</code>都是输入变量，则第二个可能会覆盖第一个，所以我们实际上在我们写y值之后不知道在x处存储了什么。另一方面，如果表达式<code>x - y</code>的简化计算为非零常数，那么我们知道我们可以保存关于x中存储的内容的认知。</p>
<p>在这个过程结束时，我们知道最后哪些表达式必须在堆栈上，并且有一个内存和存储的修改的列表。这些信息与基本语句块一起存储并用于链接（link）它们。此外，关于堆栈，存储和内存配置的知识被转发到下一个语句块。如果我们知道所有<code>JUMP</code>和<code>JUMPI</code>指令的目标，我们可以构建一个完整的程序流程图。如果只有一个我们不知道的目标（原则上这可能发生，跳跃目标可以从输入中计算），我们必须消除关于语句块输入状态的所有认知，因为它可能是未知<code>JUMP</code>指令的目标。如果任何<code>JUMPI</code>指令被发现评估为常数的条件，则将其转换为无条件跳转。</p>
<p>作为最后一步，每个语句块中的代码都会完全重新生成。从语句块的结尾处的表达式创建依赖关系图，并且不是该图的一部分的每个操作都基本上被丢弃。现在生成的代码会按照原始代码中的顺序将修改应用于内存和存储（删除已发现不需要的修改），最后在堆栈中正确的位置生成需要的所有值。</p>
<p>这些步骤适用于每个基本语句块，如果较小，则新生成的代码将用作替换。如果分析过程中在<code>JUMPI</code>指令处分割了一个基本语句块并且条件评估为常量，根据常量的值替换<code>JUMPI</code>指令，因此代码类似于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 7;</span><br><span class="line">data[7] = 9;</span><br><span class="line">if (data[x] != x + 2)</span><br><span class="line">  return 2;</span><br><span class="line">else</span><br><span class="line">  return 1;</span><br></pre></td></tr></table></figure></p>
<p>被简化为也可以编译的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[7] = 9;</span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure></p>
<p>即使指令在开始时包含<code>jump</code>指令。</p>
<h2 id="源映射（就是源码hash）"><a href="#源映射（就是源码hash）" class="headerlink" title="源映射（就是源码hash）"></a>源映射（就是源码hash）</h2><p>作为AST输出的一部分，编译器提供AST中相应节点所代表的源代码范围。这可以用于各种用途，包括基于AST报告错误的静态分析工具和突出显示局部变量及其用途的调试工具。</p>
<p>此外，编译器还可以生成从字节码到生成该指令的源代码范围的映射。对于在字节码级别上运行的静态分析工具以及对于在调试器中显示源代码当前位置或者对于断点处理，这一点同样重要。</p>
<p>这两种源映射都使用整数标识符（其实就是句柄）来引用源文件。这些是通常称为<code>&quot;sourceList&quot;</code>的源文件列表中的常规数组索引，它是组合json(combined-json)和json / npm编译器输出的一部分。</p>
<p><b style="color:#6ab0de">注意: 对于与任何特定源文件没有关联的指令的情况，源映射分配一个整数标识符-1。这可能发生在编译器生成的内联汇编语句的字节代码段中。</b></p>
<p>AST内的源映射使用以下表示法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:l:f</span><br></pre></td></tr></table></figure></p>
<p>其中s是对于源文件的开始位置的字节偏移， l是在字节源范围的长度和f为上述的源索引。</p>
<p>字节码的源映射中的编码更复杂：它是一个由<code>s:l:f:j</code>组成以<code>;</code>分隔的列表。每个元素都对应一条指令，即不能使用字节偏移量，但必须使用指令偏移量（推送指令长于单个字节）。的字段<code>s</code>，<code>l</code>和<code>f</code>如上文，<code>j</code>可以是<code>i</code>，<code>o</code>或<code>-</code>标志着一个跳转指令是否进入函数，从函数返回或是一个例如一个循环一部分的常规跳转。</p>
<p>为了压缩这些源映射，尤其是字节码，使用以下规则：</p>
<ul>
<li>如果一个字段为空，则使用前一个元素的值。</li>
<li>如果缺少<code>:</code>，则以下所有字段均视为空。</li>
</ul>
<p>这意味着以下源映射表示相同的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span><br><span class="line">1:2:1;:9;2:1:2;;</span><br></pre></td></tr></table></figure></p>
<h2 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h2><ul>
<li>在数组上用<code>delete</code>以删除其所有元素。</li>
<li>对结构元素使用较短的类型并对它们进行排序，以便将短类型组合在一起。这可以降低gas成本，因为多种<code>SSTORE</code>操作可能合并为一种（<code>SSTORE</code>成本5000或20000，因此这是您想要优化的）。使用天gas价格估算器（启用优化器）来检查！</li>
<li>让你的状态变量公开 - 编译器会自动为你创建<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#visibility-and-getters" target="_blank" rel="noopener">getters</a>。</li>
<li>如果总是在函数开始的地方检查输入条件或状态，请尝试使用<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#modifiers" target="_blank" rel="noopener">函数修饰符</a>。</li>
<li>如果你的合约有一个调用<code>send</code>的函数，但你想使用内置的send函数，请使用<code>address(contractVariable).send(amount)</code>。</li>
<li>用一个赋值语句初始化storage结构： <code>x = MyStruct({a: 1, b: 2});</code></li>
</ul>
<p>注意：如果存储结构具有压缩打包的属性，请使用单独的赋值对其进行初始化：<code>x.a = 1; x.b = 2;</code>。通过这种方式，优化器可以一次更新存储，从而使赋值更便宜。</p>
<h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><h3 id="操作符的优先顺序"><a href="#操作符的优先顺序" class="headerlink" title="操作符的优先顺序"></a>操作符的优先顺序</h3><p>以下是按评估顺序列出的操作符的优先顺序。</p>
<table>
<thead>
<tr>
<th>优先权</th>
<th>描述</th>
<th>操作者</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>后缀增量和减量</td>
<td><code>++</code>，<code>--</code></td>
</tr>
<tr>
<td></td>
<td>new的表达</td>
<td><code>new &lt;typename&gt;</code></td>
</tr>
<tr>
<td></td>
<td>数组下标</td>
<td><code>&lt;array&gt;[&lt;index&gt;]</code></td>
</tr>
<tr>
<td></td>
<td>成员访问</td>
<td><code>&lt;object&gt;.&lt;member&gt;</code></td>
</tr>
<tr>
<td></td>
<td>函数样式的调用</td>
<td><code>&lt;func&gt;(&lt;args...&gt;)</code></td>
</tr>
<tr>
<td></td>
<td>括号</td>
<td><code>(&lt;statement&gt;)</code></td>
</tr>
<tr>
<td>2</td>
<td>前缀增量和减量</td>
<td><code>++</code>，<code>--</code></td>
</tr>
<tr>
<td></td>
<td>一元正负号</td>
<td><code>+</code>，<code>-</code></td>
</tr>
<tr>
<td></td>
<td>一元操作</td>
<td><code>delete</code></td>
</tr>
<tr>
<td></td>
<td>逻辑NOT</td>
<td><code>!</code></td>
</tr>
<tr>
<td></td>
<td>按位取反</td>
<td><code>~</code></td>
</tr>
<tr>
<td>3</td>
<td>幂</td>
<td><code>**</code></td>
</tr>
<tr>
<td>4</td>
<td>乘法，除法和模</td>
<td><code>*</code>，<code>/</code>，<code>%</code></td>
</tr>
<tr>
<td>5</td>
<td>加减</td>
<td><code>+</code>，<code>-</code></td>
</tr>
<tr>
<td>6</td>
<td>按位移位运算符</td>
<td><code>&lt;&lt;</code>，<code>&gt;&gt;</code></td>
</tr>
<tr>
<td>7</td>
<td>按位与</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>8</td>
<td>按位XOR</td>
<td><code>^</code></td>
</tr>
<tr>
<td>9</td>
<td>按位或</td>
<td>&#124;</td>
</tr>
<tr>
<td>10</td>
<td>不等式操作符</td>
<td><code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code></td>
</tr>
<tr>
<td>11</td>
<td>等于操作符</td>
<td><code>==</code>，<code>!=</code></td>
</tr>
<tr>
<td>12</td>
<td>逻辑AND</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>13</td>
<td>逻辑或</td>
<td>&#124;&#124;</td>
</tr>
<tr>
<td>14</td>
<td>三元操作符</td>
<td><code>&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;</code></td>
</tr>
<tr>
<td>15</td>
<td>赋值运算符</td>
<td><code>=</code>，&#124;=，<code>^=</code>，<code>&amp;=</code>，<code>&lt;&lt;=</code>， <code>&gt;&gt;=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>， <code>%=</code></td>
</tr>
<tr>
<td>16</td>
<td>逗号运算符</td>
<td><code>,</code></td>
</tr>
</tbody>
</table>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的散列 - 仅适用于256个最新块</li>
<li><code>block.coinbase(address)</code>：当前块矿工的地址</li>
<li><code>block.difficulty(uint)</code>：当前区块的困难度</li>
<li><code>block.gaslimit(uint)</code>：当前区块的gaslimit</li>
<li><code>block.number(uint)</code>：当前区块的块高</li>
<li><code>block.timestamp(uint)</code>：当前区块的时间戳</li>
<li><code>gasleft() returns (uint256)</code>：剩余的gas</li>
<li><code>msg.data(bytes)</code>：完成calldata</li>
<li><code>msg.gas(uint)</code>：剩余gas - 在版本0.4.21中弃用并将被替换为<code>gasleft()</code></li>
<li><code>msg.sender(address)</code>：消息的发起者（当前调用者）</li>
<li><code>msg.value(uint)</code>：与消息一起发送的以太币数量（单位：wei）</li>
<li><code>now(uint)</code>：当前块时间戳（别名为<code>block.timestamp</code>）</li>
<li><code>tx.gasprice(uint)</code>：交易的gas价格</li>
<li><code>tx.origin(address)</code>：交易的发起者（完整的调用链）</li>
<li><code>assert(bool condition)</code>：如果条件是<code>false</code>,中止执行并恢复状态更改（用于内部错误）</li>
<li><code>require(bool condition)</code>：如果条件是<code>false</code>中止执行并恢复状态更改（用于格式错误的输入或外部组件中的错误）</li>
<li><code>revert()</code>：中止执行并恢复状态更改</li>
<li><code>keccak256(...) returns (bytes32)</code>：计算（紧密排列）参数的Ethereum-SHA-3（Keccak-256）散列</li>
<li><code>sha3(...) returns (bytes32)</code>：<code>keccak256</code>的别名 </li>
<li><code>sha256(...) returns (bytes32)</code>：计算（紧密排列）参数的SHA-256哈希值</li>
<li><code>ripemd160(...) returns (bytes20)</code>：计算（紧密排列）参数的RIPEMD-160哈希值</li>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：从椭圆曲线签名中恢复与公钥相关的地址，错误时返回零</li>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code>：计算<code>(x + y) % k</code>以任意精度执行加法的位置，并且不会在<code>2**256</code>环绕。断言<code>k != 0</code>从0.5.0版开始。</li>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：计算<code>(x * y) % k</code>以任意精度执行乘法的位置，并且不会在<code>2**256</code>绕回。断言<code>k != 0</code>从0.5.0版开始。</li>
<li><code>this</code>(当前合同的类型)：当前合约，明确转换为address</li>
<li><code>super</code>：继承层次结构高一级的合约</li>
<li><code>selfdestruct(address recipient)</code>：销毁当前的合约，将资金发送到给定的地址</li>
<li><code>suicide(address recipient)</code>：<code>selfdestruct</code>的别名 </li>
<li><code>&lt;address&gt;.balance(uint256)</code>：地址的余额（单位：wei）</li>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：发送指定地址相应数量的以太币，失败时返回false</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>：发送给地址指定数量的以太币，失败抛出异常</li>
</ul>
<h3 id="函数可见性说明符"><a href="#函数可见性说明符" class="headerlink" title="函数可见性说明符"></a>函数可见性说明符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &lt;visibility specifier&gt; returns (bool) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>public</code>：在外部和内部可见（为存储/状态变量创建一个<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#getter-functions" target="_blank" rel="noopener">getter函数</a>）</li>
<li><code>private</code>：只在当前合约中可见</li>
<li><code>external</code>：仅在外部可见（仅用于函数） - 即只能通过消息调用（通过<code>this.func</code>）</li>
<li><code>internal</code>：只在内部可见</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li><code>pure</code> 对于函数：禁止修改或访问状态 - 这还没有强制执行。</li>
<li><code>view</code> 函数：不允许修改状态 - 这还没有强制执行。</li>
<li><code>payable</code> 函数：允许他们在收到调用的同时接收Ether。</li>
<li><code>constant</code> 对于状态变量：禁止分配（初始化除外），不占用存储槽。</li>
<li><code>constant</code> 用于函数：与<code>view</code>相同。</li>
<li><code>anonymous</code> 事件：不将事件签名存储为主题。</li>
<li><code>indexed</code> 用于事件参数：将参数存储为主题。</li>
</ul>
<h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><p>这些关键字保留在Solidity中。它们可能成为未来语法的一部分：</p>
<p><code>abstract</code>，<code>after</code>，<code>case</code>，<code>catch</code>，<code>default</code>，<code>final</code>，<code>in</code>，<code>inline</code>，<code>let</code>，<code>match</code>，<code>null</code>， <code>of</code>，<code>relocatable</code>，<code>static</code>，<code>switch</code>，<code>try</code>，<code>type</code>，<code>typeof</code>。</p>
<h3 id="语言语法"><a href="#语言语法" class="headerlink" title="语言语法"></a>语言语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*</span><br><span class="line"></span><br><span class="line">// Pragma actually parses anything up to the trailing &apos;;&apos; to be fully forward-compatible.</span><br><span class="line">PragmaDirective = &apos;pragma&apos; Identifier ([^;]+) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ImportDirective = &apos;import&apos; StringLiteral (&apos;as&apos; Identifier)? &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; (&apos;*&apos; | Identifier) (&apos;as&apos; Identifier)? &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; &apos;&#123;&apos; Identifier (&apos;as&apos; Identifier)? ( &apos;,&apos; Identifier (&apos;as&apos; Identifier)? )* &apos;&#125;&apos; &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ContractDefinition = ( &apos;contract&apos; | &apos;library&apos; | &apos;interface&apos; ) Identifier</span><br><span class="line">                     ( &apos;is&apos; InheritanceSpecifier (&apos;,&apos; InheritanceSpecifier )* )?</span><br><span class="line">                     &apos;&#123;&apos; ContractPart* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ContractPart = StateVariableDeclaration | UsingForDeclaration</span><br><span class="line">             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition</span><br><span class="line"></span><br><span class="line">InheritanceSpecifier = UserDefinedTypeName ( &apos;(&apos; Expression ( &apos;,&apos; Expression )* &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">StateVariableDeclaration = TypeName ( &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; | &apos;constant&apos; )? Identifier (&apos;=&apos; Expression)? &apos;;&apos;</span><br><span class="line">UsingForDeclaration = &apos;using&apos; Identifier &apos;for&apos; (&apos;*&apos; | TypeName) &apos;;&apos;</span><br><span class="line">StructDefinition = &apos;struct&apos; Identifier &apos;&#123;&apos;</span><br><span class="line">                     ( VariableDeclaration &apos;;&apos; (VariableDeclaration &apos;;&apos;)* )? &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ModifierDefinition = &apos;modifier&apos; Identifier ParameterList? Block</span><br><span class="line">ModifierInvocation = Identifier ( &apos;(&apos; ExpressionList? &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">FunctionDefinition = &apos;function&apos; Identifier? ParameterList</span><br><span class="line">                     ( ModifierInvocation | StateMutability | &apos;external&apos; | &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; )*</span><br><span class="line">                     ( &apos;returns&apos; ParameterList )? ( &apos;;&apos; | Block )</span><br><span class="line">EventDefinition = &apos;event&apos; Identifier EventParameterList &apos;anonymous&apos;? &apos;;&apos;</span><br><span class="line"></span><br><span class="line">EnumValue = Identifier</span><br><span class="line">EnumDefinition = &apos;enum&apos; Identifier &apos;&#123;&apos; EnumValue? (&apos;,&apos; EnumValue)* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ParameterList = &apos;(&apos; ( Parameter (&apos;,&apos; Parameter)* )? &apos;)&apos;</span><br><span class="line">Parameter = TypeName StorageLocation? Identifier?</span><br><span class="line"></span><br><span class="line">EventParameterList = &apos;(&apos; ( EventParameter (&apos;,&apos; EventParameter )* )? &apos;)&apos;</span><br><span class="line">EventParameter = TypeName &apos;indexed&apos;? Identifier?</span><br><span class="line"></span><br><span class="line">FunctionTypeParameterList = &apos;(&apos; ( FunctionTypeParameter (&apos;,&apos; FunctionTypeParameter )* )? &apos;)&apos;</span><br><span class="line">FunctionTypeParameter = TypeName StorageLocation?</span><br><span class="line"></span><br><span class="line">// semantic restriction: mappings and structs (recursively) containing mappings</span><br><span class="line">// are not allowed in argument lists</span><br><span class="line">VariableDeclaration = TypeName StorageLocation? Identifier</span><br><span class="line"></span><br><span class="line">TypeName = ElementaryTypeName</span><br><span class="line">         | UserDefinedTypeName</span><br><span class="line">         | Mapping</span><br><span class="line">         | ArrayTypeName</span><br><span class="line">         | FunctionTypeName</span><br><span class="line"></span><br><span class="line">UserDefinedTypeName = Identifier ( &apos;.&apos; Identifier )*</span><br><span class="line"></span><br><span class="line">Mapping = &apos;mapping&apos; &apos;(&apos; ElementaryTypeName &apos;=&gt;&apos; TypeName &apos;)&apos;</span><br><span class="line">ArrayTypeName = TypeName &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line">FunctionTypeName = &apos;function&apos; FunctionTypeParameterList ( &apos;internal&apos; | &apos;external&apos; | StateMutability )*</span><br><span class="line">                   ( &apos;returns&apos; FunctionTypeParameterList )?</span><br><span class="line">StorageLocation = &apos;memory&apos; | &apos;storage&apos;</span><br><span class="line">StateMutability = &apos;pure&apos; | &apos;constant&apos; | &apos;view&apos; | &apos;payable&apos;</span><br><span class="line"></span><br><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |</span><br><span class="line">            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |</span><br><span class="line">              Throw | EmitStatement | SimpleStatement ) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ExpressionStatement = Expression</span><br><span class="line">IfStatement = &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Statement ( &apos;else&apos; Statement )?</span><br><span class="line">WhileStatement = &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; Statement</span><br><span class="line">PlaceholderStatement = &apos;_&apos;</span><br><span class="line">SimpleStatement = VariableDefinition | ExpressionStatement</span><br><span class="line">ForStatement = &apos;for&apos; &apos;(&apos; (SimpleStatement)? &apos;;&apos; (Expression)? &apos;;&apos; (ExpressionStatement)? &apos;)&apos; Statement</span><br><span class="line">InlineAssemblyStatement = &apos;assembly&apos; StringLiteral? InlineAssemblyBlock</span><br><span class="line">DoWhileStatement = &apos;do&apos; Statement &apos;while&apos; &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">Continue = &apos;continue&apos;</span><br><span class="line">Break = &apos;break&apos;</span><br><span class="line">Return = &apos;return&apos; Expression?</span><br><span class="line">Throw = &apos;throw&apos;</span><br><span class="line">EmitStatement = &apos;emit&apos; FunctionCall</span><br><span class="line">VariableDefinition = (&apos;var&apos; IdentifierList | VariableDeclaration) ( &apos;=&apos; Expression )?</span><br><span class="line">IdentifierList = &apos;(&apos; ( Identifier? &apos;,&apos; )* Identifier? &apos;)&apos;</span><br><span class="line"></span><br><span class="line">// Precedence by order (see github.com/ethereum/solidity/pull/732)</span><br><span class="line">Expression</span><br><span class="line">  = Expression (&apos;++&apos; | &apos;--&apos;)</span><br><span class="line">  | NewExpression</span><br><span class="line">  | IndexAccess</span><br><span class="line">  | MemberAccess</span><br><span class="line">  | FunctionCall</span><br><span class="line">  | &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">  | (&apos;!&apos; | &apos;~&apos; | &apos;delete&apos; | &apos;++&apos; | &apos;--&apos; | &apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression &apos;**&apos; Expression</span><br><span class="line">  | Expression (&apos;*&apos; | &apos;/&apos; | &apos;%&apos;) Expression</span><br><span class="line">  | Expression (&apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression (&apos;&lt;&lt;&apos; | &apos;&gt;&gt;&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;^&apos; Expression</span><br><span class="line">  | Expression &apos;|&apos; Expression</span><br><span class="line">  | Expression (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;) Expression</span><br><span class="line">  | Expression (&apos;==&apos; | &apos;!=&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;||&apos; Expression</span><br><span class="line">  | Expression &apos;?&apos; Expression &apos;:&apos; Expression</span><br><span class="line">  | Expression (&apos;=&apos; | &apos;|=&apos; | &apos;^=&apos; | &apos;&amp;=&apos; | &apos;&lt;&lt;=&apos; | &apos;&gt;&gt;=&apos; | &apos;+=&apos; | &apos;-=&apos; | &apos;*=&apos; | &apos;/=&apos; | &apos;%=&apos;) Expression</span><br><span class="line">  | PrimaryExpression</span><br><span class="line"></span><br><span class="line">PrimaryExpression = BooleanLiteral</span><br><span class="line">                  | NumberLiteral</span><br><span class="line">                  | HexLiteral</span><br><span class="line">                  | StringLiteral</span><br><span class="line">                  | TupleExpression</span><br><span class="line">                  | Identifier</span><br><span class="line">                  | ElementaryTypeNameExpression</span><br><span class="line"></span><br><span class="line">ExpressionList = Expression ( &apos;,&apos; Expression )*</span><br><span class="line">NameValueList = Identifier &apos;:&apos; Expression ( &apos;,&apos; Identifier &apos;:&apos; Expression )*</span><br><span class="line"></span><br><span class="line">FunctionCall = Expression &apos;(&apos; FunctionCallArguments &apos;)&apos;</span><br><span class="line">FunctionCallArguments = &apos;&#123;&apos; NameValueList? &apos;&#125;&apos;</span><br><span class="line">                      | ExpressionList?</span><br><span class="line"></span><br><span class="line">NewExpression = &apos;new&apos; TypeName</span><br><span class="line">MemberAccess = Expression &apos;.&apos; Identifier</span><br><span class="line">IndexAccess = Expression &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">BooleanLiteral = &apos;true&apos; | &apos;false&apos;</span><br><span class="line">NumberLiteral = ( HexNumber | DecimalNumber ) (&apos; &apos; NumberUnit)?</span><br><span class="line">NumberUnit = &apos;wei&apos; | &apos;szabo&apos; | &apos;finney&apos; | &apos;ether&apos;</span><br><span class="line">           | &apos;seconds&apos; | &apos;minutes&apos; | &apos;hours&apos; | &apos;days&apos; | &apos;weeks&apos; | &apos;years&apos;</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*</span><br><span class="line"></span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+ ( &apos;.&apos; [0-9]* )? ( [eE] [0-9]+ )?</span><br><span class="line"></span><br><span class="line">TupleExpression = &apos;(&apos; ( Expression? ( &apos;,&apos; Expression? )*  )? &apos;)&apos;</span><br><span class="line">                | &apos;[&apos; ( Expression  ( &apos;,&apos; Expression  )*  )? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">ElementaryTypeNameExpression = ElementaryTypeName</span><br><span class="line"></span><br><span class="line">ElementaryTypeName = &apos;address&apos; | &apos;bool&apos; | &apos;string&apos; | &apos;var&apos;</span><br><span class="line">                   | Int | Uint | Byte | Fixed | Ufixed</span><br><span class="line"></span><br><span class="line">Int = &apos;int&apos; | &apos;int8&apos; | &apos;int16&apos; | &apos;int24&apos; | &apos;int32&apos; | &apos;int40&apos; | &apos;int48&apos; | &apos;int56&apos; | &apos;int64&apos; | &apos;int72&apos; | &apos;int80&apos; | &apos;int88&apos; | &apos;int96&apos; | &apos;int104&apos; | &apos;int112&apos; | &apos;int120&apos; | &apos;int128&apos; | &apos;int136&apos; | &apos;int144&apos; | &apos;int152&apos; | &apos;int160&apos; | &apos;int168&apos; | &apos;int176&apos; | &apos;int184&apos; | &apos;int192&apos; | &apos;int200&apos; | &apos;int208&apos; | &apos;int216&apos; | &apos;int224&apos; | &apos;int232&apos; | &apos;int240&apos; | &apos;int248&apos; | &apos;int256&apos;</span><br><span class="line"></span><br><span class="line">Uint = &apos;uint&apos; | &apos;uint8&apos; | &apos;uint16&apos; | &apos;uint24&apos; | &apos;uint32&apos; | &apos;uint40&apos; | &apos;uint48&apos; | &apos;uint56&apos; | &apos;uint64&apos; | &apos;uint72&apos; | &apos;uint80&apos; | &apos;uint88&apos; | &apos;uint96&apos; | &apos;uint104&apos; | &apos;uint112&apos; | &apos;uint120&apos; | &apos;uint128&apos; | &apos;uint136&apos; | &apos;uint144&apos; | &apos;uint152&apos; | &apos;uint160&apos; | &apos;uint168&apos; | &apos;uint176&apos; | &apos;uint184&apos; | &apos;uint192&apos; | &apos;uint200&apos; | &apos;uint208&apos; | &apos;uint216&apos; | &apos;uint224&apos; | &apos;uint232&apos; | &apos;uint240&apos; | &apos;uint248&apos; | &apos;uint256&apos;</span><br><span class="line"></span><br><span class="line">Byte = &apos;byte&apos; | &apos;bytes&apos; | &apos;bytes1&apos; | &apos;bytes2&apos; | &apos;bytes3&apos; | &apos;bytes4&apos; | &apos;bytes5&apos; | &apos;bytes6&apos; | &apos;bytes7&apos; | &apos;bytes8&apos; | &apos;bytes9&apos; | &apos;bytes10&apos; | &apos;bytes11&apos; | &apos;bytes12&apos; | &apos;bytes13&apos; | &apos;bytes14&apos; | &apos;bytes15&apos; | &apos;bytes16&apos; | &apos;bytes17&apos; | &apos;bytes18&apos; | &apos;bytes19&apos; | &apos;bytes20&apos; | &apos;bytes21&apos; | &apos;bytes22&apos; | &apos;bytes23&apos; | &apos;bytes24&apos; | &apos;bytes25&apos; | &apos;bytes26&apos; | &apos;bytes27&apos; | &apos;bytes28&apos; | &apos;bytes29&apos; | &apos;bytes30&apos; | &apos;bytes31&apos; | &apos;bytes32&apos;</span><br><span class="line"></span><br><span class="line">Fixed = &apos;fixed&apos; | ( &apos;fixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">Ufixed = &apos;ufixed&apos; | ( &apos;ufixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">InlineAssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">AssemblyItem = Identifier | FunctionalAssemblyExpression | InlineAssemblyBlock | AssemblyLocalBinding | AssemblyAssignment | AssemblyLabel | NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">AssemblyLocalBinding = &apos;let&apos; Identifier &apos;:=&apos; FunctionalAssemblyExpression</span><br><span class="line">AssemblyAssignment = ( Identifier &apos;:=&apos; FunctionalAssemblyExpression ) | ( &apos;=:&apos; Identifier )</span><br><span class="line">AssemblyLabel = Identifier &apos;:&apos;</span><br><span class="line">FunctionalAssemblyExpression = Identifier &apos;(&apos; AssemblyItem? ( &apos;,&apos; AssemblyItem )* &apos;)&apos;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/04/blockchain/solidity汇编/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/blockchain/solidity汇编/" itemprop="url">solidity汇编</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T17:58:04+08:00">2018-04-04</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<p>Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。</p>
<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由于EVM是堆栈机，因此通常很难解决正确的堆栈插槽问题，并为堆栈上正确的操作码提供参数。Solidity的内联汇编试图通过以下功能来促进编写手动汇编时出现的问题和其他问题：</p>
<ul>
<li>方法样式的操作码：<code>mul(1, add(2, 3))</code>替换<code>push1 3 push1 2 add push1 1 mul</code>.</li>
<li>装配局部变量：<code>let x := add(2, 3)  let y := mload(0x40)  x := add(x, y)</code></li>
<li>访问外部变量： <code>function f(uint x) public { assembly { x := sub(x, 1) } }</code></li>
<li>标签： <code>let x := 10  repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li>
<li>循环： <code>for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }</code></li>
<li>if语句： <code>if slt(x, 0) { x := sub(0, x) }</code></li>
<li>switch语句： <code>switch x case 0 { y := mul(x, 2) } default { y := 0 }</code></li>
<li>函数调用： <code>function f(x) -&gt; y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) }   }</code></li>
</ul>
<p>我们现在要详细描述内联汇编语言。</p>
<p><b style="color:#6ab0de">警告: 内联汇编是一种在低级别访问以太坊虚拟机的方法。这丢弃了Solidity的几个重要的安全特征。</b></p>
<p><b style="color:#6ab0de">注意: TODO：写下内联汇编的作用域规则如何有点不同并且例如使用库的内部函数时出现的复杂情况。此外，编写有关编译器定义的符号。</b></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例提供了库代码以访问另一个合同的代码并将其加载到bytes变量中。这对于“普通的solidity”来说根本不可能，并且这个想法是用组装库的方式来增强语言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">library GetCode &#123;</span><br><span class="line">    function at(address _addr) public view returns (bytes o_code) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // retrieve the size of the code, this needs assembly</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line">            // allocate output byte array - this could also be done without assembly</span><br><span class="line">            // by using o_code = new bytes(size)</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line">            // new &quot;memory end&quot; including padding</span><br><span class="line">            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            // store length in memory</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line">            // actually retrieve the code, this needs assembly</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在优化器无法生成高效代码的情况下，内联汇编也可能有所帮助。请注意，由于编译器不执行检查，所以汇编更难以编写，因此只有在您确实知道自己在做什么时才应该将它用于复杂的事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // This function is less efficient because the optimizer currently fails to</span><br><span class="line">    // remove the bounds checks in array access.</span><br><span class="line">    function sumSolidity(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i)</span><br><span class="line">            o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know that we only access the array in bounds, so we can avoid the check.</span><br><span class="line">    // 0x20 needs to be added to an array because the first slot contains the</span><br><span class="line">    // array length.</span><br><span class="line">    function sumAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Same as above, but accomplish the entire code within inline assembly.</span><br><span class="line">    function sumPureAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">           // Load the length (first 32 bytes)</span><br><span class="line">           let len := mload(_data)</span><br><span class="line"></span><br><span class="line">           // Skip over the length field.</span><br><span class="line">           //</span><br><span class="line">           // Keep temporary variable so it can be incremented in place.</span><br><span class="line">           //</span><br><span class="line">           // NOTE: incrementing _data would result in an unusable</span><br><span class="line">           //       _data variable after this assembly block</span><br><span class="line">           let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">           // Iterate until the bound is not met.</span><br><span class="line">           for</span><br><span class="line">               &#123; let end := add(data, len) &#125;</span><br><span class="line">               lt(data, end)</span><br><span class="line">               &#123; data := add(data, 0x20) &#125;</span><br><span class="line">           &#123;</span><br><span class="line">               o_sum := add(o_sum, mload(data))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h3><p>Assembly会像Solidity一样解析注释，文字和标识符，因此您可以使用常规的<code>//</code>和<code>/* */</code>进行注释。内联汇编集<code>assembly { ... }</code>在这些花括号内标记，并且可以使用以下内容（请参阅后面的章节以获取更多详细信息）。</p>
<ul>
<li>文字，例如<code>0x123</code>，<code>42</code>或<code>&quot;abc&quot;</code>（最多32个字符的字符串）</li>
<li>操作码（在“指令样式”中），例如<code>mload sload dup1 sstore</code>，列表见下文.</li>
<li>方法风格的操作码，例如 <code>add(1, mlod(0))</code></li>
<li>标签，例如 <code>name:</code></li>
<li>变量声明，例如<code>let x := 7</code>，<code>let x := add(y, 3)</code>或<code>let x</code>（被分配初始值空（0））</li>
<li>标识符（如果用作内联汇编，则为标签、汇编局部变量和外部），例如<code>jump(name)</code>，<code>3 x add</code></li>
<li>赋值（以“指令风格”），例如 <code>3 =: x</code></li>
<li>函数风格的赋值，例如 <code>x := add(y, 3)</code></li>
<li>局部变量作用域范围的块，例如 <code>{ let x := 3 { let y := add(x, 1) } }</code></li>
</ul>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>本文档不希望成为以太坊虚拟机的完整描述，但下面的列表可用作其操作码的指南。</p>
<p>如果一个操作码需要参数（总是从栈顶开始），它们会在括号中给出。请注意，参数的顺序可以被看作是在不是函数风格中被颠倒（下面会解释）。<code>-</code>标记的操作码不会向堆上压项目，标记<code>*</code>的操作码是特殊的，所有其他操作符都只能将一个项目压入到堆栈中。标有<code>F</code>，<code>H</code>，<code>B</code>或<code>C</code>的操作码表明自从Frontier，Homestead, Byzantium or Constantinople开始就有了。Constantinople仍处于规划之中，所有标记如此的指令都将导致无效的指令异常。</p>
<p>在下文中，<code>mem[a...b)</code>表示从位置<code>a</code>直到（不包括）位置<code>b</code>的内存字节，<code>storage[p]</code>表示<code>storage</code>在p处的内容。</p>
<p>该操作码<code>pushi</code>和<code>jumpdest</code>不能直接使用。</p>
<p>在语法中，操作码被表示为预定义的标识符。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th></th>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop</td>
<td>-</td>
<td>F</td>
<td>停止执行，与<code>return(0,0)</code>相同</td>
</tr>
<tr>
<td>add(x, y)</td>
<td></td>
<td>F</td>
<td>x + y</td>
</tr>
<tr>
<td>sub(x, y)</td>
<td></td>
<td>F</td>
<td>x - y</td>
</tr>
<tr>
<td>mul(x, y)</td>
<td></td>
<td>F</td>
<td>x * y</td>
</tr>
<tr>
<td>div(x, y)</td>
<td></td>
<td>F</td>
<td>x / y</td>
</tr>
<tr>
<td>sdiv(x，y)</td>
<td></td>
<td>F</td>
<td>x / y，用于补码中的有符号数</td>
</tr>
<tr>
<td>mod(x，y)</td>
<td></td>
<td>F</td>
<td>x％y</td>
</tr>
<tr>
<td>smod(x，y)</td>
<td></td>
<td>F</td>
<td>x％y，用于补码中的有符号数</td>
</tr>
<tr>
<td>exp(x，y)</td>
<td></td>
<td>F</td>
<td>x对y的幂</td>
</tr>
<tr>
<td>not(x)</td>
<td></td>
<td>F</td>
<td>〜x，x的每一位都是取反的</td>
</tr>
<tr>
<td>lt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&lt;y,值为1，否则为0</td>
</tr>
<tr>
<td>gt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&gt;y,值为1，否则为0</td>
</tr>
<tr>
<td>slt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>sgt(x, y)</td>
<td></td>
<td>F</td>
<td>如果x&gt;y，值为1，否则为0，用于补码中的有符号数</td>
</tr>
<tr>
<td>eq(x, y)</td>
<td></td>
<td>F</td>
<td>如果x == y, 为1，否则为0</td>
</tr>
<tr>
<td>iszero(x)</td>
<td></td>
<td>F</td>
<td>如果x == 0，为1，否则为0</td>
</tr>
<tr>
<td>and(x, y)</td>
<td></td>
<td>F</td>
<td>x和y按位与</td>
</tr>
<tr>
<td>or(x, y)</td>
<td></td>
<td>F</td>
<td>x和y按位或</td>
</tr>
<tr>
<td>xor(x, y)</td>
<td></td>
<td>F</td>
<td>x和y的按位异或</td>
</tr>
<tr>
<td>byte(n, x)</td>
<td></td>
<td>F</td>
<td>x的第n个字节，其中最高有效字节是第0字节</td>
</tr>
<tr>
<td>shl(x, y)</td>
<td></td>
<td>C</td>
<td>y逻辑左移x位</td>
</tr>
<tr>
<td>shr(x, y)</td>
<td></td>
<td>C</td>
<td>y逻辑右移x位</td>
</tr>
<tr>
<td>sar(x, y)</td>
<td></td>
<td>C</td>
<td>y算术右移x位</td>
</tr>
<tr>
<td>addmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>（x + y）％ m以任意精确算术</td>
</tr>
<tr>
<td>mulmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>（x * y）％m以任意精确算术</td>
</tr>
<tr>
<td>signextend(i, x)</td>
<td></td>
<td>F</td>
<td>符号从最低有效位（i*8 + 7）位开始计数</td>
</tr>
<tr>
<td>keccak256(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>sha3(p, n)</td>
<td></td>
<td>F</td>
<td><code>keccak(mem[p…(p+n)))</code></td>
</tr>
<tr>
<td>jump(label)</td>
<td>-</td>
<td>F</td>
<td>跳转到标签/代码位置</td>
</tr>
<tr>
<td>jumpi(label, cond)</td>
<td>-</td>
<td>F</td>
<td>如果cond不为零，则跳转到标签</td>
</tr>
<tr>
<td>pc</td>
<td></td>
<td>F</td>
<td>代码中的当前位置</td>
</tr>
<tr>
<td>pop(x)</td>
<td>-</td>
<td>F</td>
<td>弹出x个栈顶元素</td>
</tr>
<tr>
<td>dup1…dup16</td>
<td></td>
<td>F</td>
<td>将第i个堆栈槽复制到顶部（从顶部开始计数）</td>
</tr>
<tr>
<td>swap1…swap16</td>
<td>*</td>
<td>F</td>
<td>交换栈顶和在其下面的第i个栈槽</td>
</tr>
<tr>
<td>mload(p)</td>
<td></td>
<td>F</td>
<td><code>mem[p..(p+32))</code></td>
</tr>
<tr>
<td>mstore(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p..(p+32)) := v</code></td>
</tr>
<tr>
<td>mstore8(p, v)</td>
<td>-</td>
<td>F</td>
<td><code>mem[p] := v &amp; 0xff</code>（仅修改单个字节）</td>
</tr>
<tr>
<td>sload(p)</td>
<td></td>
<td>F</td>
<td>storage[p]</td>
</tr>
<tr>
<td>sstore(p, v)</td>
<td>-</td>
<td>F</td>
<td>storage[p] := v</td>
</tr>
<tr>
<td>msize</td>
<td></td>
<td>F</td>
<td>内存大小，即最大的访问内存索引</td>
</tr>
<tr>
<td>gas</td>
<td></td>
<td>F</td>
<td>仍然可以用于执行的gas</td>
</tr>
<tr>
<td>address</td>
<td></td>
<td>F</td>
<td>当前合同/执行上下文的地址</td>
</tr>
<tr>
<td>balance(a)</td>
<td></td>
<td>F</td>
<td>地址a的账户余额（wei）</td>
</tr>
<tr>
<td>caller</td>
<td></td>
<td>F</td>
<td>调用者（不含delegatecall）</td>
</tr>
<tr>
<td>callvalue</td>
<td></td>
<td>F</td>
<td>目前的调用一起发送的以太币（wei）</td>
</tr>
<tr>
<td>calldataload(p)</td>
<td></td>
<td>F</td>
<td>从位置p开始的调用数据（32字节）</td>
</tr>
<tr>
<td>calldatasize</td>
<td></td>
<td>F</td>
<td>调用数据的大小，以字节为单位</td>
</tr>
<tr>
<td>calldatacopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从calldata数据位置f复制s个字节到mem的位置t开始的位置</td>
</tr>
<tr>
<td>codesize</td>
<td></td>
<td>F</td>
<td>当前合同/执行上下文的代码大小</td>
</tr>
<tr>
<td>codecopy(t, f, s)</td>
<td>-</td>
<td>F</td>
<td>从位置f的代码复制s字节到mem的位置t</td>
</tr>
<tr>
<td>extcodesize(a)</td>
<td></td>
<td>F</td>
<td>地址a处代码的大小</td>
</tr>
<tr>
<td>extcodecopy(a, t, f, s)</td>
<td>-</td>
<td>F</td>
<td>像<code>codecopy(t, f, s)</code>，但是从地址a处获取代码</td>
</tr>
<tr>
<td>returndatasize</td>
<td></td>
<td>B</td>
<td>最近一次返回数据的大小</td>
</tr>
<tr>
<td>returndatacopy(t, f, s)</td>
<td>-</td>
<td>B</td>
<td>将返回数据f位置的字节复制到t位置的mem</td>
</tr>
<tr>
<td>create(v, p, s)</td>
<td></td>
<td>F</td>
<td>用代码mem[p..(p + s))创建新的合约并发送v wei以太币并返回新的地址</td>
</tr>
<tr>
<td>create2(v, n, p, s)</td>
<td></td>
<td>C</td>
<td>在地址<code>keccak256(&lt;address&gt; . n . keccak256(mem[p..(p+s)))</code> 创建与代码mem[p..(p + s))的新合约并发送v wei并返回新地址</td>
</tr>
<tr>
<td>call(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>在输入mem[in..(in + insize))时提供g gas和v wei以及输出区mem[out..(out + oversize))，在地址a处调用合约，并在错误时返回0,1代表成功</td>
</tr>
<tr>
<td>callcode(g, a, v, in, insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>与<code>call</code>相同，但只能使用地址a的代码，否则保留在当前合约的上下文中</td>
</tr>
<tr>
<td>delegatecall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>H</td>
<td>与<code>callcode</code>相同，但也保持<code>caller</code> 和<code>callvalue</code></td>
</tr>
<tr>
<td>staticcall(g, a, in, insize, out, outsize)</td>
<td></td>
<td>B</td>
<td>与<code>call(g, a, 0, in, insize, out, outsize)</code>相同, 但不允许状态修改</td>
</tr>
<tr>
<td>return(p, s)</td>
<td>-</td>
<td>F</td>
<td>结束执行，返回数据mem[p..(p + s))</td>
</tr>
<tr>
<td>revert(p, s)</td>
<td>-</td>
<td>B</td>
<td>结束执行，恢复状态更改，返回数据mem[p..(p + s))</td>
</tr>
<tr>
<td>selfdestruct(a)</td>
<td>-</td>
<td>F</td>
<td>终止执行，摧毁当前合同并将资金发送给地址a</td>
</tr>
<tr>
<td>invalid</td>
<td>-</td>
<td>F</td>
<td>用无效指令结束执行</td>
</tr>
<tr>
<td>log0(p, s)</td>
<td>-</td>
<td>F</td>
<td>没有主题和mem[p..(p + s))的数据的日志</td>
</tr>
<tr>
<td>log1(p, s, t1)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1和mem[p..(p + s))的数据</td>
</tr>
<tr>
<td>log2(p, s, t1, t2)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>log3(p, s, t1, t2, t3)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2，t3和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>log4(p, s, t1, t2, t3, t4)</td>
<td>-</td>
<td>F</td>
<td>记录主题t1，t2，t3，t4和数据mem[p..(p + s))</td>
</tr>
<tr>
<td>origin</td>
<td></td>
<td>F</td>
<td>交易发送者</td>
</tr>
<tr>
<td>gasprice</td>
<td></td>
<td>F</td>
<td>交易的gas价格</td>
</tr>
<tr>
<td>blockhash(b)</td>
<td></td>
<td>F</td>
<td>块b的散列值 - 仅适用于不包括当前值的最后256个块</td>
</tr>
<tr>
<td>coinbase</td>
<td></td>
<td>F</td>
<td>目前的采矿受益者</td>
</tr>
<tr>
<td>timestamp</td>
<td></td>
<td>F</td>
<td>当前块的时间戳，以秒为单位</td>
</tr>
<tr>
<td>number</td>
<td></td>
<td>F</td>
<td>当前区块高度</td>
</tr>
<tr>
<td>difficulty</td>
<td></td>
<td>F</td>
<td>当前块的难度</td>
</tr>
<tr>
<td>gaslimit</td>
<td></td>
<td>F</td>
<td>当前块的区块gas限制</td>
</tr>
</tbody>
</table>
<h3 id="字面Literals"><a href="#字面Literals" class="headerlink" title="字面Literals"></a>字面Literals</h3><p>您可以使用十进制或十六进制符号键入整数常量，这会自动生成相应的<code>PUSHi</code>指令。下面创建代码，将2和3加起来得到5，然后与字符串“abc”进行按位与计算。字符串存储为左对齐，不能超过32个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; 2 3 add &quot;abc&quot; and &#125;</span><br></pre></td></tr></table></figure></p>
<p>译者注：这个看起来像比特币的脚本语言有木有。（基于堆栈的脚本语言，也就是说solidity的底层实现有点像比特币脚本，只是支持跳转语句而已）。</p>
<h3 id="函数风格"><a href="#函数风格" class="headerlink" title="函数风格"></a>函数风格</h3><p>您可以在操作码之后键入操作码，它们将以字节码结尾。例如将内存中在位置0x80处的数据加3，将是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0x80 mload add 0x80 mstore</span><br></pre></td></tr></table></figure></p>
<p>由于通常很难看到某些操作码的实际参数是什么，所以Solidity内联汇编还提供了一种“函数风格”表示法，其中相同的代码可如下编写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(0x80, add(mload(0x80), 3))</span><br></pre></td></tr></table></figure></p>
<p>函数风格表达式不能在内部使用函数风格，例如<code>1 2 mstore(0x80, add)</code>不是有效的程序，它必须写成<code>mstore(0x80, add(2, 1))</code>。对于不带参数的操作码，括号可以省略。</p>
<p><b style="color:red">请注意，参数的顺序在函数风格中与指令风格完全相反</b>。如果使用函数风格，第一个参数将会在堆栈顶部结束。</p>
<h3 id="访问外部变量和函数"><a href="#访问外部变量和函数" class="headerlink" title="访问外部变量和函数"></a>访问外部变量和函数</h3><p><b style="color:red">通过简单地使用它们的名称就可以访问solidity变量和其他标识符。对于内存变量，这会将地址而不是值推入堆栈</b>。<b style="color:red">存储变量不同：存储中的值可能不占用完整的存储槽，因此它们的“地址”由该槽中的槽和字节偏移量组成</b>。要检索变量<code>x</code>指向的槽，你需要使用<code>x_slot</code>并检索您使用的字节偏移量<code>x_offset</code>。</p>
<p>在赋值中（见下文），我们甚至可以使用本地Solidity变量来赋值。</p>
<p>也可以访问内联汇编外部的函数：汇编将推入它们的入口标签（应用虚函数解析）。solidity中可靠的调用语义是：</p>
<ul>
<li>调用者将<code>return label, arg1, arg2, …, argn</code>压入栈中</li>
<li>调用连同<code>ret1, ret2, …, retm</code>返回。</li>
</ul>
<p>这个特性使用起来还是有点麻烦，因为在调用期间堆栈偏移量实际上会发生变化，因此对局部变量的引用将会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    function f(uint x) public returns (uint r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) // ignore the offset, we know it is zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>EVM组装中的另一个问题是，jump和jumpi使用可以轻易改变的绝对地址。Solidity内联汇编提供了标签，以便更容易地使用跳转。请注意，标签是低级特征，只需使用汇编函数，loops，if和switch指令（参见下文），就可以编写无标签的高效汇编。以下代码计算斐波那契数列中的一个元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let n := calldataload(4)</span><br><span class="line">    let a := 1</span><br><span class="line">    let b := a</span><br><span class="line">loop:</span><br><span class="line">    jumpi(loopend, eq(n, 0))</span><br><span class="line">    a add swap1</span><br><span class="line">    n := sub(n, 1)</span><br><span class="line">    jump(loop)</span><br><span class="line">loopend:</span><br><span class="line">    mstore(0, a)</span><br><span class="line">    return(0, 0x20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，只有汇编器知道当前堆栈高度时，才能自动访问堆栈变量。如果跳转源和目标具有不同的堆栈高度，这将失效。使用这种跳转仍然ok，但在这种情况下，您应该不会访问任何堆栈变量（即使是汇编中的变量）。</p>
<p>此外，堆栈高度分析器通过操作码（而不是根据控制流）执行代码操作码，因此在下列情况下，汇编器对在标签<code>two</code>处的堆栈高度会产生错误印象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 8</span><br><span class="line">    jump(two)</span><br><span class="line">    one:</span><br><span class="line">        // Here the stack height is 2 (because we pushed x and 7),</span><br><span class="line">        // but the assembler thinks it is 1 because it reads</span><br><span class="line">        // from top to bottom.</span><br><span class="line">        // Accessing the stack variable x here will lead to errors.</span><br><span class="line">        x := 9</span><br><span class="line">        jump(three)</span><br><span class="line">    two:</span><br><span class="line">        7 // push something onto the stack</span><br><span class="line">        jump(one)</span><br><span class="line">    three:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>译者注：看来这是堆栈式语言引入jump之后带来的一个大问题，不知道如何解决这个问题，这个问题既有编译器编译逻辑也有机器代码逻辑的表示。</p>
<h3 id="声明汇编本地变量"><a href="#声明汇编本地变量" class="headerlink" title="声明汇编本地变量"></a>声明汇编本地变量</h3><p>您可以使用let关键字来声明仅在内联程序中可见的变量，实际上仅在当前的<code>{...}</code>块中可见。<b style="color:red">该let指令将创建一个为变量保留的新堆栈槽，并在达到语句块末尾时再次自动删除</b>。您需要为变量提供一个初始值0，但它也可以是一个复杂的函数风格表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint x) public view returns (uint b) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let v := add(x, 1)</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line">            &#123;</span><br><span class="line">                let y := add(sload(v), 1)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; // y is &quot;deallocated&quot; here</span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; // v is &quot;deallocated&quot; here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以将汇编局部变量和局部变量赋值给函数。请注意，当您给指向内存或存储的变量赋值时，只会更改指针而不是数据。</p>
<p>有两种赋值方式：函数风格和指令风格。对于函数风格赋值（<code>variable := value</code>），您需要在函数风格表达式中提供一个值，该值可以导致恰好一个堆栈值，对于指令风格赋值（<code>=: variable</code>），该值仅从堆栈顶部获取。对于这两种方式，冒号<code>:</code>指向变量的名称。通过用新值替换堆栈上的变量值来执行赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0 // functional-style assignment as part of variable declaration</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    sload(10)</span><br><span class="line">    =: v // instruction style assignment, puts the result of sload(10) into v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句可以用于有条件地执行代码。没有“else”部分，如果您需要多种选择，请考虑使用“switch”（请参阅​​下文）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if eq(value, 0) &#123; revert(0, 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主体的花括号是必需的。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>你可以使用switch语句作为“if/else”的一个非常基本的版本（由于汇编中if没有else，我们可以使用switch的default代替）。它采用表达式的值并将其与几个常量进行比较，采用与匹配常数对应的分支。与某些编程语言的容易出错的行为相反，控制流不会从一种情况继续下去。可以有一个回退或默认情况称为<code>default</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    switch calldataload(4)</span><br><span class="line">    case 0 &#123;</span><br><span class="line">        x := calldataload(0x24)</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        x := calldataload(0x44)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(0, div(x, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>case可以不用大括号，但case的主体确实需要它们。</p>
<h3 id="循环Loops"><a href="#循环Loops" class="headerlink" title="循环Loops"></a>循环Loops</h3><p>汇编支持一个简单的for-style循环。For-style循环有一个包含初始化部分，条件和后迭代部分的头文件。条件必须是功能式的表达，而另外两个是语句块。如果初始化部分声明了任何变量，则这些变量的作用域被扩展到正文中（包括条件和后迭代部分）。</p>
<p>以下示例计算内存中区域的总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For循环也可以写成像while循环一样：只需将初始化和后迭代部分留空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    let i := 0</span><br><span class="line">    for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123;     // while(i &lt; 0x100)</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, 0x20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>内联汇编允许定义低级函数。这些从堆栈中取出它们的参数（并返回PC），并将结果放入堆栈。调用函数的方式与执行函数风格的操作码相同。</p>
<p>函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在该函数之外定义的局部变量。没有明确的<code>return</code>语句。</p>
<p>如果您调用返回多个值的函数，则必须使用<code>a, b := f(x)</code>或者<code>let a, b := f(x)</code> 将它们分配给元组。</p>
<p>以下示例通过平方和乘法实现幂函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base, exponent) -&gt; result &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0 &#123; result := 1 &#125;</span><br><span class="line">        case 1 &#123; result := base &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">            // 通过递归进行幂值计算。</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2))</span><br><span class="line">            switch mod(exponent, 2)</span><br><span class="line">                case 1 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="要避免的事情"><a href="#要避免的事情" class="headerlink" title="要避免的事情"></a>要避免的事情</h3><p>内联汇编可能具有相当高级的表象，但实际上它是非常低级的。函数调用，loops，ifs和switch通过简单的重写规则进行转换，之后，汇编程序为您做的唯一事情就是重新安排函数风格的操作码，管理跳转标签，计算变量访问的堆栈高度并在到达语句块的末尾时删除堆栈槽中分配的本地变量。特别是对于最后两种情况，<b style="color:red">重要的是要知道，汇编程序仅从上到下计数堆栈高度，而不一定遵循控制流程。而且，swap等操作只会交换堆栈的内容，而不会交换变量的位置。</b></p>
<h3 id="solidity约定"><a href="#solidity约定" class="headerlink" title="solidity约定"></a>solidity约定</h3><p><b style="color:blue">与EVM组装相反，Solidity知道窄于256位的类型，例如uint24。为了使它们更高效，大多数算术运算只将它们视为256位数字，而高位仅在必要时清除，即在它们被写入内存之前或执行比较之前。这意味着如果您从内联汇编中访问这样的变量，则可能必须首先手动清除更高位。</b>这个有助于我们理解solidity的工作机制。</p>
<p>Solidity以一种非常简单的方式管理内存：内存位置<code>0x40</code>处有一个“空闲内存指针”。如果你想分配内存，只需在那个位置使用内存，并相应地更新指针。</p>
<p>在solidity的内存数组元素始终占据32个字节（是的，对于<code>byte[]</code>，这是真实的，而对于<code>bytes</code>和<code>string</code>不是这样）。多维内存数组是指向内存数组的指针。动态数组的长度存储在数组的第一个插槽中，然后跟随数组元素。</p>
<p><b style="color:#6ab0de">警告:静态大小的内存数组没有长度字段，但它很快就会添加，以便在静态和动态大小的数组之间实现更好的可转换性，所以请不要依赖它。</b></p>
<h2 id="独立汇编"><a href="#独立汇编" class="headerlink" title="独立汇编"></a>独立汇编</h2><p>以上内联汇编语言描述的汇编语言也可以单独使用，实际上，计划是将其用作Solidity编译器的中间语言。在这种形式下，它试图实现几个目标：</p>
<ol>
<li>写在其中的程序应该是可读的，即使代码是由Solidity的编译器生成的。</li>
<li>从汇编到字节码的翻译应该包含尽可能少的“surprises”。</li>
<li>控制流应该易于检测，以帮助进行格式验证和优化。</li>
</ol>
<p>为了实现第一个和最后一个目标，汇编提供了高层次的结构，如<code>for</code>循环，<code>if</code>和<code>switch</code>语句和函数调用。它应该能够编写汇编程序不使用明确的<code>SWAP</code>，<code>DUP</code>， <code>JUMP</code>和<code>JUMPI</code>语句，因为前两个模糊的数据流和最后两个模糊处理的控制流。此外，函数语句<code>mul(add(x, y), 7)</code>优于纯操作码语句<code>7 y x add mul</code>， 因为在第一种形式中，更容易看出哪个操作数用于哪个操作码。</p>
<p>第二个目标是通过引入一个desugaring阶段来实现的，该阶段只能以非常规的方式移除较高级别的构造，并且仍然允许检查生成的低级汇编代码。汇编程序执行的唯一非本地操作是用户定义的标识符（函数，变量，…）的名称查找，它遵循非常简单和常规的范围规则以及从堆栈中清除局部变量。</p>
<p>作用域：声明的标识符（标签，变量，函数，汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。跨函数边界访问局部变量是不合法的，即使它们在范围内。阴影是不允许的。局部变量在声明之前不能被访问，但标签，函数和内联汇编可以。assembly是特殊的语句块，用于例如返回运行时代码或创建合约。子assembly中没有可见的外部assembly标识符。</p>
<p>如果控制流经过语句块的末尾，则会插入与该语句块中声明的局部变量数匹配的流行指令。无论何时引用局部变量，代码生成器都需要知道其当前在堆栈中的相对位置，因此需要跟踪当前所谓的堆栈高度。<b style="color:red">由于所有局部变量都在块的末尾被删除，块前后的堆栈高度应该相同。如果情况并非如此，则会发出警告。</b></p>
<p>为什么要使用更高级别的结构类似<code>switch</code>，<code>for</code>和函数：</p>
<p>使用switch，for和函数，它应该有可能编写复杂的代码，而无需手工使用jump或jumpi。这使得分析控制流程变得更加容易，从而可以改进格式验证和优化。</p>
<p>此外，如果允许手动跳转，计算堆栈高度相当复杂。需要知道堆栈中所有局部变量的位置，否则在块结束时既不会自动引用局部变量也不会从堆栈中自动删除局部变量。脱钩机构正确地将操作插入无法访问的语句块，以便在没有持续控制流的跳转情况下正确调整堆栈高度。</p>
<p>例：我们将按照Solidity的示例汇编去装配。我们考虑以下Solidity程序的运行时字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  function f(uint x) public pure returns (uint y) &#123;</span><br><span class="line">    y = 1;</span><br><span class="line">    for (uint i = 0; i &lt; x; i++)</span><br><span class="line">      y = 2 * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将生成以下汇编：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60) // store the &quot;free memory pointer&quot;</span><br><span class="line">  // function dispatcher</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // memory allocator</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // the contract function</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解除阶段后，它看起来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60)</span><br><span class="line">  &#123;</span><br><span class="line">    let $0 := div(calldataload(0), exp(2, 226))</span><br><span class="line">    jumpi($case1, eq($0, 0xb3de648b))</span><br><span class="line">    jump($caseDefault)</span><br><span class="line">    $case1:</span><br><span class="line">    &#123;</span><br><span class="line">      // the function call - we put return label and arguments on the stack</span><br><span class="line">      $ret1 calldataload(4) jump(f)</span><br><span class="line">      // This is unreachable code. Opcodes are added that mirror the</span><br><span class="line">      // effect of the function on the stack height: Arguments are</span><br><span class="line">      // removed and return values are introduced.</span><br><span class="line">      pop pop</span><br><span class="line">      let r := 0</span><br><span class="line">      $ret1: // the actual return point</span><br><span class="line">      $ret2 0x20 jump($allocate)</span><br><span class="line">      pop pop let ret := 0</span><br><span class="line">      $ret2:</span><br><span class="line">      mstore(ret, r)</span><br><span class="line">      return(ret, 0x20)</span><br><span class="line">      // although it is useless, the jump is automatically inserted,</span><br><span class="line">      // since the desugaring process is a purely syntactic operation that</span><br><span class="line">      // does not analyze control-flow</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $caseDefault:</span><br><span class="line">    &#123;</span><br><span class="line">      revert(0, 0)</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $endswitch:</span><br><span class="line">  &#125;</span><br><span class="line">  jump($afterFunction)</span><br><span class="line">  allocate:</span><br><span class="line">  &#123;</span><br><span class="line">    // we jump over the unreachable code that introduces the function arguments</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let size := 0</span><br><span class="line">    $start:</span><br><span class="line">    // output variables live in the same scope as the arguments and is</span><br><span class="line">    // actually allocated.</span><br><span class="line">    let pos := 0</span><br><span class="line">    &#123;</span><br><span class="line">      pos := mload(0x40)</span><br><span class="line">      mstore(0x40, add(pos, size))</span><br><span class="line">    &#125;</span><br><span class="line">    // This code replaces the arguments by the return values and jumps back.</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    // Again unreachable code that corrects stack height.</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  f:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let x := 0</span><br><span class="line">    $start:</span><br><span class="line">    let y := 0</span><br><span class="line">    &#123;</span><br><span class="line">      let i := 0</span><br><span class="line">      $for_begin:</span><br><span class="line">      jumpi($for_end, iszero(lt(i, x)))</span><br><span class="line">      &#123;</span><br><span class="line">        y := mul(2, y)</span><br><span class="line">      &#125;</span><br><span class="line">      $for_continue:</span><br><span class="line">      &#123; i := add(i, 1) &#125;</span><br><span class="line">      jump($for_begin)</span><br><span class="line">      $for_end:</span><br><span class="line">    &#125; // Here, a pop instruction will be inserted for i</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  $afterFunction:</span><br><span class="line">  stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇编发生在以下四个阶段：</p>
<ol>
<li>解析</li>
<li>Desugaring（移除switch，for和函数）</li>
<li>操作码流生成</li>
<li>字节码生成</li>
</ol>
<p>我们将以伪正式的方式指定第一步到第三步。更正式的规格将随之而来。</p>
<h3 id="解析-语法"><a href="#解析-语法" class="headerlink" title="解析/语法"></a>解析/语法</h3><p>解析器的任务如下：</p>
<ul>
<li>将字节流转换为标识符（就是每一个单词）流，丢弃C++风格的注释（对源引用存在特殊注释，但我们不在这里解释）。</li>
<li>根据下面的语法将标识符流转换为AST</li>
<li>使用它们在其定义的语句块中注册标识符（注释到AST节点）并注意从哪个点开始，可以访问变量。</li>
</ul>
<p>汇编词法分析器遵循由Solidity自己定义的那个。</p>
<p>空格用于分隔标识符，它由空格，制表符和换行符组成。评论是常规的JavaScript/C++评论，并且以与Whitespace相同的方式进行解释。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line">AssemblyItem =</span><br><span class="line">    Identifier |</span><br><span class="line">    AssemblyBlock |</span><br><span class="line">    AssemblyExpression |</span><br><span class="line">    AssemblyLocalDefinition |</span><br><span class="line">    AssemblyAssignment |</span><br><span class="line">    AssemblyStackAssignment |</span><br><span class="line">    LabelDefinition |</span><br><span class="line">    AssemblyIf |</span><br><span class="line">    AssemblySwitch |</span><br><span class="line">    AssemblyFunctionDefinition |</span><br><span class="line">    AssemblyFor |</span><br><span class="line">    &apos;break&apos; |</span><br><span class="line">    &apos;continue&apos; |</span><br><span class="line">    SubAssembly</span><br><span class="line">AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral</span><br><span class="line">AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">AssemblyCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;</span><br><span class="line">AssemblyLocalDefinition = &apos;let&apos; IdentifierOrList ( &apos;:=&apos; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = IdentifierOrList &apos;:=&apos; AssemblyExpression</span><br><span class="line">IdentifierOrList = Identifier | &apos;(&apos; IdentifierList &apos;)&apos;</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">AssemblyStackAssignment = &apos;=:&apos; Identifier</span><br><span class="line">LabelDefinition = Identifier &apos;:&apos;</span><br><span class="line">AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &apos;switch&apos; AssemblyExpression AssemblyCase*</span><br><span class="line">    ( &apos;default&apos; AssemblyBlock )?</span><br><span class="line">AssemblyCase = &apos;case&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblyFunctionDefinition = &apos;function&apos; Identifier &apos;(&apos; IdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; &apos;(&apos; IdentifierList &apos;)&apos; )? AssemblyBlock</span><br><span class="line">AssemblyFor = &apos;for&apos; ( AssemblyBlock | AssemblyExpression )</span><br><span class="line">    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock</span><br><span class="line">SubAssembly = &apos;assembly&apos; Identifier AssemblyBlock</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure></p>
<h3 id="Desugaring-去除语法糖"><a href="#Desugaring-去除语法糖" class="headerlink" title="Desugaring(去除语法糖)"></a>Desugaring(去除语法糖)</h3><p>AST转换删除<code>for</code>,<code>switch</code>和函数结构。结果仍然可以由同一个解析器解析，但它不会使用某些结构。如果jumpdests被添加，只跳转到不继续，将添加有关堆栈内容的信息，除非未访问外部作用域的局部变量或堆栈高度与前一条指令相同。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">desugar item: AST -&gt; AST =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyFunctionDefinition(&apos;function&apos; name &apos;(&apos; arg1, ..., argn &apos;)&apos; &apos;-&gt;&apos; ( &apos;(&apos; ret1, ..., retm &apos;)&apos; body) -&gt;</span><br><span class="line">  &lt;name&gt;:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($&lt;name&gt;_start)</span><br><span class="line">    let $retPC := 0 let argn := 0 ... let arg1 := 0</span><br><span class="line">    $&lt;name&gt;_start:</span><br><span class="line">    let ret1 := 0 ... let retm := 0</span><br><span class="line">    &#123; desugar(body) &#125;</span><br><span class="line">    swap and pop items so that only ret1, ... retm, $retPC are left on the stack</span><br><span class="line">    jump</span><br><span class="line">    0 (1 + n times) to compensate removal of arg1, ..., argn and $retPC</span><br><span class="line">  &#125;</span><br><span class="line">AssemblyFor(&apos;for&apos; &#123; init &#125; condition post body) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    init // cannot be its own block because we want variable scope to extend into the body</span><br><span class="line">    // find I such that there are no labels $forI_*</span><br><span class="line">    $forI_begin:</span><br><span class="line">    jumpi($forI_end, iszero(condition))</span><br><span class="line">    &#123; body &#125;</span><br><span class="line">    $forI_continue:</span><br><span class="line">    &#123; post &#125;</span><br><span class="line">    jump($forI_begin)</span><br><span class="line">    $forI_end:</span><br><span class="line">  &#125;</span><br><span class="line">&apos;break&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_end</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_end</span><br><span class="line">    jump($forI_end)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">&apos;continue&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_continue</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_continue</span><br><span class="line">    jump($forI_continue)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">AssemblySwitch(switch condition cases ( default: defaultBlock )? ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find I such that there is no $switchI* label or variable</span><br><span class="line">    let $switchI_value := condition</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: -&gt; jumpi($switchI_caseJ, eq($switchI_value, val))</span><br><span class="line">    &#125;</span><br><span class="line">    if default block present: -&gt;</span><br><span class="line">      &#123; defaultBlock jump($switchI_end) &#125;</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: &#123; body &#125; -&gt; $switchI_caseJ: &#123; body jump($switchI_end) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $switchI_end:</span><br><span class="line">  &#125;</span><br><span class="line">FunctionalAssemblyExpression( identifier(arg1, arg2, ..., argn) ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    if identifier is function &lt;name&gt; with n args and m ret values -&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        // find I such that $funcallI_* does not exist</span><br><span class="line">        $funcallI_return argn  ... arg2 arg1 jump(&lt;name&gt;)</span><br><span class="line">        pop (n + 1 times)</span><br><span class="line">        if the current context is `let (id1, ..., idm) := f(...)` -&gt;</span><br><span class="line">          let id1 := 0 ... let idm := 0</span><br><span class="line">          $funcallI_return:</span><br><span class="line">        else -&gt;</span><br><span class="line">          0 (m times)</span><br><span class="line">          $funcallI_return:</span><br><span class="line">          turn the functional expression that leads to the function call</span><br><span class="line">          into a statement stream</span><br><span class="line">      &#125;</span><br><span class="line">    else -&gt; desugar(children of node)</span><br><span class="line">  &#125;</span><br><span class="line">default node -&gt;</span><br><span class="line">  desugar(children of node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成操作码流"><a href="#生成操作码流" class="headerlink" title="生成操作码流"></a>生成操作码流</h3><p>在操作码流生成期间，我们会跟踪计数器中的当前堆栈高度，以便可以通过名称访问堆栈变量。每个修改堆栈的操作码以及每个用堆栈调整注释的标签都会修改堆栈高度。每次引入一个新的局部变量时，它都会与当前堆栈高度一起注册。如果访问变量（复制其值或赋值），则根据引入变量时当前堆栈高度和堆栈高度之间的差异选择适当的<code>DUP</code>或<code>SWAP</code>指令。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">codegen item: AST -&gt; opcode_stream =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyBlock(&#123; items &#125;) -&gt;</span><br><span class="line">  join(codegen(item) for item in items)</span><br><span class="line">  if last generated opcode has continuing control flow:</span><br><span class="line">    POP for all local variables registered at the block (including variables</span><br><span class="line">    introduced by labels)</span><br><span class="line">    warn if the stack height at this point is not the same as at the start of the block</span><br><span class="line">Identifier(id) -&gt;</span><br><span class="line">  lookup id in the syntactic stack of blocks</span><br><span class="line">  match type of id</span><br><span class="line">    Local Variable -&gt;</span><br><span class="line">      DUPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">    Label -&gt;</span><br><span class="line">      // reference to be resolved during bytecode generation</span><br><span class="line">      PUSH&lt;bytecode position of label&gt;</span><br><span class="line">    SubAssembly -&gt;</span><br><span class="line">      PUSH&lt;bytecode position of subassembly data&gt;</span><br><span class="line">FunctionalAssemblyExpression(id ( arguments ) ) -&gt;</span><br><span class="line">  join(codegen(arg) for arg in arguments.reversed())</span><br><span class="line">  id (which has to be an opcode, might be a function name later)</span><br><span class="line">AssemblyLocalDefinition(let (id1, ..., idn) := expr) -&gt;</span><br><span class="line">  register identifiers id1, ..., idn as locals in current block at current stack height</span><br><span class="line">  codegen(expr) - assert that expr returns n items to the stack</span><br><span class="line">FunctionalAssemblyAssignment((id1, ..., idn) := expr) -&gt;</span><br><span class="line">  lookup id1, ..., idn in the syntactic stack of blocks, assert that they are variables</span><br><span class="line">  codegen(expr)</span><br><span class="line">  for j = n, ..., i:</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(idj)</span><br><span class="line">  POP</span><br><span class="line">AssemblyAssignment(=: id) -&gt;</span><br><span class="line">  look up id in the syntactic stack of blocks, assert that it is a variable</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">  POP</span><br><span class="line">LabelDefinition(name:) -&gt;</span><br><span class="line">  JUMPDEST</span><br><span class="line">NumberLiteral(num) -&gt;</span><br><span class="line">  PUSH&lt;num interpreted as decimal and right-aligned&gt;</span><br><span class="line">HexLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit interpreted as hex and left-aligned&gt;</span><br><span class="line">StringLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit utf-8 encoded and left-aligned&gt;</span><br><span class="line">SubAssembly(assembly &lt;name&gt; block) -&gt;</span><br><span class="line">  append codegen(block) at the end of the code</span><br><span class="line">dataSize(&lt;name&gt;) -&gt;</span><br><span class="line">  assert that &lt;name&gt; is a subassembly -&gt;</span><br><span class="line">  PUSH32&lt;size of code generated from subassembly &lt;name&gt;&gt;</span><br><span class="line">linkerSymbol(&lt;lit&gt;) -&gt;</span><br><span class="line">  PUSH32&lt;zeros&gt; and append position to linker table</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/04/blockchain/solidity合约/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/04/blockchain/solidity合约/" itemprop="url">solidity合约</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T00:47:52+08:00">2018-04-04</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<p>Solidity合约与面向对象语言中的类相似。它们包含可以修改这些变量的状态变量和函数中的持久数据。在不同的合约（实例）上调用函数将执行EVM函数调用，从而切换上下文以使状态变量不可访问。</p>
<h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约</h2><p>合约可以通过以太坊交易或从Solidity合约中“从外部”创建。</p>
<p>诸如<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a>之类的 IDE 使用UI元素使创建过程透明。</p>
<p>在Ethereum上以编程方式创建合约最好通过使用JavaScript API <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>完成。截至今天，它有一个名为<a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank" rel="noopener">web3.eth.Contract</a>的方法 来促进合约创建。</p>
<p><b style="color:red">创建合约时，其构造函数（与合约名称相同的函数）将执行一次。构造函数是可选的。只允许一个构造函数，这意味着不支持重载。</b></p>
<p><b style="color:blue">在内部，构造函数参数在合约本身的代码之后通过<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi" target="_blank" rel="noopener">ABI编码</a>传递，但如果使用<code>web3.js</code>，则不必关心这一点。</b></p>
<p><b style="color:blue">如果合约要创建另一个合约，则创建者必须知道所创建合约的源代码（和二进制文件）。这意味着循环创建依赖是不可能的。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    // TokenCreator is a contract type that is defined below.</span><br><span class="line">    // It is fine to reference it as long as it is not used</span><br><span class="line">    // to create a new contract.</span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    // This is the constructor which registers the</span><br><span class="line">    // creator and the assigned name.</span><br><span class="line">    function OwnedToken(bytes32 _name) public &#123;</span><br><span class="line">        // State variables are accessed via their name</span><br><span class="line">        // and not via e.g. this.owner. This also applies</span><br><span class="line">        // to functions and especially in the constructors,</span><br><span class="line">        // you can only call them like that (&quot;internally&quot;),</span><br><span class="line">        // because the contract itself does not exist yet.</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        // We do an explicit type conversion from `address`</span><br><span class="line">        // to `TokenCreator` and assume that the type of</span><br><span class="line">        // the calling contract is TokenCreator, there is</span><br><span class="line">        // no real way to check that.</span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(bytes32 newName) public &#123;</span><br><span class="line">        // Only the creator can alter the name --</span><br><span class="line">        // the comparison is possible since contracts</span><br><span class="line">        // are implicitly convertible to addresses.</span><br><span class="line">        if (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address newOwner) public &#123;</span><br><span class="line">        // Only the current owner can transfer the token.</span><br><span class="line">        if (msg.sender != owner) return;</span><br><span class="line">        // We also want to ask the creator if the transfer</span><br><span class="line">        // is fine. Note that this calls a function of the</span><br><span class="line">        // contract defined below. If the call fails (e.g.</span><br><span class="line">        // due to out-of-gas), the execution here stops</span><br><span class="line">        // immediately.</span><br><span class="line">        if (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    function createToken(bytes32 name)</span><br><span class="line">       public</span><br><span class="line">       returns (OwnedToken tokenAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        // Create a new Token contract and return its address.</span><br><span class="line">        // From the JavaScript side, the return type is simply</span><br><span class="line">        // `address`, as this is the closest type available in</span><br><span class="line">        // the ABI.</span><br><span class="line">        return new OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(OwnedToken tokenAddress, bytes32 name)  public &#123;</span><br><span class="line">        // Again, the external type of `tokenAddress` is</span><br><span class="line">        // simply `address`.</span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isTokenTransferOK(address currentOwner, address newOwner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bool ok)</span><br><span class="line">    &#123;</span><br><span class="line">        // Check some arbitrary condition.</span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可见性和Getters"><a href="#可见性和Getters" class="headerlink" title="可见性和Getters"></a>可见性和Getters</h2><p>由于Solidity知道两种函数调用（不产生实际EVM调用的内部函数（也称为“消息调用”）和外部函数调用），<b style="color:red">函数和状态变量有四种类型的可见性。</b></p>
<p><b style="color:blue">如存在函数可以指定external， public，internal或者private，其中默认为 public。对于状态变量，这external是不可能的，而且默认是internal。</b></p>
<ul>
<li>external：外部功能是合约界面的一部分，这意味着可以从其他合约和交易中调用它们。外部函数f不能在内部调用（即f()不起作用，但this.f()可以）。<b style="color:red">外部函数在接收大量数据时有时更高效。</b></li>
<li>public：<b style="color:blue">公共方法是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量，会生成一个自动获取器函数（见下文）。</b></li>
<li>internal：<b style="color:blue">这些方法和状态变量只能在内部进行访问（即从当前合约或从中衍生出的合约内），而不能使用this。</b></li>
<li>private：<b style="color:blue">私有函数和状态变量仅对它们定义的合约而不是衍生合约中可见。</b></li>
</ul>
<p><b style="color:#6ab0de">注意: 所有外部观察者都可以看到合约内的所有内容。设置成员为private只会阻止其他合约访问和修改信息，但在区块链之外，整个世界仍然可以看到它。</b></p>
<p>可见性说明符在状态变量的类型之后以及函数的参数列表和返回参数列表之间给出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a) private pure returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在以下示例中，<code>D</code>，可以调用c.getData()以检索data状态存储的值 ，但无法调用f。合约E来源于 C，因此可以调用compute方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//这将不会编译</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint private data;</span><br><span class="line"></span><br><span class="line">    function f(uint a) private returns(uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) public &#123; data = a; &#125;</span><br><span class="line">    function getData() public returns(uint) &#123; return data; &#125;</span><br><span class="line">    function compute(uint a, uint b) internal returns (uint) &#123; return a+b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    function readData() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint local = c.f(7); // error: member `f` is not visible</span><br><span class="line">        c.setData(3);</span><br><span class="line">        local = c.getData();</span><br><span class="line">        local = c.compute(3, 5); // error: member `compute` is not visible</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract E is C &#123;</span><br><span class="line">    function g() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint val = compute(3, 5); // access to internal member (from derived to parent contract)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Getter函数"><a href="#Getter函数" class="headerlink" title="Getter函数"></a>Getter函数</h3><p>编译器自动为所有公共状态变量创建getter函数。对于下面给出的合约，编译器将生成一个函数data，它不会接受任何参数并返回uint状态变量的值data。状态变量的初始化可以在声明中完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">getter方法具有外部可见性。如果符号在内部被访问（即没有<code>this.</code>），它被认为是一个状态变量。如果它是外部访问的（即with <code>this.</code>），它将作为函数进行访问。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data;</span><br><span class="line">    function x() public &#123;</span><br><span class="line">        data = 3; // internal access</span><br><span class="line">        uint val = this.data(); // external access</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个例子有点复杂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将生成以下形式的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，结构中的映射被省略，因为没有提供映射键的好方法。</p>
<h2 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h2><p><b style="color:red">修饰符可以用来轻松改变函数的行为。例如，他们可以在执行该方法之前自动检查一个条件。修饰符是合约的可继承属性，可能会被衍生合约覆盖。</b></p>
<p><b style="color:red">可修饰符，注意看代码的15行和52行，这个就是我们如何自定义自己的函数修饰符的例子，总的来说就是实现了钩子方法，超赞。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // This contract only defines a modifier but does not use</span><br><span class="line">    // it: it will be used in derived contracts.</span><br><span class="line">    // The function body is inserted where the special symbol</span><br><span class="line">    // `_;` in the definition of a modifier appears.</span><br><span class="line">    // This means that if the owner calls this function, the</span><br><span class="line">    // function is executed and otherwise, an exception is</span><br><span class="line">    // thrown.</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // This contract inherits the `onlyOwner` modifier from</span><br><span class="line">    // `owned` and applies it to the `close` function, which</span><br><span class="line">    // causes that calls to `close` only have an effect if</span><br><span class="line">    // they are made by the stored owner.</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // Modifiers can receive arguments:</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // It is important to also provide the</span><br><span class="line">    // `payable` keyword here, otherwise the function will</span><br><span class="line">    // automatically reject all Ether sent to it.</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// This function is protected by a mutex, which means that</span><br><span class="line">    /// reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br><span class="line">    /// The `return 7` statement assigns 7 to the return value but still</span><br><span class="line">    /// executes the statement `locked = false` in the modifier.</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:red">通过在一个空白分隔的列表中指定多个修饰符并按照所呈现的顺序对多个修饰符进行评估。</b></p>
<p><b style="color:#6ab0de">警告: 在早期版本的Solidity中，return具有修饰符的函数中的语句表现不同。</b></p>
<p><b style="color:red">来自修饰符或函数体的显式返回仅保留当前修饰符或函数体。返回变量被赋值并且控制流程在前一个修改器中的“_”之后继续。</b></p>
<p><b style="color:red">修饰符参数可使用允许任意表达式，在此上下文中，从该函数可见的所有符号在修饰符中都是可见的。在修饰符中引入的符号在函数中是不可见的（因为它们可能通过覆盖而改变）。(注意这里的修饰符是指修饰符函数)</b></p>
<h2 id="常量状态变量"><a href="#常量状态变量" class="headerlink" title="常量状态变量"></a>常量状态变量</h2><p><b style="color:red">状态变量可以声明为constant。在这种情况下，它们必须在编译时的常量表达式中分配。访问存储的任何表达式，blockchain数据（例如<code>now</code>，<code>this.balance</code>或 <code>block.number</code>），或者执行数据（<code>msg.value</code>或<code>gasleft()</code>）或调用外部合约是不允许的。对内存分配可能有副作用的表达式是允许的，但对其他内存对象可能有副作用的表达式则不允许。内置的功能<code>keccak256</code>，<code>sha256</code>，<code>ripemd160</code>，<code>ecrecover</code>，<code>addmod</code>和<code>mulmod</code>是允许的（即使他们这样做调用外部合约）。</b></p>
<p>在内存分配器上允许副作用的原因是应该可以构造复杂的对象，例如查找表。此功能尚未完全可用。</p>
<p>编译器不会为这些变量保留一个存储槽，并且每个出现都被各自的常量表达式替换（可能由优化器为单个值计算）。</p>
<p>并非所有类型的常量都在此时执行。唯一支持的类型是值类型和字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h3 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h3><p>可以用<code>view</code>声明函数，在这种情况下，它们保证不修改状态。</p>
<p>以下声明被视为修改状态：</p>
<ul>
<li>写入状态变量。</li>
<li><a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#events" target="_blank" rel="noopener">发射(触发)事件。</a></li>
<li><a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#creating-contracts" target="_blank" rel="noopener">创建其他合约</a>。</li>
<li>使用<code>selfdestruct</code>。</li>
<li>通过调用方法发送以太币。</li>
<li>调用任何未标记<code>view</code>或<code>pure</code>的方法。</li>
<li>使用低级别的调用。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public view returns (uint) &#123;</span><br><span class="line">        return a * (b + 42) + now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:#6ab0de">注意: 方法上的<code>constant</code>是<code>view</code>的别名，但这已被弃用，并计划在0.5.0版中删除。</b></p>
<p><b style="color:#6ab0de">注意: Getter方法被标记为<code>view</code>。</b></p>
<p><b style="color:#6ab0de">注意: 如果使用无效的显式类型转换，那么即使view调用了一个函数，状态修改也是可能的。您可以切换编译器在调用此类函数时使用<code>STATICCALL</code>，那么通过添加<code>pragma experimental &quot;v0.5.0&quot;;</code>来防止修改EVM级别的状态.</b></p>
<p><b style="color:#6ab0de">警告:编译器不强制<code>view</code>方法不去修改状态。但它会提出了一个警告。</b></p>
<h3 id="纯函数-pure-functions"><a href="#纯函数-pure-functions" class="headerlink" title="纯函数(pure functions)"></a>纯函数(<code>pure functions</code>)</h3><p>可以声明函数为<code>pure</code>，在这种情况下，它们承诺不读取或修改状态。</p>
<p>除了上面解释的状态修改语句列表之外，以下内容被认为是从状态中读取的：</p>
<ul>
<li>从状态变量读取。</li>
<li>访问<code>this.balance</code>或<code>&lt;address&gt;.balance</code>。</li>
<li>访问任何成员<code>block</code>，<code>tx</code>，<code>msg</code>（<code>msg.sig</code>和<code>msg.data</code>除外）。</li>
<li>调用任何未标记为<code>pure</code>的方法。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">        return a * (b + 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b style="color:#6ab0de">注意: 如果使用无效的显式类型转换，那么即使pure调用了一个函数，状态修改也是可能被访问的。您可以切换编译器在调用此类函数时使用<code>STATICCALL</code>，从而通过添加<code>pragma experimental &quot;v0.5.0&quot;;</code>来防止修改EVM级别的状态。</b></p>
<p><b style="color:#6ab0de">警告: 不可能阻止函数读取EVM级别的状态，只能防止它们写入状态（只有<code>view</code>能在EVM级别执行，<code>pure</code>不能）。</b></p>
<p><b style="color:#6ab0de">警告: 在版本0.4.17之前，编译器没有强制要求<code>pure</code>不读状态。</b></p>
<h3 id="fallback方法"><a href="#fallback方法" class="headerlink" title="fallback方法"></a>fallback方法</h3><p>我觉得应该在这里插入一个真实项目的示例，这样才能理解这篇的知识：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @dev fallback function ***DO NOT OVERRIDE***</span><br><span class="line">*/</span><br><span class="line">function () external payable &#123;</span><br><span class="line">    deposit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">合约可以有一个未命名的方法。这个方法不能有参数，也不能返回任何东西。如果没有其他函数与给定的函数标识符匹配（或者根本没有提供数据），它将在对合约的调用中执行。</b></p>
<p><b style="color:red">此外，只要合约收到普通以太网币（无数据），就会执行此方法。另外，为了接收以太币，必须标记回退功能payable。如果不存在此类功能，则合约无法通过正常交易接收以太币。</b></p>
<p>在最坏的情况下，fallback方法只能依靠2300gas（例如使用发送或传输以太币时使用），除了基本日志记录以外，没有太多空间来执行其他操作。以下操作将消耗比2300gas津贴更多的gas：</p>
<ul>
<li>写入存储（<code>storage</code>）</li>
<li>创建合约</li>
<li>调用消耗大量gas的外部方法</li>
<li>发送以太币</li>
</ul>
<p>像任何方法一样，只要给足够的gas，fallback方法就可以执行复杂的操作。</p>
<p><b style="color:#6ab0de">注意：即使fallback函数不能有参数，它仍然可以使用<code>msg.data</code>来检索随该调用提供的任何有效内容。</b></p>
<p><b style="color:#6ab0de">警告: 直接接收Ether的合约（没有函数调用，即使用send或transfer）但没有定义fallback函数会抛出异常，发回Ether（这在Solidity v0.4.0之前是不同的）。所以如果你想让你的合约接收Ether，你必须实现一个fallback方法。</b></p>
<p><b style="color:#6ab0de">警告：没有<code>payable</code>,<code>fallback</code>方法的合约可以作为coinbase交易（矿工挖矿奖励）的接收者或作为<code>selfdestruct</code>的目的地接收以太币。</b><br><b style="color:red">合约不能对这种以太币传输作出反应，因此也不能拒绝它们。这是EVM的设计选择，而且Solidity无法解决这个问题。</b><br><b style="color:#6ab0de">这也意味着<code>this.balance</code>可以高于合约中实施的一些账务计算的总和（即，具有在fallback函数中更新的计数器）。（这个就是在某些条件下转入的以太币，fallback函数不被执行，导致账户实际的值与你在合约中计算的值不一致的问题。）</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // This function is called for all messages sent to</span><br><span class="line">    // this contract (there is no other function).</span><br><span class="line">    // Sending Ether to this contract will cause an exception,</span><br><span class="line">    // because the fallback function does not have the `payable`</span><br><span class="line">    // modifier.</span><br><span class="line">    function() public &#123; x = 1; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// This contract keeps all Ether sent to it with no way</span><br><span class="line">// to get it back.</span><br><span class="line">contract Sink &#123;</span><br><span class="line">    function() public payable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    function callTest(Test test) public &#123;</span><br><span class="line">        test.call(0xabcdef01); // hash does not exist</span><br><span class="line">        // results in test.x becoming == 1.</span><br><span class="line"></span><br><span class="line">        // The following will not compile, but even</span><br><span class="line">        // if someone sends ether to that contract,</span><br><span class="line">        // the transaction will fail and reject the</span><br><span class="line">        // Ether.</span><br><span class="line">        //test.send(2 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>合约可以具有多个具有相同名称但具有不同参数的函数。这也适用于继承功能。以下示例显示了合约<code>A</code>范围内的函数重载<code>f</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint _in) public pure returns (uint out) &#123;</span><br><span class="line">        out = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint _in, bytes32 _key) public pure returns (uint out) &#123;</span><br><span class="line">        out = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数重载也存在于外部接口中。如果两个外部可见函数的Solidity类型不同而不是它们的外部类型不同，这是错误的(返回的类型一定要相同)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码不会被编译</span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(B _in) public pure returns (B out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(address _in) public pure returns (address out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个重载函数<code>f</code>最终都会接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p>
<h4 id="重载解析和参数匹配"><a href="#重载解析和参数匹配" class="headerlink" title="重载解析和参数匹配"></a>重载解析和参数匹配</h4><p><b style="color:blue">通过将当前作用域中的函数声明与函数调用中提供的参数进行匹配来选择重载函数。如果所有参数都可以隐式转换为预期类型，则函数被选为超载候选。如果没有确切的一个候选人，则解决失败。</b></p>
<p>注意: 重载解析不考虑返回参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">调用<code>f(50)</code>会创建一个类型错误，因为250可以隐式转换为<code>uint8</code> 和<code>uint256</code>类型。另一方面<code>f(256)</code>将解决<code>f(uint256)</code>重载，因为256不能隐式转换为uint8。</b></p>
<h2 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h2><p>事件允许方便地使用EVM日志记录工具，而后者又可用于在用于监听这些事件的dapp的用户界面中“调用”JavaScript回调。</p>
<p><b style="color:blue">Event是可继承的合约成员。当它们被调用时，它们会在交易日志中(区块链中的特殊数据结构)存储参数</b>。这些日志与合约的地址相关联，日志将被并入区块链并停留在区块链的可访问区块中（Frontier和Homestead这个永远是这样的，但这可能随着Serenity发布而改变）。<b style="color:red">日志和事件数据不能从合约内访问（甚至不能从创建它们的合约中访问）</b>。</p>
<p><b style="color:red">可以使用日志的SPV证明，因此如果外部实体提供有这种证明的合约，它可以检查日志是否确实存在于区块链中。但请注意，必须提供区块头，因为合约只能看到最后的256个区块的hash。</b></p>
<p><b style="color:blue">最多三个参数可以接收<code>indexed</code>属性，将导致搜索各个参数找到<code>indexed</code>：可以用户界面中筛选索引参数的特定值。</b> <b style="color:red">（其实就是说，参数是排序的，根据索引可以取得参数，然后指定该参数的过滤条件以达到筛选的功能,可以看一下下面我从别的地方拷贝来的代码，你就能明白一些，当然你如果能查看web3的源码，理解会更深入，其实以我的理解就是日志加查询索引而已！）。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);</span><br></pre></td></tr></table></figure>
<p>如果数组（包括string和bytes）用作索引参数，则其Keccak-256散列值将作为主题存储。</p>
<p><b style="color:red">除了用<code>anonymous</code>说明符声明事件之外，事件签名的散列是其中一个主题。这意味着无法通过名称筛选特定的匿名事件。</b></p>
<p><b style="color:red">所有非索引参数都将存储在日志的数据部分中。</b></p>
<p>注意: 索引参数不会自行存储。您只能搜索这些值，但不可能自行检索这些值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // Events are emitted using `emit`, followed by</span><br><span class="line">        // the name of the event and the arguments</span><br><span class="line">        // (if any) in parentheses. Any such invocation</span><br><span class="line">        // (even deeply nested) can be detected from</span><br><span class="line">        // the JavaScript API by filtering for `Deposit`.</span><br><span class="line">        emit Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript API中的用法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// watch for changes</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // result will contain various information</span><br><span class="line">    // including the argumets given to the `Deposit`</span><br><span class="line">    // call.</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Or pass a callback to start watching immediately</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="日志的低级接口"><a href="#日志的低级接口" class="headerlink" title="日志的低级接口"></a>日志的低级接口</h3><p>另外，也可以通过函数来访问低层接口的日志机制<code>log0</code>，<code>log1</code>，<code>log2</code>，<code>log3</code>和<code>log4</code>。<code>logi</code>接受<code>i+1</code>的bytes32类型参数，其中第一个参数将用于日志的数据部分，其他参数用作主题。上面的事件调用可以按照与上述相同的方式执行，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public payable &#123;</span><br><span class="line">        bytes32 _id = 0x420042;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>长十六进制数等于<code>keccak256(&quot;Deposit(address,hash256,uint256)&quot;)</code>, 事件的签名。</p>
<h3 id="了解事件的其他资源"><a href="#了解事件的其他资源" class="headerlink" title="了解事件的其他资源"></a>了解事件的其他资源</h3><p><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank" rel="noopener">Javascript文档</a><br><a href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol" target="_blank" rel="noopener">事件的示例用法</a><br><a href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js" target="_blank" rel="noopener">如何在js中访问它们</a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><b style="color:red">通过复制包括多态性的代码，Solidity支持多重继承。</b></p>
<p>所有的函数调用都是虚拟的，这意味着调用了大多数派生函数，除非明确给出了合约名称。</p>
<p>当合约从多个合约中继承时，只会在区块链上创建单个合约，并将所有基础合约中的代码复制到创建的合约中。</p>
<p>一般继承系统与Python非常相似 ，特别是多继承。</p>
<p>以下示例中给出了详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use `is` to derive from another contract. Derived</span><br><span class="line">// contracts can access all non-private members including</span><br><span class="line">// internal functions and state variables. These cannot be</span><br><span class="line">// accessed externally via `this`, though.</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// These abstract contracts are only provided to make the</span><br><span class="line">// interface known to the compiler. Note the function</span><br><span class="line">// without body. If a contract does not implement all</span><br><span class="line">// functions it can only be used as an interface.</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="line">// also a base class of `mortal`, yet there is only a single</span><br><span class="line">// instance of `owned` (as for virtual inheritance in C++).</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Functions can be overridden by another function with the same name and</span><br><span class="line">    // the same number/types of inputs.  If the overriding function has different</span><br><span class="line">    // types of output parameters, that causes an error.</span><br><span class="line">    // Both local and message-based function calls take these overrides</span><br><span class="line">    // into account.</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // It is still possible to call a specific</span><br><span class="line">            // overridden function.</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If a constructor takes an argument, it needs to be</span><br><span class="line">// provided in the header (or modifier-invocation-style at</span><br><span class="line">// the constructor of the derived contract (see below)).</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">请注意，上面我们调用<code>mortal.kill()</code>“转发”销毁请求。这样做的方式是有问题的，如以下示例所示</b>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Final.kill()</code>的调用将会调用<code>Base2.kill</code>称为最派生的覆盖，但这个函数将绕过<code>Base1.kill</code>，主要是因为它甚至不知道 <code>Base1</code>。解决这个问题的方法是使用super：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">如果<code>Base2</code>调用<code>super</code>的函数，它不会简单地在其一个基础合约上调用该函数。相反，它在最终的继承图中的下一个基础合约上调用该函数，因此它会调用<code>Base1.kill()</code>（请注意，最终的继承序列是 - 从派生最多的合约开始：<code>Final</code>，<code>Base2</code>，<code>Base1</code>，<code>mortal</code>，<code>owned</code>）。使用<code>super</code>时调用的实际函数在使用它的类的上下文中是未知的，尽管其类型是已知的。这对于普通的虚拟方法查找是相似的。</b></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一个可选函数，其名称与创建合约时执行的合约名称相同。<b style="color:red">构造函数可以是public或者internal</b>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint public a;</span><br><span class="line"></span><br><span class="line">    function A(uint _a) internal &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A(1) &#123;</span><br><span class="line">    function B() public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置构造函数为internal会导致合约被标记为<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#abstract-contract" target="_blank" rel="noopener">抽象</a>。</p>
<h3 id="基础构造函数的参数"><a href="#基础构造函数的参数" class="headerlink" title="基础构造函数的参数"></a>基础构造函数的参数</h3><p>派生合约需要提供基础构造函数所需的所有参数。这可以通过两种方式完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种方法直接在继承列表（<code>is Base(7)</code>）中。另一种方式是调用一个修饰符作为派生构造函数（<code>Base(_y * _y)</code>）的头部分的一部分。如果构造函数参数是一个常量来定义合约的行为或描述它，第一种实现方法更为方便。如果基础的构造函数参数取决于衍生合约的构造函数参数，则必须使用第二种方法。<b style="color:red">如果像在这个简单的例子中一样，这两处都用到了，那么修饰语风格的参数优先。</b></p>
<h3 id="多重继承和线性化"><a href="#多重继承和线性化" class="headerlink" title="多重继承和线性化"></a>多重继承和线性化</h3><p><b style="color:blue">允许多重继承的语言必须处理几个问题。一个是<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="noopener">钻石问题</a>。Solidity遵循Python的方式，并使用<a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="noopener">“C3线性化”</a>来强制基类的DAG中的特定顺序。这导致单调性的理想特性，但不允许某些继承图。特别是，在指令<code>is</code>中给出基类的顺序很重要。在下面的代码中，Solidity会给出错误<code>Linearization of inheritance graph impossible</code>。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这将不会编译</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其原因是<code>C</code>请求<code>X</code>覆盖<code>A</code> （通过<code>A,X</code>按此顺序），但<code>A</code>本身请求覆盖，这是无法解决的矛盾。</p>
<p><b style="color:red">要记住的一个简单规则是按照“most base-like”到“most derived”的顺序​​指定基类。</b></p>
<h3 id="继承不同类型的同名成员"><a href="#继承不同类型的同名成员" class="headerlink" title="继承不同类型的同名成员"></a>继承不同类型的同名成员</h3><p><b style="color:red">当继承导致具有相同名称的函数和修饰符的合约时，它被视为错误。这个错误也是由同名的事件和修饰符以及同名的函数和事件产生的。作为一个例外，状态变量getter可以覆盖公共函数。</b></p>
<h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p><b style="color:red">如果至少其中一个方法缺少如下例所示的实现（注意函数声明标头以<code>;</code>终止），则合约被标记为抽象</b>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些合约不能被编译（即使它们包含已实现的功能以及未实现的功能），但它们可以用作基本合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32) &#123; return &quot;miaow&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果合约继承自抽象合约，并且没有通过覆盖来实现所有未实现的功能，它本身就是抽象的。</p>
<p>请注意，没有实现的函数与<a href="https://solidity.readthedocs.io/en/v0.4.21/types.html#function-types" target="_blank" rel="noopener">函数类型</a>不同，即使它们的语法看起来非常相似。</p>
<p>没有实现的函数示​​例（函数声明）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(address) external returns (address);</span><br></pre></td></tr></table></figure></p>
<p>函数类型的示例（变量声明，其中变量是<code>function</code>类型的）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(address) external returns (address) foo;</span><br></pre></td></tr></table></figure></p>
<p>抽象合约将合约的定义与其实现分离开来，从而提供更好的可扩展性和自我文档，并促进像Template方法和消除代码重复这样的模式。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><b style="color:red">接口类似于抽象合约，但它们不能实现任何方法。还有其他限制</b>：</p>
<ol>
<li>无法继承其他合约或接口。</li>
<li>无法定义构造函数。</li>
<li>无法定义变量。</li>
<li>无法定义struct。</li>
<li>无法定义枚举。</li>
</ol>
<p>这些限制中的一些可能会在未来取消。</p>
<p><b style="color:red">接口基本上仅限于合约ABI可以表示的内容，并且ABI和接口之间的转换应该是可能的，而不会丢失任何信息</b>。</p>
<p>接口由关键字<code>interface</code>表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    function transfer(address recipient, uint amount) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合约可以继承接口，因为它们会继承其他合约。</p>
<h2 id="库-Libraries"><a href="#库-Libraries" class="headerlink" title="库 Libraries"></a>库 Libraries</h2><p>库与合约类似，但其用途是它们只在特定地址部署一次，并使用EVM 的<code>DELEGATECALL</code> （<code>CALLCODE</code>直到Homestead）方法重用其代码。这意味着如果调用库函数，它们的代码将在调用合约的上下文中执行，即this指向调用合约，特别是可以访问来自调用合约的存储（storage）。由于库是一段独立的源代码，因此它只能访问调用协定的状态变量（如果它们被明确提供，否则无法命名它们）。如果库函数<code>DELEGATECALL</code>不修改状态（即，如果它们是<code>view</code>或<code>pure</code>方法），则只能直接调用库函数（即不使用<code>DELEGATECALL</code>），因为库被认为是无状态的。特别是，除非Solidity的类型系统被规避，否则不可能破坏库。</p>
<p>库可以被视为使用它们的合约的隐含基础合约。它们不会在继承层次结构中显式可见，但对库函数的调用看起来就像调用显式基础合约的函数（<code>L.f()</code>如果<code>L</code>是库的名称）。此外，<code>internal</code>库函数在所有合约中都是可见的，就像库是基础合约一样。当然，对内部函数的调用使用内部调用合约，这意味着可以传递所有内部类型，并且内存类型将通过引用传递并且不会被复制。为了在EVM中实现这一点，内部库函数和其中调用的所有函数的代码将在编译时拉入到调用合约中，并且JUMP将使用常规调用而不是<code>DELEGATECALL</code>。</p>
<p>以下示例说明了如何使用库（但请务必查看<a href="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#using-for" target="_blank" rel="noopener">使用for</a>获取更高级的示例来实现Set）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // We define a new struct datatype that will be used to</span><br><span class="line">  // hold its data in the calling contract.</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // Note that the first parameter is of type &quot;storage</span><br><span class="line">  // reference&quot; and thus only its storage address and not</span><br><span class="line">  // its contents is passed as part of the call.  This is a</span><br><span class="line">  // special feature of library functions.  It is idiomatic</span><br><span class="line">  // to call the first parameter `self`, if the function can</span><br><span class="line">  // be seen as a method of that object.</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // The library functions can be called without a</span><br><span class="line">        // specific instance of the library, since the</span><br><span class="line">        // &quot;instance&quot; will be the current contract.</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // In this contract, we can also directly access knownValues.flags, if we want.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，您不必遵循这种方式来使用库：它们也可以在不定义结构数据类型的情况下使用。函数也可以在没有任何storage引用参数的情况下工作，并且它们可以具有多个storage引用参数并且在任何位置。</p>
<p><b style="color:blue">所有对<code>Set.contains</code>，<code>Set.insert</code>和<code>Set.remove</code>的调用都被编译为调用（<code>DELEGATECALL</code>）到外部合约/库</b>。<b style="color:blue">如果使用库，请注意执行实际的外部函数调用</b>。 <code>msg.sender</code>，<code>msg.value</code>和<code>this</code>在此调用中将保留它们的值，虽然（Homestead之前，因为使用的<code>CALLCODE</code>，<code>msg.sender</code>和<code>msg.value</code>改变了）。</p>
<p>下面的例子显示了如何在库中使用内存类型和内部函数，以实现自定义类型，而无需外部函数调用的开销：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // too bad, we have to add a limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于编译器无法知道库的部署位置，因此必须通过链接器将这些地址填充到最终的字节码中（请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/using-the-compiler.html#commandline-compiler" target="_blank" rel="noopener">使用命令行编译器</a>了解如何使用命令行编译器进行链接）。如果地址不作为编译器的参数给出，编译的十六进制代码将包含表单的占位符<code>__Set______</code>（其中 Set是库的名称）。地址可以通过用库合约地址的十六进制编码来手动填充替换所有这40个符号。</p>
<p>与合约相比，库的限制：</p>
<ul>
<li>没有状态变量</li>
<li>不能继承，也不能被继承</li>
<li>无法接收以太币</li>
</ul>
<p>（这些可能会在之后的版本解除。）</p>
<h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护</h3><p>正如介绍中提到，如果某个库的代码被执行应使用<code>CALL</code>，而不是一个<code>DELEGATECALL</code>或<code>CALLCODE</code>，它会恢复，除非<code>view</code>或<code>pure</code>函数被调用。</p>
<p><b style="color:red">EVM不提供直接的方式来检测合约是否被<code>CALL</code>调用，但合约可以使用<code>ADDRESS</code>操作码来找出当前正在运行的“哪里”。生成的代码将此地址与创建时使用的地址进行比较，以确定调用模式。</b></p>
<p><b style="color:red">更具体地说，库的运行时代码始终以一个推送指令开始，该指令在编译时为20个字节的零。部署代码运行时，该常量在内存中被当前地址替换，并且此修改的代码存储在合约中。在运行时，这会导致部署时间地址成为第一个被压入堆栈的常量，并且调度程序代码会将当前地址与此常量进行比较，以查看任何非<code>view</code>和非<code>pure</code>函数。</b></p>
<h2 id="using-for语句"><a href="#using-for语句" class="headerlink" title="using for语句"></a>using for语句</h2><p>该指令<code>using A for B;</code>可用于将库函数（从库<code>A</code>中）附加到任何类型（<code>B</code>）。<b style="color:red">这些函数将接收它们被调用的对象作为它们的第一个参数（如Python中的变量）</b>。</p>
<p><code>using A for *;</code>其效果是库<code>A</code>中的函数被附加到任何类型。</p>
<p>在这两种情况下，都会附加所有函数，即使是第一个参数的类型与对象类型不匹配的函数。在函数被调用的地方检查类型，并执行函数重载解析。</p>
<p><code>using A for B;</code>该指令对于当前作用域是有效的，现在仅限于一个合约，但稍后将被提升到全局作用域，这样通过包含一个模块，其数据类型（包括库函数）可用，而无需添加进一步的代码。</p>
<p>让我们以这种方式重写库中的设置示例 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// This is the same code as before, just without comments</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // this is the crucial change</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以这种方式扩展基本类型也是可能的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return uint(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint _old, uint _new) public &#123;</span><br><span class="line">        // This performs the library function call</span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        if (index == uint(-1))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        else</span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">请注意，所有库调用都是实际的EVM函数调用。这意味着如果您传递内存或值类型，将执行副本，甚至是<code>self</code>变量。唯一不执行复制的情况是使用storage引用变量。</b></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/03/blockchain/solidity表达式和控制结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/blockchain/solidity表达式和控制结构/" itemprop="url">solidity表达式和控制结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T20:10:18+08:00">2018-04-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<h2 id="输入参数和输出参数"><a href="#输入参数和输出参数" class="headerlink" title="输入参数和输出参数"></a>输入参数和输出参数</h2><p>与Javascript一样，方法可能会将参数作为输入; 不像Javascript和C中，它们也可以返回任意数量的参数作为输出。</p>
<h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名称。例如，假设我们希望我们的合约接受一种具有两个整数的外部调用，我们会写如下所示的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function taker(uint _a, uint _b) public pure &#123;</span><br><span class="line">        // do something with _a and _b.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数可以在returns关键字后用相同的语法声明 。例如，假设我们希望返回两个结果：两个给定整数的和以及乘积，那么我们会写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function arithmetics(uint _a, uint _b)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint o_sum, uint o_product)</span><br><span class="line">    &#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出参数的名称可以省略。输出值也可以使用return语句指定。该return语句还能够返回多个值，请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#multi-return" target="_blank" rel="noopener">返回多个值</a>。返回参数被初始化为零; 如果他们没有明确设定，他们将保持为零。</p>
<p><b style="color:blue">输入参数和输出参数可以用作函数体中的表达式。在那里，它们也可以在赋值语句的左侧使用。</b></p>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>除了<code>switch</code>和<code>goto</code>之外，来自JavaScript的大部分控制结构都可以使用。所以有：<code>if</code>，<code>else</code>，<code>while</code>，<code>do</code>，<code>for</code>，<code>break</code>，<code>continue</code>，<code>return</code>，<code>?:</code>，这些与C或JavaScript已知的常规语义一样。</p>
<p>条件语句不能省略括号，但可以在单个语句的主体周围省略花括号。</p>
<p>请注意，solidity没有有从非布尔类型转换为Boolean类型的方式，因为<code>if (1) { ... }</code>在C和JavaScript中是可以转化，但是不是有效的solidity语句。</p>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>当函数有多个输出参数时，<code>return (v0, v1, ..., vn)</code>可以返回多个值。组件的数量必须与输出参数的数量相同。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>可以直接（“internally”）调用当前合约的方法，也可以递归地调用，如在这个无意义的示例中所见：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g(uint a) public pure returns (uint ret) &#123; return f(); &#125;</span><br><span class="line">    function f() internal pure returns (uint ret) &#123; return g(7) + f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:blue">这些函数调用被转换为EVM内部的简单跳转。这样做的效果是当前内存不会被清除，即将内存引用传递给内部调用的函数非常有效。只有同一合约的方法可以在内部调用。</b></p>
<h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>表达式<code>this.g(8);</code>和<code>c.g(2);</code>（其中<code>c</code>是合约实例）也是有效的函数调用，但是这次函数将通过消息调用而不是直接通过跳转被称为“externally”。<b style="color:red">请注意函数调用this不能在构造函数中使用，因为实际合约尚未创建。</b></p>
<p><b style="color:red">其他合约的方法必须从外部调用。对于外部调用，所有方法参数都必须复制到内存中。</b></p>
<p>当调用其他合约的方法，调用发送wei的数量和gas可以用特殊的选项来指定<code>.value()</code>和<code>.gas()</code>分别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修饰符<code>payable</code>必须用于<code>info</code>，否则，<code>.value()</code> 选项将不可用。</p>
<p>请注意，该表达式<code>InfoFeed(addr)</code>执行显式类型转换，指出“我们知道给定地址处的合约类型是InfoFeed”，并且这不会执行构造函数。<b style="color:red">显式类型转换必须谨慎处理。不要在不确定其类型的合同上调用函数。</b></p>
<p>我们也可以直接使用<code>function setFeed(InfoFeed _feed) { feed = _feed; }</code>。要小心这样一个事实，即 <code>feed.info.value(10).gas(800)</code>只有（本地）设置函数调用发送的ether值和gas的数量，并且只有最后的括号才能执行实际的调用。</p>
<p>如果被调用合约不存在（在账户不包含代码的意义上），或者被调用合约本身抛出异常或缺少gas，函数调用会导致异常。</p>
<p><b style="color:#6ab0de">警告：与其他合约的任何交互都会产生潜在的危险，特别是如果合约的源代码未提前知晓。目前的合约将控制权移交给被调用合约，这可能会做任何事情。即使被调用合约继承自已知的父合约，继承合约也只需要具有正确的接口。然而，合约的执行可能是完全随意的，因此构成危险。另外，要做好准备，以防其在您的系统的在其他合约中调用，甚至在第一次调用返回之前回到被调用合约中。这意味着被调用合约可以通过其方法改变主动调用合约的状态变量。例如，以一种方式编写你的方法。</b></p>
<h3 id="命名调用和匿名方法参数"><a href="#命名调用和匿名方法参数" class="headerlink" title="命名调用和匿名方法参数"></a>命名调用和匿名方法参数</h3><p><b style="color:blue">函数调用参数也可以按名称的顺序给出，如果它们被包含在<code>{}</code>内，就可以在下面的例子中看到。参数列表必须按名称与函数声明中的参数列表重合，但可以按任意顺序排列。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint key, uint value) public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // named arguments</span><br><span class="line">        f(&#123;value: 2, key: 3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="省略方法参数名称"><a href="#省略方法参数名称" class="headerlink" title="省略方法参数名称"></a>省略方法参数名称</h3><p><b style="color:blue">未使用的参数名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问。</b><b style="color:red">注意：具名返回参数是可以通过名称直接访问的。这个也是solidity语言和其它语言的一个很大不同之处。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // omitted name for parameter</span><br><span class="line">    function func(uint k, uint) public pure returns(uint) &#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="通过new创建合约"><a href="#通过new创建合约" class="headerlink" title="通过new创建合约"></a>通过new创建合约</h2><p>合约可以使用new关键字创建新合约。创建合约的完整代码必须事先知道，因此递归创建依赖关系是不可能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = new D(4); // will be executed as part of C&apos;s constructor</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">        // Send ether along with the creation</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">如示例中所示，可以在创建<code>D</code>使用该<code>.value()</code>选项的实例时转发Ether ，但不可能限制gas的数量</b>。如果创建失败（由于堆栈外，没有足够的余额或其他问题），会引发异常。</p>
<h2 id="表达式评估顺序"><a href="#表达式评估顺序" class="headerlink" title="表达式评估顺序"></a>表达式评估顺序</h2><p><b style="color:blue">表达式的评估顺序没有被指定（更正式地说，表达式树中一个节点的子节点的评估顺序没有被指定，但是它们当然是在节点本身之前被评估的）。只能保证语句按顺序执行，布尔表达式的短路完成。有关更多信息，请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html#order" target="_blank" rel="noopener">操作符的优先顺序</a>。</b></p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="解构赋值和返回多值"><a href="#解构赋值和返回多值" class="headerlink" title="解构赋值和返回多值"></a>解构赋值和返回多值</h3><p><b style="color:red">Solidity内部允许元组类型，即在编译时大小为常量的可能不同类型的对象列表。这些元组可以同时返回多个值，并同时将它们分配给多个变量（或一般的LValues）</b>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br><span class="line">        var (x, b, y) = f();</span><br><span class="line">        // Assigns to a pre-existing variable.</span><br><span class="line">        (x, y) = (2, 7);</span><br><span class="line">        // Common trick to swap values -- does not work for non-value storage types.</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        // Components can be left out (also for variable declarations).</span><br><span class="line">        // If the tuple ends in an empty component,</span><br><span class="line">        // the rest of the values are discarded.</span><br><span class="line">        (data.length,) = f(); // Sets the length to 7</span><br><span class="line">        // The same can be done on the left side.</span><br><span class="line">        // If the tuple begins in an empty component, the beginning values are discarded.</span><br><span class="line">        (,data[3]) = f(); // Sets data[3] to 2</span><br><span class="line">        // Components can only be left out at the left-hand-side of assignments, with</span><br><span class="line">        // one exception:</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        // (1,) is the only way to specify a 1-component tuple, because (1) is</span><br><span class="line">        // equivalent to 1.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Arrays和Structs的复杂度"><a href="#Arrays和Structs的复杂度" class="headerlink" title="Arrays和Structs的复杂度"></a>Arrays和Structs的复杂度</h3><p>赋值语义对于像数组和结构体这样的非值类型来说更复杂一些。<b style="color:red">赋值给状态变量总是创建一个独立的副本。另一方面，赋值给局部变量只为基本类型创建独立副本，即适合32个字节的静态类型。</b><b style="color:blue">如果结构或数组（包括bytes和string）从状态变量分配给局部变量，则局部变量保存对原始状态变量的引用。对局部变量的二次赋值不会修改状态，只会改变引用。</b><b style="color:red">赋值给局部变量的成员（或元素）会改变状态。(这个意思应该是指改变arrays和struct局部变量中的某一个属相，这个肯定是改变值的)</b></p>
<h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h2><p>被声明的变量将具有初始缺省值，其字节表示全部为零。变量的“默认值”是任何类型的典型“零状态”。例如，bool is 的默认值false。uint或int类型的默认值是0。对于静态大小的数组和bytes1对bytes32，每个单独的元件将被初始化为对应于其类型的默认值。最后，对于动态大小的数组，bytes和string，默认值是一个空数组或字符串。</p>
<p><b style="color:red">在方法中的任何位置声明的变量将在整个方法的范围内，而不管它在哪里声明（这将很快发生变化，请参见下文）</b>。发生这种情况是因为Solidity从JavaScript继承了它的范围规则。这与许多语言形成对比，在这些语言中变量只在声明块结束时才声明变量。因此，下面的代码是非法的并且会导致编译器抛出一个错误：<code>Identifier already declared</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 这个不会编译的</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract ScopingErrors &#123;</span><br><span class="line">    function scoping() public &#123;</span><br><span class="line">        uint i = 0;</span><br><span class="line"></span><br><span class="line">        while (i++ &lt; 1) &#123;</span><br><span class="line">            uint same1 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i++ &lt; 2) &#123;</span><br><span class="line">            uint same1 = 0;// Illegal, second declaration of same1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function minimalScoping() public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;// Illegal, second declaration of same2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function forLoopScoping() public &#123;</span><br><span class="line">        for (uint same3 = 0; same3 &lt; 1; same3++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (uint same3 = 0; same3 &lt; 1; same3++) &#123;// Illegal, second declaration of same3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b style="color:red">除此之外，如果声明了一个变量，它将在函数的开头初始化为其默认值。因此，尽管写得不好，但下面的代码是合法的：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function foo() public pure returns (uint) &#123;</span><br><span class="line">        // baz is implicitly initialized as 0</span><br><span class="line">        uint bar = 5;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">            bar += baz;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint baz = 10;// never executes</span><br><span class="line">        &#125;</span><br><span class="line">        return bar;// returns 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="0-5-0版开始的作用域"><a href="#0-5-0版开始的作用域" class="headerlink" title="0.5.0版开始的作用域"></a><b style="color:red">0.5.0版开始的作用域</b></h3><p>从版本0.5.0开始，Solidity将更改为更广泛的C99（以及许多其他语言）的范围规则：变量从声明后的正确位置直到块的结尾才可见。<b style="color:blue">作为这条规则的一个例外，在for循环的初始化部分声明的变量只有在for循环结束之前才可见。</b></p>
<p><b style="color:blue">在代码块之外声明的变量和其他项目，例如函数，合约，用户定义的类型等，不会更改其作用域行为。这意味着您可以在声明它们之前使用状态变量并递归调用函数。</b></p>
<p>这些规则现在已经作为实验性特性引入。</p>
<p>因此，下面的示例将在没有警告的情况下编译，因为这两个变量具有相同的名称，但是不相交的范围。<b style="color:red">在非0.5.0模式下，它们具有相同的作用域（函数minimalScoping），因此它不会在那里编译。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function minimalScoping() pure public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作为C99范围规则的一个特殊示例，请注意，在下面的第一个赋值中，<code>x</code>实际上将分配外部变量而不是内部变量。在任何情况下，您都会收到有关外部变量被覆盖的警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() pure public returns (uint) &#123;</span><br><span class="line">        uint x = 1;</span><br><span class="line">        &#123;</span><br><span class="line">            x = 2; // this will assign to the outer variable</span><br><span class="line">            uint x;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; // x has value 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误处理：Assert-Require-Revert和Exceptions"><a href="#错误处理：Assert-Require-Revert和Exceptions" class="headerlink" title="错误处理：Assert, Require, Revert和Exceptions"></a>错误处理：Assert, Require, Revert和Exceptions</h2><p>Solidity使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。如果条件不满足，便利函数<code>assert</code>和<code>require</code>可以用来检查条件并抛出一个异常。<b style="color:red">该<code>assert</code>函数只能用于测试内部错误并检查不变量</b>。<b style="color:red">该require函数应用于确保有效条件（如输入或合同状态变量），或者验证从外部合约调用返回值</b>。如果使用得当，分析工具可以评估您的合约，以确定将失败的条件和方法调用，这个方法调用通过assert方法快速失败。正确运行的代码不应该达到失败的断言语句; 如果发生这种情况，您应该修复合同中的错误。</p>
<p>还有两种其他方式可以触发异常：<b style="color:red">该<code>revert</code>方法可用于标记错误并恢复当前的调用。将来还可能在revert调用中包含有关错误的详细信息。该throw关键字也可以用<code>revert()</code>替代。</b></p>
<p><b style="color:red">注意:从版本0.4.13开始，该throw关键字将被弃用，并将在未来逐步淘汰。</b></p>
<p><b style="color:blue">当子调用中发生异常时，它们会自动“冒泡”（即重新排除异常）。这个规则的例外是send和低级函数call，delegatecall以及callcode - false在发生异常而不是“冒泡”的情况下返回。</b></p>
<p><b style="color:#6ab0de">警告：作为EVM设计的一部分，如果被调用帐户不存在，低级别call，delegatecall和callcode调用将会返回成功。如果需要，必须在调用之前检查是否存在。</b></p>
<p><b style="color:red">捕捉异常尚不可能。</b></p>
<p>在以下示例中，您可以看到如何require轻松检查输入条件以及如何使用assert进行内部错误检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0); // Only allow even numbers</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);</span><br><span class="line">        // Since transfer throws an exception on failure and</span><br><span class="line">        // cannot call back here, there should be no way for us to</span><br><span class="line">        // still have half of the money.</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种<code>assert</code>风格的异常在下列情况下产生的：</p>
<ol>
<li>如果您访问数组的索引太大或是负数（即x[i] 当<code>i &gt;= x.length</code> 或<code>i &lt; 0</code>）。</li>
<li>如果您访问固定长度的bytesN索引太大或负数。</li>
<li>如果除以0或者对0取模。<code>5 / 0</code> 和<code>23 % 0</code></li>
<li>如果你数字移位的位数是负值。</li>
<li>如果你将一个太大或负值的值转换为一个枚举类型。</li>
<li>如果您调用内部函数类型的零初始化变量。</li>
<li>如果您assert使用评估为false的参数进行调用。</li>
</ol>
<p>require风格在以下情况下会生成异常：</p>
<ol>
<li>调用throw方法。</li>
<li>require使用评估为的参数进行调用false。</li>
<li>如果你调用通过消息调用方法，但它不能正常完成（即用完gas，没有匹配的方法，或抛出一个异常本身），当低层次的操作，除了call，send，delegatecall或callcode使用。低级操作不会抛出异常，但会通过返回false来指示失败。</li>
<li>如果您使用new关键字创建合约，但合约创建没有正确完成（请参阅上面有关“未正确完成”的定义）。（比如Contract构造方法中使用this）</li>
<li>如果您针对不包含代码的合约执行外部函数调用。</li>
<li><b style="color:red">如果您的合约通过一个没有payable修饰符的公共函数（包括构造函数和后备函数）接收Ether 。</b></li>
<li><b style="color:red">如果你的合同通过公共的getter函数接收Ether。</b></li>
<li>如果<code>.transfer()</code>调用失败。</li>
</ol>
<p><b style="color:blue">在内部，Solidity对一个require-style异常执行恢复操作（指令<code>0xfd</code>），并执行一个无效操作（指令<code>0xfe</code>）来抛出一个assert-style异常。在这两种情况下，这都会导致EVM恢复对该状态所做的所有更改。恢复的原因是没有安全的方法来继续执行，因为预期的效果没有发生。因为我们想保留交易的原子性，所以最安全的做法是恢复所有更改并使整个交易（或至少是调用）无效</b>。<b style="color:red">请注意，assert样式异常会消耗所有可用于调用的gas，而require风格异常不会消耗Metropolis版本中的任何气体。</b></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/03/blockchain/Solidity单位和全局可用变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/blockchain/Solidity单位和全局可用变量/" itemprop="url">Solidity单位和全局可用变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T16:48:18+08:00">2018-04-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ether单位"><a href="#Ether单位" class="headerlink" title="Ether单位"></a>Ether单位</h2><p>字面上的Ether数量可以采取的后缀<code>wei</code>，<code>finney</code>，<code>szabo</code>或<code>ether</code>，没有Ether后缀，货币数字subdenominations之间的转换单位假定是<code>wei</code>，如<code>2 ether == 2000 finney</code>, 这个值为true</p>
<h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>像后缀<code>seconds</code>，<code>minutes</code>，<code>hours</code>，<code>days</code>，<code>weeks</code>和 <code>years</code>文字数字后可以用于时间单位，其中秒是基本单元和单位之间的转换如下：</p>
<ul>
<li>1 == 1 seconds</li>
<li>1 minutes == 60 seconds</li>
<li>1 hours == 60 minutes</li>
<li>1 days == 24 hours</li>
<li>1 weeks == 7 days</li>
<li><code>1 years == 365 days</code></li>
</ul>
<p><b style="color:blue">请注意，如果您使用这些单位执行日历计算，因为不是每年都等于365天，甚至因为闰秒而不是每天都有24小时。由于闰秒无法预测，因此必须通过外部oracle更新确切的日历库。</b></p>
<p>这些后缀不能应用于变量(<b style="color:red">因为这些是字面量，solidity引入的新的概念很重要</b>)。如果你想在例如几天内解释一些输入变量，你可以通过以下方式来完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) &#123;</span><br><span class="line">    if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="特殊变量和函数"><a href="#特殊变量和函数" class="headerlink" title="特殊变量和函数"></a>特殊变量和函数</h2><p><b style="color:red">全局命名空间中总是存在特殊的变量和方法，主要用于提供有关区块链的信息。</b></p>
<h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性</h3><ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的散列 - 仅适用于256个最新块，不包括当前块</li>
<li><code>block.coinbase(address)</code>：当前区块矿工的地址</li>
<li><code>block.difficulty(uint)</code>：当前区块困难</li>
<li><code>block.gaslimit(uint)</code>：当前区块的gaslimit</li>
<li><code>block.number(uint)</code>：当前区块的块高</li>
<li><code>block.timestamp(uint)</code>：当前区块时间戳记，因为unix时期以来的秒数</li>
<li><code>msg.data(bytes)</code>：完整的calldata</li>
<li><code>msg.gas(uint)</code>：剩余gas</li>
<li><code>msg.sender(address)</code>：消息的发送者（当前调用者）</li>
<li><code>msg.sig(bytes4)</code>：calldata的前四个字节（即函数标识符）</li>
<li><code>msg.value(uint)</code>：与消息一起发送的wei的数量</li>
<li><code>now(uint)</code>：当前区块时间戳（别名为block.timestamp）</li>
<li><code>tx.gasprice(uint)</code>：交易的gas价格</li>
<li><code>tx.origin(address)</code>：交易的发送者（完整的调用链）</li>
</ul>
<p><b style="color:#6ab0de">每个外部函数调用都可以修改msg所有成员的值，包括msg.sender和 msg.value也都可以更改。这包括调用库函数。</b></p>
<p><b style="color:#6ab0de">不要依赖<code>block.timestamp</code>，<code>now</code>和<code>block.blockhash</code>作为随机的来源，除非你知道自己在做什么。<br>在一定程度上，时间戳和区块哈希都会受到矿工的影响。例如，矿工社区中的不良者可以对选定的散列运行赌场支付功能，如果他们没有收到任何钱，只需重试一次不同的散列。<br>当前块时间戳必须严格大于最后一个块的时间戳，但唯一的保证是它将位于规范链中两个连续块的时间戳之间的某处。</b></p>
<p><b style="color:#6ab0de">如果要使用库函数实现访问限制 msg.sender，则必须手动提供值 msg.sender作为参数。</b></p>
<p><b style="color:#6ab0de">出于可伸缩性原因，块哈希不可用于所有块。您只能访问最近256个块的哈希，其他所有值都将为零。</b></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="assert-bool-condition-："><a href="#assert-bool-condition-：" class="headerlink" title="assert(bool condition)："></a><code>assert(bool condition)</code>：</h3><p>如果条件不满足则抛出 - 用于内部错误。</p>
<h3 id="require-bool-condition-："><a href="#require-bool-condition-：" class="headerlink" title="require(bool condition)："></a><code>require(bool condition)</code>：</h3><p>如果条件未满足则抛出 - 用于输入或外部组件中的错误。</p>
<h3 id="revert-："><a href="#revert-：" class="headerlink" title="revert()："></a><code>revert()</code>：</h3><p>中止执行并恢复状态更改</p>
<h2 id="数学和加密函数"><a href="#数学和加密函数" class="headerlink" title="数学和加密函数"></a>数学和加密函数</h2><h3 id="addmod-uint-x-uint-y-uint-k-returns-uint-："><a href="#addmod-uint-x-uint-y-uint-k-returns-uint-：" class="headerlink" title="addmod(uint x, uint y, uint k) returns (uint)："></a><code>addmod(uint x, uint y, uint k) returns (uint)</code>：</h3><p>添加以任意精度执行的时候，计算<code>(x + y) % k</code>，并且不会环绕在<code>2**256</code>。断言<code>k!=0</code>从0.5.0版开始。</p>
<h3 id="mulmod-uint-x-uint-y-uint-k-returns-uint-："><a href="#mulmod-uint-x-uint-y-uint-k-returns-uint-：" class="headerlink" title="mulmod(uint x, uint y, uint k) returns (uint)："></a><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：</h3><p>在以任意精度执行乘法的时候，计算<code>(x * y) % k</code>，并且不会绕回<code>2**256</code>。断言<code>k!=0</code>从0.5.0版开始。</p>
<h3 id="keccak256-returns-bytes32-："><a href="#keccak256-returns-bytes32-：" class="headerlink" title="keccak256(...) returns (bytes32)："></a><code>keccak256(...) returns (bytes32)</code>：</h3><p>计算（<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-packed-mode" target="_blank" rel="noopener">紧密排列的</a>）参数的Ethereum-SHA-3（Keccak-256）散列</p>
<h3 id="sha256-returns-bytes32-："><a href="#sha256-returns-bytes32-：" class="headerlink" title="sha256(...) returns (bytes32)："></a><code>sha256(...) returns (bytes32)</code>：</h3><p>计算（<a href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-packed-mode" target="_blank" rel="noopener">紧密排列</a>）参数的SHA-256哈希值</p>
<h3 id="sha3-…-returns-bytes32-："><a href="#sha3-…-returns-bytes32-：" class="headerlink" title="sha3(…) returns (bytes32)："></a>sha3(…) returns (bytes32)：</h3><p>别名 keccak256</p>
<h3 id="ripemd160-returns-bytes20-："><a href="#ripemd160-returns-bytes20-：" class="headerlink" title="ripemd160(...) returns (bytes20)："></a><code>ripemd160(...) returns (bytes20)</code>：</h3><p>计算（紧密排列）参数的 RIPEMD-160哈希值</p>
<h3 id="ecrecover-bytes32-hash-uint8-v-bytes32-r-bytes32-s-returns-address-："><a href="#ecrecover-bytes32-hash-uint8-v-bytes32-r-bytes32-s-returns-address-：" class="headerlink" title="ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)："></a><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：</h3><p>从椭圆曲线签名中恢复与公钥相关的地址，或在错误时返回零（<a href="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio" target="_blank" rel="noopener">示例用法</a>）</p>
<p><b style="color:red">在上面，“紧密排列”意味着这些参数是连续的而没有填充。这意味着以下几点完全相同：</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line">keccak256(0x616263)</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)</span><br></pre></td></tr></table></figure></p>
<p>如果需要填充，可以使用显式类型转换：<code>keccak256(&quot;\x00\x12&quot;)</code>与<code>keccak256(uint16(0x12))</code>相同。</p>
<p>请注意，常量将使用存储它们所需的最小字节数打包。这意味着，例如<code>keccak256(0x12345678) == keccak256(uint32(0x12345678))</code>和<code>keccak256(0) == keccak256(uint8(0))</code>。</p>
<p><b style="color:red">这可能是因为您在私人区块链上调用sha256，ripemd160或者ecrecover时遇到了Out-of-Gas这种情况。这样做的原因是，这些被作为所谓的预编译的合约执行，这些合约他们收到的第一条消息后（尽管他们的合约代码是硬编码）才真正存在。发送给不存在的合约的消息更加昂贵，因此执行会出现Out-of-Gas错误。解决这个问题的一个解决方法是，先在您的实际合同中使用它们，然后将例如1Wei发送给每个合同。这不是官方或测试网上的问题。</b></p>
<h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><h3 id="lt-address-gt-balance（uint256）："><a href="#lt-address-gt-balance（uint256）：" class="headerlink" title="&lt;address&gt;.balance（uint256）："></a><code>&lt;address&gt;.balance（uint256）</code>：</h3><p>以wei为单位的地址的余额</p>
<h3 id="lt-address-gt-transfer-uint256-amount-："><a href="#lt-address-gt-transfer-uint256-amount-：" class="headerlink" title="&lt;address&gt;.transfer(uint256 amount)："></a><code>&lt;address&gt;.transfer(uint256 amount)</code>：</h3><p>给相应地址发送一定数量的以太币（单位wei），<b style="color:red">失败时抛异常，转发2300gas的量，不可调整</b></p>
<h3 id="lt-address-gt-send-uint256-amount-returns-bool-："><a href="#lt-address-gt-send-uint256-amount-returns-bool-：" class="headerlink" title="&lt;address&gt;.send(uint256 amount) returns (bool)："></a><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：</h3><p>给相应地址发送一定数量的以太币（单位wei），<b style="color:red">失败返回false，转发2300gas的量，不可调整</b></p>
<h3 id="lt-address-gt-call-returns-bool-："><a href="#lt-address-gt-call-returns-bool-：" class="headerlink" title="&lt;address&gt;.call(...) returns (bool)："></a><code>&lt;address&gt;.call(...) returns (bool)</code>：</h3><p>发出低级别的CALL，<b style="color:red">失败返回false，转发所有可用的gas，可调节</b></p>
<h3 id="lt-address-gt-callcode-returns-bool-："><a href="#lt-address-gt-callcode-returns-bool-：" class="headerlink" title="&lt;address&gt;.callcode(...) returns (bool)："></a><code>&lt;address&gt;.callcode(...) returns (bool)</code>：</h3><p>发出低级别的CALLCODE，失败返回false，转发所有可用的gas，可调节</p>
<h3 id="lt-address-gt-delegatecall-returns-bool-："><a href="#lt-address-gt-delegatecall-returns-bool-：" class="headerlink" title="&lt;address&gt;.delegatecall(...) returns (bool)："></a><code>&lt;address&gt;.delegatecall(...) returns (bool)</code>：</h3><p>发出低级别的DELEGATECALL，失败返回false，转发所有可用的gas，可调节</p>
<p>欲了解更多信息，请参阅<a href="https://solidity.readthedocs.io/en/v0.4.21/types.html#address" target="_blank" rel="noopener">地址</a>部分。</p>
<p><b style="color:#6ab0de">使用中存在一些危险<code>send</code>：如果调用堆栈深度为1024（调用程序始终强制执行此操作），则传输将失败，如果发起人耗尽gas，则传输也会失败。因此，为了进行安全的ether传输，请务必检查<code>send</code>的返回值，使用<code>transfer</code>甚至更好：使用接收方提取资金的模式。</b></p>
<p><b style="color:#6ab0de">callcode不鼓励使用，将来会被删除。</b></p>
<h2 id="合同相关"><a href="#合同相关" class="headerlink" title="合同相关"></a>合同相关</h2><h3 id="this-（当前合同的类型）："><a href="#this-（当前合同的类型）：" class="headerlink" title="this （当前合同的类型）："></a>this （当前合同的类型）：</h3><p>目前的合同，明确转换为地址</p>
<h3 id="selfdestruct-address-recipient-："><a href="#selfdestruct-address-recipient-：" class="headerlink" title="selfdestruct(address recipient)："></a>selfdestruct(address recipient)：</h3><p>销毁当前的合同，将资金发送到给定的地址</p>
<h3 id="suicide-address-recipient-："><a href="#suicide-address-recipient-：" class="headerlink" title="suicide(address recipient)："></a>suicide(address recipient)：</h3><p>别名 selfdestruct</p>
<p>此外，当前合约的所有功能都可以直接包含当前方法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cordate.github.io/2018/04/03/blockchain/solidity数据类型说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gavin Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/user-avatar">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/blockchain/solidity数据类型说明/" itemprop="url">solidity数据类型说明</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T08:43:48+08:00">2018-04-03</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/" itemprop="url" rel="index"><span itemprop="name">ethereum</span></a></span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/区块链/ethereum/solidity/" itemprop="url" rel="index"><span itemprop="name">solidity</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在看区块链的英文文档，看起来很吃力，重点是特别容易遗忘，只能记一个大概比较痛苦，也许写文章是一个比较好的思路，可以强迫自己进行总结思考。但是最近发现写文章吧，很费时，一天也就只能看一篇（面试+项目上的事情很心烦），再加上区块链这样的技术比较新，有很大的概率会出现一些新的概念，导致一些单词不太好翻译（不像java的学习，现在资料满天飞），这给阅读带来极大的障碍。不管怎样还是坚持吧！</p>
<p>今天来聊聊solidity的类型，网上看过很多资料不是翻译不好就是版本太旧，根本没法看。今天就针对官方的文档总结一下。</p>
<p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>solidity是一种静态类型的语言，这意味着每个变量的类型（State和local）在编译时需要被指定。Solidity提供几个基本类型，这些类型可以组合为复杂的类型。</p>
<p>另外，类型可以在包含运算符的表达式中相互交互。</p>
<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>下面的都是值类型，这些类型的变量永远是采用值传递。在复制和传给方法时，他们都是采用拷贝的方式。</p>
<h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><p>bool：只有值true和false</p>
<h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><p><code>int</code>/<code>uint</code>: 可变长度的有符号和无符号整数。关键字<code>uint8</code>到<code>uint256</code>，步长为8。相对的<code>int8</code>到<code>int256</code>。<code>uint</code>和<code>int</code>是<code>uint256</code>和<code>int256</code>的别名。</p>
<p>除法总是截断（它只是编译为EVM的DIV操作码），但如果两个操作符都是Literals（或Literals表达式），它就不会截断。</p>
<p>移位操作的结果是左操作数的类型(意思是y一直在右边，x一直在左边)。表达式<code>x &lt;&lt; y</code>相当于<code>x * 2 ** y</code>，<code>x &gt;&gt; y</code>相当于<code>x / 2 ** y</code>。 这意味着将负数符号转移。按负数移动会引发运行时异常。</p>
<p><b style="color:red">由有符号整数类型负值的右移产生的结果与其他编程语言产生的结果不同。 在Solidity中，将右侧的地图向右移动，以便移位后的负值将舍入为零（截断）。 在其他编程语言中，负值的右移就像四舍五入的分割（朝向负无穷大）。</b></p>
<h3 id="固定小数的数字"><a href="#固定小数的数字" class="headerlink" title="固定小数的数字"></a>固定小数的数字</h3><p><b style="color:blue">固定点数字尚未完全支持。 它们可以被声明，但不能被赋值或被分配。</b></p>
<p><code>fixed / ufixed</code>：有符号和无符号的各种大小的定点数。 关键词<code>ufixedMxN</code>和<code>fixedMxN</code>，其中M表示类型所占的位数，N表示可用的小数点数。 M必须能被8整除，并从8到256位。 N必须介于0和80之间，包括0和80。 <code>ufixed</code>和<code>fixed</code>分别为<code>ufixed128x19</code>和<code>fixed128x19</code>的别名。</p>
<h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>保存20个字节的值（以太坊地址的大小）。 地址类型也有成员，并作为所有合同的基础。</p>
<p>操作： <code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> and <code>&gt;</code></p>
<p>地址的成员：</p>
<h4 id="balance-和-transfer"><a href="#balance-和-transfer" class="headerlink" title="balance 和 transfer"></a>balance 和 transfer</h4><p>可以使用balance属性来获取账户余额。通过transfer方法发送以太币。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure></p>
<p><b style="color:#6ab0de">如果x是合同地址，则其代码（更具体而言：其fallback方法，如果存在）将与transfer调用一起执行（这是EVM的限制，无法阻止）。 如果执行耗尽gas或以任何方式失败，则以太网币转移将被还原，并且当前合同将以异常停止。</b></p>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>send是transfer低级别的副本。如果执行失败，当前合同的执行不会以异常的方式停止，但是会返回false；注意send调用深度是1024.</p>
<h4 id="call-callcode-delegatecall"><a href="#call-callcode-delegatecall" class="headerlink" title="call, callcode, delegatecall"></a>call, callcode, delegatecall</h4><p>此外，对于不符合ABI的合约接口，提供了函数call，它可以接受任意类型、任意数量的参数。 这些参数被填充到32个字节并连接。一个例外是第一个参数被编码为正好四个字节的情况。在这种情况下，它没有被填充以允许在这里使用方法签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class="line">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class="line">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure></p>
<p>call返回一个布尔值，指示调用的函数是否终止（true）或导致EVM异常（false）。 无法访问返回的实际数据（为此，我们需要事先知道编码和大小）。</p>
<p>我们可以通过<code>.gas()</code>来调整消耗的gas：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure></p>
<p>相似的，提供的以太币数量也可以被控制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure></p>
<p>最后，这些修饰可以组合使用，循序无所谓的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure></p>
<p>delegatecall可以以相同的方式使用，不同点在于只是使用了给定地址的代码，其他方面（storage、balance，……）都是从当前合约获取。delegatecall的目的是使用其他合约存储的library代码。用户必须确认storage的布局是适合双方合约delegatecall的。从Prior到homestead，只有名为<code>callcode</code>的有限变体可用，它不提供对原始合约<code>msg.sender</code>和<code>msg.value</code>值的访问。</p>
<p><b style="color:#6ab0de">这三个函数调用，delegatecall和callcode都是非常低级的函数，只能作为最后的手段，因为它们会破坏Solidity的类型安全性。</b></p>
<p><b style="color:#6ab0de"><code>.gas()</code>操作在这3个方法上都是可用的，<code>.value()方法不能在delegatecall上使用。</code></b></p>
<p><b style="color:red">所有的合约都继承了address的成员，所以我们可以通过<code>this.balance</code>来获取当前合约的账户余额。</b></p>
<p>callcode操作已被放弃，将来可能会被移除。</p>
<p>所有这些功能都是低级功能，应小心使用。具体来说，任何未知的合约都可能是恶意的，如果你要调用它，你将控制权移交给那个可以反过来又回到你的合约中的合约，所以当你的合约call调用返回时，做好改变你的状态变量的准备。</p>
<h3 id="固定大小的字节数组"><a href="#固定大小的字节数组" class="headerlink" title="固定大小的字节数组"></a>固定大小的字节数组</h3><p><code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code>. <code>byte</code> 是 <code>bytes1</code>的别名.</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li>比较： &lt;=, &lt;, ==, !=, &gt;=, &gt; (evaluate to bool)</li>
<li>位操作： &amp;, |, ^ (bitwise exclusive or), ~ (bitwise negation), &lt;&lt; (left shift), &gt;&gt; (right shift) </li>
<li>索引访问</li>
</ul>
<h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><ul>
<li>length：(只读）</li>
</ul>
<p><b style="color:#6ab0de"><code>byte[]</code>可能会浪费大量空间，31个字节；当向调用传递参数时，最好使用<code>bytes</code>.</b></p>
<h3 id="动态大小的byte数组"><a href="#动态大小的byte数组" class="headerlink" title="动态大小的byte数组"></a>动态大小的byte数组</h3><ul>
<li>bytes: 动态大小字节数据，查看<a href="http://solidity.readthedocs.io/zh/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>。不是值类型。</li>
<li>string: 动态大小的UTF-8编码字符串，查看<a href="http://solidity.readthedocs.io/zh/latest/types.html#arrays" target="_blank" rel="noopener">Arrays</a>。不是值类型。</li>
</ul>
<p>根据经验，对任意长度的原始字节数据使用字节，对任意长度的字符串（UTF-8）数据使用字符串。如果您可以将长度限制为特定数量的字节，则始终使用<code>bytes1</code>到<code>bytes32</code>中的一个，因为它们便宜得多。</p>
<h3 id="地址文字"><a href="#地址文字" class="headerlink" title="地址文字"></a>地址文字</h3><p>通过地址校验测试的十六进制文字是地址类型，例如<code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>。 长度在39到41位之间且未通过校验和测试的十六进制文字会产生警告，并被视为常规有理数字文字。</p>
<h3 id="有理数和整数文字"><a href="#有理数和整数文字" class="headerlink" title="有理数和整数文字"></a>有理数和整数文字</h3><p>整数的是0-9的序列组成的，这被解读为数字。例如69. 八进制在solidity中是不存在的，所以前导的0是无效的。</p>
<p>分数是通过<code>.</code>表示的，左或右至少有一个数字。例如<code>1.</code>,<code>.1</code>,<code>1.3</code>。</p>
<p>科学记数法也支持，其中基数可以有分数，而指数则不可以。 例子包括<code>2e10</code>，<code>-2e10</code>，<code>2e-10</code>，<code>2.5e1</code>。</p>
<p>数字文字表达式保持任意精度，直到它们被转换为非文字类型（即通过将它们与非文字表达式一起使用）。 这意味着计算不会溢出，并且不会在数字文字表达式中截断。例如<code>(2**800 + 1) - 2**800</code>导致常量1（类型uint8），尽管中间结果甚至不适合机器字大小。 此外，<code>.5 * 8</code>会导致整数<code>4</code>（<b style="color:red">尽管在它们之间使用了非整数</b>）。</p>
<p>只要操作数是整数，任何可以应用于整数的运算符也可以应用于数字文字表达式。 如果两者中的任何一个都是小数，则位操作是不允许的，并且如果指数是分数（因为这可能导致非有理数），指数是不允许的。</p>
<p><b style="color:red">对于每个有理数，Solidity都有一个数字字面类型。</b>整数文字和有理数字文字属于数字文字类型。 此外，所有数字文字表达式（即仅包含数字文字和运算符的表达式）属于数字文字类型。 所以数字文字表达式1 + 2和2 + 1对于有理数3都属于相同的数字文字类型。</p>
<p><b style="color:#6ab0de">整数除法表达式在早前的版本中是截断的，但是现在将转化为一个有理数，比如<code>5/2</code>不再等于2，二是等于2.5.</b></p>
<p><b style="color:blue">数字文字表达式只要与非文字表达式一起使用，就会转换为非文字类型。 尽管我们知道在以下示例中赋值给b的表达式的值计算为整数，但部分表达式2.5 + a没有类型检查，因此代码不会编译.</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串文字"><a href="#字符串文字" class="headerlink" title="字符串文字"></a>字符串文字</h3><p>单引号或者双引号（”foo”或者’bar’）。它不需要像C中尾部放一个0.与整数文字一样，它们的类型可以变化，但如果它们适合字节和字符串，它们可以隐式转换为<code>bytes1</code>，…，<code>bytes32</code>。</p>
<p>字符串文字也支持转义字符，例如<code>\n</code>, <code>\xNN</code>和<code>\uNNNN</code>。<code>\xNN</code>使用十六进制并插入适当类型。<code>\uNNNN</code>使用Unicode编码，插入以UTF-8序列。</p>
<h3 id="十六进制文字"><a href="#十六进制文字" class="headerlink" title="十六进制文字"></a>十六进制文字</h3><p>以<code>hex</code>开头并且用单引号或者双引号包裹。它们的内容必须是十六进制字符串，它们的值将是这些值的二进制表示。</p>
<p>十六进制文字的行为与字符串文字相似，并具有相同的可转换性限制。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是在Solidity中创建用户定义类型的一种方法。 它们可以显式转换为所有整数类型，但是不允许隐式转换。 显式转换检查运行时的值范围，失败会导致异常。 枚举需要至少一个成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法类型（函数类型）"><a href="#方法类型（函数类型）" class="headerlink" title="方法类型（函数类型）"></a>方法类型（函数类型）</h2><p>函数类型是函数的类型。 函数类型的变量可以从函数中分配，而函数类型的函数参数可以用于将函数传递给函数调用并从函数调用返回函数。 函数类型有两种 - 内部和外部方法：</p>
<p><b style="color:red">内部函数</b>只能在当前合约内（更具体地说，在当前代码单元内部，它还包含内部库函数和继承函数）内部调用，因为它们不能在当前合约的上下文之外执行。 调用内部函数是通过跳转到其入口标签来实现的，就像在内部调用当前合同的函数一样。</p>
<p><b style="color:red">外部函数</b>由一个地址和一个函数签名组成，它们可以通过外部函数调用传递并返回。</p>
<p>函数类型的标注如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure></p>
<p>与参数类型不同，返回类型不能为空 - 如果函数类型不应返回任何内容，则必须省略整个<code>returns (&lt;return types&gt;)</code>部分。</p>
<p>默认情况下，函数类型是内部的，所以内部关键字可以省略。相比之下，合约函数本身在默认情况下是公共的，只有当用作类型的名称时，默认是内部的。</p>
<p><b style="color:red">有两种方法可以访问当前合约中的函数：直接使用其名称f或使用this.f.前者将产生内部功能，后者则具有外部功能。</b></p>
<p>如果函数类型变量未初始化，调用它将导致异常。如果您在使用delete之后调用某个函数，则会发生同样的情况。</p>
<p>如果外部函数类型在Solidity上下文之外使用，则它们被视为函数类型，它将函数标识符后跟的地址一起编码为单个字节24类型。</p>
<p>请注意，当前合约的公共方法既可以用作内部函数，也可以用作外部函数。要将f用作内部函数，只需使用f，如果要使用其外部窗体，请使用this.f.</p>
<p>显示如何使用内部函数类型的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.5;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个使用外部方法类型的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Lambda和内联函数计划加入，但是现在还不支持。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>复杂类型（即不总是适合256位的类型）必须比我们已经看到的值类型更仔细地处理。 由于复制它们可能相当昂贵，我们必须考虑是否要将它们存储在内存中（不是持久的）或存储器（存储状态变量的地方）。</p>
<h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h3><p>每种复杂类型（即数组和结构）都有一个额外的注释，即“数据位置”，关于它是存储在内存还是storage中。根据上下文，总是有一个默认值，但可以通过将<code>storage</code>或<code>memory</code>添加到该类型来覆盖它。函数参数（包括返回参数）的默认值是<code>memory</code>，局部变量的默认值是<code>storage</code>，并且对该状态变量（显然）被强制为<code>storage</code>。</p>
<p>还有第三个数据位置<code>calldata</code>，它是存储函数参数的不可修改的非持久性区域。外部函数的函数参数（不返回参数）被强制为calldata并且行为主要与内存相似。</p>
<p>数据位置很重要，因为它们会改变分配的行为方式：<code>storage</code>和<code>memory</code>之间的分配以及状态变量（甚至来自其他状态变量）的分配始终会创建独立副本。虽然本地存储变量的赋值只能指定一个引用，并且该引用始终指向状态变量，即使后者在此期间发生更改。另一方面，从内存存储引用类型到另一个内存存储引用类型的分配不会创建副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; // the data location of x is storage</span><br><span class="line"></span><br><span class="line">    // the data location of memoryArray is memory</span><br><span class="line">    function f(uint[] memoryArray) &#123;</span><br><span class="line">        x = memoryArray; // works, copies the whole array to storage</span><br><span class="line">        var y = x; // works, assigns a pointer, data location of y is storage</span><br><span class="line">        y[7]; // fine, returns the 8th element</span><br><span class="line">        y.length = 2; // fine, modifies x through y</span><br><span class="line">        delete x; // fine, clears the array, also modifies y</span><br><span class="line">        // The following does not work; it would need to create a new temporary /</span><br><span class="line">        // unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br><span class="line">        // y = memoryArray;</span><br><span class="line">        // This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br><span class="line">        // is no sensible location it could point to.</span><br><span class="line">        // delete y;</span><br><span class="line">        g(x); // calls g, handing over a reference to x</span><br><span class="line">        h(x); // calls h and creates an independent, temporary copy in memory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>强制的数据位置：</p>
<ul>
<li>外部函数的参数（不返回）：calldata</li>
<li>状态变量： storage</li>
</ul>
<p>默认的数据位置：</p>
<ul>
<li>函数的参数（也返回）：memory</li>
<li>其他的本地变量： storage</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组可以有编译时固定的大小，也可以是动态的。对于<code>storage</code>数组，元素类型可以是任意的（即其他数组，映射或结构）。对于<code>memory</code>数组，它不能是一个<code>mapping</code>，如果它是一个公共可见函数的参数，则它必须是ABI类型。</p>
<p>一个固定大小的数组k和元素类型T被写为<code>T[k]</code>，一个动态大小为<code>T[]</code>的数组。举例来说，uint的5个动态数组的数组是<code>uint[][5]</code>（请注意，与其他一些语言相比，符号是反转的）。要访问第三个动态数组中的第二个uint，可以使用<code>x[2][1]</code>（索引是基于零的，<b style="color:red">并且访问以与声明相反的方式工作</b>，即<code>x[2]</code>从类型中删除一个级别正确的）。</p>
<p>bytes和string的变量是特殊数组。一个bytes与byte[]类似，但是它紧密地包含在<code>calldata</code>中。string等于bytes, 但不允许使用长度或索引访问（现在）。</p>
<p>所以bytes总是比byte[]更受欢迎，因为它比较便宜。</p>
<p><b style="color:#6ab0de">如果你想访问字符串<code>s</code>的字节表示，使用<code>bytes(s).length / bytes(s)[7] = &#39;x&#39;;</code>. 请记住，您正在访问UTF-8表示的低级字节，而不是单个字符！</b></p>
<p>有可能将公开的数组标记并让Solidity创建一个getter。 数字索引将成为getter的必需参数。</p>
<h4 id="分配内存数组"><a href="#分配内存数组" class="headerlink" title="分配内存数组"></a>分配内存数组</h4><p>在内存中创建具有可变长度的数组可以使用new关键字来完成。与<code>storage</code>数组相反，通过分配给<code>.length</code>成员来调整存储器阵列的大小是不可能的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="数组文字-行内数组"><a href="#数组文字-行内数组" class="headerlink" title="数组文字/行内数组"></a>数组文字/行内数组</h4><p>数组文字是作为表达式写入的数组，并且不会立即分配给变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] _data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组文本的类型是固定大小的<code>memory</code>数组，其基数类型是给定元素的常见类型。<code>[1,2,3]</code>的类型是<code>uint8[3] memory</code>，因为这些常量中的每一个的类型都是<code>uint8</code>。 因此，有必要将上例中的第一个元素转换为uint。请注意，目前固定大小的<code>memory</code>数组不能分配给动态大小的<code>memory</code>，即以下情况是不可能的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile.</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() &#123;</span><br><span class="line">        // The next line creates a type error because uint[3] memory</span><br><span class="line">        // cannot be converted to uint[] memory.</span><br><span class="line">        uint[] x = [uint(1), 3, 4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计划在将来删除此限制，但由于数组在ABI中的传递方式，目前会产生一些复杂性。</p>
<h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><p>数组有一个<code>length</code>成员来保存元素的数量。 通过更改<code>.length</code>成员，动态数组可以在<code>storage</code>中（不在内存中）调整大小。 尝试访问当前长度以外的元素时，不会自动发生。<code>memory</code>数组的大小一旦被创建就是固定的（但是动态的，即它可以依赖于运行时参数）。</p>
<h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>动态<code>storage</code>数组和bytes（不是字符串）具有一个名为push的成员函数，可用于在数组末尾追加一个元素。 该函数返回新的长度。</p>
<p><b style="color:#6ab0de">尚不可能在外部函数中使用数组的数组。</b></p>
<p><b style="color:#6ab0de">由于EVM的限制，无法从外部函数调用返回动态内容。 <code>contract C { function f() returns (uint[]) { ... } }</code>中的函数f将返回从web3.js调用的内容，但不会从Solidity调用。<br>现在唯一的解决方法是使用大型静态大小的数组。</b></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[2**20] m_aLotOfIntegers;</span><br><span class="line">    // Note that the following is not a pair of dynamic arrays but a</span><br><span class="line">    // dynamic array of pairs (i.e. of fixed size arrays of length two).</span><br><span class="line">    bool[2][] m_pairsOfFlags;</span><br><span class="line">    // newPairs is stored in memory - the default for function arguments</span><br><span class="line"></span><br><span class="line">    function setAllFlagPairs(bool[2][] newPairs) &#123;</span><br><span class="line">        // assignment to a storage array replaces the complete array</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFlagPair(uint index, bool flagA, bool flagB) &#123;</span><br><span class="line">        // access to a non-existing index will throw an exception</span><br><span class="line">        m_pairsOfFlags[index][0] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][1] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeFlagArraySize(uint newSize) &#123;</span><br><span class="line">        // if the new size is smaller, removed array elements will be cleared</span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() &#123;</span><br><span class="line">        // these clear the arrays completely</span><br><span class="line">        delete m_pairsOfFlags;</span><br><span class="line">        delete m_aLotOfIntegers;</span><br><span class="line">        // identical effect here</span><br><span class="line">        m_pairsOfFlags.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    function byteArrays(bytes data) &#123;</span><br><span class="line">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class="line">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += 7;</span><br><span class="line">        m_byteData[3] = 8;</span><br><span class="line">        delete m_byteData[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addFlag(bool[2] flag) returns (uint) &#123;</span><br><span class="line">        return m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createMemoryArray(uint size) returns (bytes) &#123;</span><br><span class="line">        // Dynamic memory arrays are created using `new`:</span><br><span class="line">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class="line">        // Create a dynamic byte array:</span><br><span class="line">        bytes memory b = new bytes(200);</span><br><span class="line">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Solidity提供了一种以结构形式定义新类型的方法，如以下示例所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    // Defines a new type with two fields.</span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (uint =&gt; Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    function newCampaign(address beneficiary, uint goal) returns (uint campaignID) &#123;</span><br><span class="line">        campaignID = numCampaigns++; // campaignID is return variable</span><br><span class="line">        // Creates new struct and saves in storage. We leave out the mapping type.</span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute(uint campaignID) payable &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        // Creates a new temporary memory struct, initialised with the given values</span><br><span class="line">        // and copies it over to storage.</span><br><span class="line">        // Note that you can also use Funder(msg.sender, msg.value) to initialise.</span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkGoalReached(uint campaignID) returns (bool reached) &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        if (c.amount &lt; c.fundingGoal)</span><br><span class="line">            return false;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = 0;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合约没有提供众筹合约的全部功能，但它包含了理解结构所必需的基本概念。 结构类型可以用在映射和数组中，它们本身可以包含映射和数组。</p>
<p>尽管结构本身可以是映射成员的值类型，但结构不可能包含它自己类型的成员。 这个限制是必要的，因为结构的大小必须是有限的。</p>
<p>请注意，在所有函数中，结构类型被分配给（缺省存储数据位置的）局部变量。 这不会复制该结构，而只会存储一个引用，以便分配给本地变量的成员实际写入该状态。</p>
<p>当然，您也可以直接访问结构体的成员，而无需将其分配给本地变量，比如<code>campaigns[campaignID].amount=0</code>。</p>
<h3 id="映射Mappings"><a href="#映射Mappings" class="headerlink" title="映射Mappings"></a>映射Mappings</h3><p>映射类型被声明为<code>mapping(_KeyType =&gt; _ValueType)</code>。这里<code>_KeyType</code>几乎可以是任何类型，除了映射，动态大小的数组，合约，枚举和结构。 <code>_ValueType</code>实际上可以是任何类型，包括映射。</p>
<p>映射可以看作散列表，它被虚拟初始化，这样每个可能的键都存在并映射到一个字节表示全为零的值：一个类型的<a href="http://solidity.readthedocs.io/zh/latest/control-structures.html#default-value" target="_blank" rel="noopener">默认值</a>。但是，相似性在此处结束：关键数据实际上并不存储在映射中，只有其<code>keccak256</code>哈希用于查找值。</p>
<p>因此，映射没有长度或“设置”键或值的概念。</p>
<p>映射只能用于状态变量（或作为内部函数中的存储引用类型）。</p>
<p>有可能将<code>public</code>标记映射并让Solidity创建一个getter。<code>_KeyType</code>将成为getter的必需参数，它将返回<code>_ValueType</code>。</p>
<p><code>_ValueType</code>也可以是一个映射。 getter将递归地为每个<code>_KeyType</code>使用一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint newBalance) &#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    function f() returns (uint) &#123;</span><br><span class="line">        MappingExample m = new MappingExample();</span><br><span class="line">        m.update(100);</span><br><span class="line">        return m.balances(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>映射不可迭代，但可以在其上实现数据结构。 有关示例，请参阅<a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank" rel="noopener">可迭代映射</a>。</p>
<h2 id="涉及LValues的操作符"><a href="#涉及LValues的操作符" class="headerlink" title="涉及LValues的操作符"></a>涉及LValues的操作符</h2><p>如果a是一个LValue（即一个变量或可以分配的东西），则以下运算符可用作简写：</p>
<p><code>a += e</code>相当于<code>a = a + e</code>。 相应地定义运算符 -=，*=，/=，％=，a |=，＆=和^=。 a++和a–相当于 a+= 1 / a -= 1，但表达式本身仍然具有a的前一个值。 相反，–a和++a对a有相同的效果，但在更改后返回值。</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><b style="color:red"><code>delete a</code>将类型的初始值赋给a</b>。即 对于整数而言，它相当于<code>a = 0</code>，但它也可以用于数组，它指定一个长度为零的动态数组或一个长度相同且所有元素都重置的静态数组。 对于结构体，它分配一个所有成员重置的结构体。</p>
<p>删除对整个映射没有影响（因为映射的键可能是任意的并且通常是未知的）。 所以，如果你删除一个结构体，它将重置所有不是映射的成员，并且还会映射到成员中，除非它们是映射关系。 但是，可以删除个人密钥及其映射的内容。</p>
<p><b style="color:red">需要注意的是<code>delete a</code>的行为类似于对a的赋值，即它将一个新对象存储在a中。</b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() &#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        delete x; // sets x to 0, does not affect data</span><br><span class="line">        delete data; // sets data to 0, does not affect x which still holds a copy</span><br><span class="line">        uint[] y = dataArray;</span><br><span class="line">        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also</span><br><span class="line">        // y is affected which is an alias to the storage object</span><br><span class="line">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span><br><span class="line">        // referencing storage objects can only be made from existing storage objects.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h2><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>如果编译器不允许隐式转换，但您知道自己在做什么，则有时可以使用显式类型转换。请注意，这可能会给你一些意想不到的行为，所以一定要测试以确保结果是你想要的！以下面的例子为例，你将一个负数int8转换为uint：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int8 y = -3;</span><br><span class="line">uint x = uint(y);</span><br></pre></td></tr></table></figure></p>
<p>在此代码片段的末尾，x将具有值<code>0xfffff..fd</code>（64个十六进制字符），在256位的二进制补码表示中为<code>-3</code>。</p>
<p>如果某种类型明确转换为较小类型，则会切断较高位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // b will be 0x5678 now</span><br></pre></td></tr></table></figure></p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>为了方便起见，并不总是需要明确指定变量的类型，编译器会根据分配给变量的第一个表达式的类型自动推断它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint24 x = 0x123;</span><br><span class="line">var y = x;</span><br></pre></td></tr></table></figure></p>
<p>在这里，类型y将是uint24。var函数参数或返回参数不可用。</p>
<p><b style="color:#6ab0de">该类型仅从第一个赋值中推导出来，因此以下片段中的循环是无限的，因为i将具有该类型uint8并且该类型的 任何值都小于2000.</b><code>for (var i = 0; i &lt; 2000; i++) { ... }</code>.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/user-avatar"
                alt="Gavin Zhang" />
            
              <p class="site-author-name" itemprop="name">Gavin Zhang</p>
              <p class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">82</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  

  
</div>




  <div class="powered-by">由 Gavin 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
