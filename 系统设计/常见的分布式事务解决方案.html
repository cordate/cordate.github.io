<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon2.jpg?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    fancybox: false,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="事务是什么事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。 事务ACID特性说到事务，就不得不提一下事务著名的四大特性。 原子性原子性要求，事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。 一致性一致性要求，事务在开始前和结束">
<meta name="keywords" content="分布式事务">
<meta property="og:type" content="article">
<meta property="og:title" content="常用的分布式事务解决方案">
<meta property="og:url" content="https://cordate.github.io/系统设计/常见的分布式事务解决方案.html">
<meta property="og:site_name" content="柳絮纷飞">
<meta property="og:description" content="事务是什么事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。 事务ACID特性说到事务，就不得不提一下事务著名的四大特性。 原子性原子性要求，事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。 一致性一致性要求，事务在开始前和结束">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-08T17:32:48.716Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用的分布式事务解决方案">
<meta name="twitter:description" content="事务是什么事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。 事务ACID特性说到事务，就不得不提一下事务著名的四大特性。 原子性原子性要求，事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。 一致性一致性要求，事务在开始前和结束">



  <link rel="alternate" href="https://legacy.gitbook.com/@gavinzhang1" title="柳絮纷飞" type="application/atom+xml"/>



  
  
  <link rel="canonical" href="https://cordate.github.io/系统设计/常见的分布式事务解决方案"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>常用的分布式事务解决方案 | 柳絮纷飞</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

  
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav navbar navbar-default sticky animated fadeInDown" role="navigation">
  
    <ul id="menu" class="menu nav navbar-nav hidden-sm">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-vedio">

    

    
      
    

    <a href="/vedio/" rel="section"><i class="menu-item-icon fa fa-fw fa-film"></i>视频</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-pictures">

    

    
      
    

    <a href="/pictures/" rel="section"><i class="menu-item-icon fa fa-fw fa-picture-o"></i>图片</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> 搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  
    <div class="reading-progress-bar"></div>
  

  
    
      
      <img src="/images/blog/风景6.jpeg" alt="背景图" width="100%"/>
    
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cordate.github.io/系统设计/常见的分布式事务解决方案.html"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Author"/>
      <meta itemprop="description" content="一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com"/>
      <meta itemprop="image" content="/images/user-avatar.jpg"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="柳絮纷飞"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">常用的分布式事务解决方案

              
            
          </h2>
        

        <div class="post-meta">

          <!-- 置顶的实现 -->
          

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-19 15:34:50" itemprop="dateCreated datePublished" datetime="2019-08-19T15:34:50+08:00">2019-08-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-09 01:32:48" itemprop="dateModified" datetime="2019-09-09T01:32:48+08:00">2019-09-09</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/系统设计/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/系统设计/微服务/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          <!-- 页面访问量统计 -->
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon"
              >
                <i class="fa fa-eye"></i>
                 阅读次数： 
                <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
              </span>
            </span>
          

          

          <br/>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span title="本文字数">13k</span>
            </span>
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span title="阅读时长">12 分钟</span>
            </span>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="事务是什么"><a href="#事务是什么" class="headerlink" title="事务是什么"></a>事务是什么</h1><p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p>
<h1 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h1><p>说到事务，就不得不提一下事务著名的四大特性。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性要求，事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>一致性要求，事务在开始前和结束后，数据库的完整性约束没有被破坏。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>持久性要求，一个事务完成之后，事务的执行结果必须是持久化保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。</p>
<p>注意：事务只能保证数据库的高可靠性，即数据库本身发生问题后，事务提交后的数据仍然能恢复；<b style="color:red">而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于『高可用性』的范畴。</b>因此，事务只能保证数据库的『高可靠性』，而『高可用性』需要整个系统共同配合实现。</p>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>在事务的四大特性ACID中，要求的隔离性是一种严格意义上的隔离，也就是多个事务是串行执行的，彼此之间不会受到任何干扰。这确实能够完全保证数据的安全性，但在实际业务系统中，这种方式性能不高。因此，数据库定义了四种隔离级别，隔离级别和数据库的性能是呈反比的，隔离级别越低，数据库性能越高，而隔离级别越高，数据库性能越差。</p>
<h2 id="事务执行过程中可能存在的问题"><a href="#事务执行过程中可能存在的问题" class="headerlink" title="事务执行过程中可能存在的问题"></a>事务执行过程中可能存在的问题</h2><ol>
<li>更新丢失<br>当有两个并发执行的事务，更新同一行数据，那么有可能一个事务会把另一个事务的更新覆盖掉。 当数据库没有加任何锁操作的情况下会发生。</li>
<li>脏读<br>一个事务读到另一个尚未提交的事务中的数据。 该数据可能会被回滚从而失效。 如果第一个事务拿着失效的数据去处理那就发生错误了。</li>
<li>不可重复读 （虚读）<br>不可重复度的含义：一个事务对同一行数据读了两次，却得到了不同的结果。出现的情况可能是很多种情况的。</li>
<li>幻读<br>同一事务中，用同样的操作读取两次，中间可能存在删除和插入操作使得得到的记录数不相同。</li>
</ol>
<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><h3 id="Read-uncommitted（读未提交）"><a href="#Read-uncommitted（读未提交）" class="headerlink" title="Read uncommitted（读未提交）"></a>Read uncommitted（读未提交）</h3><p>在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。<br>因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。</p>
<h3 id="Read-committed-（读提交）"><a href="#Read-committed-（读提交）" class="headerlink" title="Read committed （读提交）"></a>Read committed （读提交）</h3><p>在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。</p>
<h3 id="Repeatable-read-（重复读）"><a href="#Repeatable-read-（重复读）" class="headerlink" title="Repeatable read （重复读）"></a>Repeatable read （重复读）</h3><p>在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。</p>
<h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。</p>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。<b style="color:red">尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。如果是序列化，可以使用业务锁来进行实现；或者通过业务场景的拆分来解决就好了。</b></p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>以上说得都是单库的分布式事务的问题，但是如果在微服务的场景下，一笔业务可能涉及多个单库事务一起提交的场景。</p>
<p>这里举一个分布式事务的典型例子——用户下单过程。<br>当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p>
<ol>
<li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li>
<li>此时订单系统会生成一条订单</li>
<li>订单创建成功后，支付系统提供支付功能</li>
<li>当支付完成后，由积分系统为该用户增加积分</li>
</ol>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP理论说的是：在一个分布式系统中，最多只能满足C、A、P中的两个需求。<b style="color:red">一般来说，我们都是保证CP和AP，一般不会出现CA这种情况。</b><br>CAP的含义：</p>
<ul>
<li>C：Consistency 一致性<br>同一数据的多个副本是否实时相同。</li>
<li>A：Availability 可用性<br>可用性：一定时间内 &amp; 系统返回一个明确的结果 则称为该系统可用。</li>
<li>P：Partition tolerance 分区容错性<br><b style="color:red">将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。</b></li>
</ul>
<p>CAP理论告诉我们，在分布式系统中，C、A、P三个条件中我们最多只能选择两个。那么问题来了，究竟选择哪两个条件较为合适呢？</p>
<p>对于一个业务系统来说，可用性和分区容错性是必须要满足的两个条件，并且这两者是相辅相成的。业务系统之所以使用分布式系统，主要原因有两个：</p>
<ol>
<li>提升整体性能<br>当业务量猛增，单个服务器已经无法满足我们的业务需求的时候，就需要使用分布式系统，使用多个节点提供相同的功能，从而整体上提升系统的性能，这就是使用分布式系统的第一个原因。</li>
<li>实现分区容错性<br>单一节点 或 多个节点处于相同的网络环境下，那么会存在一定的风险，万一该机房断电、该地区发生自然灾害，那么业务系统就全面瘫痪了。为了防止这一问题，采用分布式系统，将多个子系统分布在不同的地域、不同的机房中，从而保证系统高可用性。</li>
</ol>
<p>这说明分区容错性是分布式系统的根本，如果分区容错性不能满足，那使用分布式系统将失去意义。<br>此外，可用性对业务系统也尤为重要。在大谈用户体验的今天，如果业务系统时常出现“系统异常”、响应时间过长等情况，这使得用户对系统的好感度大打折扣，在互联网行业竞争激烈的今天，相同领域的竞争者不甚枚举，系统的间歇性不可用会立马导致用户流向竞争对手。因此，我们只能通过牺牲一致性来换取系统的可用性和分区容错性。这也就是下面要介绍的BASE理论。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMDcvY2FwLmh0bWw=" title="http://www.ruanyifeng.com/blog/2018/07/cap.html">http://www.ruanyifeng.com/blog/2018/07/cap.html<i class="fa fa-external-link"></i></span></p>
</blockquote>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE是基本可用（Basically Available）、软状态（Soft state）和最终一致性（Eventually consistent）三个英文的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性，其实就是我们所说的，<b style="color:red">牺牲强一致性换取弱一致性。</b>那么具体看一下BASE中的三要素：</p>
<h2 id="1-基本可用（Basically-Available）"><a href="#1-基本可用（Basically-Available）" class="headerlink" title="1.基本可用（Basically Available）"></a>1.基本可用（Basically Available）</h2><p>当分布式系统出现故障时，允许损失部分可用性，保证核心模块的可用性。这个很好理解，当出现故障时，首先考虑的肯定是核心模块，但也不是说要牺牲掉其他模块，只是在极端情况下对服务做的降级。</p>
<p>有以下两种方式：</p>
<ul>
<li>“一定时间”可以适当延长 当举行大促时，响应时间可以适当延长</li>
<li>给部分用户返回一个降级页面 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。</li>
</ul>
<h2 id="2-软状态（Soft-state）"><a href="#2-软状态（Soft-state）" class="headerlink" title="2.软状态（Soft state）"></a>2.软状态（Soft state）</h2><p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，<b style="color:red">即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时,不需要实时的一致性</b>。例如mysql的主从同步就是存在延时的，只要上游可以接受这种延时，就没有问题。</p>
<h2 id="3-最终一致性（Eventually-consistent）"><a href="#3-最终一致性（Eventually-consistent）" class="headerlink" title="3.最终一致性（Eventually consistent）"></a>3.最终一致性（Eventually consistent）</h2><p>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。针对不同的业务，数据达到一致状态的容忍时间也是不同的。我注册之后，可以几秒钟就需要登陆，需要数据一致，但是发表一篇文章，几分钟之后达到一致性也不会有影响。</p>
<p>BASE理论其实就是对CAP理论的延伸和补充，主要是对AP的补充。牺牲数据的强一致性，来保证数据的可用性，虽然存在中间装填，但数据最终一致。</p>
<h1 id="ACID-酸碱平衡"><a href="#ACID-酸碱平衡" class="headerlink" title="ACID 酸碱平衡"></a>ACID 酸碱平衡</h1><p>ACID能够保证事务的强一致性，即数据是实时一致的。这在本地事务中是没有问题的，在分布式事务中，强一致性会极大影响分布式系统的性能，因此分布式系统中遵循BASE理论即可。但分布式系统的不同业务场景对一致性的要求也不同。如交易场景下，就要求强一致性，此时就需要遵循ACID理论，而在注册成功后发送短信验证码等场景下，并不需要实时一致，因此遵循BASE理论即可。因此要根据具体业务场景，在ACID和BASE之间寻求平衡。</p>
<h1 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h1><p>上面讲了一大堆的原理，下面我们学习一下分布式协议方面的知识。</p>
<h2 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议 2PC"></a>两阶段提交协议 2PC</h2><p>分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：</p>
<ul>
<li>该分布式系统中，<b style="color:red">存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)</b>。且节点之间可以进行网络通信。</li>
<li><b style="color:red">所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失</b>。</li>
<li><b style="color:red">所有节点不会永久性损坏，即使损坏后仍然可以恢复</b>。</li>
</ul>
<p>下面我们学习一下具体的实现细节：</p>
<ol>
<li>第一阶段（投票阶段）：<ol>
<li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li>
<li>参与者节点执行询问发起为止的所有事务操作，<b style="red">并将Undo信息和Redo信息写入日志</b>。（注意：若成功这里其实每个参与者已经执行了事务操作，日志信息很重要。）</li>
<li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li>
</ol>
</li>
<li>第二阶段（提交执行阶段）：<ol>
<li>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：<ol>
<li>协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</li>
<li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送”完成”消息。</li>
<li><b style="color:red">协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。其实事情都已经做了，没收到消息也无所谓，这里只是需要尽到通知完各个节点，以告知成功并释放占用的资源而已。</b></li>
</ol>
</li>
<li>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：<ol>
<li>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</li>
<li><b style="red">参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源</b>。</li>
<li>参与者节点向协调者节点发送”回滚完成”消息。</li>
<li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。<b style="color:red">如果没有收到会一直重试，但是这中间可能有些机器的数据没有回滚这样会带来一定的问题。</b></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>不管最后结果如何，第二阶段都会结束当前事务。</p>
<p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：</p>
<ol>
<li><b style="color:blue">执行过程中，所有参与节点都是事务阻塞型的</b>。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li>参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）</li>
<li><b style="color:red">协调者发生故障。参与者会一直阻塞下去</b>。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）</li>
<li><b style="color:red">二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交</b>。</li>
</ol>
<p>为此，Dale Skeen和Michael Stonebraker在“A Formal Model of Crash Recovery in a Distributed System”中提出了三阶段提交协议（3PC）。</p>
<h2 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议 3PC"></a>三阶段提交协议 3PC</h2><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<ol>
<li><b style="color:red">引入超时机制。同时在协调者和参与者中都引入超时机制</b>。</li>
<li><b style="color:blue">在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的</b>。</li>
</ol>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p>
<ol>
<li><p>CanCommit阶段<br>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p>
<ol>
<li>事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li>
<li>响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li>
</ol>
</li>
<li><p>PreCommit阶段<br>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。</p>
<ol>
<li>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。<ol>
<li>发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。</li>
<li>事务预提交 参与者接收到PreCommit请求后，<b style="color:red">会执行事务操作，并将undo和redo信息记录到事务日志中</b>。</li>
<li>响应反馈 <b style="color:red">如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令</b>。</li>
</ol>
</li>
<li>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<ol>
<li>发送中断请求 协调者向所有参与者发送abort请求。</li>
<li>中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ol>
</li>
</ol>
</li>
<li>doCommit阶段<br>该阶段进行真正的事务提交，也可以分为以下两种情况。<ol>
<li>执行提交<ol>
<li>发送提交请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</li>
<li>事务提交 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li>
<li>响应反馈 <b style="color:red">事务提交完之后，向协调者发送Ack响应</b>。</li>
<li>完成事务 协调者接收到所有参与者的ack响应之后，完成事务。</li>
</ol>
</li>
<li>中断事务 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。<ol>
<li>发送中断请求 协调者向所有参与者发送abort请求</li>
<li>事务回滚 参与者接收到abort请求之后，<b style="color:red">利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源</b>。</li>
<li>反馈结果 参与者完成事务回滚之后，向协调者发送ACK消息</li>
<li>中断事务 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这里需要注意的是，日志落入的undo和redo日志如果在一台机器上，那么会出现事务节点不能是同类型的其他机器，这样会导致分布式的缺陷，也容易产生这台机器倒了而找不到数据的情况。所以需要使用分布式的存储。</p>
<p>协调者可以是系统中的某一类服务；当然如果你想做得好，那么你就要将协调者独立出来做成一个单一服务，这样就具有普遍的适用性。</p>
<h1 id="分布式事务的解决方案"><a href="#分布式事务的解决方案" class="headerlink" title="分布式事务的解决方案"></a>分布式事务的解决方案</h1><p>分布式事务的解决方案有如下几种：</p>
<ul>
<li>全局消息</li>
<li>基于可靠消息服务的分布式事务</li>
<li>TCC</li>
<li>最大努力通知</li>
</ul>
<h2 id="方案1：全局事务（DTP模型）"><a href="#方案1：全局事务（DTP模型）" class="headerlink" title="方案1：全局事务（DTP模型）"></a>方案1：全局事务（DTP模型）</h2><p>全局事务基于DTP模型实现。DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。它规定了要实现分布式事务，需要三种角色：</p>
<ul>
<li>AP：Application 应用系统<br>它就是我们开发的业务系统，在我们开发的过程中，可以使用资源管理器提供的事务接口来实现分布式事务。</li>
<li>TM：Transaction Manager 事务管理器<ul>
<li>分布式事务的实现由事务管理器来完成，它会提供分布式事务的操作接口供我们的业务系统调用。这些接口称为TX接口。</li>
<li>事务管理器还管理着所有的资源管理器，通过它们提供的XA接口来同一调度这些资源管理器，以实现分布式事务。</li>
<li>DTP只是一套实现分布式事务的规范，并没有定义具体如何实现分布式事务，TM可以采用2PC、3PC、Paxos等协议实现分布式事务。</li>
</ul>
</li>
<li>RM：Resource Manager 资源管理器<ul>
<li>能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等。大部分场景下，数据库即为分布式事务中的资源管理器。</li>
<li>资源管理器能够提供单数据库的事务能力，它们通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式的事务管理。</li>
<li>XA是DTP模型定义的接口，用于向事务管理器提供该资源管理器(该数据库)的提交、回滚等能力。</li>
<li>DTP只是一套实现分布式事务的规范，RM具体的实现是由数据库厂商来完成的。</li>
</ul>
</li>
</ul>
<p>详情可以查看<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWlnb25nc2kvYXJjaGl2ZS8yMDEyLzEwLzExLzI3MTgzMTMuaHRtbA==" title="https://www.cnblogs.com/aigongsi/archive/2012/10/11/2718313.html">X/Open DTP——分布式事务模型<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1emhpd2VpNTQ5L2FydGljbGUvZGV0YWlscy83OTkyNTYxOA==" title="https://blog.csdn.net/wuzhiwei549/article/details/79925618">XA 分布式事务原理<i class="fa fa-external-link"></i></span></p>
<h2 id="方案2：基于可靠消息服务的分布式事务"><a href="#方案2：基于可靠消息服务的分布式事务" class="headerlink" title="方案2：基于可靠消息服务的分布式事务"></a>方案2：基于可靠消息服务的分布式事务</h2><p>这种实现分布式事务的方式需要通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理。下面来介绍基于消息中间件来实现这种分布式事务。</p>
<p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF1.png"></p>
<ul>
<li>在系统A处理任务A前，首先向消息中间件发送一条消息</li>
<li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li>
<li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li>
<li>系统A收到确认应答后，则可以开始处理任务A；<br>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。<br>但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li>
<li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li>
<li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li>
</ul>
<p>上述过程可以得出如下几个结论：</p>
<ul>
<li>消息中间件扮演者分布式事务协调者的角色。</li>
<li>系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，满足BASE理论。</li>
</ul>
<p>上述过程中，如果任务A处理失败，那么需要进入回滚流程，如下图所示：<br><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF2.png"></p>
<ul>
<li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li>
<li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li>
</ul>
<p>此时系统又处于一致性状态，因为任务A和任务B都没有执行。</p>
<p>上面所介绍的Commit和Rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。<br><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF3.png"></p>
<p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的Commit或Rollback指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p>
<ul>
<li>提交 若获得的状态是“提交”，则将该消息投递给系统B。</li>
<li>回滚 若获得的状态是“回滚”，则直接将条消息丢弃。</li>
<li>处理中 若获得的状态是“处理中”，则继续等待。</li>
</ul>
<p>消息中间件的超时询问机制能够防止上游系统因在传输过程中丢失Commit/Rollback指令而导致的系统不一致情况，而且能降低上游系统的阻塞时间，上游系统只要发出Commit/Rollback指令后便可以处理其他任务，无需等待确认应答。而Commit/Rollback指令丢失的情况通过超时询问机制来弥补，这样大大降低上游系统的阻塞时间，提升系统的并发度。</p>
<p>下面来说一说消息投递过程的可靠性保证。当上游系统执行完任务并向消息中间件提交了Commit指令后，便可以处理其他任务了，此时它可以认为事务已经完成，接下来消息中间件<strong>一定会保证消息被下游系统成功消费掉！</strong>那么这是怎么做到的呢？这由消息中间件的投递流程来保证。</p>
<p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p>
<p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p>
<p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF4.png"></p>
<p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF5.png"></p>
<p>有的同学可能要问：消息投递失败后为什么不回滚消息，而是不断尝试重新投递？</p>
<p>这就涉及到整套分布式事务系统的实现成本问题。我们知道，当系统A将向消息中间件发送Commit指令后，它便去做别的事情了。如果此时消息投递失败，需要回滚的话，就需要让系统A事先提供回滚接口，这无疑增加了额外的开发成本，业务系统的复杂度也将提高。对于一个业务系统的设计目标是，在保证性能的前提下，最大限度地降低系统复杂度，从而能够降低系统的运维成本。</p>
<p>不知大家是否发现，上游系统A向消息中间件提交Commit/Rollback消息采用的是异步方式，也就是当上游系统提交完消息后便可以去做别的事情，接下来提交、回滚就完全交给消息中间件来完成，并且完全信任消息中间件，认为它一定能正确地完成事务的提交或回滚。然而，消息中间件向下游系统投递消息的过程是同步的。也就是消息中间件将消息投递给下游系统后，它会阻塞等待，等下游系统成功处理完任务返回确认应答后才取消阻塞等待。为什么这两者在设计上是不一致的呢？</p>
<p>首先，上游系统和消息中间件之间采用异步通信是为了提高系统并发度。业务系统直接和用户打交道，用户体验尤为重要，因此这种异步通信方式能够极大程度地降低用户等待时间。此外，异步通信相对于同步通信而言，没有了长时间的阻塞等待，因此系统的并发性也大大增加。但异步通信可能会引起Commit/Rollback指令丢失的问题，这就由消息中间件的超时询问机制来弥补。</p>
<p>那么，消息中间件和下游系统之间为什么要采用同步通信呢？</p>
<p>异步能提升系统性能，但随之会增加系统复杂度；而同步虽然降低系统并发度，但实现成本较低。因此，在对并发度要求不是很高的情况下，或者服务器资源较为充裕的情况下，我们可以选择同步来降低系统的复杂度。我们知道，消息中间件是一个独立于业务系统的第三方中间件，它不和任何业务系统产生直接的耦合，它也不和用户产生直接的关联，它一般部署在独立的服务器集群上，具有良好的可扩展性，所以不必太过于担心它的性能，如果处理速度无法满足我们的要求，可以增加机器来解决。而且，即使消息中间件处理速度有一定的延迟那也是可以接受的，因为前面所介绍的BASE理论就告诉我们了，我们追求的是最终一致性，而非实时一致性，因此消息中间件产生的时延导致事务短暂的不一致是可以接受的。</p>
<h2 id="方案3：最大努力通知（定期校对）"><a href="#方案3：最大努力通知（定期校对）" class="headerlink" title="方案3：最大努力通知（定期校对）"></a>方案3：最大努力通知（定期校对）</h2><p>最大努力通知也被称为定期校对，其实在方案二中已经包含，这里再单独介绍，主要是为了知识体系的完整性。这种方案也需要消息中间件的参与，其过程如下：</p>
<p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.png"></p>
<ul>
<li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li>
<li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li>
<li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li>
</ul>
<p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p>
<ol>
<li>消息中间件向下游系统投递消息失败</li>
<li>上游系统向消息中间件发送消息失败</li>
</ol>
<p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”。</p>
<p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p>
<p>对于第二种情况，需要在上游系统中建立消息重发机制。可以在上游系统建立一张本地消息表，并将 任务处理过程 和 向本地消息表中插入消息 这两个步骤放在一个本地事务中完成。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。如果这量步都执行成功，那么该本地事务就完成了。接下来会有一个专门的消息发送者不断地发送本地消息表中的消息，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p>
<p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过重试机制+定期校对实现分布式事务，但相比于第二种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p>
<p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。</p>
<h2 id="方案4：TCC（两阶段型-补偿型）"><a href="#方案4：TCC（两阶段型-补偿型）" class="headerlink" title="方案4：TCC（两阶段型 + 补偿型）"></a>方案4：TCC（两阶段型 + 补偿型）</h2><p>TCC即为Try Confirm Cancel，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p>
<ul>
<li>Try：尝试待执行的业务<br>这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源</li>
<li>Confirm：执行业务<br>这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。</li>
<li>Cancel：取消执行的业务<br>若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。</li>
</ul>
<p>下面以一个转账的例子来解释下TCC实现分布式事务的过程。</p>
<p>假设用户A用他的账户余额给用户B发一个100元的红包，并且余额系统和红包系统是两个独立的系统。</p>
<ol>
<li>Try<ul>
<li>创建一条转账流水，并将流水的状态设为交易中</li>
<li>将用户A的账户中扣除100元（预留业务资源）</li>
<li>Try成功之后，便进入Confirm阶段</li>
<li>Try过程发生任何异常，均进入Cancel阶段</li>
</ul>
</li>
<li>Confirm<ul>
<li>向B用户的红包账户中增加100元</li>
<li>将流水的状态设为交易已完成</li>
<li>Confirm过程发生任何异常，均进入Cancel阶段</li>
<li>Confirm过程执行成功，则该事务结束</li>
</ul>
</li>
<li>Cancel<ul>
<li>将用户A的账户增加100元</li>
<li>将流水的状态设为交易失败</li>
</ul>
</li>
</ol>
<p>在传统事务机制中，业务逻辑的执行和事务的处理，是在不同的阶段由不同的部件来完成的：业务逻辑部分访问资源实现数据存储，其处理是由业务系统负责；事务处理部分通过协调资源管理器以实现事务管理，其处理由事务管理器来负责。二者没有太多交互的地方，所以，传统事务管理器的事务处理逻辑，仅需要着眼于事务完成（commit/rollback）阶段，而不必关注业务执行阶段。</p>
<h3 id="TCC全局事务必须基于RM本地事务来实现全局事务"><a href="#TCC全局事务必须基于RM本地事务来实现全局事务" class="headerlink" title="TCC全局事务必须基于RM本地事务来实现全局事务"></a>TCC全局事务必须基于RM本地事务来实现全局事务</h3><p>TCC服务是由Try/Confirm/Cancel业务构成的，<br>其Try/Confirm/Cancel业务在执行时，会访问资源管理器（Resource Manager，下文简称RM）来存取数据。这些存取操作，必须要参与RM本地事务，以使其更改的数据要么都commit，要么都rollback。</p>
<p>这一点不难理解，考虑一下如下场景：</p>
<p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.png"></p>
<p>假设图中的服务B没有基于RM本地事务（以RDBS为例，可通过设置auto-commit为true来模拟），那么一旦[B:Try]操作中途执行失败，TCC事务框架后续决定回滚全局事务时，该[B:Cancel]则需要判断[B:Try]中哪些操作已经写到DB、哪些操作还没有写到DB：假设[B:Try]业务有5个写库操作，[B:Cancel]业务则需要逐个判断这5个操作是否生效，并将生效的操作执行反向操作。</p>
<p>不幸的是，由于[B:Cancel]业务也有n（0&lt;=n&lt;=5）个反向的写库操作，此时一旦[B:Cancel]也中途出错，则后续的[B:Cancel]执行任务更加繁重。因为，相比第一次[B:Cancel]操作，后续的[B:Cancel]操作还需要判断先前的[B:Cancel]操作的n（0&lt;=n&lt;=5）个写库中哪几个已经执行、哪几个还没有执行，这就涉及到了幂等性问题。而对幂等性的保障，又很可能还需要涉及额外的写库操作，该写库操作又会因为没有RM本地事务的支持而存在类似问题。。。可想而知，如果不基于RM本地事务，TCC事务框架是无法有效的管理TCC全局事务的。</p>
<p>反之，基于RM本地事务的TCC事务，这种情况则会很容易处理：[B:Try]操作中途执行失败，TCC事务框架将其参与RM本地事务直接rollback即可。后续TCC事务框架决定回滚全局事务时，在知道“[B:Try]操作涉及的RM本地事务已经rollback”的情况下，根本无需执行[B:Cancel]操作。</p>
<p>换句话说，基于RM本地事务实现TCC事务框架时，一个TCC型服务的cancel业务要么执行，要么不执行，不需要考虑部分执行的情况。</p>
<h3 id="TCC事务框架应该提供Confirm-Cancel服务的幂等性保障"><a href="#TCC事务框架应该提供Confirm-Cancel服务的幂等性保障" class="headerlink" title="TCC事务框架应该提供Confirm/Cancel服务的幂等性保障"></a>TCC事务框架应该提供Confirm/Cancel服务的幂等性保障</h3><p>一般认为，服务的幂等性，是指针对同一个服务的多次(n&gt;1)请求和对它的单次(n=1)请求，二者具有相同的副作用。</p>
<p>在TCC事务模型中，Confirm/Cancel业务可能会被重复调用，其原因很多。比如，全局事务在提交/回滚时会调用各TCC服务的Confirm/Cancel业务逻辑。执行这些Confirm/Cancel业务时，可能会出现如网络中断的故障而使得全局事务不能完成。因此，故障恢复机制后续仍然会重新提交/回滚这些未完成的全局事务，这样就会再次调用参与该全局事务的各TCC服务的Confirm/Cancel业务逻辑。</p>
<p>既然Confirm/Cancel业务可能会被多次调用，就需要保障其幂等性。那么，应该由TCC事务框架来提供幂等性保障？还是应该由业务系统自行来保障幂等性呢？个人认为，应该是由TCC事务框架来提供幂等性保障。如果仅仅只是极个别服务存在这个问题的话，那么由业务系统来负责也是可以的；然而，这是一类公共问题，毫无疑问，所有TCC服务的Confirm/Cancel业务存在幂等性问题。TCC服务的公共问题应该由TCC事务框架来解决；而且，考虑一下由业务系统来负责幂等性需要考虑的问题，就会发现，这无疑增大了业务系统的复杂度。</p>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Gavin Zhang</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://cordate.github.io/系统设计/常见的分布式事务解决方案.html" title="常用的分布式事务解决方案">https://cordate.github.io/系统设计/常见的分布式事务解决方案.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/分布式事务/" rel="tag"><i class="fa fa-tag"></i> 分布式事务</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
              <div>
                

<script src="//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.css">


  


<div class="likely">
  
    <div class="twitter">Tweet</div>
  
    <div class="facebook">Share</div>
  
    <div class="linkedin">Link</div>
  
    <div class="gplus">Plus</div>
  
    <div class="vkontakte">Share</div>
  
    <div class="odnoklassniki">Class</div>
  
    <div class="telegram">Send</div>
  
    <div class="whatsapp">Send</div>
  
    <div class="pinterest">Pin</div>
  
</div>

              </div>
            
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/基础知识/同步与异步，阻塞与非阻塞.html" rel="next" title="同步与异步，阻塞与非阻塞与IO模型">
                <i class="fa fa-chevron-left"></i> 同步与异步，阻塞与非阻塞与IO模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/系统设计/高可用/高可用架构相关名词.html" rel="prev" title="高可用架构相关名词">
                高可用架构相关名词 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="gitalk-container">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <!-- 左侧菜单--站点概览 -->
<div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image"
      src="/images/user-avatar.jpg"
      alt="Gavin Zhang"/>
  
  <p class="site-author-name" itemprop="name">Gavin Zhang</p>
  <div class="site-description motion-element" itemprop="description">一个孤独的开发者，正在互联网公司踩坑<br />邮箱：zlcgavin@gmail.com</div>
</div>

<!-- 下方的分类标签 -->

  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">115</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>


<!-- rss -->

  <div class="feed-link motion-element">
    <a href="https://legacy.gitbook.com/@gavinzhang1" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>





  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="GitHub &rarr; https://github.com/yourname"><i class="fa fa-fw fa-github"></i>GitHub</span>
      </span>
    
  </div>



  <div class="cc-license motion-element" itemprop="license">
  
  
    
  
  
  
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"/></span>
  </div>





          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#事务是什么"><span class="nav-number">1.</span> <span class="nav-text">事务是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务ACID特性"><span class="nav-number">2.</span> <span class="nav-text">事务ACID特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性"><span class="nav-number">2.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一致性"><span class="nav-number">2.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离性"><span class="nav-number">2.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久性"><span class="nav-number">2.4.</span> <span class="nav-text">持久性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事务的隔离级别"><span class="nav-number">3.</span> <span class="nav-text">事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务执行过程中可能存在的问题"><span class="nav-number">3.1.</span> <span class="nav-text">事务执行过程中可能存在的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四种隔离级别"><span class="nav-number">3.2.</span> <span class="nav-text">四种隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-uncommitted（读未提交）"><span class="nav-number">3.2.1.</span> <span class="nav-text">Read uncommitted（读未提交）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-committed-（读提交）"><span class="nav-number">3.2.2.</span> <span class="nav-text">Read committed （读提交）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Repeatable-read-（重复读）"><span class="nav-number">3.2.3.</span> <span class="nav-text">Repeatable read （重复读）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable-序列化"><span class="nav-number">3.2.4.</span> <span class="nav-text">Serializable 序列化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式事务"><span class="nav-number">4.</span> <span class="nav-text">分布式事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAP理论"><span class="nav-number">5.</span> <span class="nav-text">CAP理论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BASE理论"><span class="nav-number">6.</span> <span class="nav-text">BASE理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基本可用（Basically-Available）"><span class="nav-number">6.1.</span> <span class="nav-text">1.基本可用（Basically Available）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-软状态（Soft-state）"><span class="nav-number">6.2.</span> <span class="nav-text">2.软状态（Soft state）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-最终一致性（Eventually-consistent）"><span class="nav-number">6.3.</span> <span class="nav-text">3.最终一致性（Eventually consistent）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ACID-酸碱平衡"><span class="nav-number">7.</span> <span class="nav-text">ACID 酸碱平衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式事务协议"><span class="nav-number">8.</span> <span class="nav-text">分布式事务协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#两阶段提交协议-2PC"><span class="nav-number">8.1.</span> <span class="nav-text">两阶段提交协议 2PC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三阶段提交协议-3PC"><span class="nav-number">8.2.</span> <span class="nav-text">三阶段提交协议 3PC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考"><span class="nav-number">8.3.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式事务的解决方案"><span class="nav-number">9.</span> <span class="nav-text">分布式事务的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方案1：全局事务（DTP模型）"><span class="nav-number">9.1.</span> <span class="nav-text">方案1：全局事务（DTP模型）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案2：基于可靠消息服务的分布式事务"><span class="nav-number">9.2.</span> <span class="nav-text">方案2：基于可靠消息服务的分布式事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案3：最大努力通知（定期校对）"><span class="nav-number">9.3.</span> <span class="nav-text">方案3：最大努力通知（定期校对）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方案4：TCC（两阶段型-补偿型）"><span class="nav-number">9.4.</span> <span class="nav-text">方案4：TCC（两阶段型 + 补偿型）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCC全局事务必须基于RM本地事务来实现全局事务"><span class="nav-number">9.4.1.</span> <span class="nav-text">TCC全局事务必须基于RM本地事务来实现全局事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCC事务框架应该提供Confirm-Cancel服务的幂等性保障"><span class="nav-number">9.4.2.</span> <span class="nav-text">TCC事务框架应该提供Confirm/Cancel服务的幂等性保障</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019-09-25</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gavin Zhang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">894k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">13:33</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    
      <div>
        <!-- add this第三方工具 -->
<div class="addthis_inline_share_toolbox">
  <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d2f5e89bbcb7cce" async="async"></script>
</div>

      </div>
    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>








  



  
  





  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>







  



  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/lazyload/lozad.min.js?v=1.10.0"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/reading_progress/reading_progress.js"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  
  <script src="/js/exturl.js?v=7.2.0"></script>


  

  

  


  
    

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"/>



<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

<script>
  var gitalk = new Gitalk({
    clientID: '9ed54522a8818f2ebf63',
    clientSecret: '2977df7ea417b2b266949482dce578d39d7a2df6',
    repo: 'cordate.github.io',
    owner: 'cordate',
    admin: ['cordate'],
    id: md5(location.pathname),
    
      language: 'zh-CN',
    
    distractionFreeMode: 'true'
  });
  gitalk.render('gitalk-container');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  


  

</body>
</html>
