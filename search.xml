<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图解机器学习-最小二乘学习法</title>
      <link href="//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%AD%A6%E4%B9%A0%E6%B3%95.html"/>
      <url>//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E5%AD%A6%E4%B9%A0%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="最小二乘学习法"><a href="#最小二乘学习法" class="headerlink" title="最小二乘学习法"></a>最小二乘学习法</h1><p>这是一个有监督回归的学习方法。我们将对以d维实向量x作为输入、以实数值y作为输出的函数y=f(x)的学习匹配。但是一般输出样本y<sub>i</sub>的真实值f(x<sub>i</sub>)中经常会存在噪声。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95.png?raw=true"></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>最小二乘学习法是对模型的输出f<sub>θ</sub>(x<sub>i</sub>)和训练集输出{y<sub>i</sub>}<sup>n</sup><sub>i=1</sub>的平方差：<br><img title="J_{LS}(\theta )=\frac{1}{2}\sum_{i=1}^{n}(f_\theta(x_i)-y_i)^2" data-src="https://latex.codecogs.com/gif.latex?J_{LS}(\theta&space;)=\frac{1}{2}\sum_{i=1}^{n}(f_\theta(x_i)-y_i)^2"></p><p>为最小的参数θ进行学习：<br><img title="\hat{\theta }_{LS}=\underset{\theta}{argmin}\: J_{LS}(\theta)" data-src="https://latex.codecogs.com/gif.latex?\hat{\theta&space;}_{LS}=\underset{\theta}{argmin}\:&space;J_{LS}(\theta)"></p><p>“LS”是Least Squares的缩写。上面之所以加上1/2的系数，是为了约去对J<sub>LS</sub>进行微分时得到的2.平方误差(f<sub>θ</sub>(x<sub>i</sub>)-y<sub>i</sub>)<sup>2</sup>是残差f<sub>θ</sub>(x<sub>i</sub>)-y<sub>i</sub>的L<sub>2</sub>范数。所以最小二乘法也称为L<sub>2</sub>损失最小化学习法。</p><p>如果使用线性模型：<br><img title="f_\theta (x)=\sum_{j=1}^{b}\theta_{j}\phi_{j}(x)=\theta^{T}\phi (x)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&amp;space;(x)=\sum_{j=1}^{b}\theta_{j}\phi_{j}(x)=\theta^{T}\phi&amp;space;(x)"><br>的话，那么训练样本的平方差J<sub>LS</sub>就能够表示为下述形式。<br><img title="J_{LS}(\theta)=\frac{1}{2}\left \| \Phi \theta -y \right \|^2" data-src="https://latex.codecogs.com/gif.latex?J_{LS}(\theta)=\frac{1}{2}\left&space;\|&space;\Phi&space;\theta&space;-y&space;\right&space;\|^2"><br>在这里，y=(y<sub>1</sub>,···y<sub>n</sub>)<sup>T</sup>是训练输出的n维向量，Φ是下面定义的n × b阶矩阵，也称为设计矩阵。<br><img title="\Phi=\begin{bmatrix} \phi _1(x_1) & \cdots & \phi _b(x_1) \\ \vdots & \ddots & \vdots \\ \phi _1(x_n) & \cdots & \phi _b(x_n) \end{bmatrix}" data-src="https://latex.codecogs.com/gif.latex?\Phi=\begin{bmatrix}&space;\phi&space;_1(x_1)&space;&&space;\cdots&space;&&space;\phi&space;_b(x_1)&space;\\&space;\vdots&space;&&space;\ddots&space;&&space;\vdots&space;\\&space;\phi&space;_1(x_n)&space;&&space;\cdots&space;&&space;\phi&space;_b(x_n)&space;\end{bmatrix}"></p><p><b style="color:red">将结果变成一个矩阵进行统一处理而已！</b></p><p>训练样本的平方差J<sub>LS</sub>的参数向量θ的偏微分▽<sub>θ</sub>J<sub>LS</sub>以<br><img title="\triangledown_{\theta }J_{LS}=\begin{pmatrix} \frac{\partial J_{LS}}{\partial\theta_1} & \cdots & \frac{\partial J_{LS}}{\partial\theta_b} \end{pmatrix}^T=\Phi ^T\Phi \theta -\Phi ^Ty" data-src="https://latex.codecogs.com/gif.latex?\triangledown_{\theta&space;}J_{LS}=\begin{pmatrix}&space;\frac{\partial&space;J_{LS}}{\partial\theta_1}&space;&&space;\cdots&space;&&space;\frac{\partial&space;J_{LS}}{\partial\theta_b}&space;\end{pmatrix}^T=\Phi&space;^T\Phi&space;\theta&space;-\Phi&space;^Ty"></p><p>这样的形式给出。如果将其微分设置为0，最小二乘解就满足关系式<br><img title="\Phi ^T\Phi \theta =\Phi ^Ty" data-src="https://latex.codecogs.com/gif.latex?\Phi&space;^T\Phi&space;\theta&space;=\Phi&space;^Ty"></p><p>这个方程式的解使用设计矩阵Φ的广义逆矩阵Φ<sup>†</sup>：(pinv)来进行计算，可以得出<br><img title="\hat{\theta}_{LS}=\Phi^\dagger y" data-src="https://latex.codecogs.com/gif.latex?\hat{\theta}_{LS}=\Phi^\dagger&space;y"></p><p>在这里，<sup>†</sup>是剑标。相对于只有方阵、非奇异矩阵才能定义逆矩阵，广义逆矩阵则是矩形矩阵或奇异矩阵都可以定义，是对逆矩阵的推广。Φ<sup>†</sup>Φ有逆矩阵的时候，广义逆矩阵Φ<sup>†</sup>可以用下式表示。<br><img title="\Phi^\dagger = (\Phi^T\Phi)^{-1}\Phi^T" data-src="https://latex.codecogs.com/gif.latex?\Phi^\dagger&space;=&space;(\Phi^T\Phi)^{-1}\Phi^T"></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> knn </tag>
            
            <tag> 图解机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习模型</title>
      <link href="//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B.html"/>
      <url>//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>如何使特定的函数与数据集相近似。</p><h1 id="学习模型"><a href="#学习模型" class="headerlink" title="学习模型"></a>学习模型</h1><h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><p><b style="color:red">监督学习、直接得出后验概率。</b></p><p>纯粹的这种模型往往没有太大的实用价值。因此在实际的应用中，经常会对线性模型进行相应的扩展，使其变成基于参数的线性模型，这样就可以使线性模型也能用于表示非线性的输入与输出了。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B.gif?raw=true"></p><p>在上式中，<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWNvZ3MuY29tL2VxbmVkaXQucGhwP2xhdGV4PVxwaGlfe2p9KHgp" title="https://www.codecogs.com/eqnedit.php?latex=\phi_{j}(x)"><img title="\phi_{j}(x)" data-src="https://latex.codecogs.com/gif.latex?\phi_{j}(x)"><i class="fa fa-external-link"></i></span>是基函数向量<img title="(\phi_{1}(x),\phi_{2}(x),......\phi_{b}(x))^T" data-src="https://latex.codecogs.com/gif.latex?(\phi_{1}(x),\phi_{2}(x),......\phi_{b}(x))^T">的第j个因子，<img title="\theta_{j}" data-src="https://latex.codecogs.com/gif.latex?\theta_{j}">是参数向量<img title="\theta=(\theta_1,\theta_2,......,\theta_b)^{T}" data-src="https://latex.codecogs.com/gif.latex?\theta=(\theta_1,\theta_2,......,\theta_b)^{T}">的第j个因子。另外b是基函数的个数。我们可以看到，虽然上式依然是基于参数向量θ的线性形式，但是把基函数变为多项式的形式<br><img title="\phi(x)=(1,x,x^2,......x^{b-1})^T" data-src="https://latex.codecogs.com/gif.latex?\phi(x)=(1,x,x^2,......x^{b-1})^T"><br>或者变为b=2m+1的三角多项式形式<br><img title="\phi(x)=(1,sin(x),cos(x),sin(2x),cos(2x),......,sin(mx),cos(mx))^T" data-src="https://latex.codecogs.com/gif.latex?\phi(x)=(1,sin(x),cos(x),sin(2x),cos(2x),......,sin(mx),cos(mx))^T"><br>上述的线性模型就可以表示复杂的非线性性模型了。</p><p>在上述模型中，一维的输入x还可以扩展为d维的向量形式<img title="x=(x^{(1)},x^{(2)},......x^{(d)})^T" data-src="https://latex.codecogs.com/gif.latex?x=(x^{(1)},x^{(2)},......x^{(d)})^T">.</p><p>对于多维的输入向量x，如何选择合适的基函数呢？下面介绍使用一维的基函数来构造多维基函数的乘法模型和加法模型做相应的介绍。</p><p>乘法模型是指，把一维的基函数作为因子，通过使其相乘而获得多维基函数的方法。<br><img title="\sum_{j_1=1}^{b^{'}}...\sum_{j_d=1}^{b^{'}}\theta_{j_{1},...,j_d}\phi_{j_{1}}(x^{(1)})\cdot\cdot\cdot \phi_{j_{d}}(x^{(d)})" data-src="https://latex.codecogs.com/gif.latex?\sum_{j_1=1}^{b^{'}}...\sum_{j_d=1}^{b^{'}}\theta_{j_{1},...,j_d}\phi_{j_{1}}(x^{(1)})\cdot\cdot\cdot&space;\phi_{j_{d}}(x^{(d)})"></p><p>上式中，b<sup>‘</sup>代表各维的参数个数。由于乘法模型由多个不同的一维基函数任意组合而成。但需要注意的是，所有参数的个数是(b<sup>‘</sup>)<sup>d</sup>，即总的输入维数是以d次方的形式呈指数级增长的。例如，当b<sup>‘</sup>=10,d=100的时候，全部参数的个数将会是10<sup>100</sup> 。</p><p>这是一个天文数字，以至于普通计算机无法计算。这种我们通常称为<b style="color:red">维度灾难</b>.如何避免维度灾难，是机器学习算法研究中非常热门的研究领域。</p><p>加法模型是指把一维的基函数作为因子，通过使其相加而获得多维基函数的方法。<br><img title="f_\theta (x)=\sum_{k=1}^{d}\sum_{j=1}^{b^{'}}\theta_{k,j}\phi_{j}(x^{(k)})" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=\sum_{k=1}^{d}\sum_{j=1}^{b^{'}}\theta_{k,j}\phi_{j}(x^{(k)})"></p><p>加法模型中所有参数的个数是b<sup>‘</sup>d, 其只会随着输入维数d呈线性增长。但是，由于加法模型只考虑了一维基函数相加的情况，表现力要比乘法模型逊色许多。</p><h2 id="核模型"><a href="#核模型" class="headerlink" title="核模型"></a>核模型</h2><p><b style="color:red">无监督学习</b></p><p>在线性模型中，多项式或三角多项式等基函数与训练样本{(x<sub>i</sub>,y<sub>i</sub>)}<sup>n</sup><sub>i=1</sub>是毫不相关的。而核模型，则会在进行基函数的设计时使用到输入样本{x<sub>i</sub>}<sup>n</sup><sub>i=1</sub>。</p><p>核模型，是以使用被称为核函数的二元函数K(·,·)，以K(x,x<sub>j</sub>)<sup>n</sup><sub>j=1</sub>的线性结合方式加以定义的。<br><img title="f_\theta (x)=\sum_{j=1}^{n}\theta_{j}K(x,x_j)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=\sum_{j=1}^{n}\theta_{j}K(x,x_j)"><br>在众多的核函数中，以高斯核函数的使用最为广泛。<br><img title="K(x,c)=exp(-\frac{\left \| x-c \right \|^2}{2h^2})" data-src="https://latex.codecogs.com/gif.latex?K(x,c)=exp(-\frac{\left&space;\|&space;x-c&space;\right&space;\|^2}{2h^2})"><br>在上式中，||*||代表2范数，即：<img title="\left \| x \right \|=\sqrt{x^{T}x}" data-src="https://latex.codecogs.com/gif.latex?\left&space;\|&space;x&space;\right&space;\|=\sqrt{x^{T}x}">. h和c分别对应于高斯核函数的带宽和均值。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%96%AF%E6%96%B9%E7%A8%8B1.png?raw=true"></p><p>在高斯核函数中，对各个输入样本{x<sub>i</sub>}<sup>n</sup><sub>i=1</sub>进行高斯配置，并把其高度{θ<sub>i</sub>}<sup>n</sup><sub>i=1</sub>作为参数进行学习(图2.5)。因此在高斯核模型中，一般只能在训练集的输入样本附近对函数进行近似（图2.6）。与对输入空间的全体函数进行近似的乘法模型不同，在高斯核模型中，因为只能在训练集的输入样本{x<sub>i</sub>}<sup>n</sup><sub>i=1</sub>附近对函数进行近似，所以从某种程度上来说也减轻了维度灾难的影响。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%B8%80%E7%BB%B4%E9%AB%98%E6%96%AF%E6%A0%B8%E6%A8%A1%E5%9E%8B.png?raw=true"></p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E7%9A%84%E9%AB%98%E6%96%AF%E6%A0%B8%E6%A8%A1%E5%9E%8B.png?raw=true"></p><p>实际上，在核模型中，参数的个数不依赖于输入变量x的维度d，只由训练样本数n决定。因此，即使输入维度d相当大，只要训练样本数n不是太大，也会在普通计算机的处理范围之内。而即使训练样本数n也很大，只要把输入样本{x<sub>i</sub>}<sup>n</sup><sub>i=1</sub>的部分集合{c<sub>j</sub>}<sup>b</sup><sub>j=1</sub>作为核均值来进行计算，计算负荷也可以得到很好的抑制。</p><p><img title="f_\theta (x)=\sum_{j=1}^{b}\theta_{j}K(x,c_j)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=\sum_{j=1}^{b}\theta_{j}K(x,c_j)"></p><p>该模型是参数向量θ=(θ<sub>1</sub>,θ<sub>2</sub>,···,θ<sub>n</sub>)<sup>T</sup>的线性形式，因此也可以作为<img title="f_\theta (x)=\sum_{j=1}^{b}\theta_{j}\phi_{j}(x)=\theta^{T}\phi (x)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=\sum_{j=1}^{b}\theta_{j}\phi_{j}(x)=\theta^{T}\phi&space;(x)">这样的基于参数的线性模型的特例来考虑。但是由于基函数依赖输入样本，因此核模型的操作与基于参数的线性模型有很大的不同。在统计学中，通常把与基于参数的线性模型称为参数模型，把核模型称为非参数模型，以示区别。然而，我们把核模型视为基于参数的线性模型，应该也没有太大的问题。</p><p>核模型的另一个特征是当输入样本x不是向量的时候，也能够很容易地实现扩展。<br><img title="f_\theta (x)=\sum_{j=1}^{n}\theta_{j}K(x,x_j)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&amp;space;(x)=\sum_{j=1}^{n}\theta_{j}K(x,x_j)"><br>这个核模型函数中，输入样本x只存在于核函数K(x, x’)中，因此，只需对两个输入样本x和x’相对应的核函数加以定义，而不用关心输入样本x具体是什么。例如，目前已经有人提出了输入样本x是字符串、决策树或图表等的核函数。使用这样的核函数进行的机器学习算法，称为核映射方法。核映射方法是近几年机器学习的热门研究领域。</p><h2 id="层级模型"><a href="#层级模型" class="headerlink" title="层级模型"></a>层级模型</h2><p>与参数相关的非线性模型，称为非线性模型。只要是与参数相关的、不是线性的模型，都可以称之为非线性模型。这其中需要特别说明的是非线性模型中的层级模型，它在很多方面都有着广泛的应用。<br><img title="f_\theta (x)=\sum_{j=1}^{b}\alpha_{j}\phi(x;\beta_j)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=\sum_{j=1}^{b}\alpha_{j}\phi(x;\beta_j)"><br>上式中，φ(x;β)是含有参数向量β的基函数。层级模型是基于参数向量α=(α<sub>1</sub>,α<sub>2</sub>,···,α<sub>b</sub>)<sup>T</sup>的线性形式。但是因为层级模型的基函数里也包含参数向量{β<sub>j</sub>}<sup>b</sup><sub>j=1</sub>，所以层级模型又是基于参数向量θ=(α<sup>T</sup>,β<sub>1</sub><sup>T</sup>,···,β<sub>b</sub><sup>T</sup>)<sup>T</sup>的非线性形式。</p><p>基函数通常采用S型函数：<br><img title="\phi(x;\beta)=\frac{1}{1+exp(-x^{T}\omega -\gamma )}, \beta=(\omega^{T}, \gamma)^{T}" data-src="https://latex.codecogs.com/gif.latex?\phi(x;\beta)=\frac{1}{1&plus;exp(-x^{T}\omega&space;-\gamma&space;)},&space;\beta=(\omega^{T},&space;\gamma)^{T}"><br>或者高斯函数<br><img title="\phi(x;\beta)=exp(-\frac{\left \| x-c \right \|^2}{2h_2}), \beta =(c^T, h)^T" data-src="https://latex.codecogs.com/gif.latex?\phi(x;\beta)=exp(-\frac{\left&space;\|&space;x-c&space;\right&space;\|^2}{2h_2}),&space;\beta&space;=(c^T,&space;h)^T"><br>S型函数模仿的是人类脑细胞的输入输出函数，因此使用S型函数的层级模型也经常称为人工神经网络模型。另外，虽然这里的高斯函数与高斯核函数是相同的，但是，核模型中的带宽和均值都是固定的，而在层级模型中，在对耦合系数参数{α<sub>j</sub>}<sup>b</sup><sub>j=1</sub>进行学习的同时，也会对带宽和均值进行学习。因此，一般认为层级模型能够比核模型更加灵活地对函数进行近似。层级模型有时也表现为三层神经网络的形式。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%B8%89%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png?raw=true"></p><p>然而在层级模型中，参数θ和函数f<sub>θ</sub>并不是一一对应的。例如，在b=2的人工神经网络模型中，<br><img title="f_\theta (x)=\alpha _1\phi (x;\omega _1,\gamma_1) + \alpha _2\phi (x;\omega _2,\gamma _2)" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=\alpha&space;_1\phi&space;(x;\omega&space;_1,\gamma_1)&space;&plus;&space;\alpha&space;_2\phi&space;(x;\omega&space;_2,\gamma&space;_2)"><br>当上面的ω<sub>1</sub>=ω<sub>2</sub>=ω，且γ<sub>1</sub>=γ<sub>2</sub>=γ时，如果α<sub>1</sub>+α<sub>2</sub>是固定值的话，就都变成了同一个函数<br><img title="f_\theta (x)=(\alpha_1+\alpha _2)\phi (x;\omega ,\gamma )" data-src="https://latex.codecogs.com/gif.latex?f_\theta&space;(x)=(\alpha_1&plus;\alpha&space;_2)\phi&space;(x;\omega&space;,\gamma&space;)"><br>正因为有这样的特性，人工神经网络模型也以学习过程异常艰难而著称。</p><p>针对像人工神经网络这样的层级模型，采用贝叶斯学习的方法是不错的选择。另外，近些年来也有些研究者发现，通过从邻近输入样本的层级开始，一层一层地进行无监督学习，就可以很好地进行人工神经网络的初始化操作。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> knn </tag>
            
            <tag> 图解机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是机器学习</title>
      <link href="//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"/>
      <url>//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h1><h2 id="学习的种类"><a href="#学习的种类" class="headerlink" title="学习的种类"></a>学习的种类</h2><p>根据处理的数据种类的不同，可以分为监督学习、无监督学习、强化学习等几种类型。</p><p>监督学习：<b style="color:red">对没有学习过的问题也可以做出正确解答，使计算机获得这种泛化能力，是监督学习的最终目标。</b>监督学习在手写文字识别、声音处理、图像处理、垃圾邮件分类与拦截、网页检索、基因诊断以及股票预测等各个方面，都有着广泛的应用。<b style="color:red">这一机器学习的典型任务包括：预测数值型数据的回归、预测分类标签的分类、预测顺序的排序等。</b></p><p>无监督学习：基本上指计算机在互联网中自动收集信息，并从中获取有用信息。<b style="color:red">无监督学习在人造卫星故障诊断、视频分析、社交网站解析和声音信号解析等各方面大显身手的同时，在数据可视化以及作为监督学习方法的前处理工具方面，也有着广泛的应用。</b>这一类机器学习的典型任务有聚类、异常检测等。</p><p>强化学习：与监督学习类似，也以使计算机获得对没有学习过的问题作出正确解答的泛化能力为目标，但在学习的过程中，不设置老师提示对错、告知最终答案的环节。然而如果真的在学习过程中不能从周围环境中获得任何信息的话，强化学习就变成了无监督学习了.<b style="color:#00f">强化学习是指在没有老师提示的情况下，自己对预测结果进行评估的方法.</b>通过自我评估，学生为了获得老师的最高嘉奖而不断地进行学习。强化学习，在机器人的自动控制、计算机游戏中的人工智能、市场战略的最优化等方面均有广泛应用。在强化学习中经常会用到回归、分类、聚类和降维等各种各样的机器学习算法。</p><h2 id="机器学习任务的例子"><a href="#机器学习任务的例子" class="headerlink" title="机器学习任务的例子"></a>机器学习任务的例子</h2><p>回归：是指把实函数在样本点附近加以近似的有监督的函数近似问题。（函数回归，连续不间断的曲线）</p><p>分类：是指对于指定的模式进行识别的有监督的模式识别问题。分类问题只是单纯地对样本应该属于哪一个类别进行预测，并根据预测准确与否来衡量泛化误差，这一点与回归是不同的。</p><p>异常检测：是指寻找输入样本中所包含的异常数据的问题。在已知正常数据与异常数据的例子的情况下，其与有监督学习的分类问题是相同的。但是一般情况下，在异常检测中，对于什么样的数据是异常的事先是未知的。在这样的无监督的异常检测中，一般采用<b style="color:red">密度估计</b>的方法，把靠近密度中心的数据作为正常数据，偏离的作为异常数据。</p><p>聚类：与分类相同，也是模式匹配，但是属于无监督学习的一种。只给属于样本，然后判断各个样本属于哪个族，有多少簇等。在聚类问题中，如何准确计算样本间的相似度是很重要的课题。</p><p>降维：是指从高维度数据中提取关键信息，将其转换为易于计算的低维度问题进而求解的方法。降维根据数据种类的不同，可以分为监督学习和无监学习两种。在转换为较低维度的样本之后，应该保持原始输入样本的数据分布性质，以及数据间的近邻关系不发生变化。</p><h2 id="机器学习的方法"><a href="#机器学习的方法" class="headerlink" title="机器学习的方法"></a>机器学习的方法</h2><p>机器学习有多种不同的流派。这里以对模式x的类别y进行预测的分类问题为例，对机器学习中的主要流派，即产生式分类和判别式分类，以及频率派和贝叶斯派的基本方法加以介绍。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hdHJpeF9zcGFjZS9hcnRpY2xlL2RldGFpbHMvODM3MTM2MzI=" title="https://blog.csdn.net/matrix_space/article/details/83713632">机器学习：几种分类识别问题<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9ib29rL21pbmlhcnRpY2xlLzE5NTg3Mw==" title="http://www.ituring.com.cn/book/miniarticle/195873">生成的分类和识别的分类<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGlueW1pbmQuY24vYXJ0aWNsZXMvMTIw" title="https://www.tinymind.cn/articles/120">详解计算机视觉五大技术：图像分类、对象检测、目标跟踪、语义分割和实例分割<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bmR1YW5tdXh1ZS9hcnRpY2xlL2RldGFpbHMvMjAxMjI5MzE=" title="https://blog.csdn.net/yunduanmuxue/article/details/20122931">模式识别（二）：分类问题简介<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25nY2hhbzk5L2FydGljbGUvZGV0YWlscy83NDkxMDk4NA==" title="https://blog.csdn.net/xiongchao99/article/details/74910984">模式识别之分类器<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> knn </tag>
            
            <tag> 图解机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于招聘的想法</title>
      <link href="//%E5%9B%A2%E9%98%9F%E4%B8%8E%E6%80%9D%E8%80%83/%E5%85%B3%E4%BA%8E%E6%8B%9B%E8%81%98%E7%9A%84%E6%83%B3%E6%B3%95.html"/>
      <url>//%E5%9B%A2%E9%98%9F%E4%B8%8E%E6%80%9D%E8%80%83/%E5%85%B3%E4%BA%8E%E6%8B%9B%E8%81%98%E7%9A%84%E6%83%B3%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>程序员招聘已经成了一个话题，之前做团队leader的时候我就在想什么样的团队是我们想要的。加入阿里才3个月，却面对团队的压力需要帮忙招聘，有的团队还引入到了KPI中，而我们所在的团队希望我们每周找简历，达不到要求就处理罚钱的规定。这个规定让我无所适从，甚至有了很强的离职想法！所以我决定写一篇文章来阐述一下我对这件事的看法。（当然团队内部是不能去说的。）</p><h1 id="如何让团队招聘"><a href="#如何让团队招聘" class="headerlink" title="如何让团队招聘"></a>如何让团队招聘</h1><p>其实我觉得之前所叙述的，可以简单的归纳为任务驱动式的。其实我觉得简单地任务驱动式没有啥问题，因为很多团队都采用这种管理的方式，的确有一些弊端。但是我觉得招聘是我们工作之外的事情，如果采用任务驱动式势必会让人产生反感，也许是个人觉得反感。那么既然是任务就必然会产生奖罚制度。这个思维就是这样的思路，所以就有了我文章开头的遭遇。</p><p>而我觉得重要的制度就是一种文化，团队工作之外的事情怎么让团队去做呢？当然动员是必须的，你不说别人也不会去采取行动呀，毕竟每天都在想这个团队缺啥的人还是比较少的，但是我觉得优秀的团队被动的人应该是少数，你只要动员他们总会有想法的。我觉得更多的是让团队有种归属感，团队文化的认同感，这样他们才会为你打广告，在这种情况下，大家都是自愿的，会认真帮助团队将事情做好，比如检查候选人是否合适，如果是任务式的，候选人只要不要太离谱，可能都会被推荐进来，因为任务要达成。所以这个时候大家开始关注质量，于是开始奖惩制度。关于奖惩制度我也想说，适合工作成果；工作之外的事情，尽量少用罚款，否则团队的认同感就会被降低，应该使用奖而不罚的态度；而对于工作成果使用有奖有罚，我觉得是应该的。不同的场景下，应该使用不同的制度去应对。</p><p>总结下来就是使用团队认同感和文化推动成员帮助团队招兵买马，奖励做出贡献的员工；但是注意有的员工是有资源的，就是说达成同样一件事，有的员工可能不费事，而有的人付出的代价可能会比较大。这个需要心中有数，能力这个事情有的时候并不体现在成果上。就是将工作成果和业余成果做一个区分，不要交叉和影响。</p><h1 id="人才短期战略"><a href="#人才短期战略" class="headerlink" title="人才短期战略"></a>人才短期战略</h1><p>我们招聘人才往往是比较急，可是等团队人够了，正真的人才来了也只能拒绝，所以我觉得招聘中，不管多急，人才应该有余量，当有合适人选的时候，也可压缩余量，但是不能饱和。饱和的缺点是不能引入外部人才，同时内部工作饱和，大家做的事情也比较少，工作的余量可以检测一个员工的好坏。</p><p>关于短期招聘，其实就是扩宽渠道，这就是一个我找人才的过程，这个过程会异常痛苦。其实如果你平时就比较关注这个人才战略，你就可以实现人才找你，只要你发布了相应信息，可能就会有人才响应，所以我觉得这个过程就是人才找你。</p><p>所以说伯乐和人才都在相互寻找，渠道真的很重要，不是吗？那么就提一下人才找你之人才战略。</p><h1 id="人才是一种战略"><a href="#人才是一种战略" class="headerlink" title="人才是一种战略"></a>人才是一种战略</h1><p>做过Leader或者面试过别人的，应该都知道招聘人才是一个漫长的过程。能找到团队需要的人那是很难的。这个就是我们团队现在的错误，那就是没有人才战略，而强制团队每一个去找，其实就是广撒网多捞鱼。其实人才的招聘是有战略思维的，绝大分的人才不会自荐，简历写的也许也不行，甚至还有各种性格缺陷，这些都是我们发现一个人才能的阻碍。所以除了HR那边的硬性指标，我们也应该通过很多方式发现人才的真实才能。</p><h2 id="建立人才库"><a href="#建立人才库" class="headerlink" title="建立人才库"></a>建立人才库</h2><p>这个大家都知道，每个公司都有相应的人才库，甚至有大数据分析等，从人才库中找到适合自己的人才。人才库可以是自己的，也可以通过第三方网站进行爬取，也可以进行购买。总之建立人才库的方式有很多的。</p><h2 id="品牌形象"><a href="#品牌形象" class="headerlink" title="品牌形象"></a>品牌形象</h2><p>建立品牌形象来找人才，这个其实和公司的形象有很大关系。其实我们公司虽然很多人想进，但是我觉得他的影响力已经下降，因为大家都可以从论坛中发现这里面的真实情况，所以需要改革内部制度，建立完善的制度吸引人才。</p><h2 id="技术影响"><a href="#技术影响" class="headerlink" title="技术影响"></a>技术影响</h2><p>比如说建立技术网站，向全网普及知识扩大影响力的同时，也可以让更多的人才关注到你，只要你在里面发布消息，这种影响力还是比较客观的，也容易加大伯乐和千里马之间的认知，因为有时人才也怕遇到坑。</p><h2 id="渠道"><a href="#渠道" class="headerlink" title="渠道"></a>渠道</h2><p>各大招聘网站是渠道，这个大家都明白。但是大家也可以关注行业的新闻，从里面找到人才都在关注啥，然后从这里面发现人才的聚集地，将人才招为己用。还有比如博客，git库等等各种地方，都可以找到你想要的人才。</p><h2 id="猎头"><a href="#猎头" class="headerlink" title="猎头"></a>猎头</h2><p>上面说的渠道维护成本很高，所以猎头的出现就可以解决这个问题，而且老板和应聘者直接沟通必然有些话是不能说的，但是和猎头可以聊得多一些。但是猎头也有好坏之分的。而且猎头非专业人士，对人才的感知更多是凭感觉。</p><h1 id="留住人才"><a href="#留住人才" class="headerlink" title="留住人才"></a>留住人才</h1><p>奖罚分明，维护良好的制度，培养积极的团队文化和氛围。让员工工作的爽，生活愉快，减少工作和生活的交织对于留住一个人才确实是比不可少的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 团队与思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 招聘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战笔记——k-近邻算法</title>
      <link href="//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.html"/>
      <url>//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>k-近邻算法采用<b style="color:#f33b45">测量不同特征值之间的距离</b>方法进行分类。</p><p>算法特点：</p><ul><li>优点：精度高、对异常值不敏感、无数据输入假定。</li><li>缺点：计算复杂度高、空间复杂度高。（<b style="color:#f33b45">耗时，耗计算资源，例如中间数据的存储，另外是测试对象，要和所有的样本对象进行比较，没有训练的过程，只有测试过程。</b>）。最大的缺点就是<b style="color:#f33b45">无法给出数据的内在含义</b>。</li><li>适用数据范围：数值型（<b style="color:#f33b45">可以通过范围进行散列</b>）和标称型。（散列）</li></ul><p>工作原理：<b style="color:#f33b45">存在一个样本数据集合，也称训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。</b></p><p>K值的意思：<b style="color:#f33b45">一般来说，我们只选择样本数据集中前k个最相似的数据，这就是K-近邻算法中K的出处，通常k是不大于20的整数。最后少数服从多数。</b></p><p>注意这里需要说明的是：</p><ul><li>距离：<b style="color:#3399ea">可以是加权距离，集合距离或者矩阵距离，总之是算法的核心所在。这里比较常用的距离有曼哈顿距离（L1）和欧氏距离（L2）</b></li><li>分类：<b style="color:#3399ea">这个是决定业务场景的字段，有这个字段我们就知道，本算法的应用所在。</b></li></ul><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/20180929142841702.png?raw=true"></p><p><b style="color:#7c79e5">k-近邻算法的一般流程：</b></p><ol><li>收集数据集</li><li>准备数据：距离计算所需要的数值，最好是结构化的数据格式。</li><li>分析数据</li><li><b style="color:#fb6">训练算法：此步骤不适合此算法。（但是可以验证距离函数是否是比较好的设计）</b></li><li>测试算法：计算错误率</li><li>使用算法</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一、电影分类</p><p>二、使用k-近邻算法改进约会网站的配对效果</p><p>三、手写识别系统</p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p><b style="color:#f33b45">要将算法的结果可视化的话，需要选择二维或者三维的模型，然后确定坐标系的特征指数，以及特征指数之间的关系。这里我想到的特征指数如下：</b></p><p><b style="color:#f33b45">距离、k的取值、多种特征值的组合特征、趋势等等。</b></p><p><b style="color:#f33b45">其实这里比较注意的是特征值的组合特征；这种组合特征可能是比率，趋势，平方差，偏移值，信息熵等等。注意这些特征之间的关系，只有有关系的特征才能这样去做。</b></p><p><b style="color:#f33b45">另外还有一种降维的做法就是将一个值取出来，设置几个值，使用多张图表进行展示。</b></p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/20180929143041755.png?raw=true"></p><p>上面是数据图的一种表示！</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRGV0ZXJtaW5lZDIyL3AvNjM0OTg3MS5odG1s" title="https://www.cnblogs.com/Determined22/p/6349871.html">机器学习 —— 基础整理（三）生成式模型的非参数方法： Parzen窗估计、k近邻估计；k近邻分类器<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25ldmVyZXZlcjAxL2FydGljbGUvZGV0YWlscy84NDk0NjQzNw==" title="https://blog.csdn.net/neverever01/article/details/84946437">K近邻聚类算法<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> knn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战笔记——机器学习基础</title>
      <link href="//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80.html"/>
      <url>//%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p>1、机器学习分为监督学习和无监督学习。</p><p>2、监督学习一般使用两种类型的目标变量：标称型和数值型</p><ul><li><b style="color:#f33b45">标称型：就是取值比较固定的类型。有点像枚举类型，有穷值。这种特性的数据比较适合用于分类。</b></li><li>数值型：在无限的数据集中取值。比较适合找规律和线性回归，另外范围限定后也会成为标称型。</li></ul><p>3、 我们可以将数据集分为测试集、验证集和训练集。</p><ul><li>训练集用于处理训练模型</li><li>验证集用于调试自己的训练出来的模型</li><li>测试集是对最终模型的验证，防止最终验证的时候，这些数据集被使用。</li></ul><p>4、 关于交叉验证：将数据集分为多个部分，随机选取一个作为测试集，其他的都是训练集。</p><p>5、 简单地说，机器学习就是将无用的数据转化为有用的信息。将无联系的数据转化为有序的价值。</p><p>6、 前期的ETL就是建立数学模型来解决问题。而机器学习是数据算法转化数据的价值。</p><p>7、 数据的采集：各种数据的采集是各种系统的运行结果，最重要的数据采集来自于传感器数据。</p><p>8、 <b style="color:#f33b45">机器学习的主要任务就是分类，使用标称型的数据。机器学习的另一个任务就是回归。分类和回归属于监督学习，之所以被称为监督学习，是因为这类算法必须知道预测什么，即目标变量的分类信息。</b></p><p>9、 无监督学习：数据没有类别信息，也不会给定目标值。在无监督学习中，将数据集合分成由类似的对象组成的多个类的过程被称为<b style="color:#f33b45">聚类</b>；将寻找描述数据统计值的过程称之为<b style="color:#f33b45">密度估计</b>。无监督学习还可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息。</p><p>10、 如何选择合适的算法</p><ol><li>首先考虑使用机器学习的目的。</li><li>考虑数据是离散型还是连续型。离散型适合分类，连续型适合回归。</li><li>是否考虑将数据划分成离散的，可以使用无监督学习中的<b style="color:#f33b45">聚类</b>；如果还需要估计数据与每个分组的相似程度，则需要使用<b style="color:#f33b45">密度估计</b>算法。</li></ol><p>上面提到的原则不是一成不变的，要敢于打破常规解决问题。除此之外也有其他的考量指标：</p><ul><li>特征值是连续型还是离散型</li><li>特征值中是否存在缺失的值，何种原因导致值缺失</li><li>数据中是否存在异常值</li><li>某个特征发生的概率如何</li></ul><p>同时还要尝试不同的算法的执行效果，一般来说发现最好算法的关键环节是反复试错的迭代过程。</p><p>11、 机器学习开发的步骤：</p><ol><li>收集数据</li><li>准备输入数据</li><li>分析输入数据：通过一维、二维、三维图形展示数据也是不错的方法，但是一般是多维的。但是多维也可以通过图形化展示的。这一步的作用主要是确保没有垃圾数据。</li><li>训练算法：机器学习算法从这一步才真正开始学习。</li><li>测试算法</li><li>使用算法：将机器学习算法转换为应用程序。</li></ol><p>12、 NumPy函数库的使用基础知识。</p><hr><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存栅栏</title>
      <link href="//java/%E5%86%85%E5%AD%98%E6%A0%85%E6%A0%8F.html"/>
      <url>//java/%E5%86%85%E5%AD%98%E6%A0%85%E6%A0%8F.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="什么是内存栅栏？"><a href="#什么是内存栅栏？" class="headerlink" title="什么是内存栅栏？"></a>什么是内存栅栏？</h2><p>内存栅栏(Memory Barriers)，是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p><h3 id="内存栅栏提供了两个功能"><a href="#内存栅栏提供了两个功能" class="headerlink" title="内存栅栏提供了两个功能"></a>内存栅栏提供了两个功能</h3><ol><li>确保从另一个CPU来看栅栏的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；</li><li>实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。</li></ol><h2 id="为什么需要内存栅栏？"><a href="#为什么需要内存栅栏？" class="headerlink" title="为什么需要内存栅栏？"></a>为什么需要内存栅栏？</h2><p><b style="color:#00f">对主存的一次访问一般花费硬件的数百次时钟周期。为了减少这种操作，CPU通过使用Cache来达到高效获取数据的目的。然后Cache为了提高性能，会对指令进行重排序。</b></p><p><b style="color:red">当重排序对最终的结果没有影响的时候，这种优化是有益的。但是当多线程共享数据时，重排序将导致错误的结果。所以为了在共享变量的情况下依然可以使用指令重排序，产生了内存栅栏来保证程序的正确性。</b></p><h2 id="内存栅栏是怎么实现的？"><a href="#内存栅栏是怎么实现的？" class="headerlink" title="内存栅栏是怎么实现的？"></a>内存栅栏是怎么实现的？</h2><p>在底层，内存栅栏是一组指令，一般包括<code>Store Barrier</code>、<code>Load Barrier</code>和<code>Full Barrier</code>。</p><p>几乎所有的处理器至少支持一种粗粒度的屏障指令，通常被称为“栅栏（Fence）”，它保证在栅栏前初始化的load和store指令，能够严格有序的在栅栏后的load和store指令之前执行。</p><p>不同的CPU架构有不同的实现方式，以X86为例：</p><ul><li>Store Barrier,强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到主存</li><li>Load Barrier,强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。</li><li>Full Barrier，复合了load和store屏蔽指令。</li></ul><p><b style="color:red">无论在何种处理器上，这几乎都是最耗时的操作之一（与原子指令差不多，甚至更消耗资源），所以大部分处理器还会支持更细粒度的屏障指令。</b></p><p>下图是CPU的Local Memory与主存的通信过程：<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/java/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%9B%BE1.jpg?raw=true"></p><h2 id="Java中内存栅栏的使用"><a href="#Java中内存栅栏的使用" class="headerlink" title="Java中内存栅栏的使用"></a>Java中内存栅栏的使用</h2><p>Java内存模型中volatile变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。一个类的final字段会在初始化后插入一个store屏障，来确保final字段在构造函数初始化完成并可被使用时可见。</p><h2 id="内存栅栏对性能的影响"><a href="#内存栅栏对性能的影响" class="headerlink" title="内存栅栏对性能的影响"></a>内存栅栏对性能的影响</h2><p>内存栅栏阻止了 CPU 很多隐式的内存延迟技术的执行，因此是有性能损耗的，不过在上层看来这种损耗并不大。在合适的时候使用内存栅栏，仍然是一种高效的做法。</p><h2 id="关于线程"><a href="#关于线程" class="headerlink" title="关于线程"></a>关于线程</h2><p>内存栅栏的知识，这个需要结合线程来进行分析学习。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWhhbnMvJUU1JTg2JTg1JUU1JUFEJTk4JUU1JUIxJThGJUU5JTlBJTlD" title="https://zh.wikipedia.org/zh-hans/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C">维基百科 - 内存屏障<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存屏障 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda教程-流程相关</title>
      <link href="//blockchain/corda/Corda%E6%95%99%E7%A8%8B-%E6%B5%81%E7%A8%8B%E7%9B%B8%E5%85%B3.html"/>
      <url>//blockchain/corda/Corda%E6%95%99%E7%A8%8B-%E6%B5%81%E7%A8%8B%E7%9B%B8%E5%85%B3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="使用客户端RPC-API"><a href="#使用客户端RPC-API" class="headerlink" title="使用客户端RPC API"></a>使用客户端RPC API</h1><p>在本教程中，我们将构建一个简单的命令行实用程序，该实用程序连接到节点，创建一些现金交易并将交易图转储到标准输出。然后，我们将在顶部放置一些简单的可视化。有关Corda如何在Corda中工作的说明，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2NsaWVudHJwYy5odG1s" title="https://docs.corda.net/head/clientrpc.html">Client RPC<i class="fa fa-external-link"></i></span>。</p><p>我们首先连接到节点本身。为了本教程的目的，我们将使用Driver来启动一个公证人和一个可以发行、移动和退出现金的Alice节点。</p><p>下面是我们如何将节点配置为创建具有权限的用户来启动<code>CashIssueFlow</code>， <code>CashPaymentFlow</code>以及<code>CashExitFlow</code>：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOrVisualise</span> </span>&#123;</span><br><span class="line">    Print,</span><br><span class="line">    Visualise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    require(args.isNotEmpty()) &#123; <span class="string">"Usage: &lt;binary&gt; [Print|Visualise]"</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> printOrVisualise = PrintOrVisualise.valueOf(args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> baseDirectory = Paths.<span class="keyword">get</span>(<span class="string">"build/rpc-api-tutorial"</span>)</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"user"</span>, <span class="string">"password"</span>, permissions = setOf(startFlow&lt;CashIssueFlow&gt;(),</span><br><span class="line">            startFlow&lt;CashPaymentFlow&gt;(),</span><br><span class="line">            startFlow&lt;CashExitFlow&gt;(),</span><br><span class="line">            invokeRpc(CordaRPCOps::nodeInfo)</span><br><span class="line">    ))</span><br><span class="line">    driver(DriverParameters(driverDirectory = baseDirectory, extraCordappPackagesToScan = listOf(<span class="string">"net.corda.finance"</span>), waitForAllNodesToFinish = <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">val</span> node = startNode(providedName = ALICE_NAME, rpcUsers = listOf(user)).<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure><p></p><p>现在我们可以使用有效的RPC用户登录连接到节点本身，并使用<code>generateTransactions</code>（稍后定义）开始在不同线程中生成交易：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val client = CordaRPCClient(node.rpcAddress)</span><br><span class="line">val proxy = client.start(&quot;user&quot;, &quot;password&quot;).proxy</span><br><span class="line"></span><br><span class="line">thread &#123;</span><br><span class="line">    generateTransactions(proxy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>proxy 公开节点的完整RPC接口：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the RPC protocol version, which is the same the node's Platform Version. Exists since version 1 so guaranteed</span></span><br><span class="line"><span class="comment"> * to be present.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> protocolVersion: <span class="built_in">Int</span> <span class="keyword">get</span>() = nodeInfo().platformVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a list of currently in-progress state machine infos. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachinesSnapshot</span><span class="params">()</span></span>: List&lt;StateMachineInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a data feed of currently in-progress state machine infos and an observable of</span></span><br><span class="line"><span class="comment"> * future state machine adds/removes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachinesFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;StateMachineInfo&gt;, StateMachineUpdate&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of vault states for a given query criteria (and optional order and paging specification)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Generic vault query function which takes a [QueryCriteria] object to define filters,</span></span><br><span class="line"><span class="comment"> * optional [PageSpecification] and optional [Sort] modification criteria (default unsorted),</span></span><br><span class="line"><span class="comment"> * and returns a [Vault.Page] object containing the following:</span></span><br><span class="line"><span class="comment"> *  1. states as a List of &lt;StateAndRef&gt; (page number and size defined by [PageSpecification])</span></span><br><span class="line"><span class="comment"> *  2. states metadata as a List of [Vault.StateMetadata] held in the Vault States table.</span></span><br><span class="line"><span class="comment"> *  3. total number of results available if [PageSpecification] supplied (otherwise returns -1)</span></span><br><span class="line"><span class="comment"> *  4. status types used in this query: UNCONSUMED, CONSUMED, ALL</span></span><br><span class="line"><span class="comment"> *  5. other results (aggregate functions with/without using value groups)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> VaultQueryException if the query cannot be executed for any reason</span></span><br><span class="line"><span class="comment"> *        (missing criteria or parsing error, paging errors, unsupported query, underlying database error)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes</span></span><br><span class="line"><span class="comment"> *   If no [PageSpecification] is provided, a maximum of [DEFAULT_PAGE_SIZE] results will be returned.</span></span><br><span class="line"><span class="comment"> *   API users must specify a [PageSpecification] if they are expecting more than [DEFAULT_PAGE_SIZE] results,</span></span><br><span class="line"><span class="comment"> *   otherwise a [VaultQueryException] will be thrown alerting to this condition.</span></span><br><span class="line"><span class="comment"> *   It is the responsibility of the API user to request further pages and/or specify a more suitable [PageSpecification].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DOCSTART VaultQueryByAPI</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryBy</span><span class="params">(criteria: <span class="type">QueryCriteria</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     paging: <span class="type">PageSpecification</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     sorting: <span class="type">Sort</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultQueryByAPI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">Note:</span> cannot apply @JvmOverloads to interfaces nor interface implementations</span></span><br><span class="line"><span class="comment">// Java Helpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOCSTART VaultQueryAPIHelpers</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQuery</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryByCriteria</span><span class="params">(criteria: <span class="type">QueryCriteria</span>, contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryByWithPagingSpec</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, paging: <span class="type">PageSpecification</span>)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultQueryByWithSorting</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, sorting: <span class="type">Sort</span>)</span></span>: Vault.Page&lt;T&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultQueryAPIHelpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot (as per queryBy) and an observable of future updates to the vault for the given query criteria.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Generic vault query function which takes a [QueryCriteria] object to define filters,</span></span><br><span class="line"><span class="comment"> * optional [PageSpecification] and optional [Sort] modification criteria (default unsorted),</span></span><br><span class="line"><span class="comment"> * and returns a [DataFeed] object containing</span></span><br><span class="line"><span class="comment"> * 1) a snapshot as a [Vault.Page] (described previously in [CordaRPCOps.vaultQueryBy])</span></span><br><span class="line"><span class="comment"> * 2) an [Observable] of [Vault.Update]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes: the snapshot part of the query adheres to the same behaviour as the [CordaRPCOps.vaultQueryBy] function.</span></span><br><span class="line"><span class="comment"> *        the [QueryCriteria] applies to both snapshot and deltas (streaming updates).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// DOCSTART VaultTrackByAPI</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackBy</span><span class="params">(criteria: <span class="type">QueryCriteria</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     paging: <span class="type">PageSpecification</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     sorting: <span class="type">Sort</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultTrackByAPI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">Note:</span> cannot apply @JvmOverloads to interfaces nor interface implementations</span></span><br><span class="line"><span class="comment">// Java Helpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOCSTART VaultTrackAPIHelpers</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrack</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackByCriteria</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackByWithPagingSpec</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, paging: <span class="type">PageSpecification</span>)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ContractState&gt;</span> <span class="title">vaultTrackByWithSorting</span><span class="params">(contractStateType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">T</span>&gt;, criteria: <span class="type">QueryCriteria</span>, sorting: <span class="type">Sort</span>)</span></span>: DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">// DOCEND VaultTrackAPIHelpers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@suppress</span> Returns a list of all recorded transactions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO This method should be removed once SGX work is finalised and the design of the corresponding API using [FilteredTransaction] can be started</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">"This method is intended only for internal use and will be removed from the public API soon."</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">internalVerifiedTransactionsSnapshot</span><span class="params">()</span></span>: List&lt;SignedTransaction&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@suppress</span> Returns a data feed of all recorded transactions and an observable of future recorded ones.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * TODO This method should be removed once SGX work is finalised and the design of the corresponding API using [FilteredTransaction] can be started</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">"This method is intended only for internal use and will be removed from the public API soon."</span>)</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">internalVerifiedTransactionsFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;SignedTransaction&gt;, SignedTransaction&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a snapshot list of existing state machine id - recorded transaction hash mappings. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachineRecordedTransactionMappingSnapshot</span><span class="params">()</span></span>: List&lt;StateMachineTransactionMapping&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot list of existing state machine id - recorded transaction hash mappings, and a stream of future</span></span><br><span class="line"><span class="comment"> * such mappings as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stateMachineRecordedTransactionMappingFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;StateMachineTransactionMapping&gt;, StateMachineTransactionMapping&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns all parties currently visible on the network with their advertised services. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">networkMapSnapshot</span><span class="params">()</span></span>: List&lt;NodeInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns all parties currently visible on the network with their advertised services and an observable of</span></span><br><span class="line"><span class="comment"> * future updates to the network.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">networkMapFeed</span><span class="params">()</span></span>: DataFeed&lt;List&lt;NodeInfo&gt;, NetworkMapCache.MapChange&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns [DataFeed] object containing information on currently scheduled parameters update (null if none are currently scheduled)</span></span><br><span class="line"><span class="comment"> * and observable with future update events. Any update that occurs before the deadline automatically cancels the current one.</span></span><br><span class="line"><span class="comment"> * Only the latest update can be accepted.</span></span><br><span class="line"><span class="comment"> * Note: This operation may be restricted only to node administrators.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TODO This operation should be restricted to just node admins.</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">networkParametersFeed</span><span class="params">()</span></span>: DataFeed&lt;ParametersUpdateInfo?, ParametersUpdateInfo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Accept network parameters with given hash, hash is obtained through [networkParametersFeed] method.</span></span><br><span class="line"><span class="comment"> * Information is sent back to the zone operator that the node accepted the parameters update - this process cannot be</span></span><br><span class="line"><span class="comment"> * undone.</span></span><br><span class="line"><span class="comment"> * Only parameters that are scheduled for update can be accepted, if different hash is provided this method will fail.</span></span><br><span class="line"><span class="comment"> * Note: This operation may be restricted only to node administrators.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parametersHash hash of network parameters to accept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if network map advertises update with different parameters hash then the one accepted by node's operator.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if failed to send the approval to network map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TODO This operation should be restricted to just node admins.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">acceptNewNetworkParameters</span><span class="params">(parametersHash: <span class="type">SecureHash</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start the given flow with the given arguments. [logicType] must be annotated</span></span><br><span class="line"><span class="comment"> * with [net.corda.core.flows.StartableByRPC].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">startFlowDynamic</span><span class="params">(logicType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">FlowLogic</span>&lt;<span class="type">T</span>&gt;&gt;, <span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: FlowHandle&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start the given flow with the given arguments, returning an [Observable] with a single observation of the</span></span><br><span class="line"><span class="comment"> * result of running the flow. [logicType] must be annotated with [net.corda.core.flows.StartableByRPC].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">startTrackedFlowDynamic</span><span class="params">(logicType: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">FlowLogic</span>&lt;<span class="type">T</span>&gt;&gt;, <span class="keyword">vararg</span> args: <span class="type">Any</span>?)</span></span>: FlowProgressHandle&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to kill a flow. This is not a clean termination and should be reserved for exceptional cases such as stuck fibers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the flow existed and was killed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">killFlow</span><span class="params">(id: <span class="type">StateMachineRunId</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns Node's NodeInfo, assuming this will not change while the node is running. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nodeInfo</span><span class="params">()</span></span>: NodeInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns network's notary identities, assuming this will not change while the node is running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the identities are sorted based on legal name, and the ordering might change once new notaries are introduced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">notaryIdentities</span><span class="params">()</span></span>: List&lt;Party&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add note(s) to an existing Vault transaction. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addVaultTransactionNote</span><span class="params">(txnId: <span class="type">SecureHash</span>, txnNote: <span class="type">String</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Retrieve existing note(s) for a given Vault transaction. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getVaultTransactionNotes</span><span class="params">(txnId: <span class="type">SecureHash</span>)</span></span>: Iterable&lt;String&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether an attachment with the given hash is stored on the node. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">attachmentExists</span><span class="params">(id: <span class="type">SecureHash</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Download an attachment JAR by ID. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">openAttachment</span><span class="params">(id: <span class="type">SecureHash</span>)</span></span>: InputStream</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Uploads a jar to the node, returns it's hash. */</span></span><br><span class="line"><span class="meta">@Throws(java.nio.file.FileAlreadyExistsException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadAttachment</span><span class="params">(jar: <span class="type">InputStream</span>)</span></span>: SecureHash</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Uploads a jar including metadata to the node, returns it's hash. */</span></span><br><span class="line"><span class="meta">@Throws(java.nio.file.FileAlreadyExistsException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">uploadAttachmentWithMetadata</span><span class="params">(jar: <span class="type">InputStream</span>, uploader: <span class="type">String</span>, filename: <span class="type">String</span>)</span></span>: SecureHash</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Queries attachments metadata */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">queryAttachments</span><span class="params">(query: <span class="type">AttachmentQueryCriteria</span>, sorting: <span class="type">AttachmentSort</span>?)</span></span>: List&lt;AttachmentId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the node's current time. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">currentNodeTime</span><span class="params">()</span></span>: Instant</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a [CordaFuture] which completes when the node has registered wih the network map service. It can also</span></span><br><span class="line"><span class="comment"> * complete with an exception if it is unable to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RPCReturnsObservables</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">waitUntilNetworkReady</span><span class="params">()</span></span>: CordaFuture&lt;<span class="built_in">Void</span>?&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO These need rethinking. Instead of these direct calls we should have a way of replicating a subset of</span></span><br><span class="line"><span class="comment">// the node's state locally and query that directly.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the well known identity from an abstract party. This is intended to resolve the well known identity</span></span><br><span class="line"><span class="comment"> * from a confidential identity, however it transparently handles returning the well known identity back if</span></span><br><span class="line"><span class="comment"> * a well known identity is passed in.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> party identity to determine well known identity for.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> well known identity, if found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wellKnownPartyFromAnonymous</span><span class="params">(party: <span class="type">AbstractParty</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the [Party] corresponding to the given key, if found. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partyFromKey</span><span class="params">(key: <span class="type">PublicKey</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the [Party] with the X.500 principal as it's [Party.name]. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">wellKnownPartyFromX500Name</span><span class="params">(x500Name: <span class="type">CordaX500Name</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get a notary identity by name.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the notary identity, or null if there is no notary by that name. Note that this will return null if there</span></span><br><span class="line"><span class="comment"> * is a peer with that name but they are not a recognised notary service.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">notaryPartyFromX500Name</span><span class="params">(x500Name: <span class="type">CordaX500Name</span>)</span></span>: Party?</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may</span></span><br><span class="line"><span class="comment"> * get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results</span></span><br><span class="line"><span class="comment"> * but rather show them via a user interface and let the user pick the one they wanted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> query The string to check against the X.500 name components</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exactMatch If true, a case sensitive match is done against each component of each X.500 name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">partiesFromName</span><span class="params">(query: <span class="type">String</span>, exactMatch: <span class="type">Boolean</span>)</span></span>: Set&lt;Party&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Enumerates the class names of the flows that this node knows about. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registeredFlows</span><span class="params">()</span></span>: List&lt;String&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a node's info from the network map cache, where known.</span></span><br><span class="line"><span class="comment"> * Notice that when there are more than one node for a given name (in case of distributed services) first service node</span></span><br><span class="line"><span class="comment"> * found will be returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node info if available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nodeInfoFromParty</span><span class="params">(party: <span class="type">AbstractParty</span>)</span></span>: NodeInfo?</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Clear all network map data from local node cache. */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">clearNetworkMapCache</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Sets the value of the node's flows draining mode.</span></span><br><span class="line"><span class="comment"> * If this mode is [enabled], the node will reject new flows through RPC, ignore scheduled flows, and do not process</span></span><br><span class="line"><span class="comment"> * initial session messages, meaning that P2P counterparties will not be able to initiate new flows involving the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> enabled whether the flows draining mode will be enabled.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setFlowsDrainingModeEnabled</span><span class="params">(enabled: <span class="type">Boolean</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns whether the flows draining mode is enabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> setFlowsDrainingModeEnabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isFlowsDrainingModeEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shuts the node down. Returns immediately.</span></span><br><span class="line"><span class="comment"> * This does not wait for flows to be completed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>我们需要用来转储交易图的RPC操作是<code>internalVerifiedTransactionsFeed</code>。类型签名告诉我们RPC操作将返回一系列交易和一个<code>Observable</code>流。这是一种普遍的模式，我们查询一些数据，节点将返回当前的快照和将来的更新。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2NsaWVudHJwYy5odG1s" title="https://docs.corda.net/head/clientrpc.html">客户端RPC<i class="fa fa-external-link"></i></span>更详细地描述了可观察对象.<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (transactions: List&lt;SignedTransaction&gt;, futureTransactions: Observable&lt;SignedTransaction&gt;) = proxy.internalVerifiedTransactionsFeed()</span><br></pre></td></tr></table></figure><p></p><p>该图将被定义如下：</p><ul><li>每个交易都是一个顶点，由打印<code>NODE &lt;txhash&gt;</code>表示</li><li>每个输入 - 输出关系都是一个边，由prining <code>EDGE &lt;txhash&gt; &lt;txhash&gt;</code>表示</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (printOrVisualise) &#123;</span><br><span class="line">    PrintOrVisualise.Print -&gt; &#123;</span><br><span class="line">        futureTransactions.startWith(transactions).subscribe &#123; transaction -&gt;</span><br><span class="line">            println(<span class="string">"NODE <span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            transaction.tx.inputs.forEach &#123; (txhash) -&gt;</span><br><span class="line">                println(<span class="string">"EDGE <span class="variable">$txhash</span> <span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们只需要自己创建交易！<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateTransactions</span><span class="params">(proxy: <span class="type">CordaRPCOps</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vault = proxy.vaultQueryBy&lt;Cash.State&gt;().states</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ownedQuantity = vault.fold(<span class="number">0</span>L) &#123; sum, state -&gt;</span><br><span class="line">        sum + state.state.<span class="keyword">data</span>.amount.quantity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> issueRef = OpaqueBytes.of(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> notary = proxy.notaryIdentities().first()</span><br><span class="line">    <span class="keyword">val</span> me = proxy.nodeInfo().legalIdentities.first()</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">val</span> random = SplittableRandom()</span><br><span class="line">        <span class="keyword">val</span> n = random.nextDouble()</span><br><span class="line">        <span class="keyword">if</span> (ownedQuantity &gt; <span class="number">10000</span> &amp;&amp; n &gt; <span class="number">0.8</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> quantity = Math.abs(random.nextLong()) % <span class="number">2000</span></span><br><span class="line">            proxy.startFlow(::CashExitFlow, Amount(quantity, USD), issueRef)</span><br><span class="line">            ownedQuantity -= quantity</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ownedQuantity &gt; <span class="number">1000</span> &amp;&amp; n &lt; <span class="number">0.7</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> quantity = Math.abs(random.nextLong() % Math.min(ownedQuantity, <span class="number">2000</span>))</span><br><span class="line">            proxy.startFlow(::CashPaymentFlow, Amount(quantity, USD), me)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> quantity = Math.abs(random.nextLong() % <span class="number">1000</span>)</span><br><span class="line">            proxy.startFlow(::CashIssueFlow, Amount(quantity, USD), issueRef, notary)</span><br><span class="line">            ownedQuantity += quantity</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们在这里使用几个RPC函数来查询节点集群或我们自己的库中的公证信息。<b style="color:red">这些RPC函数还会返回<code>Observable</code>对象，以便节点可以向我们发送更新的值。但是，我们在这里不需要更新，因此我们将这些观察值标记为<code>notUsed</code>（通常，您应该始终订阅一个<code>Observable</code> 或将其标记为未使用，否则会泄漏节点中的资源）。</b></p><p>然后在一个循环中，我们随机生成一个Issue，一个Pay或一个Exit交易。</p><p>我们需要启动一个现金交易的RPC是<code>startFlow</code>在足够的权限下启动一个任意的流程。</p><p>最后，我们掌握了一切：我们启动几个节点，连接到它们，并开始创建交易，同时监听已成功创建的交易，并将这些交易转储到控制台。我们只需要运行它！<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Build the example</span></span><br><span class="line">./gradlew docs/source/example-code:installDist</span><br><span class="line"><span class="meta">#</span><span class="bash"> Start it</span></span><br><span class="line">./docs/source/example-code/build/install/docs/source/example-code/bin/client-rpc-tutorial Print</span><br></pre></td></tr></table></figure><p></p><p>现在让我们尝试对交易图进行可视化。我们将使用一个名为<code>graphstream</code>的图形绘制库。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    PrintOrVisualise.Visualise -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> graph = MultiGraph(<span class="string">"transactions"</span>)</span><br><span class="line">        transactions.forEach &#123; transaction -&gt;</span><br><span class="line">            graph.addNode&lt;Node&gt;(<span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        transactions.forEach &#123; transaction -&gt;</span><br><span class="line">            transaction.tx.inputs.forEach &#123; ref -&gt;</span><br><span class="line">                graph.addEdge&lt;Edge&gt;(<span class="string">"<span class="variable">$ref</span>"</span>, <span class="string">"<span class="subst">$&#123;ref.txhash&#125;</span>"</span>, <span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        futureTransactions.subscribe &#123; transaction -&gt;</span><br><span class="line">            graph.addNode&lt;Node&gt;(<span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            transaction.tx.inputs.forEach &#123; ref -&gt;</span><br><span class="line">                graph.addEdge&lt;Edge&gt;(<span class="string">"<span class="variable">$ref</span>"</span>, <span class="string">"<span class="subst">$&#123;ref.txhash&#125;</span>"</span>, <span class="string">"<span class="subst">$&#123;transaction.id&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        graph.display()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果我们使用<code>Visualise</code>运行客户端，我们应该看到随着新交易的创建，会绘制一个简单的随机图。</p><h2 id="将您的CorDapp与Corda节点上的类列入白名单"><a href="#将您的CorDapp与Corda节点上的类列入白名单" class="headerlink" title="将您的CorDapp与Corda节点上的类列入白名单"></a>将您的CorDapp与Corda节点上的类列入白名单</h2><p>如<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2NsaWVudHJwYy5odG1s" title="https://docs.corda.net/head/clientrpc.html">Client RPC<i class="fa fa-external-link"></i></span>所述，您必须将您添加的RPC请求或Corda节点响应中所需的任何其他类添加到白名单中。这里有一个例子，你可以通过这两种方法来做几个示例类。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not annotated, so need to whitelist manually.</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRPCValue</span></span>(<span class="keyword">val</span> foo: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Annotated, so no need to whitelist manually.</span></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRPCValue2</span></span>(<span class="keyword">val</span> bar: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleRPCSerializationWhitelist</span> : <span class="type">SerializationWhitelist &#123;</span></span></span><br><span class="line">    <span class="comment">// Add classes like this.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> whitelist = listOf(ExampleRPCValue::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL3J1bm5pbmctYS1ub2RlLmh0bWw=" title="https://docs.corda.net/head/running-a-node.html">在本地运行节点<i class="fa fa-external-link"></i></span>这里查看更多插件。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>与客户端关联的RPC凭证必须与服务器节点上配置的权限集匹配。这涉及身份验证（用户名和密码）和基于角色的授权（授权用户有权运行的一组经过授权的RPC操作）。</p><p><b style="color:#00f">注意：权限以String的形式表示，以允许RPC实现添加他们自己的权限。目前唯一定义的权限类型是StartFlow，它定义了经过身份验证的使用可能执行的白名单流程的列表。管理员用户（或开发人员）也可能被分配ALL权限，该权限授予对任何流量的访问权限。</b></p><p>在上面的说明中，服务器节点权限是以编程方式driver代码中配置的：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver(driverDirectory = baseDirectory) &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"user"</span>, <span class="string">"password"</span>, permissions = setOf(startFlow&lt;CashFlow&gt;()))</span><br><span class="line">    <span class="keyword">val</span> node = startNode(<span class="string">"CN=Alice Corp,O=Alice Corp,L=London,C=GB"</span>, rpcUsers = listOf(user)).<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure><p></p><p>当使用配置文件启动独立节点时，我们必须提供RPC凭证，如下所示：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user, password=password, permissions=[ StartFlow.net.corda.finance.flows.CashFlow ] &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>在使用Gradle Cordformation插件配置和部署节点时，您必须以类似的方式提供RPC凭据：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [</span><br><span class="line">        [<span class="string">'username'</span> : <span class="string">"user"</span>,</span><br><span class="line">         <span class="string">'password'</span> : <span class="string">"password"</span>,</span><br><span class="line">         <span class="string">'permissions'</span> : [<span class="string">"StartFlow.net.corda.finance.flows.CashFlow"</span>]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>然后，您可以按如下方式部署和启动节点（公证人和Alice）：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> to create a <span class="built_in">set</span> of configs and installs under ``docs/<span class="built_in">source</span>/example-code/build/nodes`` run</span></span><br><span class="line">./gradlew docs/source/example-code:deployNodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> to open up two new terminals with the two nodes run</span></span><br><span class="line">./docs/source/example-code/build/nodes/runnodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> followed by the same commands as before:</span></span><br><span class="line">./docs/source/example-code/build/install/docs/source/example-code/bin/client-rpc-tutorial Print</span><br><span class="line">./docs/source/example-code/build/install/docs/source/example-code/bin/client-rpc-tutorial Visualise</span><br></pre></td></tr></table></figure><p></p><p>关于启动流RPC，还有一个额外的安全层，要执行的流必须注解<code>@StartableByRPC</code>。没有此注解的流程无法使用RPC执行。</p><p>请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL3NlY3VyZS1jb2RpbmctZ3VpZGVsaW5lcy5odG1s" title="https://docs.corda.net/head/secure-coding-guidelines.html">安全编码指南<i class="fa fa-external-link"></i></span>中的安全性，<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2NvcmRhLWNvbmZpZ3VyYXRpb24tZmlsZS5odG1s" title="https://docs.corda.net/head/corda-configuration-file.html">节点配置<i class="fa fa-external-link"></i></span>中的节点配置以及<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL3J1bm5pbmctYS1ub2RlLmh0bWw=" title="https://docs.corda.net/head/running-a-node.html">本地运行节点<i class="fa fa-external-link"></i></span>中的<code>Cordformation</code> 。</p><h1 id="构建交易"><a href="#构建交易" class="headerlink" title="构建交易"></a>构建交易</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>理解和实施Corda中的交易是构建和实施真实世界智能合约的关键。只有通过构建包含适当数据的有效Corda交易，分类账上的节点才能将真实世界的业务对象映射到Corda分类账中数据的共享数字视图。更重要的是，作为新智能合约的开发者，它是决定哪些数据格式良好以及哪些数据应该被拒绝为错误或防止恶意活动的代码。本文档详细介绍了在构建交易作为流程的一部分时所使用的一些注意事项和API。</p><h2 id="交易的基本生命周期"><a href="#交易的基本生命周期" class="headerlink" title="交易的基本生命周期"></a>交易的基本生命周期</h2><p>Corda的交易包含许多要素：</p><ol><li>一组将被最终接受的交易处理的输入状态引用</li><li>一组输出状态，用于创建/替换使用状态，从而成为分类账上新的最新数据版本</li><li>一系列<code>Attachment</code>可以包含法律文件，合同代码或专用加密部分作为原生合同状态之外的扩展的项目</li><li>一组<code>Command</code>项目，用于指示在交易中编码的分类帐转换的类型。每个命令还有一组相关联的签名者密钥，这些签名者密钥将用于签署交易</li><li>签名者列表，它是各个<code>Command</code>对象上的签名者的联合</li><li>指定哪个公证节点正在跟踪状态消费的公证身份（如果交易的输入状态用不同的公证节点注册，那么流程将不得不插入额外的<code>NotaryChange</code>交易，以便在允许突变任何状态之前将状态迁移到一致的公证节点）</li><li>可选择一个时间窗口，公证人可以使用时间窗口来限定提议的交易可以提交给分类帐的时间段</li></ol><p>交易是通过填充一个<code>TransactionBuilder</code>。通常情况下，<code>TransactionBuilder</code>需要在各方之间进行交换，然后才能完全填充。这是Corda隐私模型的直接结果，其中输入状态很可能是其他节点未知的。</p><p>一旦builder完全填充，流程应该通过签署<code>TransactionBuilder</code>创建一个<code>SignedTransaction</code>来冻结它。这是分类账协议流程的关键 - 一旦流程将节点的签名附加到交易中，它就有效地声明它接受交易的所有细节。</p><p>对于流程来说，最好的做法是接收其他Party的<code>TransactionSignature</code>而不是完整的<code>SignedTransaction</code>对象，因为否则我们必须单独检查它是否仍然是相同的<code>SignedTransaction</code>，而不是恶意的替代品。</p><p>将交易提交给分类帐的最后阶段是公证<code>SignedTransaction</code>，并将其分发给所有适当的当事人并将数据记录到分类账中。这些操作最好委托给<code>FinalityFlow</code>，而不是手动调用各个步骤。但是，请注意，对其他节点的最终广播是异步的，因此必须小心在单元测试中正确等待Vault更新。</p><h2 id="收集输入"><a href="#收集输入" class="headerlink" title="收集输入"></a>收集输入</h2><p>形成交易的第一步是收集一组输入引用。根据智能合约所捕获的业务流程的性质以及请求的参数化细节，此流程将会有明显的不同。但是，它通常涉及通过<code>ServiceHub</code>里的<code>VaultService</code>接口来搜索vault来定位输入状态。</p><p>给一些更具体的细节考虑两个简化的现实世界的情况。首先是基本的外汇现金交易。这笔交易需要找到一组资金进行交易。流程建模，这是在<code>FxTransactionBuildTutorial.kt</code>实现了 （见docs/source/example-code/src/main/kotlin/net/corda/docs/FxTransactionBuildTutorial.kt的 主<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRh" title="https://github.com/corda/corda">corda代码库<i class="fa fa-external-link"></i></span>中）。其次，一个简单的商业模式，其中parties手动接受或拒绝对方的贸易提案，这是在<code>WorkflowTransactionBuildTutorial.kt</code>中实现的（见 docs/source/example-code/src/main/kotlin/net/corda/docs/WorkflowTransactionBuildTutorial.kt的 主<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRh" title="https://github.com/corda/corda">corda代码库<i class="fa fa-external-link"></i></span>中）。要使用IntelliJ IDE运行和浏览这些示例，可以run/step完成<code>FxTransactionBuildTutorialTest.kt</code>和<code>WorkflowTransactionBuildTutorialTest.kt</code>中的相应单元测试，这些测试将流程驱动为模拟内存节点网络的一部分。</p><p>注意：创建这些单元测试的IntelliJ运行配置之前，转到 运行- &gt;编辑配置- &gt;默认设置- &gt; JUnit中，添加 <code>-javaagent:lib/quasar.jar</code> 到VM选项，并设置工作目录<code>$PROJECT_DIR$</code>，那么<code>Quasar</code>仪器的配置就正确完成了。</p><p>对于现金交易，假设我们使用的是在<code>:financial</code>gradle模块的标准<code>CashState</code>。<code>Cash</code>合同利用<code>FungibleAsset</code>状态与模型互换资产的持有量，并允许拆分，合并和求状态的总和，以满足合同义务。我们通常会使用该 Cash.generateSpend方法将所需数量的现金收集到a中TransactionBuilder，设置输出并生成Move 命令。然而，为了使事情更加清楚，这里示出的示例性流程的代码将手动通过指定相关的查询条件的过滤器到进行输入的查询tryLockFungibleStatesForSpending的方法VaultService。</p><p>// This is equivalent to the Cash.generateSpend<br>// Which is brought here to make the filtering logic more visible in the example<br>private fun gatherOurInputs(serviceHub: ServiceHub,<br>lockId: UUID,<br>amountRequired: Amount&lt;Issued<currency>&gt;,<br>notary: Party?): Pair&lt;List&lt;StateAndRef&lt;Cash.State&gt;&gt;, Long&gt; {<br>// extract our identity for convenience<br>val ourKeys = serviceHub.keyManagementService.keys<br>val ourParties = ourKeys.map { serviceHub.identityService.partyFromKey(it) ?: throw IllegalStateException(“Unable to resolve party from key”) }<br>val fungibleCriteria = QueryCriteria.FungibleAssetQueryCriteria(owner = ourParties)</currency></p><pre><code>val notaries = notary ?: serviceHub.networkMapCache.notaryIdentities.first()val vaultCriteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(notary = listOf(notaries as AbstractParty))val logicalExpression = builder { CashSchemaV1.PersistentCashState::currency.equal(amountRequired.token.product.currencyCode) }val cashCriteria = QueryCriteria.VaultCustomQueryCriteria(logicalExpression)val fullCriteria = fungibleCriteria.and(vaultCriteria).and(cashCriteria)val eligibleStates = serviceHub.vaultService.tryLockFungibleStatesForSpending(lockId, fullCriteria, amountRequired.withoutIssuer(), Cash.State::class.java)check(eligibleStates.isNotEmpty()) { &quot;Insufficient funds&quot; }val amount = eligibleStates.fold(0L) { tot, (state) -&gt; tot + state.data.amount.quantity }val change = amount - amountRequired.quantityreturn Pair(eligibleStates, change)</code></pre><p>}<br>这是一项外汇交易，所以我们预计另一种来自交易对手货币的投入状态。然而，Corda隐私模型意味着我们不知道其他节点的状态。因此，我们的流程必须要求另一个节点执行类似的查询并将额外的输入返回给交易（参见 ForeignExchangeFlow交换的更多细节）。我们现在拥有所有必需的输入StateRef项目，并可转而收集输出。</p><p>对于贸易审批流程，我们需要实施一个简单的工作流程模式。我们首先将未经确认的交易细节记录在实现LinearState界面的状态对象中。此记录的一个字段用于将业务工作流映射到枚举状态。最初，发起者创建一个新的状态对象，该对象UniqueIdentifier在其linearId属性中接收新的状态， 并且启动工作流状态为NEW。该Contract.verify方法的写法是允许发起者签署该初始事务并将其发送给另一方。该模式确保为了审计目的在两个分类帐上都记录永久性副本，但是可以防止状态被恶意置于批准状态。接下来的工作流程步骤随后将消耗状态作为一方输入的事务处理，然后输出一个新的版本，其中包含任何状态更新，或者与业务流程相匹配linearId的修改，这些更改将保留在整个变更中。附Command对象有助于验证方法将更改限制在工作流中每个步骤的相应字段和签名者。在这种情况下，通常双方都签署了变更交易，但如果允许单方面签署，例如一方可以阻止拒绝，那么这是有效的。通常，这些工作流的手动启动器将通过RPC接口向Vault查询正确合同类型的状态以及正确的工作流状态。然后，RPC将启动相关流程StateRef或使用linearId值作为流程的参数，以识别正在进行操作的状态。因此，收集给定的最新输入状态的代码StateRef将使用VaultService如下代码：</p><p>val criteria = VaultQueryCriteria(stateRefs = listOf(ref))<br>val latestRecord = serviceHub.vaultService.queryBy&lt;TradeApprovalContract.State&gt;(criteria).states.single()<br>生成命令<br>对于要添加到事务中的命令，这些命令需要正确反映当前的任务。这些必须匹配，因为在该Contract.verify方法中该命令将用于选择验证码路径。Contract.verify然后该方法将限制事务的允许内容以反映该上下文。典型的限制可能包括输入现金金额必须等于输出现金金额，或者工作流步骤仅允许更改状态字段。有时，命令可能会捕获一些数据，例如外汇汇率或一方的身份，或者在批量操作中产生命令的特定输入的StateRef。这些数据将被用来进一步帮助Contract.verify，因为为了确保分布式环境中的一致性，安全性和可重复性Contract.verify，交易是唯一允许使用交易内容来决定合法性的。</p><p>命令的另一个基本要求是将正确的PublicKey对象集 添加到Command构建器上，这将用于在最终验证的事务上形成一组必需的签名者。这些必须与Contract.verify方法的期望保持一致 ，这应该写成防御性的检查。特别是，预计至少资产的所有者必须签署许可转让该资产。另外，在进行资产交换时，通常还需要其他签署方，例如甲骨文公司的Oracle身份标识或双方。</p><p>生成输出<br>找到一StateAndRefs组作为交易输入后，流程必须生成输出状态。通常，这是对Kotlin copy方法的简单调用，以修改将在事务中转换的几个字段。generateXXX如果任务更复杂，合同代码可能会提供一种帮助此流程的 方法。对于工作流程状态，稍微修改的副本状态通常就足够了，特别是因为我们希望保留linearId状态修订版本之间的关系，以便Vault查询可以找到最新的修订版本。</p><p>对于可替代的合同状态，例如cash在分配大量输入状态时，通常会分配和分配总金额，例如为原始所有者产生剩余的余额输出状态。请记住，成功交易的结果总是要完全消耗/消耗输入状态，因此需要这样才能节省总现金。例如来自演示代码：</p><p>// Gather our inputs. We would normally use VaultService.generateSpend<br>// to carry out the build in a single step. To be more explicit<br>// we will use query manually in the helper function below.<br>// Putting this into a non-suspendable function also prevents issues when<br>// the flow is suspended.<br>val (inputs, residual) = gatherOurInputs(serviceHub, lockId, sellAmount, request.notary)</p><p>// Build and an output state for the counterparty<br>val transferedFundsOutput = Cash.State(sellAmount, request.counterparty)</p><p>val outputs = if (residual &gt; 0L) {<br>// Build an output state for the residual change back to us<br>val residualAmount = Amount(residual, sellAmount.token)<br>val residualOutput = Cash.State(residualAmount, serviceHub.myInfo.singleIdentity())<br>listOf(transferedFundsOutput, residualOutput)<br>} else {<br>listOf(transferedFundsOutput)<br>}<br>return Pair(inputs, outputs)<br>构建SignedTransaction<br>收集了交易的所有组件后，我们现在需要使用a TransactionBuilder来构建完整的SignedTransaction。我们实例化一个TransactionBuilder并提供一个与输出状态相关的公证。然后我们不断添加输入，输出，命令和附件以完成交易。</p><p>一旦交易完成后，我们呼吁ServiceHub.signInitialTransaction签署TransactionBuilder 并将其转换为SignedTransaction。</p><p>这个过程的例子是：</p><p>// Modify the state field for new output. We use copy, to ensure no other modifications.<br>// It is especially important for a LinearState that the linearId is copied across,<br>// not accidentally assigned a new random id.<br>val newState = latestRecord.state.data.copy(state = verdict)</p><p>// We have to use the original notary for the new transaction<br>val notary = latestRecord.state.notary</p><p>// Get and populate the new TransactionBuilder<br>// To destroy the old proposal state and replace with the new completion state.<br>// Also add the Completed command with keys of all parties to signal the Tx purpose<br>// to the Contract verify method.<br>val tx = TransactionBuilder(notary).<br>withItems(<br>latestRecord,<br>StateAndContract(newState, TRADE_APPROVAL_PROGRAM_ID),<br>Command(TradeApprovalContract.Commands.Completed(),<br>listOf(ourIdentity.owningKey, latestRecord.state.data.source.owningKey)))<br>tx.setTimeWindow(serviceHub.clock.instant(), 60.seconds)<br>// We can sign this transaction immediately as we have already checked all the fields and the decision<br>// is ultimately a manual one from the caller.<br>// As a SignedTransaction we can pass the data around certain that it cannot be modified,<br>// although we do require further signatures to complete the process.<br>val selfSignedTx = serviceHub.signInitialTransaction(tx)<br>private fun buildTradeProposal(ourInputStates: List&lt;StateAndRef&lt;Cash.State&gt;&gt;,<br>ourOutputState: List&lt;Cash.State&gt;,<br>theirInputStates: List&lt;StateAndRef&lt;Cash.State&gt;&gt;,<br>theirOutputState: List&lt;Cash.State&gt;): SignedTransaction {<br>// This is the correct way to create a TransactionBuilder,<br>// do not construct directly.<br>// We also set the notary to match the input notary<br>val builder = TransactionBuilder(ourInputStates.first().state.notary)</p><pre><code>// Add the move commands and key to indicate all the respective owners and need to signval ourSigners = ourInputStates.map { it.state.data.owner.owningKey }.toSet()val theirSigners = theirInputStates.map { it.state.data.owner.owningKey }.toSet()builder.addCommand(Cash.Commands.Move(), (ourSigners + theirSigners).toList())// Build and add the inputs and outputsbuilder.withItems(*ourInputStates.toTypedArray())builder.withItems(*theirInputStates.toTypedArray())builder.withItems(*ourOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())builder.withItems(*theirOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())// We have already validated their response and trust our own data// so we can sign. Note the returned SignedTransaction is still not fully signed// and would not pass full verification yet.return serviceHub.signInitialTransaction(builder, ourSigners.single())</code></pre><p>}<br>完成SignedTransaction<br>创建完成TransactionBuilder并将其转换为a后SignedTransaction，验证和形成完整的过程SignedTransaction开始，然后通过公证完成。在实践中，这是一个相对刻板的过程，因为假设SignedTransaction构建正确，验证应立即进行。但是，重新检查从外部节点接收的任何数据的业务详情也很重要，因为恶意方在返回事务之前总是可以修改内容。因此，每个远程流程应该尽可能多地检查SignedTransaction内部的初始状态unwrap的同意签署前的接收。任何问题都应立即抛出异常来中止流程。同样，始发者应始终对其原始提案应用任何新签名，以确保交易内容未被远程方更改。</p><p>因此，典型的代码SignedTransaction 使用该verifySignaturesExcept方法检查收到的信息，但不包括其本身，公证人以及尚未申请其签名的任何其他方。SignedTransaction应该通过扩展toLedgerTransaction和调用 进一步充分验证内容verify。因此，应该进行更多的特定于上下文的业务检查，因为Contract.verify不允许访问外部上下文。例如，流程可能需要检查当事人是否正确，或者Command交易中的现在是否符合特定流程的预期。演示代码中的一个例子是：</p><p>// First we receive the verdict transaction signed by their single key<br>val completeTx = sourceSession.receive<signedtransaction>().unwrap {<br>// Check the transaction is signed apart from our own key and the notary<br>it.verifySignaturesExcept(ourIdentity.owningKey, it.tx.notary!!.owningKey)<br>// Check the transaction data is correctly formed<br>val ltx = it.toLedgerTransaction(serviceHub, false)<br>ltx.verify()<br>// Confirm that this is the expected type of transaction<br>require(ltx.commands.single().value is TradeApprovalContract.Commands.Completed) {<br>“Transaction must represent a workflow completion”<br>}<br>// Check the context dependent parts of the transaction as the<br>// Contract verify method must not use serviceHub queries.<br>val state = ltx.outRef&lt;TradeApprovalContract.State&gt;(0)<br>require(serviceHub.myInfo.isLegalIdentity(state.state.data.source)) {<br>“Proposal not one of our original proposals”<br>}<br>require(state.state.data.counterparty == sourceSession.counterparty) {<br>“Proposal not for sent from correct source”<br>}<br>it<br>}<br>在验证之后，远程流程将把其签名返回给始发者。发起人应该将该签名应用于开始 SignedTransaction并重新检查签名匹配。</signedtransaction></p><p>提交交易<br>一旦将所有签名应用于该签名SignedTransaction，最后的步骤都是公证，并确保所有节点都记录完全签署的交易。代码为FinalityFlow：</p><p>// Notarise and distribute the completed transaction.<br>subFlow(FinalityFlow(allPartySignedTx, setOf(newState.source)))<br>部分可见交易<br>迄今为止的讨论认为，各方需要对交易进行充分的可见性签署。但是，可能会出现以下情况：各方需要存储用于审计目的的私人数据，或者向监管机构提供证据，但不希望与其他贸易伙伴分享。Corda的拆解/ Merkle树支持允许流程发送完整事务的一部分以限制对远程方的可见性。要做到这一点，可以使用 SignedTransaction.buildFilteredTransaction扩展方法来产生一个FilteredTransaction。SignedTransaction 我们希望隐藏的元素将被替换为其安全散列。总体事务ID仍然可以通过FilteredTransaction防止私有数据的更改来证明 ，但我们不会将该数据直接暴露给其他节点。在这里可以找到完整的例子NodeInterestRatesirs-demo与RatesFixFlow流程交互的项目中的Oracle代码 。另外，请参阅交易拆分。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda教程——合约部分</title>
      <link href="//blockchain/corda/Corda%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94%E5%90%88%E7%BA%A6%E9%83%A8%E5%88%86.html"/>
      <url>//blockchain/corda/Corda%E6%95%99%E7%A8%8B%E2%80%94%E2%80%94%E5%90%88%E7%BA%A6%E9%83%A8%E5%88%86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h1><p>本教程将带您通过撰写合同，以简单的商业纸张合同为例。Corda的智能合约有三个关键要素：</p><ul><li>可执行代码（验证逻辑）</li><li>状态对象</li><li>命令</li></ul><p>智能合约的核心是验证交易中状态对象更改的可执行代码。状态对象是分类账中保存的数据，它代表合约实例的当前状态，并用作交易的输入和输出。命令是包含在交易中的附加数据，用于描述发生了什么，用于指示可执行代码如何验证交易。例如，一个<code>Issue</code>命令可能指示验证逻辑应该看到一个输出，该输出不存在作为输入的输出，由签署该命令的相同实体发出。</p><p>首先要考虑的是合约状态的生命周期，它们是如何发行的，它们发布后会发生什么，以及它们如何销毁（如果适用）。对于商业票据合约，状态是由希望创建合约在未来（到期日）支付货款的法律实体签发的，现在换取较少的付款。然后，他们被转移（转移）给另一个所有者，作为交易的一部分，发行人在收到付款资金后，通过向所有者支付商业票据的面值销毁（赎回）后来的（到期日之后）。</p><p><b style="color:red">商业票据的生命周期如下图所示：</b><br><img alt="" data-src="https://docs.corda.net/head/_images/contract-cp.png"></p><h2 id="开始商业票据（paper）类"><a href="#开始商业票据（paper）类" class="headerlink" title="开始商业票据（paper）类"></a>开始商业票据（paper）类</h2><p>智能合约是一个实现<code>Contract</code>接口的类。这可以直接实现，就像这里所做的那样，或者通过继承一个抽象合约，比如<code>OnLedgerAsset</code>。Corda任何合约的核心是确定给定交易是否有效的<code>verify</code>方法。这个例子展示了如何从头开始编写一个<code>verify</code>函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaper</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        TODO()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每份合约都必须至少有一个<code>verify</code>方法。验证方法不返回任何内容。这是故意的：函数要么正确地完成，要么抛出异常，在这种情况下，交易被拒绝。</p><p><b style="color:#00f">到目前为止，这么简单。现在我们需要定义商业票据状态，它代表一张已发行票据的所有权事实。</b></p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>状态是存储由合约检查的数据的类。商业票据状态的结构如下：<br><img alt="" data-src="https://docs.corda.net/head/_images/contract-cp-state.png"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(</span><br><span class="line">        <span class="keyword">val</span> issuance: PartyAndReference,</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> owner: AbstractParty,</span><br><span class="line">        <span class="keyword">val</span> faceValue: Amount&lt;Issued&lt;Currency&gt;&gt;,</span><br><span class="line">        <span class="keyword">val</span> maturityDate: Instant</span><br><span class="line">) : OwnableState &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> participants = listOf(owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withoutOwner</span><span class="params">()</span></span> = copy(owner = AnonymousParty(NullKeys.NullPublicKey))</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwner</span><span class="params">(newOwner: <span class="type">AbstractParty</span>)</span></span> = CommandAndState(CommercialPaper.Commands.Move(), copy(owner = newOwner))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个实现<code>ContractState</code>接口的类。</p><p>我们的状态有四个领域：</p><ul><li><code>issuance</code>，是对某一方发布的特定商业票据的参考。</li><li><code>owner</code>，当前所有者的公钥。这与在比特币中看到的概念是一样的：公钥没有附加的身份，并且由于隐私原因预计会一次性使用。然而，与比特币不同的是，我们将个体所有权视为个别状态层面而不是平台层面的概念，因为我们认为平台上的许多（可能是大多数）合约不代表“所有者/发行人”关系，而是“party/party“衍生合约等关系。</li><li><code>faceValue</code>，一个<code>Amount&lt;Issued&lt;Currency&gt;&gt;</code>包装整数个便士和特定于一些发行者（例如正规银行，中央银行等）的货币的货币。你可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2FwaS1jb3JlLXR5cGVzLmh0bWw=" title="https://docs.corda.net/head/api-core-types.html">API：核心类型<i class="fa fa-external-link"></i></span>中阅读更多关于这个非常常见的类型。</li><li><code>maturityDate</code>中，即时，这是从Java 8标准时间库中的类型。它定义了时间线上的一个点。</li></ul><p>状态是不可变的，因此这个类也被定义为不可变的。Kotlin版本中的修饰符<code>data</code>会导致编译器自动生成equals/hashCode/toString方法，以及可用于创建原始对象变体的复制方法。如果您熟悉该语言，则数据类与Scala中的案例类相似。<code>withoutOwner</code>方法使用自动生成的复制方法来返回状态的一个版本，其拥有者公钥已被删除：稍后将证明这一点很有用。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><b style="color:red">合约的验证逻辑可能会有所不同，具体取决于它自动执行的状态级生命周期的哪个阶段。因此，将附加数据传递到并非永久存在于分类帐中的状态所代表的合约代码中以便明确交易的意图会很有用。</b></p><p>为此我们有命令。通常他们不需要包含任何数据，他们只需要存在。<b style="color:red">命令是与某些签名关联的一段数据</b>。在合约运行时签名已经被检查过，<b style="color:red">所以从合约代码的角度来看，一个命令只是一个带有连接公钥列表的数据结构</b>。每个密钥都有一个签名，证明相应的私钥用于签名。由于这种方法，合约永远不会直接与数字签名进行交互或处理。</p><p>现在我们来定义一些命令：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Commands</span> : <span class="type">CommandData &#123;</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Move</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Redeem</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Issue</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个简单的分组接口或静态类，这给了我们一个类型，我们所有的命令有共通之处，那么我们就创建三个命令：<code>Move</code>，<code>Redeem</code>，<code>Issue</code>。<code>TypeOnlyCommandData</code>对于命令内部没有数据的情况是一个有用的工具; 只有存在很重要。它定义了equals和hashCode，以便任何实例始终将相等值和散列值与相同的值进行比较。</p><h2 id="verify方法"><a href="#verify方法" class="headerlink" title="verify方法"></a><code>verify</code>方法</h2><p>智能合约的核心是验证一组状态转换（交易）的代码。该函数很简单：给定一个表示交易的类，如果该函数返回，则该交易被认为是可接受的。如果它抛出异常，则交易被拒绝。</p><p>每个交易可以有多个不同类型的输入和输出状态。要运行的合约集合取决于每个状态中的代码引用。每份合约只运行一次。例如，一份包含2个现金状态和1个商业票据状态作为输入的合同，其输出为1个现金状态和1个商业票据状态，将分别运行两次合同：现金和商业票据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Group by everything except owner: any modification to the CP at all is considered changing it fundamentally.</span></span><br><span class="line">    <span class="keyword">val</span> groups = tx.groupStates(State::withoutOwner)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are two possible things that can be done with this CP. The first is trading it. The second is redeeming</span></span><br><span class="line">    <span class="comment">// it for cash on or after the maturity date.</span></span><br><span class="line">    <span class="keyword">val</span> command = tx.commands.requireSingleCommand&lt;CommercialPaper.Commands&gt;()</span><br></pre></td></tr></table></figure><p>我们从使用<code>groupStates</code>方法开始，它使用一个类型和一个函数。状态分组是确保您的合同可以在同一个交易中处理同一类型的多个不相关的状态的一种方式，这是资产拆分/合并，原子交换等所需的。接下来会有更多说明。</p><p>第二行代码的作用就是：它搜索一个从超类<code>CommercialPaper.Commands</code>类型继承的命令对象 ，并返回它，或者在有零个或多个这样的命令时抛出异常。</p><h2 id="使用状态组"><a href="#使用状态组" class="headerlink" title="使用状态组"></a>使用状态组</h2><p>写一个智能合约最简单的方法就是说，每个交易可以有一个单一的输入状态和该合约所涵盖的单一输出状态。这对开发者来说很容易，但会阻止很多重要的用例。</p><p>编写合约的下一个最简单的方法是迭代每个输入状态，并期望它具有输出状态。现在你可以建立一个单一的交易，例如，同时以不同的货币移动两个不同的现金状态。但是当你想在移动另一个状态的同时发出或退出一个状态时，它会变得复杂。</p><p>一旦你想分裂和合并状态，事情会变得更加困难。我们说，如果接受者对待彼此的状态是可以互相替代的，尽管它们并不完全相同。美元账单是可以替代的，因为即使一个人可能穿着/有点脏，另一个可能是新鲜的，他们仍然价值正好1美元。同样的，十美元的钞票几乎完全相当于十美元的钞票。另一方面，10美元和10英镑是不可替代的：如果你试图用10美元+ 10美元的票据支付20英镑的东西，你的交易将不被接受。</p><p>为了使这一切更容易，合同API提供了一个组的概念。一组是一组输入状态和输出状态，应该一起检查有效性。</p><p>考虑以下简化的货币交易交易：</p><ul><li>输入：Alice拥有12,000美元（A）</li><li>输入：Alice拥有3,000美元（A）</li><li>输入：Bob拥有10,000英镑（B）</li><li>输出：爱丽丝拥有的10,000英镑（B）</li><li>输出：Bob拥有15,000美元（A）</li></ul><p>在这笔交易中，爱丽丝和鲍勃以10,000英镑交易15,000美元。爱丽丝以两种不同的投入形式出钱，例如因为她收到了两笔款项中的美元。输入和输出金额确实平衡，但现金智能合约必须单独考虑英镑和美元，因为它们不可替代：它们不能合并在一起。所以我们有两个组：A和B.</p><p><code>LedgerTransaction.groupStates</code>方法为我们处理这个逻辑：首先，它只选择给定类型的状态（因为交易可能包括其他类型的状态，例如表示债券所有权的状态，或者多信号状态），然后它需要一个函数将状态映射到分组key。共享相同密钥的所有状态都组合在一起。在上述现金示例的情况下，分组key将是货币。</p><p>在这种合约中，我们不希望CP可以替换：合并和拆分（在我们的例子中）是不允许的。所以我们只使用状态的副本减去所有者字段作为分组键。</p><p>以下是一些代码示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type of groups is List&lt;InOutGroup&lt;State, Pair&lt;PartyReference, Currency&gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">val</span> groups = tx.groupStates &#123; it: Cash.State -&gt; it.amount.token &#125;</span><br><span class="line">  <span class="keyword">for</span> ((inputs, outputs, key) <span class="keyword">in</span> groups) &#123;</span><br><span class="line">      <span class="comment">// Either inputs or outputs could be empty.</span></span><br><span class="line">      <span class="keyword">val</span> (deposit, currency) = key</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>groupStates</code>调用使用提供的功能来计算“分组键”。所有具有相同分组键的状态都放在同一组中。分组键可以是实现equals / hashCode的任何内容，但它总是不应在输入和输出之间改变的字段的集合。在上面的例子中，我们选择了我们想要的字段并将它们打包成一个<code>Pair</code>。它返回一个列表<code>InOutGroup</code>，它只是输入，输出和用于定义组的密钥的持有者。在Kotlin版本中，我们使用解构来解压缩这些数据，以便方便地访问输入，输出，存款数据和货币。</p><p>这些规则可以应用于输入和输出，就好像它是单个交易一样。一个组可能有零输入或零输出：当将资产发放到分类帐或删除它们时可能会发生这种情况。</p><p>在这个例子中，我们采用不同的方式，并使用状态类本身作为聚合器。我们只是删除允许更改的字段，使分组键成为“不是那样的一切”：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> groups = tx.groupStates(State::withoutOwner)</span><br></pre></td></tr></table></figure><p>对于有许多字段必须保持不变且只有一两个真正可变的字段的大型状态来说，通过这种方式做事通常比专门命名每个必须保持不变的字段更容易。<code>withoutOwner</code>这里的函数只是返回对象的一个​​副本，但是将<code>owner</code>字段设置为<code>NullPublicKey</code>，这只是全零的公钥。这是无效和无用的，但没关系，因为我们所做的只是防止字段在equals和hashCode中出现问题。</p><h2 id="检查要求"><a href="#检查要求" class="headerlink" title="检查要求"></a>检查要求</h2><p>在提取命令和组之后，我们遍历每个组并验证它是否满足所需的业务逻辑。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> timeWindow: TimeWindow? = tx.timeWindow</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((inputs, outputs, _) <span class="keyword">in</span> groups) &#123;</span><br><span class="line">    <span class="keyword">when</span> (command.value) &#123;</span><br><span class="line">        <span class="keyword">is</span> Commands.Move -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> input = inputs.single()</span><br><span class="line">            requireThat &#123;</span><br><span class="line">                <span class="string">"the transaction is signed by the owner of the CP"</span> using (input.owner.owningKey <span class="keyword">in</span> command.signers)</span><br><span class="line">                <span class="string">"the state is propagated"</span> using (outputs.size == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// Don't need to check anything else, as if outputs.size == 1 then the output is equal to</span></span><br><span class="line">                <span class="comment">// the input ignoring the owner field due to the grouping.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">is</span> Commands.Redeem -&gt; &#123;</span><br><span class="line">            <span class="comment">// Redemption of the paper requires movement of on-ledger cash.</span></span><br><span class="line">            <span class="keyword">val</span> input = inputs.single()</span><br><span class="line">            <span class="keyword">val</span> received = tx.outputs.map &#123; it.<span class="keyword">data</span> &#125;.sumCashBy(input.owner)</span><br><span class="line">            <span class="keyword">val</span> time = timeWindow?.fromTime ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Redemptions must be timestamped"</span>)</span><br><span class="line">            requireThat &#123;</span><br><span class="line">                <span class="string">"the paper must have matured"</span> using (time &gt;= input.maturityDate)</span><br><span class="line">                <span class="string">"the received amount equals the face value"</span> using (received == input.faceValue)</span><br><span class="line">                <span class="string">"the paper must be destroyed"</span> using outputs.isEmpty()</span><br><span class="line">                <span class="string">"the transaction is signed by the owner of the CP"</span> using (input.owner.owningKey <span class="keyword">in</span> command.signers)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">is</span> Commands.Issue -&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> output = outputs.single()</span><br><span class="line">            <span class="keyword">val</span> time = timeWindow?.untilTime ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Issuances must be timestamped"</span>)</span><br><span class="line">            requireThat &#123;</span><br><span class="line">                <span class="comment">// Don't allow people to issue commercial paper under other entities identities.</span></span><br><span class="line">                <span class="string">"output states are issued by a command signer"</span> using (output.issuance.party.owningKey <span class="keyword">in</span> command.signers)</span><br><span class="line">                <span class="string">"output values sum to more than the inputs"</span> using (output.faceValue.quantity &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="string">"the maturity date is not in the past"</span> using (time &lt; output.maturityDate)</span><br><span class="line">                <span class="comment">// Don't allow an existing CP state to be replaced by this issuance.</span></span><br><span class="line">                <span class="string">"can't reissue an existing state"</span> using inputs.isEmpty()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unrecognised command"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个循环是合约的核心逻辑。</p><p>第一行只是简单地从交易中获取时间窗口。在交易中设置时间窗口是可选的，所以在这里可能会丢失时间。我们稍后检查它是否为空。</p><p><b style="color:#00f">警告： 在Kotlin版本中，只要我们先与交易时间进行比较，编译器就会验证我们是否忘记检查是否缺失。不幸的是，由于需要流畅的Java互操作性，如果我们编写<code>someDate &gt; time</code>，它不会发生这种检查。所以最好总是先写<code>time &lt; someDate</code>交易时间窗口。</b></p><p>接下来，根据命令对象的类型，我们选取​​三条路径中的一条路径。</p><h3 id="如果该命令是“Move”命令："><a href="#如果该命令是“Move”命令：" class="headerlink" title="如果该命令是“Move”命令："></a>如果该命令是“Move”命令：</h3><p>第一行（Java中的前三行）强制要求该组中有一张商业票据。我们不允许多个单位的CP分拆或合并，即使它们属于同一个所有者。<code>single()</code>方法是由Kotlin标准库定义的静态扩展方法：给定一个列表，如果列表大小不是1，则抛出异常，否则返回该列表中的单个项目。在Java中，这看起来像许多<code>FooUtils</code>类型单例类熟悉的类型的常规静态方法，我们在这里静态地导入它。在Kotlin中，它显示为可以在任何JDK列表上调用的方法。语法略有不同，但在幕后，代码编译为相同的字节码。</p><p>接下来，我们检查交易是否被标记为商业票据当前所有者的公钥签署。由于该平台已经在合同开始执行之前验证了所有数字签名，因此我们所要做的就是验证所有者的公钥是签署交易的密钥之一。Java代码很简单：我们只是使用<code>Preconditions.checkStateGuava</code> 的方法。Kotlin版本看起来有点奇怪：我们有一个<code>requireThat</code>构造，看起来像它构建在语言中。实际上需要这是平台合同API提供的普通功能。Kotlin支持创建特定于域的语言 通过语言的几个特征的交集，我们在这里使用它来支持需求的自然列表。要查看它编译的内容，请查看Java版本。<code>requireThat</code>中的每个<code>&quot;string&quot; using (expression)</code>语句都会变成断言，表明给定的表达式为真， 并且抛出包含该字符串（如果没有）的断言的<code>IllegalArgumentException</code>异常。这只是写出定期断言的另一种方式，但将英语要求放在前面和中心。</p><p>接下来，我们简单地验证输出状态是否存在：移动不允许从分类账中删除CP。分组逻辑已经确保细节相同并且没有被更改，除了所有者的公钥之外。</p><h3 id="如果该命令是“Redeem”命令，则需求更为复杂："><a href="#如果该命令是“Redeem”命令，则需求更为复杂：" class="headerlink" title="如果该命令是“Redeem”命令，则需求更为复杂："></a>如果该命令是“Redeem”命令，则需求更为复杂：</h3><ol><li>我们仍检查是否有CP输入状态。</li><li>我们希望看到CP的面值正在作为针对某一方的现金债权，即CP的发行人真正偿还了面值。</li><li>交易必须在到期日之后进行。</li><li>商业票据（paper）不得通过此交易进行传播：它必须由无输出状态的群组删除。这可以防止相同的CP被认为可以多次兑换。</li></ol><p>为了计算现金流动的多少，我们使用<code>sumCashBy</code>效用函数。再一次，这是一个扩展函数，所以在Kotlin代码中，即使JDK没有提供这种方法，它看起来好像是一种<code>List&lt;Cash.State&gt;</code>类型的方法。在Java中，我们看到它的真实性质：它实际上是一个名为<code>CashKt.sumCashBy</code>的静态方法。该方法只返回一个<code>Amount</code>对象，该对象包含该给定公钥所拥有的交易输出中所有现金状态的总和，或者如果没有这样的状态则抛出异常或如果在产出中有不同的货币代表！所以我们可以看到，这个合约对赎回交易的结构施加了限制：您不允许在CP不涉及的同一交易中移动货币。如果它是一个真正的限制，这个限制可以通过更好的API来解决。</p><h3 id="最后，我们支持一个Issue命令，在分类账上创建商业票据的新实例。"><a href="#最后，我们支持一个Issue命令，在分类账上创建商业票据的新实例。" class="headerlink" title="最后，我们支持一个Issue命令，在分类账上创建商业票据的新实例。"></a>最后，我们支持一个<code>Issue</code>命令，在分类账上创建商业票据的新实例。</h3><p>它同样在发布时实施各种不变量，例如，必须有一个输出CP状态。</p><p>这份合同很简单，并没有实现真正的商业纸张生命周期管理计划所能实现的所有业务逻辑。例如，没有逻辑需要发行人签名进行赎回：假设与赎回同时发生的任何货币转移足够好。也许这应该是收紧的。同样，如果发行人已经破产，如果发生争议等，没有逻辑处理会发生什么情况。</p><p>随着原型的发展，将会探索这些要求并更新本教程以反映合同API的改进。</p><h2 id="如何测试你的合同"><a href="#如何测试你的合同" class="headerlink" title="如何测试你的合同"></a>如何测试你的合同</h2><p>当然，单元测试你的新业务逻辑块是非常重要的，以确保它的行为像你期望的那样。由于合约代码只是一个常规的Java函数，因此您可以用通常的方式手工完全写出逻辑。但是这样做会很不方便，然后你会厌倦写作测试，那很糟糕：你可能会想要跳过一些。</p><p>为了使合同测试更加方便Corda为Kotlin和Java提供了类似于语言的API，使您可以轻松构建交易链并验证它们是通过验证还是失败并显示特定的错误消息。</p><p>使用该领域特定语言测试合同在单独的教程，<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL3R1dG9yaWFsLXRlc3QtZHNsLmh0bWw=" title="https://docs.corda.net/head/tutorial-test-dsl.html">编写合同测试<i class="fa fa-external-link"></i></span>中有介绍。</p><h2 id="将生成API添加到您的合同"><a href="#将生成API添加到您的合同" class="headerlink" title="将生成API添加到您的合同"></a>将生成API添加到您的合同</h2><p>合同类必须提供验证功能，但他们也可以选择提供帮助功能来简化其使用。大多数合同提供的一个简单的函数类是生成函数，它可以创建或修改交易以执行某些操作（操作通常可以 1:1 映射到命令，但不一定如此）。</p><p>生成可能涉及复杂的逻辑。例如，现金合同有一个<code>generateSpend</code>方法，给定一组现金状态并选择一种方法将它们组合在一起以满足发送的金额。在我们正在使用的不可变状态模型中，账单（状态）只能被创建和删除，但从未被修改过。因此，当我们只有900美元和500美元需要将两种状态结合在一起时，发送1200美元，然后创建1200美元和200美元的两种新输出状态。后一种状态被称为变化，并且是任何使用比特币的人都应该熟悉的概念。</p><p>作为另一个例子，我们可以想象实现网络算法的代码可能会产生复杂的交易，这些交易必须由很多人签名。虽然这样的代码对于单个实用方法来说可能太大（它可能更像一个模块），但基本概念是相同的：使用复杂逻辑准备交易。</p><p>然而，对于我们的商业票据合同，可以用它来完成的事情非常简单。让我们从一个方法来结束发行过程：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateIssue</span><span class="params">(issuance: <span class="type">PartyAndReference</span>, faceValue: <span class="type">Amount</span>&lt;<span class="type">Issued</span>&lt;<span class="type">Currency</span>&gt;&gt;, maturityDate: <span class="type">Instant</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  notary: <span class="type">Party</span>)</span></span>: TransactionBuilder &#123;</span><br><span class="line">    <span class="keyword">val</span> state = State(issuance, issuance.party, faceValue, maturityDate)</span><br><span class="line">    <span class="keyword">val</span> stateAndContract = StateAndContract(state, CP_PROGRAM_ID)</span><br><span class="line">    <span class="keyword">return</span> TransactionBuilder(notary = notary).withItems(stateAndContract, Command(Commands.Issue(), issuance.party.owningKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们提及发行方（即调用方），并可能包含我们可能需要的任何内部簿记/参考号码。参考字段是放置（例如）连接键的理想场所。然后是票据的面值和到期日。它返回一个<code>TransactionBuilder</code>。<code>TransactionBuilder</code>是该平台提供的少数几个可变类之一。它允许您添加输入，输出和命令，并且可以在多个合同之间传递。</p><p>注意：生成方法理想情况下应该写成彼此合作，即它们应该将<code>TransactionBuilder</code>作为一个参数而不是返回，除非您确定将这种类型的交易与其他交易结合起来没有意义。在这种情况下，在做其他事情的同时发行CP只会带来不值得的复杂性，因此我们每次都会返回一个新对象：发行人应该发行CP（由他们自己），然后在一个单独的交易中出售。</p><p>我们定义的函数创建一个<code>CommercialPaper.State</code>对象，该对象通常只使用我们提供的参数，但它填充状态的所有者字段与发布方相同。</p><p>然后，我们将<code>CommercialPaper.State</code>对象与对<code>CommercialPaper</code>合同内部定义的合同的引用进行合并<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    const <span class="keyword">val</span> CP_PROGRAM_ID: ContractClassName = <span class="string">"net.corda.finance.contracts.CommercialPaper"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此值是合同的完全限定类名，它告诉Corda平台在哪里查找应该用于验证包含此合同类型的输出状态的交易的合约代码。通常，合约代码将作为附件包含在交易中（请参阅使用附件）。</p><p>返回的部分交易有一个<code>Command</code>对象作为参数。这是实现<code>CommandData</code>接口的任何对象的容器，以及预计要签署此交易的密钥列表。在这种情况下，签发要求签发方签字，所以我们把派对的钥匙放在那里。</p><p><code>TransactionBuilder</code>具有便利的<code>withItems</code>的方法，需要一个可变参数列表。你可以传入任何<code>StateAndRef</code>（输入），<code>StateAndContract</code>（输出）或<code>Command</code>对象，它会为你建立交易。</p><p>最后要注意的一件事是：我们要求调用者选择一个公证人来控制这个状态，并防止它被双重花费。您可以在公证文章中了解关于此主题的更多信息。</p><p>注意： 现在，不要担心如何挑选公证人。稍后会有更多基础设施为您自动执行此决定。</p><p>如何移动票据，即将所有权重新分配给其他人？<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateMove</span><span class="params">(tx: <span class="type">TransactionBuilder</span>, paper: <span class="type">StateAndRef</span>&lt;<span class="type">State</span>&gt;, newOwner: <span class="type">AbstractParty</span>)</span></span> &#123;</span><br><span class="line">    tx.addInputState(paper)</span><br><span class="line">    <span class="keyword">val</span> outputState = paper.state.<span class="keyword">data</span>.withNewOwner(newOwner).ownableState</span><br><span class="line">    tx.addOutputState(outputState, CP_PROGRAM_ID)</span><br><span class="line">    tx.addCommand(Command(Commands.Move(), paper.state.<span class="keyword">data</span>.owner.owningKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里，该方法需要预先存在<code>TransactionBuilder</code>并添加到该方法中。这是正确的，因为通常情况下，您会希望将原子CP(商业票据 Commercial Paper)的销售与某些其他资产（如现金）的移动结合起来。所以这两种生成方法都应该在同一个交易上运行。您可以在商业票据合同的单元测试中看到这样的例子。</p><p>票据是作为一个<code>StateAndRef&lt;CommercialPaper.State&gt;</code>对象给予我们的。这听起来就像是一个小对象，它有一个状态对象（副本），还有一个<code>(txhash, index)</code>表示这个状态在分类帐上的位置。</p><p>我们将现有票据状态添加为输入，将所有者字段调整为输出的相同票据状态，最后添加具有旧所有者公钥的移动命令：这是强制当前所有者签名出现在交易中的原因，这是合同中检查的内容。</p><p>最后，我们可以做到赎回。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(InsufficientBalanceException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">generateRedeem</span><span class="params">(tx: <span class="type">TransactionBuilder</span>, paper: <span class="type">StateAndRef</span>&lt;<span class="type">State</span>&gt;, services: <span class="type">ServiceHub</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Add the cash movement using the states in our vault.</span></span><br><span class="line">    Cash.generateSpend(</span><br><span class="line">            services = services,</span><br><span class="line">            tx = tx,</span><br><span class="line">            amount = paper.state.<span class="keyword">data</span>.faceValue.withoutIssuer(),</span><br><span class="line">            ourIdentity = services.myInfo.singleIdentityAndCert(),</span><br><span class="line">            to = paper.state.<span class="keyword">data</span>.owner</span><br><span class="line">    )</span><br><span class="line">    tx.addInputState(paper)</span><br><span class="line">    tx.addCommand(Command(Commands.Redeem(), paper.state.<span class="keyword">data</span>.owner.owningKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里我们可以看到一个组合合约的例子。当所有者希望赎回商业票据时，发行人（即调用者）必须从其vault中收取现金，并将面值发送给票据所有人。</p><p>注意：这份合同没有明确的轮转概念。</p><p>该库是可以从Bitcoin和ethereum熟悉的概念。它只是一组由调用方拥有的状态（如现金）。在这里，我们使用保险库（Vault）来更新我们交易的部分交易，从商业票据发行人到当前所有者的现金流动。如果我们的Vault中没有足够的现金，则会抛出异常。然后，我们将票据本身作为输入添加，但不是输出（因为我们希望将其从分类帐中移除）。最后，我们添加应由商业票据所有者签署的兑换命令。</p><p>警告：我们传递给<code>Cash.generateSpend</code>函数的数量必须首先处理<code>withoutIssuer</code>。这反映了我们处理发行人约束的方式仍在演变的事实; 商业票据合同要求以特定方（例如中央银行或发行人自己的银行）发行的货币形式支付。但是，保险库(Vault)希望利用任何发行人的现金状态来组合花费交易，因此我们必须在此剥离它。这表示设计不匹配，我们将在未来的版本中使用更完整的方式来表达发行者约束。</p><p><code>TransactionBuilder</code>本身并不准备随时使用，所以首先，我们必须将其转换为网络认可的东西。最重要的下一步是参与实体签署它。通常，启动流程将<code>SignedTransaction</code>通过调用<code>serviceHub.toSignedTransaction</code>方法创建一个部分签名的初始化。然后冻结<code>SignedTransaction</code>可以通过流程传递给其他节点，这些可以使用<code>serviceHub.createSignature</code>签名和分发。在<code>CollectSignaturesFlow</code>提供了一个这个过程的通用实现，可以作为<code>subFlow</code>使用。</p><p>您可以通过检查商业票据单元测试来了解交易流程构建的不同阶段。</p><h2 id="如何构建和传播多方交易"><a href="#如何构建和传播多方交易" class="headerlink" title="如何构建和传播多方交易"></a>如何构建和传播多方交易</h2><p>好的，现在我们知道如何定义分类账的规则，并且我们知道如何构建满足这些规则的交易……并且如果我们所做的只是维护我们自己的数据就足够了。但我们不是：Corda是关于保持许多不同的方面彼此同步。</p><p>在经典的区块链系统中，所有数据都传输给每个人，如果您想要做一些奇特的事情，比如多方交易，那么您就是自己的。在Corda数据只传输给有需要的人，多方交易是一种生活方式，所以我们为管理他们提供了很多支持。</p><p>您可以了解交易如何在同级之间移动，并通过单独的教程“<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2Zsb3ctc3RhdGUtbWFjaGluZXMuaHRtbA==" title="https://docs.corda.net/head/flow-state-machines.html">编写流程<i class="fa fa-external-link"></i></span>”中的构建签名公证-广播流程进行。</p><h2 id="非资产导向的智能合约"><a href="#非资产导向的智能合约" class="headerlink" title="非资产导向的智能合约"></a>非资产导向的智能合约</h2><p>尽管本教程介绍了如何实施自有资产，但并不要求状态和代码合同 必须关心资产的所有权。把状态视为代表有关世界的有用事实，并且（代码）合约是强加关于事实如何结合以产生新事实的逻辑关​​系最好。<b style="color:#00f">或者，您可以想象，状态就像关系数据库中的行一样，合约就像存储过程和关系约束。</b></p><p>在编写处理交易类实体而不是资产类实体的合约时，您可能希望参考“<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2NvbnRyYWN0LWlycy5odG1s" title="https://docs.corda.net/head/contract-irs.html">利率掉期交易<i class="fa fa-external-link"></i></span>”和随附的源代码。虽然所有概念都是相同的，但交易通常不是可拆分的或可合并的，因此您不必担心很多关于状态分组的问题。注：关于利率掉期交易可以参见<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg4JUE5JUU3JThFJTg3JUU2JThFJTg5JUU2JTlDJTlGJUU0JUJBJUE0JUU2JTk4JTkz" title="https://zh.wikipedia.org/wiki/%E5%88%A9%E7%8E%87%E6%8E%89%E6%9C%9F%E4%BA%A4%E6%98%93">维基百科<i class="fa fa-external-link"></i></span>，缩写IRS。</p><h2 id="在特定的时间让事情发生"><a href="#在特定的时间让事情发生" class="headerlink" title="在特定的时间让事情发生"></a>在特定的时间让事情发生</h2><p>如果您可以对节点进行编程，使其在成熟后立即自动兑换商业票据，那将会很不错。Corda为各状态宣传将来发生的预定事件提供了一种途径。虽然这些信息在默认情况下被忽略，但如果相应的Cordapp已在您的节点中安装并处于活动状态，并且您的保管库认为该状态是相关的（例如因为您拥有该状态），则节点可自动开始创建交易的过程并贯穿整个生命周期。您可以在文章“ <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2V2ZW50LXNjaGVkdWxpbmcuaHRtbA==" title="https://docs.corda.net/head/event-scheduling.html">事件日程安排<i class="fa fa-external-link"></i></span> ”中了解更多。</p><h2 id="产权负担"><a href="#产权负担" class="headerlink" title="产权负担"></a>产权负担</h2><p>所有合同状态可能最多由另一个状态担保，我们称之为产权负担。</p><p>如果存在这种负债状态，则会强制对设保状态进行额外的控制，因为在交易执行期间也会验证产权状态合同。例如，合同状态可能会受到时间锁定合同状态的影响; 那么状态只能在一个交易中进行处理，以验证在保留时间锁定中指定的时间已过。</p><p>设保状态指的是按索引产生的负担，而所提到的负债状态是创造担保状态的同一交易中特定位置上的输出状态。请注意，正在使用的已设置状态必须在同一交易中消耗其负担，否则交易无效。</p><p>在<code>ContractState</code>接口中，产权负担参考是可选的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> encumbrance: <span class="built_in">Int</span>? <span class="keyword">get</span>() = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>上面提到的时间锁定协议可以非常简单地实现：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTimeLock</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> time = tx.timeWindow?.untilTime ?: <span class="keyword">throw</span> IllegalStateException(...)</span><br><span class="line">        ...</span><br><span class="line">        requireThat &#123;</span><br><span class="line">            <span class="string">"the time specified in the time-lock has passed"</span> <span class="keyword">by</span></span><br><span class="line">                    (time &gt;= tx.inputs.filterIsInstance&lt;TestTimeLock.State&gt;().single().validFrom)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们可以设置一个设防状态：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> encumberedState = Cash.State(amount = <span class="number">1000.</span>DOLLARS `issued <span class="keyword">by</span>` defaultIssuer, owner = DUMMY_PUBKEY_1, encumbrance = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> fourPmTimelock = TestTimeLock.State(Instant.parse(<span class="string">"2015-04-17T16:00:00.00Z"</span>))</span><br></pre></td></tr></table></figure><p></p><p>当我们构造一个产生担保状态的交易时，我们必须将该负债放置在该交易的相应输出位置。当我们随后使用该设防状态时，同样的保留状态必须在输入状态组中的某处可用。</p><p>将来，我们会考虑立约的概念。这是产权负担与担保状态每次迭代并行的地方。例如，现金状态可能会受到居籍负担的影响，该现金状况会检查现金状态正在转移到的所有者身份的住所，以便维护制裁审查条例，并防止现金支付给住在如朝鲜。在这种情况下，产权负担应该永久地附加于由此产生的所有未来现金状态。</p><p>我们也会考虑标记能够成为产权负担的状态。这将防止状态无意中将其用作负担。例如，上面的时间锁定可以作为一种负担，但是能够用另一个锁定现金状态是没有意义的。</p><h1 id="撰写合同测试"><a href="#撰写合同测试" class="headerlink" title="撰写合同测试"></a>撰写合同测试</h1><p>本教程将带您完成使用Kotlin和Java编写合同测试所需的步骤。</p><p>测试DSL允许用交易相互引用来定义分类账的一部分，以及验证其正确性的方法。</p><h2 id="测试单个事务"><a href="#测试单个事务" class="headerlink" title="测试单个事务"></a>测试单个事务</h2><p>我们从空账本开始：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommercialPaperTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">emptyLedger</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ledger &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>DSL关键字<code>ledger</code>需要一个可以建立多个交易的闭包，并且可以验证它们的整体正确性。分类账实际上是一个没有预先存在的交易或服务的新鲜世界。</p><p>我们将从定义返回<code>CommercialPaper</code>状态的帮助函数开始：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bigCorp = TestIdentity((CordaX500Name(<span class="string">"BigCorp"</span>, <span class="string">"New York"</span>, <span class="string">"GB"</span>)))</span><br></pre></td></tr></table></figure><p></p><p>这是MEGA_CORP发行的一张面值为1000美元的CommercialPaper，并在7日内到期。</p><p>我们添加一个CommercialPaper交易：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPDoesntCompile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledger &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CommercialPaper.CP_PROGRAM_ID) &#123; inState &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们可以使用transaction原语向账本添加交易。交易可以通过指定<code>input</code>-s，<code>output</code>-s，<code>command</code>-s和<code>attachment</code>-s 来定义。</p><p>上述<code>input</code>调用有点特别，交易实际上不包含输入状态，只是引用其他交易的输出状态。上面的<code>input</code>调用在分类账中创建了一个虚拟交易（不会被验证），它会输出指定的状态，并引用来自该交易的虚拟交易。</p><p>上面的代码不能编译：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">29</span>, <span class="number">17</span>) Kotlin: Type mismatch: inferred type <span class="keyword">is</span> <span class="built_in">Unit</span> but EnforceVerifyOrFail was expected</span><br></pre></td></tr></table></figure><p></p><p>这是故意的：DSL迫使我们在<code>transaction</code>最后一行指定<code>verifies()</code>或者：<code><code>fails with</code>(“some text”)</code><br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example test will fail with this exception.</span></span><br><span class="line"><span class="meta">@Test(expected = IllegalStateException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们来看看失败的交易。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example test will fail with this exception.</span></span><br><span class="line"><span class="meta">@Test(expected = TransactionVerificationException.ContractRejection::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPMove</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行时，该代码会产生以下错误：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.corda.core.contracts.TransactionVerificationException$ContractRejection: java.lang.IllegalArgumentException: Failed requirement: the state <span class="keyword">is</span> propagated</span><br></pre></td></tr></table></figure><p></p><p>交易验证失败，因为我们想移动票据，但没有指定输出 - 但状态应该传播。但是，我们可以通过更改<code>verifies()</code>为<code><code>fails with</code>(“the state is propagated”)</code>以下内容来指定这是预期行为：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPMoveFails</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            `fails with`(<span class="string">"the state is propagated"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们可以继续构建交易，直到<code>verifies</code>：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simpleCPMoveFailureAndSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> inState = getPaper()</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(CP_PROGRAM_ID, inState)</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            `fails with`(<span class="string">"the state is propagated"</span>)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, inState.withOwner(alice.party))</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>output</code>指定我们希望将输入状态传输到<code>ALICE</code>并且<code>command</code>添加由输入状态的当前所有者签名的<code>Move</code>命令本身<code>MEGA_CORP_PUBKEY</code>。</p><p>我们构建了完整的签名商业票据交易并对其进行验证。请注意我们遗漏了<code>fails with</code>这一行 - 这很好，失败将在部分构建的交易中进行测试。</p><p>如果我们想测试错误的Party签署交易时会发生什么，我们该怎么办？如果我们简单地添加<code>command</code>, 它将永久破坏交易…输入<code>tweak</code>：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `simple issuance with tweak`<span class="params">()</span></span> &#123;</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        transaction &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper()) <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            tweak &#123;</span><br><span class="line">                <span class="comment">// The wrong pubkey.</span></span><br><span class="line">                command(bigCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">                timeWindow(TEST_TX_TIME)</span><br><span class="line">                `fails with`(<span class="string">"output states are issued by a command signer"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>tweak</code>创建交易的本地副本。这使得本地“破坏”交易成为可能，同时不修改原来的交易，允许测试不同的错误情况。</p><p>我们现在有一个测试单个交易的简单测试。这已经很有用了，事实上，以这种方式测试单个交易是非常普遍的。甚至还有一个简单的顶级<code>transaction</code>元，它可以用一个交易创建一个分类帐：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `simple issuance with tweak and top level transaction`<span class="params">()</span></span> &#123;</span><br><span class="line">    ledgerServices.transaction(dummyNotary.party) &#123;</span><br><span class="line">        output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper()) <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        attachments(CP_PROGRAM_ID)</span><br><span class="line">        tweak &#123;</span><br><span class="line">            <span class="comment">// The wrong pubkey.</span></span><br><span class="line">            command(bigCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            `fails with`(<span class="string">"output states are issued by a command signer"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">        timeWindow(TEST_TX_TIME)</span><br><span class="line">        verifies()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="链接交易"><a href="#链接交易" class="headerlink" title="链接交易"></a>链接交易</h2><p>现在我们知道如何定义单个交易了，我们来看看如何定义它们的链：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `chain commercial paper`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> issuer = megaCorp.party.ref(<span class="number">123</span>)</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        unverifiedTransaction &#123;</span><br><span class="line">            attachments(Cash.PROGRAM_ID)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"alice's $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy alice.party)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        transaction(<span class="string">"Issuance"</span>) &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        transaction(<span class="string">"Trade"</span>) &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            input(<span class="string">"alice's $900"</span>)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"borrowed $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy megaCorp.party)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</span><br><span class="line">            command(alice.publicKey, Cash.Commands.Move())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个例子中，我们声明<code>ALICE</code>有900美元，但我们不关心从哪里开始。为此我们可以使用 <code>unverifiedTransaction</code>。请注意我们不需要指定<code>verifies()</code>。</p><p>请注意，我们使用<code>&quot;alice&#39;s $900&quot;</code>标记了输出，同样在命名为<code>&quot;Issuance&quot;</code>的交易中，我们使用<code>&quot;paper&quot;</code>标记了一个商业票据。现在我们可以随后在其他交易中引用它们，例如通过<code>input(&quot;alice&#39;s $900&quot;)</code>或<code>&quot;paper&quot;.output&lt;ICommercialPaperState&gt;()</code>。</p><p>最后一笔命名为<code>&quot;Trade&quot;</code>的交易举例说明了向爱丽丝卖出900美元<code>CommercialPaper</code>的简单事实，仅仅在7天后以10％的利率面值减价100美元。</p><p>我们也可以测试整个分类帐调用<code>verifies()</code>和<code>fails()</code>分类账级别。为此，我们创建一个使用相同输入两次的简单示例：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `chain commercial paper double spend`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> issuer = megaCorp.party.ref(<span class="number">123</span>)</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        unverifiedTransaction &#123;</span><br><span class="line">            attachments(Cash.PROGRAM_ID)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"alice's $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy alice.party)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        transaction(<span class="string">"Issuance"</span>) &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction(<span class="string">"Trade"</span>) &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            input(<span class="string">"alice's $900"</span>)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"borrowed $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy megaCorp.party)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</span><br><span class="line">            command(alice.publicKey, Cash.Commands.Move())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            <span class="comment">// We moved a paper to another pubkey.</span></span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"bob's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(bob.party))</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fails()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>交易单独<code>verifies()</code>，但状态花了两次！这就是为什么我们需要全球总账验证（<code>fails()</code>最后）。和前面的例子一样，我们可以用<code>tweak</code>来创建整个分类账的本地副本：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `chain commercial tweak`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> issuer = megaCorp.party.ref(<span class="number">123</span>)</span><br><span class="line">    ledgerServices.ledger(dummyNotary.party) &#123;</span><br><span class="line">        unverifiedTransaction &#123;</span><br><span class="line">            attachments(Cash.PROGRAM_ID)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"alice's $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy alice.party)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some CP is issued onto the ledger by MegaCorp.</span></span><br><span class="line">        transaction(<span class="string">"Issuance"</span>) &#123;</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"paper"</span>, getPaper())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Issue())</span><br><span class="line">            attachments(CP_PROGRAM_ID)</span><br><span class="line">            timeWindow(TEST_TX_TIME)</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction(<span class="string">"Trade"</span>) &#123;</span><br><span class="line">            input(<span class="string">"paper"</span>)</span><br><span class="line">            input(<span class="string">"alice's $900"</span>)</span><br><span class="line">            output(Cash.PROGRAM_ID, <span class="string">"borrowed $900"</span>, <span class="number">900.</span>DOLLARS.CASH issuedBy issuer ownedBy megaCorp.party)</span><br><span class="line">            output(CP_PROGRAM_ID, <span class="string">"alice's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(alice.party))</span><br><span class="line">            command(alice.publicKey, Cash.Commands.Move())</span><br><span class="line">            command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">            verifies()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tweak &#123;</span><br><span class="line">            transaction &#123;</span><br><span class="line">                input(<span class="string">"paper"</span>)</span><br><span class="line">                <span class="comment">// We moved a paper to another pubkey.</span></span><br><span class="line">                output(CP_PROGRAM_ID, <span class="string">"bob's paper"</span>, <span class="string">"paper"</span>.output&lt;ICommercialPaperState&gt;().withOwner(bob.party))</span><br><span class="line">                command(megaCorp.publicKey, CommercialPaper.Commands.Move())</span><br><span class="line">                verifies()</span><br><span class="line">            &#125;</span><br><span class="line">            fails()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        verifies()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="升级合同"><a href="#升级合同" class="headerlink" title="升级合同"></a>升级合同</h1><p><b style="color:#00f">虽然在开发合同代码时需要谨慎对待，但不可避免地需要进行升级以修复错误（无论是在设计还是实施中）。升级可能涉及将合同代码的一个版本替换为另一个版本或更改为了解如何迁移现有状态对象的不同合同。当状态对象作为输出添加到交易中时，它们通过<code>StateAndContract</code>类型链接到它们打算提供的合同代码 。改变一个状态的合同只需要一个<code>ContractClassName</code>换另一个。</b></p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>以下是合约升级的工作流程：</p><ol><li>银行A和B在非平台上进行交易谈判</li><li>银行A和B执行流程以使用合约X构建代表交易的状态对象，并将其包含在交易中（然后签署并发送到共识服务）</li><li>时间流逝</li><li>合同X的开发人员发现了合同代码中的一个错误，并且发布了一个新版本，合同Y.开发人员然后会通知所有现有用户（例如通过邮件列表或CorDapp Store），以阻止他们的节点使用合同发布更多状态X</li><li>银行A和B通过标准变更控制流程审查新合同，并确定他们同意升级的合同状态（他们可能会决定不升级某些合同状态，因为这些合同状态可能需要履行其他义务合同）</li><li>银行A和B指示他们的Corda节点（通过RPC）愿意使用约定X升级状态对象以使用约定的升级路径来表示具有合同Y的对象</li><li>其中一方（Initiator）启动一个流程，用引用合同Y的新状态对象来替换引用合同X的状态对象</li><li>提议的交易（the Proposal），以旧状态作为输入并且重新发布状态作为输出，被创建并且用节点的私钥签名</li><li>该Initiator节点将拟议中的交易，与它提出的新合同升级路径的细节一起，给状态对象的所有参与者</li><li>每个对方（Acceptors）验证提案，相应地签署或拒绝状态重新发布，并将签名或拒绝通知发回给发起节点</li><li>如果从各方收到签名，则Initiator组装完整的签名交易并将其发送给公证处</li></ol><h2 id="授权升级"><a href="#授权升级" class="headerlink" title="授权升级"></a>授权升级</h2><p>每个正在升级合同的状态的参与者都必须指示他们的节点在升级发生之前同意升级。<code>ContractUpgradeFlow</code>用于管理授权过程。每个节点管理员都可以使用RPC 为相关状态触发一个<code>Authorise</code>或一个<code>Deauthorise</code>流。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authorise</span></span>(</span><br><span class="line">        <span class="keyword">val</span> stateAndRef: StateAndRef&lt;*&gt;,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> upgradedContractClass: Class&lt;<span class="keyword">out</span> UpgradedContract&lt;*, *&gt;&gt;</span><br><span class="line">) : FlowLogic&lt;<span class="built_in">Void</span>?&gt;() &#123;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deauthorise</span></span>(<span class="keyword">val</span> stateRef: StateRef) : FlowLogic&lt;<span class="built_in">Void</span>?&gt;() &#123;</span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span>: <span class="built_in">Void</span>? &#123;</span><br></pre></td></tr></table></figure><h2 id="提议升级"><a href="#提议升级" class="headerlink" title="提议升级"></a>提议升级</h2><p>在各方授权合同升级之后，合同参与方之一可以通过触发<code>ContractUpgradeFlow.Initiate</code>流程启动升级流程。<code>Initiate</code>创建包括旧状态和更新状态的交易，并将其发送给每个参与者。每个参与者将验证交易，在其上创建签名，并将签名发送回发起人。一旦收集完所有签名，交易将会公证并保存到每个参与者的保险库中。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设银行A与银行B签订了一项协议，银行B由状态目标<code>DummyContractState</code>代表并受合约代码<code>DummyContract</code>的约束。合约交换几天后，合约代码的开发者发现了合约代码中的一个错误。</p><p>银行A和银行B决定将合同升级为<code>DummyContractV2</code>：</p><ol><li><p>开发人员创建一个<code>DummyContractV2</code>扩展<code>UpgradedContract</code>该类的新合同，以及一个<code>DummyContractV2.State</code>引用新合同的新状态对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyContractV2</span> : <span class="type">UpgradedContractWithLegacyConstraint</span>&lt;<span class="type">DummyContract.State, DummyContractV2.State</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        const <span class="keyword">val</span> PROGRAM_ID: ContractClassName = <span class="string">"net.corda.testing.contracts.DummyContractV2"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legacyContract: String = DummyContract::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">name</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> legacyContractConstraint: AttachmentConstraint = AlwaysAcceptAttachmentConstraint</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">val</span> magicNumber: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="keyword">val</span> owners: List&lt;AbstractParty&gt;) : ContractState &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> participants: List&lt;AbstractParty&gt; = owners</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Commands</span> : <span class="type">CommandData &#123;</span></span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Create</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Move</span> : <span class="type">TypeOnlyCommandData</span></span>(), Commands</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">upgrade</span><span class="params">(state: <span class="type">DummyContract</span>.<span class="type">State</span>)</span></span>: State &#123;</span><br><span class="line">        <span class="keyword">return</span> State(state.magicNumber, state.participants)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Other verifications.</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>银行A指示其节点接受合同升级到<code>DummyContractV2</code>合同状态。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rpcClient : CordaRPCClient = &lt;&lt; Bank A<span class="string">'s Corda RPC Client &gt;&gt;</span></span><br><span class="line"><span class="string">val rpcA = rpcClient.proxy()</span></span><br><span class="line"><span class="string">rpcA.startFlow(ContractUpgradeFlow.Authorise(&lt;&lt;StateAndRef of the contract state&gt;&gt;, DummyContractV2::class.java))</span></span><br></pre></td></tr></table></figure></li><li><p>银行B启动升级流程，该流程将向所有合同参与者发送升级提议。合同状态的每个参与者在签署并返回合同状态升级提议后，都将验证并同意升级。升级后的交易将按流量记录在每个参与者的节点中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rpcClient : CordaRPCClient = &lt;&lt; Bank B<span class="string">'s Corda RPC Client &gt;&gt;</span></span><br><span class="line"><span class="string">val rpcB = rpcClient.proxy()</span></span><br><span class="line"><span class="string">rpcB.startFlow(&#123; stateAndRef, upgrade -&gt; ContractUpgradeFlow(stateAndRef, upgrade) &#125;,</span></span><br><span class="line"><span class="string">    &lt;&lt;StateAndRef of the contract state&gt;&gt;,</span></span><br><span class="line"><span class="string">    DummyContractV2::class.java)</span></span><br></pre></td></tr></table></figure></li></ol><p>注意: 查看<code>ContractUpgradeFlowTest</code>更详细的代码示例。</p><h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><p>集成测试包括在本地引入节点并通过启动流程并检查其状态来测试它们的不变量。</p><p><b style="color:#00f">在本教程中，我们将展示三个节点 - Alice，Bob和公证人。Alice将向Bob发放现金，然后Bob将这笔现金返还给Alice。我们将看到如何在此期间测试一些简单的确定性和非确定性不变量。</b></p><p><b style="color:red">为了产生节点，我们将使用驱动程序DSL。这个DSL允许从代码启动节点进程。它管理网络map服务并在后台安全地关闭节点。</b></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">driver(DriverParameters(startNodesInProcess = <span class="keyword">true</span>,</span><br><span class="line">        extraCordappPackagesToScan = listOf(<span class="string">"net.corda.finance.contracts.asset"</span>))) &#123;</span><br><span class="line">    val aliceUser = User(<span class="string">"aliceUser"</span>, <span class="string">"testPassword1"</span>, permissions = setOf(</span><br><span class="line">            startFlow&lt;CashIssueFlow&gt;(),</span><br><span class="line">            startFlow&lt;CashPaymentFlow&gt;(),</span><br><span class="line">            invokeRpc(<span class="string">"vaultTrackBy"</span>),</span><br><span class="line">            invokeRpc(CordaRPCOps::notaryIdentities),</span><br><span class="line">            invokeRpc(CordaRPCOps::networkMapFeed)</span><br><span class="line">    ))</span><br><span class="line">    val bobUser = User(<span class="string">"bobUser"</span>, <span class="string">"testPassword2"</span>, permissions = setOf(</span><br><span class="line">            startFlow&lt;CashPaymentFlow&gt;(),</span><br><span class="line">            invokeRpc(<span class="string">"vaultTrackBy"</span>),</span><br><span class="line">            invokeRpc(CordaRPCOps::networkMapFeed)</span><br><span class="line">    ))</span><br><span class="line">    val (alice, bob) = listOf(</span><br><span class="line">            startNode(providedName = ALICE_NAME, rpcUsers = listOf(aliceUser)),</span><br><span class="line">            startNode(providedName = BOB_NAME, rpcUsers = listOf(bobUser))</span><br><span class="line">    ).transpose().getOrThrow()</span><br></pre></td></tr></table></figure><p>上面的代码启动三个节点：</p><ul><li>Alice，拥有用户权限来启动<code>CashIssueFlow</code>和 <code>CashPaymentFlow</code>流程。</li><li>Bob，只有拥有用户权限才能启动<code>CashPaymentFlow</code></li><li>公证人提供了一份<code>ValidatingNotaryService</code>。我们不会直接连接到公证人，所以没有必要提供<code>User</code></li></ul><p><code>startNode</code>函数一旦节点完全启动完成就返回<code>future</code>。这允许节点的启动是平行的。我们等待这些<code>futures</code>，因为我们需要返回的信息; 他们各自的<code>NodeHandles</code>s。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aliceClient = CordaRPCClient(alice.rpcAddress)</span><br><span class="line"><span class="keyword">val</span> aliceProxy = aliceClient.start(<span class="string">"aliceUser"</span>, <span class="string">"testPassword1"</span>).proxy</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bobClient = CordaRPCClient(bob.rpcAddress)</span><br><span class="line"><span class="keyword">val</span> bobProxy = bobClient.start(<span class="string">"bobUser"</span>, <span class="string">"testPassword2"</span>).proxy</span><br></pre></td></tr></table></figure><p></p><p>获得句柄后，我们等待双方向网络map注册，以确保我们没有网络map注册的竞争条件。接下来我们使用我们创建的测试用户从测试过程分别连接到Alice和Bob。然后我们建立RPC链接，使我们能够启动流程和查询状态。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bobVaultUpdates = bobProxy.vaultTrackBy&lt;Cash.State&gt;().updates</span><br><span class="line"><span class="keyword">val</span> aliceVaultUpdates = aliceProxy.vaultTrackBy&lt;Cash.State&gt;().updates</span><br></pre></td></tr></table></figure><p></p><p>我们会对Alice和Bob的保险库(Vault)发生更改感兴趣，因此我们会查询每个保险库(Vault)的更新流。</p><p>现在我们都已经建立起来了，我们终于可以获得一些现金行动了！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">val issueRef = OpaqueBytes.of(0)</span><br><span class="line">val notaryParty = aliceProxy.notaryIdentities().first()</span><br><span class="line">(1..10).map &#123; i -&gt;</span><br><span class="line">    aliceProxy.startFlow(::CashIssueFlow,</span><br><span class="line">            i.DOLLARS,</span><br><span class="line">            issueRef,</span><br><span class="line">            notaryParty</span><br><span class="line">    ).returnValue</span><br><span class="line">&#125;.transpose().getOrThrow()</span><br><span class="line">// We wait for all of the issuances to run before we start making payments</span><br><span class="line">(1..10).map &#123; i -&gt;</span><br><span class="line">    aliceProxy.startFlow(::CashPaymentFlow,</span><br><span class="line">            i.DOLLARS,</span><br><span class="line">            bob.nodeInfo.singleIdentity(),</span><br><span class="line">            true</span><br><span class="line">    ).returnValue</span><br><span class="line">&#125;.transpose().getOrThrow()</span><br><span class="line"></span><br><span class="line">bobVaultUpdates.expectEvents &#123;</span><br><span class="line">    parallel(</span><br><span class="line">            (1..10).map &#123; i -&gt;</span><br><span class="line">                expect(</span><br><span class="line">                        match = &#123; update: Vault.Update&lt;Cash.State&gt; -&gt;</span><br><span class="line">                            update.produced.first().state.data.amount.quantity == i * 100L</span><br><span class="line">                        &#125;</span><br><span class="line">                ) &#123; update -&gt;</span><br><span class="line">                    println(&quot;Bob vault update of $update&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第一个循环创建10个线程，每个线程在Alice节点上启动一个<code>CashFlow</code>流。我们指定我们要向鲍勃发放<code>i</code>美元，并将公证人设置为负责公证所创建状态的公证人。请注意，由于我们没有花费任何状态，只会在分类帐上创建新的状态，所以不会发生公证。</p><p>为了本教程的目的，我们从不同的线程开始流程，演示如何测试非确定性，这是<code>expectEvents</code>块的功能。</p><p>Expect DSL允许在事件流上检查排序约束。上面的代码指定我们期望10个更新以<code>bobVaultUpdates</code>未指定的顺序在流上发出（这是<code>parallel</code>构造的作用）。我们指定一个（否则可选）<code>match</code>谓词来标识我们感兴趣的特定更新，然后我们将打印这些更新。</p><p>如果我们运行迄今为止编写的代码，我们应该看到4个节点启动（<code>Alice</code>，<code>Bob</code>，<code>公证</code>和<code>一个隐含的网络map服务</code>），然后Bob的10个日志从Alice接收1,2，… 10美元，以某种未指定的顺序。</p><p>接下来，我们希望Bob将这笔现金退还给Alice。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    bobProxy.startFlow(::CashPaymentFlow, i.DOLLARS, alice.nodeInfo.singleIdentity()).returnValue.getOrThrow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aliceVaultUpdates.expectEvents &#123;</span><br><span class="line">    sequence(</span><br><span class="line">            (<span class="number">1.</span><span class="number">.10</span>).map &#123; i -&gt;</span><br><span class="line">                expect &#123; update: Vault.Update&lt;Cash.State&gt; -&gt;</span><br><span class="line">                    println(<span class="string">"Alice got vault update of <span class="variable">$update</span>"</span>)</span><br><span class="line">                    assertEquals(update.produced.first().state.<span class="keyword">data</span>.amount.quantity, i * <span class="number">100</span>L)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这一次，我们会按顺序进行。我们让Bob按顺序向Alice付10美元。我们确保一个在<code>CashFlow</code>已经等待完成<code>startFlow</code>的<code>returnValue</code>。</p><p>然后，我们再次使用Expect DSL，这次使用<code>sequence</code>用于测试按照我们预期的顺序到达的更新。</p><p>请注意，<code>parallel</code>和<code>sequence</code>可以被嵌套到彼此任意地来测试更复杂的场景。</p><p>这就是这些！我们看到了如何在本地启动几个corda节点，如何连接它们以及如何测试一些简单的关于<code>CashFlow</code>的不变量。</p><p><b style="color:red">要运行完整的测试，您可以从IntelliJ 打开<code>example-code/src/integration-test/kotlin/net/corda/docs/IntegrationTestingTutorial.kt</code> 并运行测试，或者使用gradle：</b><br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Run example-code integration tests</span><br><span class="line">./gradlew docs/source/example-code:integrationTest -i</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字证书基础知识</title>
      <link href="//%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>//%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>关于数字证书，一定会想起Https，其实Https是基于<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJhbnNwb3J0X0xheWVyX1NlY3VyaXR5" title="https://en.wikipedia.org/wiki/Transport_Layer_Security">SSL/TLS<i class="fa fa-external-link"></i></span>的。SSL/TLS其实不止可以用于HTTP，任何采用TCP协议的数据通信都可以采用SSL/TLS进行传输，比如FTP。只是就当前而言，SSL/TLS最为广泛的应用在于HTTPS。当然想起SSL，大家一定还会想起RSA，接着就是SSH了。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>这里需要提到公私钥的密码体制了，这个网上的资料有很多就不多说明了。</p><h2 id="关于HTTPS"><a href="#关于HTTPS" class="headerlink" title="关于HTTPS"></a>关于HTTPS</h2><p>其实客户机加密数据发送给服务器，由于只有服务器才有私钥，所以这个过程是没有任何问题的。但是反过来服务器加密数据发送给客户机，由于公钥是公开的这个过程就有问题了，因为大家都可以看到内容。</p><p>另外如果有人冒充服务器，让用户替换了自己的公钥，这样也会遭受中间人攻击。所以用户也需要验证公钥是不是相应服务器的公钥，所以就出现了数据证书。</p><p>服务器向客户端发送信息的时候要加上签名，还要加上数字证书，这样客户端既可以验证内容和公钥是否正确了。</p><p>以上的过程只是用于服务器和客户端约定以后的通信加密密串，一旦约定成功就可以使用对称加密进行后续的通信了。<br>如下：</p><ol><li>client -&gt; server: 你好，以后使用这个密串通信吧！（公钥加密）</li><li>server -&gt; client: 好的！（数字签名，证书）</li></ol><p>你看整个过程还是比较简洁的。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>经过上面的说明之后，我们来理解什么是数字证书。数字证书就是对网站生成的公钥进行签名的第三方服务机构。证书里面包含：</p><ul><li>Issuer (证书的发布机构)</li><li>Valid from , Valid to (证书的有效期)</li><li>Public key (公钥)</li><li>Subject (主题)： 这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 对于这里的证书来说，证书的所有者是Trustwave这个公司。</li><li>Signature algorithm (签名所使用的算法)</li><li>Thumbprint, Thumbprint algorithm (指纹以及指纹算法)</li></ul><p>当然这里我们不得不提到根证书，一般系统都是信任根证书，否则就不存在数字证书的合法性了。我们都知道CA机构是分层级的，包括根证书(Root Certificate)、中间证书(Intermediate Certificate)以及最底层的网站证书。其中根证书签署中间证书，中间证书在签署最底层的网站证书，由此组成一个证书链(Certificate Chain)。整个对证书的颁发、管理、认证组成了一整套基础设施——<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHVibGljX2tleV9pbmZyYXN0cnVjdHVyZQ==" title="https://en.wikipedia.org/wiki/Public_key_infrastructure">PKI<i class="fa fa-external-link"></i></span>。</p><p>其实这样的分层是通过公钥的嵌套签名实现的层级关系。</p><h2 id="关于如何发布证书"><a href="#关于如何发布证书" class="headerlink" title="关于如何发布证书"></a>关于如何发布证书</h2><p>使用java的keytool工具可以生成相应的公私钥，还可以向CA机构购买证书服务。当然我们也可以自建自己的证书机构，只是不会有人承认而已，而且还要用户将我们的证书放入操作系统的信任列表中，这样实现起来比较麻烦。这里就不做更多说明了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9kYXZlbmtpbi9wL2RpZ2l0YWwtY2VydGlmaWNhdGUuaHRtbA==" title="http://www.cnblogs.com/davenkin/p/digital-certificate.html">数字证书学习笔记<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTEvMDgvd2hhdF9pc19hX2RpZ2l0YWxfc2lnbmF0dXJlLmh0bWw=" title="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？<i class="fa fa-external-link"></i></span> 阮一峰的博客一般都是清晰好懂的。<br><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9KZWZmcmV5U3VuL2FyY2hpdmUvMjAxMC8wNi8yNC8xNjI3MjQ3Lmh0bWw=" title="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">数字证书原理<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字证书 </tag>
            
            <tag> CA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda教程 - hello world</title>
      <link href="//blockchain/corda/Corda%E6%95%99%E7%A8%8B-hello%20world.html"/>
      <url>//blockchain/corda/Corda%E6%95%99%E7%A8%8B-hello%20world.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>CorDapps是安装在一个或多个Corda节点上的插件，并使节点的所有者能够使节点执行一些新的过程 - 从发行债券工具到做餐馆预订。</p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>我们的CorDapp将对账单进行模拟。IOU–“IO（我们）（YO）U”的简称 - 记录了一个人欠给他人一笔钱的事实。很明显，这是我们只想在贷款人和借款人之间需要知道的基础上进行沟通的敏感信息。幸运的是，这是Corda擅长的领域之一。由于区块链平台的规范，Corda可以轻松地让一小组人员就共享事实达成一致，而无需与网络上的其他人分享这一事实。</p><p>为了提供任何有用的功能，我们的CorDapp至少需要两个东西：</p><ul><li>状态，Corda节点达成共识的共同事实，然后存储在分类账上</li><li>流程，封装了执行特定分类帐更新的过程</li></ul><p>我们的IOU CorDapp也不例外。它将定义一个状态和一个流程：</p><h3 id="IOUState"><a href="#IOUState" class="headerlink" title="IOUState"></a>IOUState</h3><p>我们的状态将是<code>IOUState</code>。它将存储借条的价值，以及贷款人和借款人的身份。我们可以想象<code>IOUState</code>如下：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/tutorial-state.png"></p><h3 id="IOUFlow"><a href="#IOUFlow" class="headerlink" title="IOUFlow"></a>IOUFlow</h3><p>我们的流程将是<code>IOUFlow</code>。此流程将完全自动化将新IOU发放到分类账的过程。它由以下步骤组成：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/simple-tutorial-flow.png"></p><p>在传统的分布式账本系统中，所有数据都被广播给每个网络参与者，您不需要考虑数据流 - 只需打包分类账更新并将其发送给网络上的其他人即可。但在Corda，隐私是核心焦点，流程使我们能够在同意分类账更新的过程中仔细控制谁看到了什么。</p><h3 id="CorDapp模板"><a href="#CorDapp模板" class="headerlink" title="CorDapp模板"></a>CorDapp模板</h3><p>编写新的CorDapp时，通常需要将其基于标准模板：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhcHAtdGVtcGxhdGUtamF2YQ==" title="https://github.com/corda/cordapp-template-java">Java的Cordapp模板<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhcHAtdGVtcGxhdGUta290bGlu" title="https://github.com/corda/cordapp-template-kotlin">kotlin的Cordapp模板<i class="fa fa-external-link"></i></span></li></ul><p>Cordapp模板为开发CorDapp提供了必需的样板，并允许您将CorDapp快速部署到虚拟节点的本地测试网络上，以测试其功能。</p><p>CorDapps可以用Java和Kotlin编写，并且将在本教程中以两种语言提供代码。</p><p>请注意，不需要下载和安装Corda本身。Corda V1.0所需的库将从一个在线Maven仓库自动下载。</p><h4 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h4><p>要下载模板，请在要下载CorDapp模板的目录中打开终端窗口，然后运行以下命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/corda/cordapp-template-java.git ;  cd cordapp-template-java</span><br></pre></td></tr></table></figure><p></p><p><em>要么</em><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/corda/cordapp-template-kotlin.git ;  cd cordapp-template-kotlin</span><br></pre></td></tr></table></figure><p></p><h4 id="在IntelliJ中打开模板"><a href="#在IntelliJ中打开模板" class="headerlink" title="在IntelliJ中打开模板"></a>在IntelliJ中打开模板</h4><p>下载模板后，按照以下说明在IntelliJ中打开它：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC90dXRvcmlhbC1jb3JkYXBwLmh0bWwjb3BlbmluZy10aGUtZXhhbXBsZS1jb3JkYXBwLWluLWludGVsbGlq44CC" title="https://docs.corda.net/tutorial-cordapp.html#opening-the-example-cordapp-in-intellij。">https://docs.corda.net/tutorial-cordapp.html#opening-the-example-cordapp-in-intellij。<i class="fa fa-external-link"></i></span></p><h4 id="模板结构"><a href="#模板结构" class="headerlink" title="模板结构"></a>模板结构</h4><p>该模板有许多文件，但我们可以忽略其中的大部分。我们只会修改以下文件：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于kotlin</span></span><br><span class="line"><span class="comment">// 1. The state</span></span><br><span class="line">cordapp-contracts-states/src/main/kotlin/com/template/StatesAndContracts.kt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The flow</span></span><br><span class="line">cordapp/src/main/kotlin/com/template/App.kt</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于java</span></span><br><span class="line"><span class="comment">// 1. The state</span></span><br><span class="line">cordapp-contracts-states/src/main/java/com/template/TemplateState.java</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The flow</span></span><br><span class="line">cordapp/src/main/java/com/template/TemplateFlow.java</span><br></pre></td></tr></table></figure><h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>为了防止以后出现构建错误，我们应该在开始之前删除以下文件：</p><ul><li>Java的： <code>cordapp/src/main/java/com/template/TemplateClient.java</code></li><li>kotlin： <code>cordapp/src/main/kotlin/com/template/Client.kt</code><h4 id="迄今取得进展"><a href="#迄今取得进展" class="headerlink" title="迄今取得进展"></a>迄今取得进展</h4>我们现在有一个模板，可以用来定义我们的IOU CorDapp。我们先来定义一下<code>IOUState</code>。<h3 id="编写状态"><a href="#编写状态" class="headerlink" title="编写状态"></a>编写状态</h3>在Corda，分类帐上的共享事实以状态表示。我们的第一个任务是定义一个新的状态类型来表示IOU。<h4 id="ContractState接口"><a href="#ContractState接口" class="headerlink" title="ContractState接口"></a>ContractState接口</h4>Corda状态是实现ContractState接口的类的任何实例。<code>ContractState</code>接口被定义为如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The list of entities considered to have a stake in this state.</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们可以看到<code>ContractState</code>接口只有一个字段<code>participants</code>。<code>participants</code>是这个状态相关的实体列表。</p><p>除此之外，我们的状态可以自由定义它需要的任何字段，方法，帮助者或内部类，以准确地表示分类账上给定类型的共享事实。</p><h4 id="建模IOUs"><a href="#建模IOUs" class="headerlink" title="建模IOUs"></a>建模IOUs</h4><p>我们应该如何在账本上定义代表借据？除了实现ContractState 接口之外，我们<code>IOUState</code>还需要属性来跟踪IOU的相关特性：</p><ul><li>IOU的价值</li><li>借条的贷方</li><li>借条的借款人</li></ul><p>还有更多可以包含的领域，比如IOU的货币，但现在让我们忽略它们。稍后添加它们通常就像为您的类定义添加附加属性一样简单。</p><h4 id="定义IOUState"><a href="#定义IOUState" class="headerlink" title="定义IOUState"></a>定义IOUState</h4><p>让我们开始打开<code>TemplateState.java</code>（对于Java）或<code>StatesAndContracts.kt</code>（对于Kotlin）并更新 <code>TemplateState</code>以定义<code>IOUState</code>：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace TemplateState's definition with:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUState</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>,</span><br><span class="line">               <span class="keyword">val</span> lender: Party,</span><br><span class="line">               <span class="keyword">val</span> borrower: Party) : ContractState &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> participants <span class="keyword">get</span>() = listOf(lender, borrower)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果你使用Java，你还需要重命名<code>TemplateState.java</code>为<code>IOUState.java</code>。</p><p>为了定义IOUState，我们做了以下更改：</p><ul><li>我们已将<code>TemplateState</code>类重新命名为<code>IOUState</code></li><li>我们已经为Java 添加了属性<code>value</code>，<code>lender</code>以及<code>borrower</code>, Java中所需的getter和setter。<ul><li><code>value</code>是类型的<code>int</code>（在Java中）/ <code>Int</code>（在Kotlin中）</li><li><code>lender</code>并且<code>borrower</code>是类型<code>Party</code><ul><li><code>Party</code>是一种内置的Corda类型，表示网络上的实体</li></ul></li></ul></li><li>我们已经覆盖<code>participants</code>返回<code>lender</code>和<code>borrower</code>的列表<ul><li><code>participants</code> 是应该被通知创建或消费这个状态的所有各方的名单</li></ul></li></ul><p>我们发放到分类账上的借条只是这个类的实例。</p><h4 id="合同怎么处理？"><a href="#合同怎么处理？" class="headerlink" title="合同怎么处理？"></a>合同怎么处理？</h4><p>如果您已阅读白皮书或重要概念部分，您会知道每个州都有一个关联合同，该合同会对状态随着时间的推移而产生不变量。包括合同对于我们的第一个CorDapp并不重要，所以我们现在只使用由模板定义的空白<code>TemplateContract</code>和<code>TemplateContract.Commands.Action</code>命令。在下一个教程中，我们将实施我们自己的合约和命令。</p><h3 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h3><p>流程会对节点可以执行的一系列步骤进行编码，以实现特定的分类帐更新。通过在节点上安装新的流程，我们允许节点处理新的业务流程。我们定义的流程将允许节点发放 IOUState到分类帐上。</p><h4 id="流程轮廓"><a href="#流程轮廓" class="headerlink" title="流程轮廓"></a>流程轮廓</h4><p>我们的流程目标是协调一项借条发行交易。Corda中的交易是更新分类账的变更的原子单位。每笔交易都是将零个或多个现有状态标记为历史（输入），同时创建零个或多个新状态（输出）的建议。</p><p>创建这个交易并将其应用于分类帐的过程将由IOU的贷方进行，并且需要执行以下步骤：</p><ol><li>将发行新IOU的交易提案建立在分类帐上</li><li>签署交易提案</li><li>记录交易</li><li>将交易发送给借条人，以便他们也可以记录</li></ol><p>在此阶段，我们不要求借款人批准和签署IOU发行交易。当我们在下一个教程中查看合约时，我们将能够施加这个要求。</p><h5 id="支流"><a href="#支流" class="headerlink" title="支流"></a>支流</h5><p>Corda中很常见诸如记录交易或向交易对手发送交易等任务。Corda不是强迫每个开发人员重新实现自己的逻辑来处理这些任务，而是提供了许多库流程来处理这些任务。我们将这些流程调用到较大流程的上下文中，以处理可重复的任务子流程 。</p><p>在我们的案例中，我们可以使用IOU发行流程的步骤3和步骤4自动化<code>FinalityFlow</code>。</p><h4 id="FlowLogic"><a href="#FlowLogic" class="headerlink" title="FlowLogic"></a>FlowLogic</h4><p>所有的流程都必须继承<code>FlowLogic</code>。然后通过重写<code>FlowLogic.call</code>来定义流程采取的步骤。</p><p>让我们在<code>TemplateFlow.java</code>或<code>App.kt</code>中定义我们的<code>IOUFlow</code>。删除模板（<code>Initiator</code>和<code>Responder</code>）中的两个现有流程，并将其替换为以下内容：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace TemplateFlow's definition with:</span></span><br><span class="line"><span class="meta">@InitiatingFlow</span></span><br><span class="line"><span class="meta">@StartableByRPC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUFlow</span></span>(<span class="keyword">val</span> iouValue: <span class="built_in">Int</span>,</span><br><span class="line">              <span class="keyword">val</span> otherParty: Party) : FlowLogic&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The progress tracker provides checkpoints indicating the progress of the flow to observers. */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> progressTracker = ProgressTracker()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The flow logic is encapsulated within the call() method. */</span></span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// We retrieve the notary identity from the network map.</span></span><br><span class="line">        <span class="keyword">val</span> notary = serviceHub.networkMapCache.notaryIdentities[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create the transaction components.</span></span><br><span class="line">        <span class="keyword">val</span> outputState = IOUState(iouValue, ourIdentity, otherParty)</span><br><span class="line">        <span class="keyword">val</span> cmd = Command(TemplateContract.Commands.Action(), ourIdentity.owningKey)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We create a transaction builder and add the components.</span></span><br><span class="line">        <span class="keyword">val</span> txBuilder = TransactionBuilder(notary = notary)</span><br><span class="line">                .addOutputState(outputState, TEMPLATE_CONTRACT_ID)</span><br><span class="line">                .addCommand(cmd)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We sign the transaction.</span></span><br><span class="line">        <span class="keyword">val</span> signedTx = serviceHub.signInitialTransaction(txBuilder)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We finalise the transaction.</span></span><br><span class="line">        subFlow(FinalityFlow(signedTx))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果你使用Java，你还需要重命名<code>TemplateFlow.java</code>为<code>IOUFlow.java</code>。我们一步一步浏览这段代码。</p><p>我们已经定义了自己的<code>FlowLogic</code>重写了<code>FlowLogic.call</code>。<code>FlowLogic.call</code>有一个返回类型，必须匹配传递给它的类型参数<code>FlowLogic</code>- 这是通过运行流程返回的类型。</p><p><code>FlowLogic</code>子类可以有选择地使用构造函数参数，这些参数可以用作<code>FlowLogic.call</code>的参数。在我们的案例中，我们有两个：</p><ul><li><code>iouValue</code>，这是发行借据的价值</li><li><code>otherParty</code>，借条的借款人（运行该流程的节点是贷方）</li></ul><p><code>FlowLogic.call</code>被注解<code>@Suspendable</code> - <b style="color:Red">这可以让流程在遇到长时间运行的操作时被检查并指向并序列化到磁盘，从而允许您的节点继续运行其他流程。忘记这个注解将导致一些非常奇怪的错误信息！</b></p><p>在<code>FlowLogic</code>子类本身上还有更多的注释：</p><ul><li><code>@InitiatingFlow</code> 意味着该流程可以由节点直接启动</li><li><code>@StartableByRPC</code> 允许节点所有者通过RPC调用启动此流程</li></ul><p>我们来看看<code>FlowLogic.call</code>它自己的步骤。这是我们实际描述发行<code>IOUState</code>到分类账的程序的地方。</p><h5 id="选择一个公证人"><a href="#选择一个公证人" class="headerlink" title="选择一个公证人"></a>选择一个公证人</h5><p>每笔交易都需要一名公证人来防止双重花费，并担任时间戳管理机构。我们在流程中做的第一件事是从节点的<code>ServiceHub</code>检索一个公证人。<code>ServiceHub.networkMapCache</code>提供有关网络上其他节点以及它们提供的服务的信息。</p><p>注意: 无论何时我们需要流程中的信息 - 无论是关于我们自己的节点的身份，节点的本地存储还是网络的其余部分，我们通常都会通过节点的<code>ServiceHub</code>获取它。</p><h5 id="建立交易"><a href="#建立交易" class="headerlink" title="建立交易"></a>建立交易</h5><p>我们将分两步建立交易提案：</p><ul><li>创建交易的组件</li><li>将这些组件添加到交易生成器</li></ul><h5 id="交易项目"><a href="#交易项目" class="headerlink" title="交易项目"></a>交易项目</h5><p>我们的交易将具有以下结构：<br><img alt="" data-src="https://docs.corda.net/head/_images/simple-tutorial-transaction.png"></p><ul><li>输出<code>IOUState</code>的右侧表示我们将添加到分类账的状态。如您所见，没有任何输入 - 我们在创建IOU时不会消耗任何现有账本状态</li><li><code>Action</code>是将借条人列为签署人的命令</li></ul><p>我们已经讨论过了<code>IOUState</code>，但我们还没有看过命令。命令有两个功能：</p><ul><li>它们表明交易的意图 - 发行，转让，赎回，撤销。当我们在下一个教程中讨论合同时，这将是至关重要的</li><li>它们允许我们为交易定义所需的签名者。例如，IOU的创建可能只需要贷方的签名，而IOU的转移可能需要IOU的借款人和贷方的签名</li></ul><p>每个<code>Command</code>包含一个命令类型和一个公钥列表。现在，我们使用预先定义的<code>TemplateContract.Action</code>作为命令类型，并将贷方列为唯一的公钥。这意味着为使交易有效，贷款人必须签署交易。</p><h5 id="创建一个事务生成器"><a href="#创建一个事务生成器" class="headerlink" title="创建一个事务生成器"></a>创建一个事务生成器</h5><p>要真正建立拟议的交易，我们需要一个<code>TransactionBuilder</code>。这是一个可变的交易类，我们可以在其中添加输入，输出，命令以及交易所需的任何其他项目。我们创建一个<code>TransactionBuilder</code>使用我们早先检索的公证人。</p><p>一旦我们有了<code>TransactionBuilder</code>，我们添加我们的组件：</p><ul><li>该命令直接使用<code>TransactionBuilder.addCommand</code>添加</li><li>输出<code>IOUState</code>使用<code>TransactionBuilder.addOutputState</code>添加。除了输出状态本身外，这种方法还要参考管理状态演变随时间推移的合约。在这里，我们传递了一个对其没有限制的<code>TemplateContract</code>引用。我们将在下一个教程中定义一个强制约束的合约</li></ul><h5 id="签署交易"><a href="#签署交易" class="headerlink" title="签署交易"></a>签署交易</h5><p>现在我们有一个有效的交易提案，我们需要签署它。交易一旦签署，任何人都无法修改交易而不会使此签名无效。这有效地使交易不可变。</p><p>我们用<code>ServiceHub.toSignedTransaction</code>签名交易，它返回一个<code>SignedTransaction</code>。<code>SignedTransaction</code>是将交易与该交易上的签名列表配对的对象。</p><h5 id="完成交易"><a href="#完成交易" class="headerlink" title="完成交易"></a>完成交易</h5><p>我们现在有一个有效的签名交易。剩下要做的就是让所有相关方都记录下来。通过这样做，它将成为分类账的永久部分。如上所述，我们将使用一个内置的<code>FinalityFlow</code>流程自动处理这个过程。<code>FinalityFlow</code>完全自动化的过程：</p><ul><li>如果需要，公证交易（即如果交易包含输入 和/或 时间窗口）</li><li>将它记录在我们的Vault中</li><li>将它发送给其他参与者（即贷方）以供他们进行记录</li></ul><h3 id="运行我们的CorDapp"><a href="#运行我们的CorDapp" class="headerlink" title="运行我们的CorDapp"></a>运行我们的CorDapp</h3><p>现在我们已经编写了一个CorDapp，现在是通过在一些真正的Corda节点上运行它来测试它的时候了。</p><h4 id="部署我们的CorDapp"><a href="#部署我们的CorDapp" class="headerlink" title="部署我们的CorDapp"></a>部署我们的CorDapp</h4><p>我们来看看我们要部署的节点。打开项目的build.gradle文件并向下滚动到<code>task deployNodes</code>部分。本节定义了三个节点。有两个标准节点（<code>PartyA</code>和<code>PartyB</code> ），<b style="color:red">以及运行网络map服务并公布验证公证服务的特殊网络map/公证节点。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">task deployNodes(type: net.corda.plugins.Cordform, dependsOn: [&apos;jar&apos;]) &#123;</span><br><span class="line">    directory &quot;./build/nodes&quot;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=Notary,L=London,C=GB&quot;</span><br><span class="line">        notary = [validating : true]</span><br><span class="line">        p2pPort 10002</span><br><span class="line">        rpcPort 10003</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=PartyA,L=London,C=GB&quot;</span><br><span class="line">        p2pPort 10005</span><br><span class="line">        rpcPort 10006</span><br><span class="line">        webPort 10007</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">        rpcUsers = [[ user: &quot;user1&quot;, &quot;password&quot;: &quot;test&quot;, &quot;permissions&quot;: [&quot;ALL]]]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name &quot;O=PartyB,L=New York,C=US&quot;</span><br><span class="line">        p2pPort 10008</span><br><span class="line">        rpcPort 10009</span><br><span class="line">        webPort 10010</span><br><span class="line">        sshdPort 10024</span><br><span class="line">        cordapps = [&quot;net.corda:corda-finance:$corda_release_version&quot;]</span><br><span class="line">        rpcUsers = [[ user: &quot;user1&quot;, &quot;password&quot;: &quot;test&quot;, &quot;permissions&quot;: [&quot;ALL&quot;]]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们可以使用Gradle 来运行<code>deployNodes</code>任务。对于每个节点定义，Gradle将：</p><ul><li>将项目的源文件打包到一个CorDapp jar中</li><li><code>build/nodes</code>使用我们已安装的CorDapp创建一个新节点</li></ul><p>我们现在可以通过从项目的根目录运行以下命令来完成此操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew clean deployNodes</span><br></pre></td></tr></table></figure><p></p><h4 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a>运行节点</h4><p>运行<code>deployNodes</code>将构建<code>build/nodes</code>下的节点。如果我们导航到其中一个文件夹，我们将看到三个节点文件夹。每个节点文件夹具有以下结构：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|____corda.jar                     // The runnable node</span><br><span class="line">|____corda-webserver.jar           // The node&apos;s webserver</span><br><span class="line">|____node.conf                     // The node&apos;s configuration file</span><br><span class="line">|____cordapps</span><br><span class="line">|____java/kotlin-source-0.1.jar  // Our IOU CorDapp</span><br></pre></td></tr></table></figure><p></p><p>我们通过从项目的根目录运行以下命令来启动节点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/nodes/runnodes</span><br></pre></td></tr></table></figure><p></p><h4 id="与节点交互"><a href="#与节点交互" class="headerlink" title="与节点交互"></a>与节点交互</h4><p>现在我们的节点正在运行，让我们命令其中一个通过开启我们的<code>IOUFlow</code>创建一个借条。在更大的应用程序中，我们通常会提供一个位于节点顶部的Web API。在这里，为了简单起见，我们将通过其内置的CRaSH shell与节点进行交互。</p><p>转到显示<code>PartyA</code>的CRaSH shell的终端窗口。键入<code>help</code>将显示可用命令的列表。</p><p>注意: 本地终端shell只能在开发模式下使用。在生产环境中，可以启用SSH服务器。有关SSH和如何连接的更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL3NoZWxsLmh0bWw=" title="https://docs.corda.net/head/shell.html">Shell<i class="fa fa-external-link"></i></span>页面。</p><p>我们想用PartyB创建一个99的欠条。我们开始<code>IOUFlow</code>输入：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin</span><br><span class="line">start IOUFlow iouValue: 99, otherParty: "O=PartyB,L=New York,C=US"</span><br><span class="line">// Java</span><br><span class="line">start IOUFlow arg0: 99, arg1: "O=PartyB,L=New York,C=US"</span><br></pre></td></tr></table></figure><p></p><p>这个单一命令将导致PartyA和PartyB自动同意一个借条。这是流程框架的一大优势 - 它允许您将复杂的协商和更新过程减少为单个函数调用。</p><p>如果这个流程奏效了，它应该在PartyA和PartyB的Vault里记录一条新的借条。让我们检查。</p><p>我们可以运行以下命令来检查每个节点的vault的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vaultQuery contractStateType: com.template.IOUState</span><br></pre></td></tr></table></figure><p></p><p>PartyA和PartyB的保险库都应显示以下输出：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">states:</span><br><span class="line">- state:</span><br><span class="line">    data:</span><br><span class="line">      value: 99</span><br><span class="line">      lender: "C=GB,L=London,O=PartyA"</span><br><span class="line">      borrower: "C=US,L=New York,O=PartyB"</span><br><span class="line">      participants:</span><br><span class="line">      - "C=GB,L=London,O=PartyA"</span><br><span class="line">      - "C=US,L=New York,O=PartyB"</span><br><span class="line">    contract: "com.template.contract.IOUContract"</span><br><span class="line">    notary: "C=GB,L=London,O=Notary"</span><br><span class="line">    encumbrance: null</span><br><span class="line">    constraint:</span><br><span class="line">      attachmentId: "F578320232CAB87BB1E919F3E5DB9D81B7346F9D7EA6D9155DC0F7BA8E472552"</span><br><span class="line">  ref:</span><br><span class="line">    txhash: "5CED068E790A347B0DD1C6BB5B2B463406807F95E080037208627565E6A2103B"</span><br><span class="line">    index: 0</span><br><span class="line">statesMetadata:</span><br><span class="line">- ref:</span><br><span class="line">    txhash: "5CED068E790A347B0DD1C6BB5B2B463406807F95E080037208627565E6A2103B"</span><br><span class="line">    index: 0</span><br><span class="line">  contractStateClassName: "com.template.state.IOUState"</span><br><span class="line">  recordedTime: 1506415268.875000000</span><br><span class="line">  consumedTime: null</span><br><span class="line">  status: "UNCONSUMED"</span><br><span class="line">  notary: "C=GB,L=London,O=Notary"</span><br><span class="line">  lockId: null</span><br><span class="line">  lockUpdateTime: 1506415269.548000000</span><br><span class="line">totalStatesAvailable: -1</span><br><span class="line">stateTypes: "UNCONSUMED"</span><br><span class="line">otherResults: []</span><br></pre></td></tr></table></figure><p></p><p>这是发放IOUState到分类帐上的交易。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>我们已经编写了一个简单的CorDapp，允许将欠款发放到账本上。我们的CorDapp由两个关键部分组成：</p><ul><li>IOUState在账本上代表欠条</li><li>IOUFlow，编排商定分类帐一张欠条的创作过程</li></ul><p>完成本教程后，您的CorDapp应该如下所示：</p><ul><li>Java：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhLXR1dDEtc29sdXRpb24tamF2YQ==" title="https://github.com/corda/corda-tut1-solution-java">https://github.com/corda/corda-tut1-solution-java<i class="fa fa-external-link"></i></span></li><li>Kotlin：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhLXR1dDEtc29sdXRpb24ta290bGlu" title="https://github.com/corda/corda-tut1-solution-kotlin">https://github.com/corda/corda-tut1-solution-kotlin<i class="fa fa-external-link"></i></span></li></ul><h4 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h4><p>我们可以对这个CorDapp进行一些改进：</p><ul><li>我们应该使用合同测试和流程测试框架添加单元测试</li><li>我们应该IOUState.value从一个整数变为适当的一种货币</li><li>我们可以添加一个API，以便与CorDapp进行交互</li></ul><p>但现在，最大的优先事项是<code>IOUContract</code>在每个<code>IOUState</code>时间段的演变中增加强加的限制 。这将是我们下一篇教程的重点。</p><h2 id="Hello-World-V2-合约约束"><a href="#Hello-World-V2-合约约束" class="headerlink" title="Hello World V2 - 合约约束"></a>Hello World V2 - 合约约束</h2><p>注意： 本教程扩展了上一篇的Hello，World教程中构建的CorDapp 。</p><p>在Hello，World教程中，我们构建了一个CorDapp，允许我们在账本上对IOU进行建模。我们的CorDapp由两个元素组成：</p><ul><li><code>IOUState</code>在账本上代表欠条</li><li><code>IOUFlow</code>，编排商定分类帐一张欠条的创作过程</li></ul><p>然而，我们的CorDapp并未对随着时间的推移对账簿上的借条发展施加任何限制。任何人都可以自由地在任何一方之间创造任何价值的欠条。</p><p>在本教程中，我们将编写一份合约，对IOUState可能随时间变化的规则制定规则。反过来，这将需要对前一教程中定义的流程进行一些小的更改。</p><h3 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h3><p>很容易想象大多数CorDapps会想要对它们的状态随着时间的推移施加一些限制：</p><ul><li>现金类的CorDapp不会希望允许用户无限制地创建生成资金的交易（至少在没有中央银行或商业银行参与的情况下）</li><li>贷款类的CorDapp可能不希望允许创建负值贷款</li><li>资产交易的CorDapp不会允许用户在没有交易对手同意的情况下完成交易</li></ul><p>在Corda，我们对各状态如何使用合约进行限制。</p><p>注意：Corda的合约与其他分布式账本平台的智能合约有很大不同。它们不是表示当前世界状态的有状态对象。相反，像真实世界的合约一样，他们只是对允许的交易类型施加规则。</p><p>每个状态都有相关的合约。如果交易不符合交易中每个输入和输出状态的合约，则交易无效。</p><h3 id="合约接口"><a href="#合约接口" class="headerlink" title="合约接口"></a>合约接口</h3><p>就像每个Corda状态必须实现<code>ContractState</code>接口一样，每个合约都必须实现 <code>Contract</code>接口：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contract</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implements the contract constraints in code.</span></span><br><span class="line">    <span class="meta">@Throws(IllegalArgumentException::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们可以看到，Contract它通过一个verify将交易作为输入的函数来表达它的约束，并且：</p><ul><li>抛出一个，IllegalArgumentException如果它拒绝交易提议</li><li>如果它接受交易提议，则无提示返回</li></ul><h4 id="控制IOU演变"><a href="#控制IOU演变" class="headerlink" title="控制IOU演变"></a>控制IOU演变</h4><p><code>IOUState</code>一个好的合约会是什么样子？没有正确或错误的答案 - 这取决于你希望你的CorDapp如何表现。</p><p>对于我们的CorDapp，让我们强加一下我们只想允许创建IOU的限制。我们不希望节点转让它们或将它们兑换为现金。强制执行此行为的一种方法是强加以下限制：</p><ul><li>涉及IOU的交易必须消耗零输入，并创建一个类型<code>IOUState</code>的输出</li><li>交易还应该包括一个<code>Create</code>命令，表明交易的意图（更多的命令很快）</li></ul><p>我们可能还想对发布<code>IOUState</code>的属性施加一些限制：</p><ul><li>其价值必须是非负的</li><li>贷款人和借款人不能是同一个实体</li></ul><p>最后，我们要强制限制谁需要签署交易：</p><ul><li>借条的放款人必须签字</li><li>借条的借款人必须签字</li></ul><p>我们可以将这一交易描述如下：<br><img alt="" data-src="https://docs.corda.net/head/_images/simple-tutorial-transaction-2.png"></p><h4 id="定义IOUContract"><a href="#定义IOUContract" class="headerlink" title="定义IOUContract"></a>定义IOUContract</h4><p>我们来写一个强制执行这些约束的合约。我们将通过修改<code>TemplateContract.java</code>或 <code>StatesAndContracts.kt</code>更新<code>TemplateContract</code>来定义一个<code>IOUContract</code>：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace IOUContract's contract ID and definition with:</span></span><br><span class="line">const <span class="keyword">val</span> IOU_CONTRACT_ID = <span class="string">"com.template.IOUContract"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUContract</span> : <span class="type">Contract &#123;</span></span></span><br><span class="line">    <span class="comment">// Our Create command.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Create</span> : <span class="type">CommandData</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">verify</span><span class="params">(tx: <span class="type">LedgerTransaction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> command = tx.commands.requireSingleCommand&lt;Create&gt;()</span><br><span class="line"></span><br><span class="line">        requireThat &#123;</span><br><span class="line">            <span class="comment">// Constraints on the shape of the transaction.</span></span><br><span class="line">            <span class="string">"No inputs should be consumed when issuing an IOU."</span> using (tx.inputs.isEmpty())</span><br><span class="line">            <span class="string">"There should be one output state of type IOUState."</span> using (tx.outputs.size == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// IOU-specific constraints.</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">out</span> = tx.outputsOfType&lt;IOUState&gt;().single()</span><br><span class="line">            <span class="string">"The IOU's value must be non-negative."</span> using (<span class="keyword">out</span>.value &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="string">"The lender and the borrower cannot be the same entity."</span> using (<span class="keyword">out</span>.lender != <span class="keyword">out</span>.borrower)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Constraints on the signers.</span></span><br><span class="line">            <span class="string">"There must be two signers."</span> using (command.signers.toSet().size == <span class="number">2</span>)</span><br><span class="line">            <span class="string">"The borrower and lender must be signers."</span> using (command.signers.containsAll(listOf(</span><br><span class="line">                    <span class="keyword">out</span>.borrower.owningKey, <span class="keyword">out</span>.lender.owningKey)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果你使用Java，你还需要重命名<code>TemplateContract.java</code>为<code>IOUContract.java</code>。</p><h4 id="Create命令"><a href="#Create命令" class="headerlink" title="Create命令"></a>Create命令</h4><p>我们添加到合同中的第一件事是一个命令。命令有两个功能：</p><ul><li>它们表明交易的意图，使我们能够对不同类型的交易进行不同的验证。例如，建议设立借条的交易可能必须满足兑换欠条的不同约束</li><li>它们允许我们为交易定义所需的签名者。例如，IOU的创建可能只需要贷方的签名，而IOU的转移可能需要IOU的借款人和贷方的签名</li></ul><p>我们的合约有一个命令，一个<code>Create</code>命令。<b style="color:red">所有命令都必须实现该<code>CommandData</code>接口。</b></p><p>该<code>CommandData</code>接口是命令的简单标记接口。实际上，它的声明只有两个单词（Kotlin接口不需要body）：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CommandData</span></span></span><br></pre></td></tr></table></figure><p></p><h4 id="验证逻辑"><a href="#验证逻辑" class="headerlink" title="验证逻辑"></a>验证逻辑</h4><p>我们的合约还需要通过实现<code>verify</code>来定义实际的合同约束。我们写这个verify函数的目标 是编写一个函数，给定一个交易：</p><ul><li>如果交易被认为是无效的，则抛出异常<code>IllegalArgumentException</code></li><li>如果该交易被认为是有效就不要抛出一个异常</li></ul><p>在决定交易是否有效时，该<code>verify</code>方法只能访问交易的内容：</p><ul><li><code>tx.inputs</code>，其中列出了输入</li><li><code>tx.outputs</code>，其中列出了输出</li><li><code>tx.commands</code>，其中列出了命令及其相关的签名者</li></ul><p>以及交易的附件和时间窗口，我们不会在这里使用。</p><p>基于上面列举的约束条件，<code>verify</code>如果满足以下任一条件，我们需要编写一个拒绝交易的函数：</p><ul><li><b style="color:red">该交易不包含<code>Create</code>命令</b></li><li>交易有输入</li><li>交易没有确切的一个输出</li><li>借据本身是无效的</li><li>交易不需要贷方的签名</li></ul><h4 id="命令约束"><a href="#命令约束" class="headerlink" title="命令约束"></a>命令约束</h4><p>我们的第一个约束是围绕交易的命令。我们使用Corda的<code>requireSingleCommand</code>功能来测试单个<code>Create</code>命令的存在。</p><p>如果该<code>Create</code>命令不存在，或者该交易有多个<code>Create</code>命令，则将抛出异常并且合同验证将失败。</p><h4 id="交易限制"><a href="#交易限制" class="headerlink" title="交易限制"></a>交易限制</h4><p>我们还希望我们的交易没有输入，只有单一输出 - 发行交易。</p><p>为了施加这个以及随后的限制，我们使用了<code>Corda</code>的内置<code>requireThat</code>模块。<code>requireThat</code>提供了一种简洁的方式来编写以下内容：</p><ul><li>如果右侧的条件不计算为真…</li><li>… IllegalArgumentException在左侧抛出消息</li></ul><p>像以前一样，抛出此异常的行为会导致交易被视为无效。</p><h4 id="借条限制"><a href="#借条限制" class="headerlink" title="借条限制"></a>借条限制</h4><p>我们想要对其IOUState本身施加两个约束：</p><ul><li>其价值必须是非负的</li><li>贷款人和借款人不能是同一个实体</li></ul><p>我们将这些约束与以前一样强加在同一个<code>requireThat</code>块中。</p><p>你可以看到，我们不仅限于在<code>requireThat</code>块中编写约束。我们也可以编写其他语句 - 在这种情况下，提取交易的单个<code>IOUState</code>元素并将其分配给一个变量。</p><h4 id="签名者约束"><a href="#签名者约束" class="headerlink" title="签名者约束"></a>签名者约束</h4><p>最后，我们要求贷款人和借款人都是交易中必需的签名人。交易所需的签名者等于命令中列出的所有签名者的联合。因此，我们从<code>Create</code>早先检索的命令中提取签名者。</p><p>这是一个绝对必要的约束 - 它确保在没有<code>IOUState</code>贷方和借方节点的明确同意的情况下在账本上不能创建账户。</p><h4 id="目前取得进展"><a href="#目前取得进展" class="headerlink" title="目前取得进展"></a>目前取得进展</h4><p>我们现在已经写了一个<code>IOUContract</code>限制每个<code>IOUState</code>时间的演变：</p><ul><li>一个<code>IOUState</code>只能被创建，不转移或赎回</li><li>创建一个<code>IOUState</code>无需输入，一个<code>IOUState</code>输出和一个 <code>Create</code>命令的发布事务</li><li>将<code>IOUState</code>通过发行交易创建必须有一个非负值，贷款人与借款人必须是不同的实体</li></ul><p>接下来，我们将更新IOUFlow它，以便在发放IOUState到分类账时遵守这些合同约束。</p><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>我们现在需要更新我们的流程来实现三件事情：</p><ul><li>验证我们构建的交易提案是否满足<code>IOUContract</code>约束条件</li><li>更新贷款方的流程以请求借款人的签名</li><li>为响应贷方签名请求的借款人创建一个响应流程</li></ul><p>我们将通过修改我们在前一教程中编写的流程来实现这一点。</p><h4 id="验证交易"><a href="#验证交易" class="headerlink" title="验证交易"></a>验证交易</h4><p>在<code>IOUFlow.java</code>或者<code>App.kt中</code>，将imports块更改为以下内容：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> co.paralleluniverse.fibers.Suspendable</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.Command</span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.StateAndContract</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.CollectSignaturesFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.FinalityFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.FlowLogic</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.InitiatingFlow</span><br><span class="line"><span class="keyword">import</span> net.corda.core.flows.StartableByRPC</span><br><span class="line"><span class="keyword">import</span> net.corda.core.identity.Party</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.TransactionBuilder</span><br><span class="line"><span class="keyword">import</span> net.corda.core.utilities.ProgressTracker</span><br></pre></td></tr></table></figure><p></p><p>在从网络中检索公证人的身份之后，通过更改代码进行更新<code>IOUFlow.call</code>，如下所示：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We create a transaction builder.</span></span><br><span class="line"><span class="keyword">val</span> txBuilder = TransactionBuilder(notary = notary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We create the transaction components.</span></span><br><span class="line"><span class="keyword">val</span> outputState = IOUState(iouValue, ourIdentity, otherParty)</span><br><span class="line"><span class="keyword">val</span> outputContractAndState = StateAndContract(outputState, IOU_CONTRACT_ID)</span><br><span class="line"><span class="keyword">val</span> cmd = Command(IOUContract.Create(), listOf(ourIdentity.owningKey, otherParty.owningKey))</span><br><span class="line"></span><br><span class="line"><span class="comment">// We add the items to the builder.</span></span><br><span class="line">txBuilder.withItems(outputContractAndState, cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verifying the transaction.</span></span><br><span class="line">txBuilder.verify(serviceHub)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Signing the transaction.</span></span><br><span class="line"><span class="keyword">val</span> signedTx = serviceHub.signInitialTransaction(txBuilder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a session with the other party.</span></span><br><span class="line"><span class="keyword">val</span> otherpartySession = initiateFlow(otherParty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Obtaining the counterparty's signature.</span></span><br><span class="line"><span class="keyword">val</span> fullySignedTx = subFlow(CollectSignaturesFlow(signedTx, listOf(otherpartySession), CollectSignaturesFlow.tracker()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finalising the transaction.</span></span><br><span class="line">subFlow(FinalityFlow(fullySignedTx))</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">在原始的CorDapp中，我们通过调用一个称为<code>FinalityFlow</code>子流程的内置流来自动化对交易进行公证处理并将其记录到每个参与者的库中</b>。我们将使用另一个预定义的流程<code>CollectSignaturesFlow</code>来收集借款人的签名。</p><p>首先，我们需要更新命令。我们现在正在使用<code>IOUContract.Create</code>，而不是 <code>TemplateContract.Commands.Action</code>。我们也希望根据合同约束将借款人变成必需的签名人。这与将借款人的公钥添加到交易的命令一样简单。</p><p>我们还需要使用对旧的<code>IOUContract</code>的引用将输出状态添加到交易中，而不是旧的<code>TemplateContract</code>。</p><p>现在我们的状态是由一个真实的合约来管理的，我们希望在开始签署过程之前检查我们的交易提案是否满足这些要求。我们通过调用<code>TransactionBuilder.verify</code>我们的交易建议来完成此工作，然后再添加我们的签名来完成。</p><h4 id="请求借款人的签名"><a href="#请求借款人的签名" class="headerlink" title="请求借款人的签名"></a>请求借款人的签名</h4><p>我们现在需要与借款人沟通，要求他们签署交易。无论何时您想在流程环境中与另一方进行交流，您首先需要与他们建立流程会话。如果交易对手已经注册<code>FlowLogic</code>以响应<code>FlowLogic</code>发起会话，则将建立会话。这两个<code>FlowLogic</code>实例之间的所有通信都将作为本次会话的一部分。</p><p>一旦我们与借款人建立会话，我们就会使用<code>CollectSignaturesFlow</code>收集借款人的签名，这需要：</p><ul><li>由流程发起人签署的交易</li><li>流程发起人与所需签署人之间的流程会话列表</li></ul><p>并返回由所有必填签名者签署的交易。</p><p>然后，我们可以将这个完全签署的交易传递给<code>FinalityFlow</code>。</p><h4 id="创建借款人的流程"><a href="#创建借款人的流程" class="headerlink" title="创建借款人的流程"></a>创建借款人的流程</h4><p>在出借方方面，我们使用的<code>CollectSignaturesFlow</code>自动收集签名。为了让贷款人作出回应，我们还需要编写一个回应流程。在Java中的<code>IOUFlowResponder.java</code>新文件或Kotlin中的<code>App.kt</code>文件中，添加以下类：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add these imports:</span></span><br><span class="line"><span class="keyword">import</span> net.corda.core.contracts.requireThat</span><br><span class="line"><span class="keyword">import</span> net.corda.core.transactions.SignedTransaction</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define IOUFlowResponder:</span></span><br><span class="line"><span class="meta">@InitiatedBy(IOUFlow::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUFlowResponder</span></span>(<span class="keyword">val</span> otherPartySession: FlowSession) : FlowLogic&lt;<span class="built_in">Unit</span>&gt;() &#123;</span><br><span class="line">    <span class="meta">@Suspendable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> signTransactionFlow = <span class="keyword">object</span> : SignTransactionFlow(otherPartySession, SignTransactionFlow.tracker()) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkTransaction</span><span class="params">(stx: <span class="type">SignedTransaction</span>)</span></span> = requireThat &#123;</span><br><span class="line">                <span class="keyword">val</span> output = stx.tx.outputs.single().<span class="keyword">data</span></span><br><span class="line">                <span class="string">"This must be an IOU transaction."</span> using (output <span class="keyword">is</span> IOUState)</span><br><span class="line">                <span class="keyword">val</span> iou = output <span class="keyword">as</span> IOUState</span><br><span class="line">                <span class="string">"The IOU's value can't be too high."</span> using (iou.value &lt; <span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subFlow(signTransactionFlow)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>与<code>IOUFlow</code>一样，我们的<code>IOUFlowResponder</code>流程是一个<code>FlowLogic</code>子类, 重写了<code>FlowLogic.call</code>。</p><p>该流程使用<code>InitiatedBy</code>(<code>IOUFlow.class</code>)注解，这意味着您的节点将在从<code>Initiator</code>另一个节点上运行的实例接收到消息时调用<code>IOUFlowResponder.call</code> 。<code>IOUFlow</code>的这条消息会是什么？如果我们看一下<code>CollectSignaturesFlow</code>定义，我们可以看到我们将被发送一个<code>SignedTransaction</code>，并且预计将通过该交易发回我们的签名。</p><p>我们可以编写自己的流程来处理这个过程。但是，也有一个预定义的流程<code>SignTransactionFlow</code>可以自动处理流程。唯一的问题是<code>SignTransactionFlow</code>是一个抽象类 - 我们必须继承它并重写<code>SignTransactionFlow.checkTransaction</code>。</p><h4 id="CheckTransactions"><a href="#CheckTransactions" class="headerlink" title="CheckTransactions"></a>CheckTransactions</h4><p><code>SignTransactionFlow</code>将在签署之前自动验证交易及其签名。但是，仅仅因为交易在合同中有效并不意味着我们一定要签名。如果我们不想处理有问题的交易对手，或者价值太高，或者我们对交易结构不满意，该怎么办？</p><p>重写<code>SignTransactionFlow.checkTransaction</code>允许我们定义这些额外的检查。在我们的案例中，我们正在检查：</p><ul><li>交易涉及的<code>IOUState</code> - 确保<code>IOUContract</code>将运行以验证交易</li><li>借条的价值低于一定数额（在这种情况下为100）</li></ul><p>如果这些条件中的任何一个都不符合，我们将不签署交易 - 即使交易及其签名在合同中有效。</p><p>一旦我们定义了<code>SignTransactionFlow</code>子类，我们就会调用<code>FlowLogic.subFlow</code>，并且与借方和贷方的流程自动进行通信。</p><h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>我们现在已经更新了流程，以验证交易并收集贷方签名，符合中定义的<code>IOUContract</code>约束条件。我们现在可以使用与之前相同的说明重新运行我们更新的CorDapp 。</p><p>我们的CorDapp现在对发行IOU进行限制。最重要的是，借款发行现在需要借款人和借款人达成协议，然后才能在账本上创建借条。这样可以防止贷款人或借款人以一种只有利于自己的方式单方面更新分类账。</p><p>完成本教程后，您的CorDapp应该如下所示：</p><ul><li>Java：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhLXR1dDItc29sdXRpb24tamF2YQ==" title="https://github.com/corda/corda-tut2-solution-java">https://github.com/corda/corda-tut2-solution-java<i class="fa fa-external-link"></i></span></li><li>Kotlin：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhLXR1dDItc29sdXRpb24ta290bGlu" title="https://github.com/corda/corda-tut2-solution-kotlin">https://github.com/corda/corda-tut2-solution-kotlin<i class="fa fa-external-link"></i></span></li></ul><p>你现在应该准备开发你自己的CorDapps。您也可以在这里找到样品CorDapps的列表 。在编写CorDapps时，您还需要了解有关Corda API的更多信息 。</p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL2hlbGxvLXdvcmxkLWludHJvZHVjdGlvbi5odG1s" title="https://docs.corda.net/head/hello-world-introduction.html">Hello, World!<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9oZWFkL3R1dC10d28tcGFydHktaW50cm9kdWN0aW9uLmh0bWw=" title="https://docs.corda.net/head/tut-two-party-introduction.html">Hello, World! Pt.2 - Contract constraints<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda networks</title>
      <link href="//blockchain/corda/Corda-networks.html"/>
      <url>//blockchain/corda/Corda-networks.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="设置Corda网络"><a href="#设置Corda网络" class="headerlink" title="设置Corda网络"></a>设置Corda网络</h2><p>Corda网络由多台运行节点的机器组成。这些节点使用持久协议进行通信，以创建和验证交易。</p><p>这种节点可能具有三种更广泛的功能类别。这些功能块是作为服务提供的，一个节点可以运行其中几个。</p><ul><li>公证人：运行公证服务见证人状态的节点花费并最终决定交易是否是双重花费</li><li>Oracle：通过提供影响交易有效性的事实将账本与外部世界链接起来的网络服务</li><li>常规节点：所有节点都有一个Vault，并且可能开始与其他节点，公证人和神谕（Oracle）进行通信的协议，并发展他们的私人分类账</li></ul><h3 id="建立你自己的网络"><a href="#建立你自己的网络" class="headerlink" title="建立你自己的网络"></a>建立你自己的网络</h3><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>给定Corda网络中的每个节点都必须具有由网络根CA签署的身份证书。有关更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvcGVybWlzc2lvbmluZy5odG1s" title="https://docs.corda.net/releases/release-V3.1/permissioning.html">网络许可<i class="fa fa-external-link"></i></span>。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>节点可以通过在节点的目录中添加/编辑<code>node.conf</code>进行配置。有关详情请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY29yZGEtY29uZmlndXJhdGlvbi1maWxlLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html">节点配置<i class="fa fa-external-link"></i></span>。</p><p>一个示例配置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">dataSourceProperties : &#123;</span><br><span class="line">    dataSourceClassName : org.h2.jdbcx.JdbcDataSource</span><br><span class="line">    &quot;dataSource.url&quot; : &quot;jdbc:h2:file:&quot;$&#123;baseDirectory&#125;&quot;/persistence&quot;</span><br><span class="line">    &quot;dataSource.user&quot; : sa</span><br><span class="line">    &quot;dataSource.password&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:10004&quot;</span><br><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user1, password=letmein, permissions=[ StartFlow.net.corda.protocols.CashProtocol ] &#125;</span><br><span class="line">]</span><br><span class="line">devMode : true</span><br></pre></td></tr></table></figure><p></p><p>有关网络配置的最重要的配置是：</p><ul><li><code>p2pAddress</code>：这指定了Artemis将与其他节点进行消息传递绑定的主机和端口。需要注意的是绑定的地址将不是<code>my-corda-node</code>，而是<code>::</code>（所有网络接口上的所有地址）。指定的主机名是必须由网络中的其他节点在外部解析的主机名。在上述配置中，这是VPN中机器的可解析名称。</li><li><code>rpcAddress</code>：Artemis将为RPC调用绑定的地址。</li><li><code>webAddress</code>：网络服务器应该绑定的地址。需要注意的是端口必须是来自截然不同p2pAddress并且rpcAddress如果他们是在同一台机器上。</li></ul><h4 id="引导网络"><a href="#引导网络" class="headerlink" title="引导网络"></a>引导网络</h4><p>节点使用网络图互相看到。这是一个静态签名的节点信息文件的集合，每个节点在网络中都有一个文件。大多数生产部署将通过HTTP使用高度可用，安全的网络映射分布。</p><p>对于节点（至少最初）驻留在同一个文件系统中的测试部署，可以将这些节点信息文件直接放置在节点的<code>additional-node-infos</code>目录中，节点将从该目录中选择并将它们存储在本地网络映射缓存中。节点在启动时生成自己的节点信息文件。</p><p>除了网络映射之外，网络中的所有节点都必须使用相同的一组网络参数。这些是一组保证节点间互操作性的常量。HTTP网络图分发节点自动下载的网络参数。在没有这个的情况下，网络参数必须在本地生成。这可以通过网络引导程序完成。这是一个工具，用于扫描公共目录中的所有节点配置，以生成复制到节点目录的网络参数文件。它还将每个节点的节点信息文件复制到每个其他节点，以便它们可以互相交换。</p><p>引导程序工具可以从<span class="exturl" data-url="aHR0cDovL2Rvd25sb2Fkcy5jb3JkYS5uZXQvbmV0d29yay1ib290c3RyYXBwZXItY29yZGEtWC5ZLmphcg==" title="http://downloads.corda.net/network-bootstrapper-corda-X.Y.jar">http://downloads.corda.net/network-bootstrapper-corda-X.Y.jar<i class="fa fa-external-link"></i></span> 下载，其中<code>X</code>是主要的Corda版本，并且<code>Y</code>是次要的Corda版本。</p><p>要使用它，请为要创建的每个节点创建一个包含<code>node.conf</code>文件的目录。然后运行以下命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar network-bootstrapper.jar &lt;nodes-root-dir&gt;</span><br></pre></td></tr></table></figure><p></p><p>例如，在包含这些文件的目录上运行命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├──notary.conf //公证人的node.conf文件</span><br><span class="line">├──partya.conf // Party A的node.conf文件</span><br><span class="line">└──partyb.conf //乙方的node.conf文件</span><br></pre></td></tr></table></figure><p></p><p>会生成包含三个节点的目录：公证人，partya和partyb。</p><p>该工具仅引导网络。如果新节点需要加入网络，或者现有节点已经改变节点信息中的某些内容，例如P2P地址，它就不能动态更新。为此，新的节点信息文件将需要放置在其他节点的<code>additional-node-infos</code>目录中。一个简单的方法是使用rsync。但是，如果事先知道节点集合，最终节点文件夹可以在引导程序中预生成并且只在需要时启动。</p><h4 id="白名单合同"><a href="#白名单合同" class="headerlink" title="白名单合同"></a>白名单合同</h4><p>如果您想创建区域白名单（请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvc2V0dGluZy11cC1hLWNvcmRhLW5ldHdvcmsuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/setting-up-a-corda-network.html">API：合同约束<i class="fa fa-external-link"></i></span>），则可以传入CorDapp jar列表：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar network-bootstrapper.jar &lt;nodes-root-dir&gt; &lt;path-to-first-corDapp&gt; &lt;path-to-second-corDapp&gt; ..</span><br></pre></td></tr></table></figure><p></p><p>CorDapp jars将被散列并扫描Contract类。默认情况下，该工具将生成一个名为<code>whitelist.txt</code>包含每个包含该jar散列项的合约的条目的文件。</p><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.corda.finance.contracts.asset.Obligation：decd098666b9657314870e192ced0c3519c2c9d395507a238338f8d003929de8</span><br><span class="line">net.corda.finance.contracts.asset.Cash:decd098666b9657314870e192ced0c3519c2c9d395507a238338f8d003929de9</span><br></pre></td></tr></table></figure><p></p><p>这些将被添加到<code>NetworkParameters.whitelistedContractImplementations</code>。请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvbmV0d29yay1tYXAuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/network-map.html">网络映射<i class="fa fa-external-link"></i></span>。</p><p>这意味着默认情况下，网络引导程序工具会将所有通过的CorDapps中的所有合约列入白名单。</p><p>如果根目录中有一个文件<code>whitelist.txt</code>，工具会将新的jar散列或合约附加到它。</p><p>区域操作员将维护这个白名单文件，并使用该工具将新版本的CorDapps添加到它。</p><p>警告:</p><ul><li>区域操作员必须确保该文件仅被附加。</li><li>如果操作员从列表中删除哈希值，则指向该版本的所有交易将突然失败约束验证，并且整个链会受到影响。</li><li>如果合同从白名单中删除，那么从此时开始创建的所有状态将受到HashAttachmentConstraint约束。</li></ul><p>注意：在未来的版本中，我们将提供维护合约白名单的防篡改方式。</p><p>对于约束的细粒度控制，如果多个合约存在于同一个jar中，则该工具从另一个文件中读取： <code>exclude_whitelist.txt</code>，其中包含不应列入白名单的合约列表，因此默认为严格限制： <code>HashAttachmentConstraint</code></p><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.corda.finance.contracts.asset.Cash</span><br><span class="line">net.corda.finance.contracts.asset.CommercialPaper</span><br></pre></td></tr></table></figure><p></p><h4 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h4><p>您现在可以按任何顺序启动节点。您应该看到一条横幅，一些日志行，并最终显示该节点已完全启动。<code>Node started up and registered</code></p><p>在流程管理方面，没有规定的方法。您可以手动启动jars，也可以使用systemd。</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>只有少数重要的线条打印在控制台上。有关详细信息/诊断问题，请检查日志。</p><p>日志记录是标准的log4j2，可以进行相应配置。日志默认被重定向到<code>NODE_DIRECTORY/logs/</code>中的文件。</p><h4 id="连接到节点"><a href="#连接到节点" class="headerlink" title="连接到节点"></a>连接到节点</h4><p>一旦节点启动成功，您可以连接到它作为客户端来启动协议/查询状态等。根据您的网络设置，您可能需要通过管道远程执行此操作。</p><p>请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvdHV0b3JpYWwtY2xpZW50cnBjLWFwaS5odG1s" title="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html">使用客户端RPC API<i class="fa fa-external-link"></i></span>了解如何建立RPC链接。</p><p>旁注：客户始终与具有单一身份的单个节点相关联，该身份只能看到其分类账的一部分。</p><h2 id="网络许可"><a href="#网络许可" class="headerlink" title="网络许可"></a>网络许可</h2><p>Corda网络获得许可。要连接到网络，节点需要在其<code>&lt;workspace&gt;/certificates/</code>文件夹中有三个密钥库 ：</p><ul><li><code>truststore.jks</code>，它存储可信的公钥和证书（在我们的例子中是网络根CA的证书）</li><li><code>nodekeystore.jks</code>，它存储节点的身份密钥对和证书</li><li><code>sslkeystore.jks</code>，它存储节点的TLS密钥对和证书</li></ul><p><b style="color:red">生产部署需要安全的证书颁发机构。大多数生产部署将使用现有的证书颁发机构或使用将在未来几个月内提供的软件构建一个。在此之前，以下文档可用于创建您自己的认证中心。</b></p><p>注意: 如果您正在查找有关如何连接到现有兼容区域的信息，请转至章节：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvcGVybWlzc2lvbmluZy5odG1sI2Nvbm5lY3RpbmctdG8tYS1jb21wYXRpYmlsaXR5LXpvbmU=" title="https://docs.corda.net/releases/release-V3.1/permissioning.html#connecting-to-a-compatibility-zone">连接到兼容区域<i class="fa fa-external-link"></i></span></p><h3 id="证书层级"><a href="#证书层级" class="headerlink" title="证书层级"></a>证书层级</h3><p>Corda网络有四种类型的证书颁发机构（CA）：</p><ul><li>根CA网络</li><li><b style="color:red">门卫CA</b><ul><li><b style="color:red">使用门卫CA代替根网络CA进行日常密钥签名以降低根网络CA的私钥被泄露的风险</b></li></ul></li><li>节点自己的CA<ul><li>每个节点在发布用于签署其身份密钥和TLS证书的子证书时充当自己的CA.</li></ul></li><li>合法身份的CA<ul><li>除签署交易外，Node的着名合法身份也可以颁发机密合法身份证书</li></ul></li></ul><p>以下约束也是强制性的：</p><ul><li>门卫证书由网络根发出，证书不包含扩展名</li><li><b style="color:red">知名服务身份证书由具有门卫证书的实体颁发</b></li><li>节点CA证书由具有门卫证书的实体颁发</li><li>众所周知的合法身份/TLS证书由标记为节点CA的证书颁发</li><li>保密合法身份证书由标记为众所周知的合法身份的证书颁发</li><li>Party的证书被标记为知名身份或机密身份</li><li>高于门卫/网络map的证书结构有意保留，因为它们与身份服务无关，因此在这些证书上实施特定结构没有优势。证书层次结构一致性检查是必需的，因为节点可以颁发自己的证书，并可以在证书上设置自己的角色标志，验证这些证书是否与证书层次结构设计一致，这一点很重要。作为副作用，这也作为对颁发证书的二级深度限制.</li></ul><p>所有证书必须与自定义角色扩展一起发布（见下文）。</p><p>我们可以将权限结构可视化如下：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/certificate_structure.png"></p><h3 id="密钥对和证书格式"><a href="#密钥对和证书格式" class="headerlink" title="密钥对和证书格式"></a>密钥对和证书格式</h3><p>您可以使用任何标准关键工具或Corda<code>X509Utilities</code>（使用Bouncy Castle）来创建所需的公钥/私钥对和证书。密钥对和证书应遵守以下限制：</p><ul><li>证书必须遵循X.509标准<ul><li>我们推荐X.509 v3用于向前兼容</li></ul></li><li>TLS证书必须遵循TLS v1.2标准</li><li>根网络CA，门卫CA和节点CA密钥以及节点TLS密钥必须遵循以下方案之一：<ul><li>ECDSA使用NIST P-256曲线（secp256r1）</li><li>具有3072位密钥大小的RSA</li></ul></li></ul><h3 id="证书角色扩展"><a href="#证书角色扩展" class="headerlink" title="证书角色扩展"></a>证书角色扩展</h3><p>Corda证书具有自定义的X.509 v3扩展名，用于指定证书所涉及的角色。该扩展具有OID <code>1.3.6.1.4.1.50530.1.1</code>并且不重要，因此Corda节点之外的实现可以安全地忽略它。该扩展包含一个ASN.1整数，用于标识证书的身份类型：</p><ol><li>门卫 doorman</li><li>网络map （Network Map）</li><li>服务标识 Service identity（目前仅用作分布式公证中的共享标识）</li><li>节点证书颁发机构 Node certificate authority （从中发布TLS和知名身份证书）</li><li>传输层安全 Transport layer security</li><li>众所周知的合法身份 Well-known legal identity</li><li>保密的法律身份 Confidential legal identity</li></ol><p>在典型的安装中，节点管理员不需要知道这些。但是，当节点证书由外部工具（例如组织内部署的现有PKI解决方案）管理时，了解这些约束非常重要。</p><p>证书路径验证被扩展，以便证书必须包含扩展名（如果扩展名存在于发行者的证书中）。</p><h3 id="创建根和门卫CA"><a href="#创建根和门卫CA" class="headerlink" title="创建根和门卫CA"></a>创建根和门卫CA</h3><h4 id="创建根网络CA的密钥库（keyStore）和信任库（trustStore）"><a href="#创建根网络CA的密钥库（keyStore）和信任库（trustStore）" class="headerlink" title="创建根网络CA的密钥库（keyStore）和信任库（trustStore）"></a>创建根网络CA的密钥库（keyStore）和信任库（trustStore）</h4><ol><li>创建一个新的密钥对<ul><li>这将用作根网络CA的密钥对</li></ul></li><li>为密钥对创建一个自签名证书。基本约束扩展必须设置为true<ul><li>这将被用作根网络CA的证书</li></ul></li><li>创建一个新的密钥库，并将根网络CA的密钥对和证书存储在其中以供以后使用<ul><li>此根密钥库将被根网络CA用于签署门卫CA的证书</li></ul></li><li>使用别名<code>cordarootca</code>创建一个名为<code>truststore.jks</code>并存储根网络CA证书的新Java密钥库<ul><li>随后必须将该密钥库供应给各个节点，以便它们可以将其存储在其<code>certificates</code>文件夹中</li></ul></li></ol><p><b style="color:Red">警告: 根网络CA的私钥应该受到保护并保持安全。</b></p><h4 id="创建门卫CA的密钥库"><a href="#创建门卫CA的密钥库" class="headerlink" title="创建门卫CA的密钥库"></a>创建门卫CA的密钥库</h4><ol><li>创建一个新的密钥对<ul><li>这将被用作门卫CA的密钥对</li></ul></li><li>获取使用根网络CA密钥签名的密钥对的证书。基本约束扩展必须设置为true<ul><li>这将被用作门卫CA的证书</li></ul></li><li>创建一个新的密钥库，并将门卫CA的密钥对和证书链（即门卫CA证书和根网络CA证书）存储在其中以备后用<ul><li>这个密钥库将被门卫CA用来签署节点的身份证书</li></ul></li></ol><h3 id="创建节点CA密钥库和TLS密钥库"><a href="#创建节点CA密钥库和TLS密钥库" class="headerlink" title="创建节点CA密钥库和TLS密钥库"></a>创建节点CA密钥库和TLS密钥库</h3><h4 id="创建节点CA密钥库"><a href="#创建节点CA密钥库" class="headerlink" title="创建节点CA密钥库"></a>创建节点CA密钥库</h4><ol><li>对于每个节点，创建一个新的密钥对</li><li>获取使用门卫CA密钥签名的密钥对的证书。基本约束扩展必须设置为true</li><li>使用别名<code>cordaclientca</code>创建一个名为<code>nodekeystore.jks</code>并存储密钥对的新Java密钥库<ul><li>节点将在本地存储此密钥库以签署其身份密钥和匿名密钥</li></ul></li></ol><h4 id="创建节点TLS密钥库"><a href="#创建节点TLS密钥库" class="headerlink" title="创建节点TLS密钥库"></a>创建节点TLS密钥库</h4><ol><li>对于每个节点，创建一个新的密钥对</li><li>为使用节点CA密钥签名的密钥对创建证书。基本约束扩展必须设置为 false</li><li>使用别名<code>cordaclienttls</code>创建一个名为<code>sslkeystore.jks</code>并存储密钥和证书的新Java密钥库<ul><li>节点将在本地存储此密钥库以签署其TLS证书</li></ul></li></ol><h3 id="在节点上安装证书"><a href="#在节点上安装证书" class="headerlink" title="在节点上安装证书"></a>在节点上安装证书</h3><p>对于每个节点，将以下文件复制到节点的证书目录（<code>&lt;workspace&gt;/certificates/</code>）中：</p><ol><li>节点的nodekeystore.jks密钥库</li><li>节点的sslkeystore.jks密钥库</li><li>根网络CA的truststore.jks密钥库</li></ol><h3 id="连接到兼容区域"><a href="#连接到兼容区域" class="headerlink" title="连接到兼容区域"></a>连接到兼容区域</h3><p><b style="color:red">要连接到兼容区域，您需要提交证书签名请求（CSR）以获取该区域的有效标识，从而向其证书签名授权（门卫）注册。</b></p><p>在您注册之前，您必须首先收到包含来自区域操作员的根证书的信任存储文件。然后运行以下命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar --initial-registration --network-root-truststore-password &lt;trust store password&gt;</span><br></pre></td></tr></table></figure><p></p><p>默认情况下，它会期望信任存储文件位于该位置<code>certificates/network-root-truststore.jks</code>。这可以用附加<code>--network-root-truststore</code>标志覆盖。</p><p>将根据从节点配置中获取的节点信息创建证书签名请求。生成请求需要来自节点配置文件的以下信息。</p><ul><li>myLegalName： 您公司的法定名称为X.500字符串。X.500允许区分具有相同名称的实体，因为合法名称在网络上必须是唯一的。如果另一个节点已经被许可使用该名称，则许可服务器将自动拒绝该请求。如果违反合法名称规则，请求也将被拒绝，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2VuZXJhdGluZy1hLW5vZGUuaHRtbCNub2RlLW5hbWluZw==" title="https://docs.corda.net/releases/release-V3.1/generating-a-node.html#node-naming">节点命名<i class="fa fa-external-link"></i></span>以获取更多信息。</li><li>电子邮件地址： 例如“<span class="exturl" data-url="bWFpbHRvOmFkbWluQGNvbXBhbnkuY29t" title="mailto:admin@company.com">admin@company.com<i class="fa fa-external-link"></i></span>“</li><li>DEVMODE： 必须设置为false</li><li>compatibilityZoneURL：<br>Corda兼容区域网络管理服务根URL。<br>由Corda节点生成的一对新的私钥和公钥将用于创建请求。<br>该实用程序将向门卫服务器提交请求并定期轮询结果以检索证书。一旦请求被批准并且从服务器下载证书，节点将使用证书和生成的私钥创建密钥库和信任库。</li></ul><p>注意: 如果批准过程花费的时间比预期的长，您可以随时退出。请求过程将在重新启动时恢复。</p><p>只有在节点首次连接到网络或证书过期时，才需要此过程。</p><h2 id="Network-Map"><a href="#Network-Map" class="headerlink" title="Network Map"></a>Network Map</h2><p>网络map是已签名的NodeInfo对象的集合。每个NodeInfo都由其节点签名代表，因此不能被篡改。它在兼容区域中形成一组可达节点。节点可以从两个来源接收这些对象：</p><ul><li>一个讲述简单的基于HTTP的协议的网络映射服务器。</li><li>节点的目录中的<code>additional-node-infos</code>目录。</li></ul><p>网络映射服务器还分配参数文件，该参数文件为所有节点需要同意保持同步的各种设置定义值。</p><p>注意:在Corda 3中没有提供HTTP网络映射服务器的实现。这是因为兼容性区域管理其成员资格（数据库，票务工作流程，HSM硬件等）的细节预计会因运营商而异，所以我们提供了一个简单的基于REST的协议，用于上载/下载NodeInfos并管理网络参数。未来版本的Corda可能会为运行测试区提供一个简单的“存根”实现。在Corda 3中，运行测试网络的正确方法是通过您自己的机制分发相关文件。我们提供了一个工具来自动完成这项任务的大部分（见下文）。</p><h3 id="HTTP网络map协议"><a href="#HTTP网络map协议" class="headerlink" title="HTTP网络map协议"></a>HTTP网络map协议</h3><p>如果节点配置了<code>compatibilityZoneURL</code>配置，那么它首先将其自己的签名上传<code>NodeInfo</code> 到服务器（<b style="color:Red">并且每次启动时都会更改</b>），然后继续下载整个网络map。网络map由一个<code>NodeInfo</code>哈希列表组成。节点定期轮询网络映射（基于HTTP缓存有效头），并且下载和缓存任何新条目。不再存在的条目将从节点的缓存中删除。</p><p>网络地图服务的一组REST端点如下。</p><table><thead><tr><th style="text-align:center">请求方法</th><th style="text-align:center">路径</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">/network-map/publish</td><td style="text-align:center">让节点将其签名NodeInfo对象上传到网络地图。</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">/network-map/ack-parameters</td><td style="text-align:center">为了节点操作员确认网络图，新参数被接受以供将来更新。</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">/network-map</td><td style="text-align:center">检索当前签名的网络地图对象。整个对象用附加的网络映射证书进行签名。</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">/network-map/node-info/{hash}</td><td style="text-align:center">检索NodeInfo网络地图对象中指定的签名。</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">/network-map/network-parameters/{hash}</td><td style="text-align:center">检索签名的网络参数（见下文）。整个对象用附加的网络映射证书进行签名。</td></tr></tbody></table><p>HTTP用于网络map服务，而不是Corda自己的基于AMQP的对等消息传递协议，以便将服务器置于缓存内容交付网络后面，如Cloudflare，Akamai，Amazon Cloudfront等。通过使用工业HTTP缓存网络，map服务器可以更有效地屏蔽DoS攻击。另外，对于分发很少变化的小文件的情况，HTTP是一个很好理解和优化的协议。Corda自己的协议设计用于使用签名的二进制消息分离为并行和嵌套流的身份验证身份之间的复杂多方会话，这对于网络映射分发不是必需的。</p><h3 id="additional-node-infos目录"><a href="#additional-node-infos目录" class="headerlink" title="additional-node-infos目录"></a><code>additional-node-infos</code>目录</h3><p>除了HTTP网络map服务外，或者如果节点没有连接到一个节点，节点将轮询位于其基本目录中的<code>additional-node-infos</code>目录的内容。预计每个文件都是网络地图服务发布的相同签名<code>NodeInfo</code>对象。这些会自动添加到节点的缓存中，并可用于补充或替换HTTP网络图。如果同一节点通过这两种机制进行广告，则采用最新的节点。</p><p>启动时，节点会生成自己的签名节点信息文件，格式的文件名nodeInfo-${hash}。它也可以使用–just-generate-node-info命令行标志生成而不需要启动节点。要创建一个没有HTTP网络映射服务的简单网络，只需将该文件放置在该网络中每个节点的<code>additional-node-infos</code>目录中即可。例如，一个简单的方法是使用rsync。</p><p>通常，测试网络具有提前知晓的结构。为了创建这样的网络，我们提供了一个 <code>network-bootstrapper</code>工具。如果给定网络中每台机器的IP地址/域名，此工具会预先生成节点配置目录。生成的节点目录包含网络中每个其他节点的NodeInfos以及网络参数文件和身份证书。生成的节点不需要一次全部在线 - 一个未与之交互的离线节点不会以任何方式影响网络。因此，像这样生成的测试集群可以按照您可能需要的最大大小来确定大小，然后根据需要进行放大和缩小。</p><p>更多信息可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvc2V0dGluZy11cC1hLWNvcmRhLW5ldHdvcmsuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/setting-up-a-corda-network.html">设置Corda网络<i class="fa fa-external-link"></i></span>中找到。</p><h3 id="网络参数"><a href="#网络参数" class="headerlink" title="网络参数"></a>网络参数</h3><p>网络参数是一组值，参与该区域的每个节点需要达成一致并用于正确互操作。它们可以被认为是Corda部署的各个方面的封装，理性人可能会不同意。虽然其他区块链/DLT系统通常需要源代码fork以改变各种常量（如加密货币中的硬币总数，使用的端口号等），但在Corda中，我们将这些决策重构为单独的文件，并允许“区域运营商”对其进行决策。操作员签署一个包含这些值的数据结构，并将它们与网络map一起分发。提供工具以获得用户选择同意新版本参数的权限，并确保每个人同时切换到它们。</p><p>如果节点正在使用HTTP网络map服务，那么在首次启动时，它将下载已签名的网络参数，将其缓存在<code>network-parameters</code>文件中并将其应用到节点上。</p><p>警告: 如果<code>network-parameters</code>文件发生更改并且不再与网络map服务所发布的内容相匹配，则该节点将自动关闭。解决方法是删除不正确的文件并重新启动节点，以便可以再次下载参数。</p><p>如果节点没有使用HTTP网络map服务，那么预计签名文件是通过其他方式提供的。对于这种情况，网络引导程序工具除了生成网络参数文件之外，还会将节点信息文件分发到节点目录。</p><p>当前的一组网络参数：</p><ul><li>minimumPlatformVersion：节点必须运行的最低平台版本。低于此值的任何节点都不会启动。</li><li>notaries： 在兼容区域中允许的公证人的身份和验证类型（验证或不验证）的列表。</li><li>maxMessageSize： （目前这被忽略，但它将在未来的版本中发布。）</li><li>maxTransactionSize：交易的最大允许字节数。这是交易对象及其附件的大小。</li><li>modifiedTime： 网络参数上次由兼容性区域运算符修改的时间。</li><li>epoch： 网络参数的版本号。从1开始，只要有任何参数改变，它就会一直增加。</li><li>whitelistedContractImplementations：合同代码的白名单版本列表。对于每个合同类，都有包含该合同的已批准CorDapp jar版本的散列列表。点击此处了解更多关于区域限制的信息<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWNvbnRyYWN0LWNvbnN0cmFpbnRzLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html">API：合同限制<i class="fa fa-external-link"></i></span></li></ul><p>更多参数将在未来版本中添加，以管理诸如允许的端口号，节点在从区域被逐出之前可以离线多久，区域成员是否需要IPv6连接，所需的加密算法和部署时间表（例如用于后期量子密码学），与SGX有关的参数等等。</p><h3 id="网络参数更新过程"><a href="#网络参数更新过程" class="headerlink" title="网络参数更新过程"></a>网络参数更新过程</h3><p>如果需要更改网络参数，Corda区域操作员将开始更新过程。有很多原因可能导致这一决定：例如，添加公证人，设置添加的新字段以实现平滑的网络互操作性，或者需要更改现有的兼容性常量。</p><p>注意: 未来版本可能支持分阶段推出网络参数更改的概念。</p><p>要同步兼容区域中的所有节点以使用新的一组网络参数，将提供两种RPC方法。该流程需要人员交互和对变更的批准，因此节点操作员可以在同意之前查看差异。</p><p>当更新即将发生时，网络map服务开始用通常的网络map数据通告附加信息。它包括新的网络参数哈希，更改说明和更新截止日期。节点向网络映射服务器查询新的一组参数。</p><p>新的参数集被公布的事实显示在节点日志中，并带有“下载的新网络参数”消息，并且通过RPC连接的程序可以通过使用该<code>CordaRPCOps.networkParametersFeed</code>方法接收<code>ParametersUpdateInfo</code>。通常，区域操作员还会通过电子邮件向节点操作员发送电子邮件，让他们了解即将发生的更改的详细信息，以及理由，如何提交对象，截止日期等。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Data class containing information about the scheduled network parameters update. The info is emitted every time node</span></span><br><span class="line"><span class="comment"> * receives network map with [ParametersUpdate] which wasn't seen before. For more information see: [CordaRPCOps.networkParametersFeed] and [CordaRPCOps.acceptNewNetworkParameters].</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> hash new [NetworkParameters] hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> parameters new [NetworkParameters] data structure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> description description of the update</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> updateDeadline deadline for accepting this update using [CordaRPCOps.acceptNewNetworkParameters]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ParametersUpdateInfo</span></span>(</span><br><span class="line">        <span class="keyword">val</span> hash: SecureHash,</span><br><span class="line">        <span class="keyword">val</span> parameters: NetworkParameters,</span><br><span class="line">        <span class="keyword">val</span> description: String,</span><br><span class="line">        <span class="keyword">val</span> updateDeadline: Instant</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>节点管理员可以检查更改并决定是否要接受它。在更新截止日期之前应该进行批准。在截止日期前不批准的节点可能会被区域运营商从网络地图中删除，但这是由运营商决定的决定。例如，运营商也可能会选择更改截止日期。</p><p>如果网络运营商开始通告一组不同的新参数，那么该新的组将覆盖前一组。只有最新的更新才能被接受。</p><p>要将参数批准发送回区域操作员， 必须使用更新来调用RPC方法<code>fun acceptNewNetworkParameters(parametersHash: SecureHash)</code>。请注意，批准不能撤消。您可以通过Corda shell执行<code>parametersHash</code>操作（请参阅Shell）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run acceptNewNetworkParameters parametersHash: &quot;ba19fc1b9e9c1c7cbea712efda5f78b53ae4e5d123c89d02c9da44ec50e9c17d&quot;</span><br></pre></td></tr></table></figure><p></p><p>如果管理员不接受更新，则下一次该节点在截止日期后轮询网络映射，则通告的网络参数将为更新后的网络参数。前一组参数将不再有效。此时节点将自动关闭，并要求节点操作员再次将其恢复。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>随着Corda平台的不断发展和新功能的增加，拥有版本控制系统变得非常重要，它允许用户轻松比较版本并了解可用功能。每个Corda发行版都使用标准的语义版本方案<code>major.minor.patch</code>。这在公开域中发布时非常有用，但对于在平台上工作的开发人员不友好。它首先必须被解析，然后他们有三个独立的部分来确定API差异。发布版本仍然有用，节点发送的每个MQ消息都将其附加到标题属性<code>release-version</code>以进行调试。</p><p>使用单个增量整数值来表示Corda平台的API版本（称为平台版本）要容易得多。它类似于Android的API级别。它从1开始，每增加一个版本，就会增加1，这会改变整个平台上任何公开暴露的API。这包括节点本身的公共API，RPC系统，消息传递，序列化等。API始终保持向后兼容性，并且使用弃用从旧API迁移。在极少数情况下，API可能不得不被删除，例如由于安全问题。平台版本和发布版本之间没有任何关系 - 主要，次要或补丁值的更改可能会或可能不会增加平台版本。</p><p>平台版本是节点<code>NodeInfo</code>对象的一部分，可以从中获得<code>ServiceHub</code>。这使得CorDapp能够找出正在运行的版本并确定是否有可用的功能。当一个节点向网络映射服务注册时，它将使用该节点的平台版本来强制执行网络的最低​​版本要求。</p><p>注意: 未来版本可能会引入目标平台版本的概念，这与Android的<code>targetSdkVersion</code>类似，并且会为平台行为发生变化的情况提供维护行为兼容性的手段。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】Systemd添加自定义系统服务设置自定义开机启动</title>
      <link href="//linux/Systemd%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.html"/>
      <url>//linux/Systemd%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="服务权限"><a href="#服务权限" class="headerlink" title="服务权限"></a>服务权限</h2><p>systemd有系统和用户区分；系统（<code>/user/lib/systemd/system/</code>）、用户（<code>/etc/lib/systemd/user/</code>）.一般系统管理员手工创建的单元文件建议存放在<code>/etc/systemd/system/</code>目录下面。</p><h2 id="创建服务文件"><a href="#创建服务文件" class="headerlink" title="创建服务文件"></a>创建服务文件</h2><p>一般是放在<code>/etc/systemd/system/</code>目录下面，命名都是<code>xxx.service</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=kibana</span><br><span class="line">Group=kibana</span><br><span class="line">PIDFile=/run/nginx.pid</span><br><span class="line">EnvironmentFile=-/etc/default/kibana</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kibana</span><br><span class="line">ExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.conf</span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">Restart=always</span><br><span class="line">WorkingDirectory=/</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p></p><p>下面是具体字段的说明：</p><p><code>[Unit]</code>单元的说明：</p><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Description</td><td style="text-align:center">服务的简单描述</td></tr><tr><td style="text-align:center">Documentation</td><td style="text-align:center">服务文档</td></tr><tr><td style="text-align:center">Before、After</td><td style="text-align:center">定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。</td></tr><tr><td style="text-align:center">Requires</td><td style="text-align:center">这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。</td></tr><tr><td style="text-align:center">Wants</td><td style="text-align:center">推荐使用。这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</td></tr></tbody></table><p><code>[Service]</code>单元的说明：</p><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Type=simple（默认值）</td><td style="text-align:center">systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。</td></tr><tr><td style="text-align:center">Type=forking</td><td style="text-align:center">systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。</td></tr><tr><td style="text-align:center">Type=oneshot</td><td style="text-align:center">这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。</td></tr><tr><td style="text-align:center">Type=notify</td><td style="text-align:center">与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。</td></tr><tr><td style="text-align:center">Type=dbus</td><td style="text-align:center">若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。</td></tr><tr><td style="text-align:center">Type=idle</td><td style="text-align:center">systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。</td></tr><tr><td style="text-align:center">PIDFile</td><td style="text-align:center">pid文件路径</td></tr><tr><td style="text-align:center">ExecStart</td><td style="text-align:center">指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。</td></tr><tr><td style="text-align:center">ExecReload</td><td style="text-align:center">指定单元停止时执行的命令或者脚本。</td></tr><tr><td style="text-align:center">ExecStop</td><td style="text-align:center">指定单元停止时执行的命令或者脚本。</td></tr><tr><td style="text-align:center">PrivateTmp</td><td style="text-align:center">True表示给服务分配独立的临时空间</td></tr><tr><td style="text-align:center">Restart</td><td style="text-align:center">这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。</td></tr><tr><td style="text-align:center">RemainAfterExit</td><td style="text-align:center">如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</td></tr></tbody></table><p><code>[Install]</code>单元的说明：</p><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Alias</td><td style="text-align:center">为单元提供一个空间分离的附加名字。</td></tr><tr><td style="text-align:center">RequiredBy</td><td style="text-align:center">单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。</td></tr><tr><td style="text-align:center">WantBy</td><td style="text-align:center">单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。</td></tr><tr><td style="text-align:center">Also</td><td style="text-align:center">指出和单元一起安装或者被协助的单元。</td></tr><tr><td style="text-align:center">DefaultInstance</td><td style="text-align:center">实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</td></tr></tbody></table><h2 id="重载服务"><a href="#重载服务" class="headerlink" title="重载服务"></a>重载服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure><p>就会在<code>/etc/systemd/system/multi-user.target.wants/</code>目录下新建一个<code>/usr/lib/systemd/system/nginx.service</code> 文件的链接。</p><h2 id="操作服务"><a href="#操作服务" class="headerlink" title="操作服务"></a>操作服务</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo journalctl -f -u nginx.service</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reload nginx.service</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop nginx.service</span><br></pre></td></tr></table></figure><h2 id="原创"><a href="#原创" class="headerlink" title="原创"></a>原创</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuNTFjdG8uY29tL3dqYjEwMDAwLzE3ODgzNjQ=" title="http://blog.51cto.com/wjb10000/1788364">systemd添加自定义系统服务设置自定义开机启动<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> systemd </tag>
            
            <tag> rc.d </tag>
            
            <tag> 服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda Nodes</title>
      <link href="//blockchain/corda/Corda-Nodes.html"/>
      <url>//blockchain/corda/Corda-Nodes.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="创建本地节点"><a href="#创建本地节点" class="headerlink" title="创建本地节点"></a>创建本地节点</h2><p>每个Corda节点都有以下的结构<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── certificates            // The node&apos;s certificates</span><br><span class="line">├── corda-webserver.jar     // The built-in node webserver</span><br><span class="line">├── corda.jar               // The core Corda libraries</span><br><span class="line">├── logs                    // The node logs</span><br><span class="line">├── node.conf               // The node&apos;s configuration files</span><br><span class="line">├── persistence.mv.db       // The node&apos;s database</span><br><span class="line">└── cordapps                // The CorDapps jars installed on the node</span><br></pre></td></tr></table></figure><p></p><p>该节点通过编辑其<code>node.conf</code>文件进行配置。通过将CorDapp JAR放入该<code>cordapps</code>文件夹中来在节点上安装CorDapps 。</p><p>在开发模式下（即何时<code>devMode = true</code>，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY29yZGEtY29uZmlndXJhdGlvbi1maWxlLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html">节点配置<i class="fa fa-external-link"></i></span>以获取更多信息）， 如果所需的密钥库不存在，则<code>certificates</code>目录中将填充预先配置的密钥库。这可以确保开发人员能够尽快获得节点的工作。但是，这些预配置的密钥库不安全。要了解更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvcGVybWlzc2lvbmluZy5odG1s" title="https://docs.corda.net/releases/release-V3.1/permissioning.html">网络许可<i class="fa fa-external-link"></i></span>。</p><h2 id="节点命名"><a href="#节点命名" class="headerlink" title="节点命名"></a>节点命名</h2><p>节点的名称必须是有效的X.500专有名称。为了与其他实现（特别是TLS实现）兼容，我们将允许的X.500名称属性类型约束为X.509证书（在RFC 3280中指定）的最小支持集的子集以及locality属性：</p><ul><li>组织（O）</li><li>州（ST）</li><li>地点（L）</li><li>国家（C）</li><li>组织单元（OU）</li><li>通用名称（CN）</li></ul><p>更多信息参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2VuZXJhdGluZy1hLW5vZGUuaHRtbCNub2RlLW5hbWluZw==" title="https://docs.corda.net/releases/release-V3.1/generating-a-node.html#node-naming">这个网址<i class="fa fa-external-link"></i></span>！</p><h2 id="Cordform任务"><a href="#Cordform任务" class="headerlink" title="Cordform任务"></a>Cordform任务</h2><p>Corda提供了一个名为的gradle插件<code>Cordform</code>，允许您自动生成和配置一组用于测试和演示的节点。这是一个<code>Cordform</code>调用的示例任务<code>deployNodes</code>，它创建三个节点，在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhcHAtdGVtcGxhdGUta290bGluL2Jsb2IvcmVsZWFzZS1WMy9idWlsZC5ncmFkbGUjTDEwMA==" title="https://github.com/corda/cordapp-template-kotlin/blob/release-V3/build.gradle#L100">Kotlin CorDapp模板<i class="fa fa-external-link"></i></span>中定义：<br></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> deployNodes(type: net.corda.plugins.Cordform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line">    directory <span class="string">"./build/nodes"</span></span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Notary,L=London,C=GB"</span></span><br><span class="line">        <span class="comment">// The notary will offer a validating notary service.</span></span><br><span class="line">        notary = [validating : <span class="keyword">true</span>]</span><br><span class="line">        p2pPort  <span class="number">10002</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10003</span></span><br><span class="line">            adminPort <span class="number">10023</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No webport property, so no webserver will be created.</span></span><br><span class="line">        h2Port   <span class="number">10004</span></span><br><span class="line">        <span class="comment">// Includes the corda-finance CorDapp on our node.</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyA,L=London,C=GB"</span></span><br><span class="line">        p2pPort  <span class="number">10005</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10006</span></span><br><span class="line">            adminPort <span class="number">10026</span></span><br><span class="line">        &#125;</span><br><span class="line">        webPort  <span class="number">10007</span></span><br><span class="line">        h2Port   <span class="number">10008</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">        <span class="comment">// Grants user1 all RPC permissions.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"ALL"</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyB,L=New York,C=US"</span></span><br><span class="line">        p2pPort  <span class="number">10009</span></span><br><span class="line">        rpcSettings &#123;</span><br><span class="line">            port <span class="number">10010</span></span><br><span class="line">            adminPort <span class="number">10030</span></span><br><span class="line">        &#125;</span><br><span class="line">        webPort  <span class="number">10011</span></span><br><span class="line">        h2Port   <span class="number">10012</span></span><br><span class="line">        cordapps = [<span class="string">"net.corda:corda-finance:$corda_release_version"</span>]</span><br><span class="line">        <span class="comment">// Grants user1 the ability to start the MyFlow flow.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"StartFlow.net.corda.flows.MyFlow"</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>要将节点配置扩展到<code>deployNodes</code>任务中定义的属性之外，请使用<code>configFile</code>路径（相对或绝对）设置为其他配置文件的属性。根据node.conf，该文件应该遵循标准的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY29yZGEtY29uZmlndXJhdGlvbi1maWxlLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html">节点配置<i class="fa fa-external-link"></i></span>格式。该文件的属性将被附加到生成的节点配置中。通过<code>-PconfigFile</code>命令行选项运行Gradle任务时，也可以添加文件的路径。但是，相同的文件将应用于所有节点。在前面的示例<code>PartyB</code>节点之后，将有一个从文件添加的额外配置选项<code>none-b.conf</code>：<br></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> deployNodes(type: net.corda.plugins.Cordform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line">    [...]</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=PartyB,L=New York,C=US"</span></span><br><span class="line">        [...]</span><br><span class="line">        <span class="comment">// Grants user1 the ability to start the MyFlow flow.</span></span><br><span class="line">        rpcUsers = [[ user: <span class="string">"user1"</span>, <span class="string">"password"</span>: <span class="string">"test"</span>, <span class="string">"permissions"</span>: [<span class="string">"StartFlow.net.corda.flows.MyFlow"</span>]]]</span><br><span class="line">        configFile = <span class="string">"samples/trader-demo/src/main/resources/none-b.conf"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行此任务将在<code>build/nodes</code>文件夹中创建三个节点：</p><ul><li>一个<code>Notary</code>节点：<ul><li>提供验证公证服务</li><li>没有网络服务器（因为<code>webPort</code>没有定义）</li><li>正在运行<code>corda-finance</code>CorDapp</li></ul></li><li><code>PartyA</code>和<code>PartyB</code>节点：<ul><li>不提供任何服务</li><li>将有一个网络服务器（因为<code>webPort</code>已定义）</li><li>正在运行<code>corda-finance</code> CorDapp</li><li>有一个RPC用户，<code>user1</code>可以用来通过RPC登录到节点</li></ul></li></ul><p>此外，所有三个节点都将包含项目源文件夹中定义的所有CorDapps，即使这些CorDapps未列入每个节点的<code>cordapps</code>条目中。这意味着<code>deployNodes</code>，例如从模板CorDapp，运行任务会自动构建模板CorDapp并将其添加到每个节点。</p><p><b style="color:red">您可以扩展<code>deployNodes</code>以生成其他节点。</b></p><p>这<code>Dockerform</code>是一个<code>Cordform</code>的姐姐任务。它具有几乎相同的语法，并产生非常相似的结果 - 通过使用<code>docker-compose</code>增加一个额外的文件来增强节点的易用性。您可以在下面<code>IRS Demo&lt;https://github.com/corda/corda/blob/release-V3.0/samples/irs-demo/cordapp/build.gradle#L111&gt;</code> 的主Corda GitHub存储库的samples目录中找到示例任务：<br></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> rpcUsersList = [</span><br><span class="line">    [<span class="string">'username'</span> : <span class="string">"user"</span>,</span><br><span class="line">     <span class="string">'password'</span> : <span class="string">"password"</span>,</span><br><span class="line">     <span class="string">'permissions'</span> : [</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.flows.AutoOfferFlow\$Requester"</span>,</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.flows.UpdateBusinessDayFlow\$Broadcast"</span>,</span><br><span class="line">             <span class="string">"StartFlow.net.corda.irs.api.NodeInterestRates\$UploadFixesFlow"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.vaultQueryBy"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.networkMapSnapshot"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.currentNodeTime"</span>,</span><br><span class="line">             <span class="string">"InvokeRpc.wellKnownPartyFromX500Name"</span></span><br><span class="line">     ]]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// (...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> prepareDockerNodes(type: net.corda.plugins.Dockerform, dependsOn: [<span class="string">'jar'</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Notary Service,L=Zurich,C=CH"</span></span><br><span class="line">        notary = [validating : <span class="keyword">true</span>]</span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Bank A,L=London,C=GB"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Bank B,L=New York,C=US"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project("</span>:finance<span class="string">").group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    node &#123;</span><br><span class="line">        name <span class="string">"O=Regulator,L=Moscow,C=RU"</span></span><br><span class="line">        cordapps = [<span class="string">"$&#123;project.group&#125;:finance:$corda_release_version"</span>]</span><br><span class="line">        rpcUsers = rpcUsersList</span><br><span class="line">        useTestClock <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不需要指定端口，因为每个节点都是独立的容器，所以不会发生端口冲突。运行该任务将创建与“Cordform任务”中所述的相同的文件夹结构<code>Dockerfile</code>，并<code>docker-compose.yml</code>在每个节点目录中和<code>build/nodes</code>目录中添加一个附加文件夹结构。默认情况下，每个节点都公开端口<code>10003</code>，这是RPC连接的默认端口。</p><p>要创建我们<code>deployNodes</code>任务中定义的节点，请在定义任务的项目根目录的终端窗口中运行以下命令<code>deployNodes</code>：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew deployNodes</span><br></pre></td></tr></table></figure><p></p><p>这将在<code>build/nodes</code>文件夹中创建节点。将为该deployNodes任务中定义的每个节点生成一个节点文件夹，以及runnodes用于同时运行所有节点以进行测试和开发的shell脚本（或Windows上的批处理文件）。如果您对CorDapp源代码或deployNodes任务进行了任何更改，则需要重新运行该任务以查看更改才能生效。</p><p>现在可以按照运行节点中的说明<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvcnVubmluZy1hLW5vZGUuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/running-a-node.html">运行节点<i class="fa fa-external-link"></i></span>。</p><h2 id="本地运行节点"><a href="#本地运行节点" class="headerlink" title="本地运行节点"></a>本地运行节点</h2><p>出于测试目的，本地运行Corda节点有几种方法。</p><h3 id="一次启动所有节点"><a href="#一次启动所有节点" class="headerlink" title="一次启动所有节点"></a>一次启动所有节点</h3><p><code>runnodes</code>是一个shell脚本（或Windows上的批处理文件），<code>deployNodes</code>可以让您快速启动所有节点及其Web服务器。<code>runnodes</code>只能用于测试目的。</p><p><code>runnodes</code>通过从项目的根目录运行以下命令来启动节点：命令：<code>build/nodes/runnodes</code>.</p><p>如果<code>OutOfMemoryError</code>在与节点进行交互时收到异常，则需要增加可供其使用的Java堆内存量，这可以在单独运行时执行。</p><h3 id="启动单个Corda节点"><a href="#启动单个Corda节点" class="headerlink" title="启动单个Corda节点"></a>启动单个Corda节点</h3><p>通过打开节点文件夹中的终端窗口并运行以下命令来运行节点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda.jar</span><br></pre></td></tr></table></figure><p></p><p>默认情况下，节点将查找调用的配置文件<code>node.conf</code>和在当前工作目录中调用的CorDapps <code>cordapps</code>文件夹。您可以在命令行上覆盖配置文件和工作区路径（例如 <code>./corda.jar --config-file=test.conf --base-directory=/opt/corda/nodes/test</code>）。</p><p>您可以使用<code>-Xmx</code>命令行参数来增加节点可用的Java堆内存量。例如，以下内容将以2048MB的堆大小运行节点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx2048m -jar corda.jar</span><br></pre></td></tr></table></figure><p></p><p>也可以通过在节点的文件夹中打开终端窗口并运行以下命令来运行节点的Web服务器：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar corda-webserver.jar</span><br></pre></td></tr></table></figure><p></p><h3 id="启动启用远程调试的节点"><a href="#启动启用远程调试的节点" class="headerlink" title="启动启用远程调试的节点"></a>启动启用远程调试的节点</h3><p><b style="color:red">要启用节点的远程调试，请从终端窗口运行以下命令：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dcapsule.jvm.args=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005&quot; -jar corda.jar</span><br></pre></td></tr></table></figure><p></p><p>该命令行将在端口5005上启动调试器并暂停进程，等待调试器附件。</p><h2 id="部署节点"><a href="#部署节点" class="headerlink" title="部署节点"></a>部署节点</h2><p>这些说明适用于想要将Corda节点部署到服务器的人员，无论他们是按照<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2VuZXJhdGluZy1hLW5vZGUuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/generating-a-node.html">本地创建节点<i class="fa fa-external-link"></i></span>中的指示信息开发并测试了CorDapp 还是正在部署第三方CorDapp。</p><h3 id="Linux：作为系统服务安装并运行Corda"><a href="#Linux：作为系统服务安装并运行Corda" class="headerlink" title="Linux：作为系统服务安装并运行Corda"></a>Linux：作为系统服务安装并运行Corda</h3><p>我们建议创建系统服务来运行节点和可选的Web服务器。这提供日志记录和服务处理，并确保Corda服务在启动时运行。</p><p>具体细节查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZGVwbG95aW5nLWEtbm9kZS5odG1s" title="https://docs.corda.net/releases/release-V3.1/deploying-a-node.html">这里<i class="fa fa-external-link"></i></span>！</p><h3 id="测试安装是否正确"><a href="#测试安装是否正确" class="headerlink" title="测试安装是否正确"></a>测试安装是否正确</h3><p>运行节点后，然后通过rpc服务尝试连接节点，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet your-hostname.example.com 10002</span><br></pre></td></tr></table></figure><p></p><p>如果你收到这个信息<code>Escape character is ^]</code>，说明Corda已经启动并且可使用。</p><h2 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h2><h3 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h3><p>Corda all-in-one <code>corda.jar</code>文件由<code>gradle buildCordaJAR</code>任务生成，默认为从当前工作目录中的<code>node.conf</code>文件读取配置。可以使用<code>--config-file</code> 命令行选项以不同名称或不同文件位置（相对路径相对于当前工作目录）为目标来配置此行为。另外，命令行<code>--base-directory</code>选项会更改Corda节点工作空间的位置，如果指定<code>node.conf</code>，则工作空间的根目录中会出现配置文件。</p><p>用于该<code>gradle deployNodes</code>任务的配置文件模板将在该文件夹<code>/config/dev</code>中找到。还要注意，从<code>:node</code>gradle模块的内置资源文件<code>/node/src/main/resources/reference.conf</code>中加载了一组基本的默认值。此文件中的所有属性都可以在文件配置中进行过滤，对于很少更改的属性，此默认值允许将该属性从配置文件中排除。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Corda配置文件使用JSON超集的HOCON格式。它具有多种功能，使其成为配置格式非常有用。请访问他们的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGVzYWZlaHViL2NvbmZpZy9ibG9iL21hc3Rlci9IT0NPTi5tZA==" title="https://github.com/typesafehub/config/blob/master/HOCON.md">页面<i class="fa fa-external-link"></i></span>了解更多详情。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>用于托管IRS Demo服务的常规节点配置文件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">dataSourceProperties : &#123;</span><br><span class="line">    dataSourceClassName : org.h2.jdbcx.JdbcDataSource</span><br><span class="line">    &quot;dataSource.url&quot; : &quot;jdbc:h2:file:&quot;$&#123;baseDirectory&#125;&quot;/persistence&quot;</span><br><span class="line">    &quot;dataSource.user&quot; : sa</span><br><span class="line">    &quot;dataSource.password&quot; : &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:10004&quot;</span><br><span class="line">rpcUsers : [</span><br><span class="line">    &#123; username=user1, password=letmein, permissions=[ StartFlow.net.corda.protocols.CashProtocol ] &#125;</span><br><span class="line">]</span><br><span class="line">devMode : true</span><br></pre></td></tr></table></figure><p></p><p>简单的Notary配置文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Notary Service,OU=corda,L=London,C=GB&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br><span class="line">p2pAddress : &quot;localhost:12345&quot;</span><br><span class="line">rpcSettings = &#123;</span><br><span class="line">    useSsl = false</span><br><span class="line">    standAloneBroker = false</span><br><span class="line">    address : &quot;my-corda-node:10003&quot;</span><br><span class="line">    adminAddress : &quot;my-corda-node:10004&quot;</span><br><span class="line">&#125;</span><br><span class="line">webAddress : &quot;localhost:12347&quot;</span><br><span class="line">notary : &#123;</span><br><span class="line">    validating : false</span><br><span class="line">&#125;</span><br><span class="line">devMode : true</span><br><span class="line">compatibilityZoneURL : &quot;https://cz.corda.net&quot;</span><br></pre></td></tr></table></figure><p></p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>下面是字段的解释，请查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY29yZGEtY29uZmlndXJhdGlvbi1maWxlLmh0bWwjZmllbGRz" title="https://docs.corda.net/releases/release-V3.1/corda-configuration-file.html#fields">这里<i class="fa fa-external-link"></i></span>。</p><h2 id="客户端RPC"><a href="#客户端RPC" class="headerlink" title="客户端RPC"></a>客户端RPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Corda提供了一个客户端库，允许您使用JVM兼容语言轻松编写客户端以与正在运行的节点进行交互。库使用消息队列协议连接到节点，然后提供一个简单的RPC接口与节点进行交互。正常情况下，您会对Java对象进行调用，并且会为您处理来回编组。</p><p>客户端库的起点是<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpL2phdmFkb2MvbmV0L2NvcmRhL2NsaWVudC9ycGMvQ29yZGFSUENDbGllbnQuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/api/javadoc/net/corda/client/rpc/CordaRPCClient.html"><code>CordaRPCClient</code><i class="fa fa-external-link"></i></span>类。<code>CordaRPCClient</code>提供了一个<code>start</code>返回<code>CordaRPCConnection</code>的方法。一个<code>CordaRPCConnection</code>允许您访问的实现 <code>CordaRPCOps</code>接口，这个接口有<code>proxy</code>方法（kotlin）或<code>getProxy()</code>（Java中）。可以订阅RPC操作返回的可观察数据，以便从节点接收正在进行的更新流。有关此功能的更多详细信息在该proxy方法的文档中提供。</p><p><b style="color:#00f">警告: 返回的<code>CordaRPCConnection</code>创建并消耗少量服务器端资源的成本有点高。当你完成它时，请调用<code>close</code>方法。或者，您可以在传入的lambda结束后使用CordaRPCClient上的<code>use</code>方法自动清理。不要为每次调用创建新的代理 - 重复使用现有的代理。</b></p><p>有关使用RPC API的简要教程，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvdHV0b3JpYWwtY2xpZW50cnBjLWFwaS5odG1s" title="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html">使用客户端RPC API<i class="fa fa-external-link"></i></span>。</p><h3 id="RPC权限"><a href="#RPC权限" class="headerlink" title="RPC权限"></a>RPC权限</h3><p>对于节点的所有者通过RPC与其节点进行交互，他们必须定义一个或多个RPC用户。每个用户都使用用户名和密码进行身份验证，并为其分配一组权限，以控制他们可以执行哪些RPC操作。</p><p>通过将RPC用户添加到rpcUsers节点node.conf文件的列表中来创建RPC用户：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>默认情况下，RPC用户没有权限执行任何RPC操作。</p><h4 id="授予流权限"><a href="#授予流权限" class="headerlink" title="授予流权限"></a>授予流权限</h4><p>您向RPC用户提供使用语法启动特定流程的权限 ：<code>StartFlow.&lt;fully qualified flow name&gt;</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “StartFlow.net.corda.flows.ExampleFlow1” ，</span><br><span class="line">            “StartFlow.net.corda.flows.ExampleFlow2” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>您还可以向RPC用户提供使用语法启动任何流的权限 <code>InvokeRpc.startFlow</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “InvokeRpc.startFlow” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h4 id="授予其他RPC权限"><a href="#授予其他RPC权限" class="headerlink" title="授予其他RPC权限"></a>授予其他RPC权限</h4><p>您向RPC用户提供使用以下语法执行特定RPC操作的权限 ：<code>InvokeRpc.&lt;rpc method name&gt;</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “InvokeRpc.nodeInfo” ，</span><br><span class="line">            “InvokeRpc.networkMapSnapshot” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h4 id="授予所有权限"><a href="#授予所有权限" class="headerlink" title="授予所有权限"></a>授予所有权限</h4><p>您可以使用权限为RPC用户提供执行任何RPC操作（包括启动任何流）的 ALL权限：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rpcUsers = [ </span><br><span class="line">    &#123; </span><br><span class="line">        username = exampleUser </span><br><span class="line">        password = examplePass </span><br><span class="line">        permissions = [ </span><br><span class="line">            “ALL” </span><br><span class="line">        ] </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h3 id="RPC安全管理"><a href="#RPC安全管理" class="headerlink" title="RPC安全管理"></a>RPC安全管理</h3><p>设置<code>rpcUsers</code>提供了一种向固定用户授予RPC权限的简单方法，但有一些明显的缺点。为了支持旨在提高安全性和灵活性的用例，Corda提供了额外的安全功能，例如：</p><ul><li>从外部数据源（例如：远程RDBMS）获取用户凭证和权限，以及可选的内存中缓存。特别是，这允许外部更新凭证和权限，而不需要重新启动节点。</li><li>密码以散列加密的形式存储。这被认为是安全问题时必须考虑的问题。Corda目前支持符合Apache Shiro框架提供的模块化加密格式的灵活密码哈希格式</li></ul><p>这些功能由嵌套在<code>security</code>字段中的一组选项控制<code>node.conf</code>。以下示例显示如何使用哈希加密格式的密码配置从远程数据库中检索用户凭据和权限，并启用用户数据的内存中缓存：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">security  =  &#123; </span><br><span class="line">    authService  =  &#123; </span><br><span class="line">        dataSource  =  &#123; </span><br><span class="line">            type  =  “DB” ，</span><br><span class="line">            passwordEncryption  =  “SHIRO_1_CRYPT” ，</span><br><span class="line">            connection  =  &#123; </span><br><span class="line">               jdbcUrl  =  “&lt;jdbc connection string&gt;” </span><br><span class="line">               username  =  “&lt;db username&gt;” </span><br><span class="line">               password  =  “&lt;db user password&gt;” </span><br><span class="line">               driverClassName  =  “&lt;JDBC驱动程序&gt;”</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        options  =  &#123; </span><br><span class="line">             cache  =  &#123; </span><br><span class="line">                expireAfterSecs  =  120 </span><br><span class="line">                maxEntries  = 10000 </span><br><span class="line">             &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另外，也可以具有嵌入在用户的静态列表<code>security</code>通过指定结构<code>dataSource</code>的<code>INMEMORY</code>类型：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">security  =  &#123; </span><br><span class="line">    authService  =  &#123; </span><br><span class="line">        dataSource  =  &#123; </span><br><span class="line">            type  =  “INMEMORY” ，</span><br><span class="line">            users  =  [ </span><br><span class="line">                &#123; </span><br><span class="line">                    username  =  “&lt;username&gt;” ，</span><br><span class="line">                    password  =  “&lt;password&gt;” ，</span><br><span class="line">                    permissions  =  [ “&lt;permission 1&gt;” ， “&lt;permission 2&gt; “ ， ...] </span><br><span class="line">                &#125;，</span><br><span class="line">                ... </span><br><span class="line">            ] </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY2xpZW50cnBjLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/clientrpc.html">原文<i class="fa fa-external-link"></i></span></p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Corda Shell是嵌入式的命令行工具，允许管理员控制和监视节点。它基于CRaSH外壳，并支持许多相同的功能。这些功能包括：</p><ul><li>调用任何节点的RPC方法</li><li>查看线程显示板，堆使用情况，VM属性</li><li>上传和下载附件</li><li>向基础数据库发出SQL查询</li><li>查看JMX指标并监控导出</li><li>用于文本和对象的UNIX样式管道，<code>egrep</code>命令用于处理列式数据的命令</li></ul><h3 id="通过本地终端的shell"><a href="#通过本地终端的shell" class="headerlink" title="通过本地终端的shell"></a>通过本地终端的shell</h3><p>在开发模式下，shell将显示在节点的终端窗口中。<code>--no-local-shell</code>运行节点时可以通过传递标志来禁用它 。</p><h3 id="SSH链接的Shell"><a href="#SSH链接的Shell" class="headerlink" title="SSH链接的Shell"></a>SSH链接的Shell</h3><h4 id="启用S​​SH访问"><a href="#启用S​​SH访问" class="headerlink" title="启用S​​SH访问"></a>启用S​​SH访问</h4><p>默认情况下，SSH服务器被禁用。要启用它，必须在节点的<code>node.conf</code>文件中配置一个端口：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sshd &#123; </span><br><span class="line">    port = 2222 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>用户使用与RPC相同的凭据通过SSH登录到shell。这是因为shell实际上使用RPC调用与节点进行通信。不需要RPC权限来允许连接和登录。</p><p>主机密钥从文件<code>&lt;node root directory&gt;/sshkey/hostkey.pem</code>加载。如果这个文件不存在，它会自动生成。在开发模式下，可以指定种子在同一台计算机上提供相同的结果，以避免主机检查错误。</p><h4 id="链接到shell"><a href="#链接到shell" class="headerlink" title="链接到shell"></a>链接到shell</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p [portNumber] [host] -l [user]</span><br></pre></td></tr></table></figure><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>当通过SSH访问shell时，需要一些额外的RPC权限：</p><ul><li>观察流（<code>flow watch</code>）需要<code>InvokeRpc.stateMachinesFeed</code></li><li>启动流程需要<code>InvokeRpc.startTrackedFlowDynamic</code>以及启动流程<code>InvokeRpc.registeredFlows</code>的许可</li></ul><h3 id="通过shell与节点交互"><a href="#通过shell与节点交互" class="headerlink" title="通过shell与节点交互"></a>通过shell与节点交互</h3><p>shell通过发出RPC（远程过程调用）与节点交互。您可以通过输入<code>run</code>后跟所需RPC方法的名称从shell进行 RPC。例如，您可以运行以下命令，在节点上看到注册流程的列表：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run registeredFlows</span><br></pre></td></tr></table></figure><p></p><p>一些RPC返回将在屏幕上显示的事件流，直到您按Ctrl-C。</p><p>您可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9hcGkva290bGluL2NvcmRhL25ldC5jb3JkYS5jb3JlLm1lc3NhZ2luZy8tY29yZGEtci1wLWMtb3BzL2luZGV4Lmh0bWw=" title="https://docs.corda.net/api/kotlin/corda/net.corda.core.messaging/-corda-r-p-c-ops/index.html">这里<i class="fa fa-external-link"></i></span>找到可用RPC方法的列表 。</p><h4 id="流程命令"><a href="#流程命令" class="headerlink" title="流程命令"></a>流程命令</h4><p>该shell还具有处理流程的特殊命令：</p><ul><li><code>flow list</code> 列出节点上可用的流</li><li><code>flow watch</code> 显示当前在节点上运行的所有流，并显示结果（或错误）信息</li><li><code>flow start</code> 开始一个流程。该命令<code>flow start</code>采用流类的名称或其任何明确的子字符串，以及要传递给流构造函数的数据。如果给定子字符串有多个匹配项，则可能的匹配项将被打印出来。如果流有多个构造函数，那么参数的名称和类型将用于尝试并自动确定使用哪一个。如果与可用构造函数的匹配不清楚，则每个可用构造函数未匹配的原因将被打印出来。在模糊匹配的情况下，将使用第一个适用的构造函数.</li></ul><h4 id="参数语法"><a href="#参数语法" class="headerlink" title="参数语法"></a>参数语法</h4><p>使用称为<code>Yaml</code>（又一种标记语言）的语法将参数传递给RPC或流命令，这是一种简单的JSON类语言。Yaml的主要特点是：</p><ul><li>参数用逗号分隔</li><li>每个参数都被指定为一对<code>key: value</code><ul><li>有MUST是冒号后面输入一个空格，否则你会得到一个语法错误</li></ul></li><li>除非包含逗号，冒号或嵌入引号，否则字符串不需要用引号括起来</li><li>类名必须是完全合格的（例如<code>java.lang.String</code>）</li></ul><p>注意: 如果您的CorDapp是用Java编写的，除非使用<code>-parameters</code>javac参数编译节点，否则命名参数将不起作用 。请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2VuZXJhdGluZy1hLW5vZGUuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/generating-a-node.html">本地创建节点<i class="fa fa-external-link"></i></span>以了解如何通过Gradle指定<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2VuZXJhdGluZy1hLW5vZGUuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/generating-a-node.html">节点<i class="fa fa-external-link"></i></span>。</p><h5 id="创建一个类的实例"><a href="#创建一个类的实例" class="headerlink" title="创建一个类的实例"></a>创建一个类的实例</h5><p>类实例使用花括号语法创建。例如，如果我们有一个<code>Campaign</code>具有以下构造函数的类：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Campaign(val name: String, val target: Int)</span><br></pre></td></tr></table></figure><p></p><p>然后我们可以创建这个类的一个实例作为参数传递，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCampaign: &#123; name: Roger, target: 1000 &#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="从字符串到类型的映射"><a href="#从字符串到类型的映射" class="headerlink" title="从字符串到类型的映射"></a>从字符串到类型的映射</h5><p>几个参数类型可以自动从字符串映射。查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpL2tvdGxpbi9jb3JkYS9uZXQuY29yZGEuY2xpZW50LmphY2tzb24vLWphY2tzb24tc3VwcG9ydC9pbmRleC5odG1s" title="https://docs.corda.net/releases/release-V3.1/api/kotlin/corda/net.corda.client.jackson/-jackson-support/index.html">定义的解析器<i class="fa fa-external-link"></i></span>以获取更多信息。我们覆盖这里最常见的类型。</p><h5 id="Amount"><a href="#Amount" class="headerlink" title="Amount"></a>Amount</h5><p>类型的参数<code>Amount&lt;Currency&gt;</code>可以写为：</p><ul><li>美元（$），英镑（£）或欧元（€）符号，后面跟着小数点</li><li>以ISO货币代码（例如“100.12 CHF”）开头的小数<h5 id="OpaqueBytes"><a href="#OpaqueBytes" class="headerlink" title="OpaqueBytes"></a>OpaqueBytes</h5>类型的参数<code>OpaqueBytes</code>可以作为字符串提供，该字符串将自动转换为 <code>OpaqueBytes</code>。<h5 id="Party"><a href="#Party" class="headerlink" title="Party"></a>Party</h5>类型的参数<code>Party</code>可以用几种方式写入：</li><li>通过使用节点的全名： “O=Monogram Bank,L=Sao Paulo,C=GB”</li><li>通过仅指定组织名称： “Monogram Bank”</li><li>通过指定名称的任何其他非模糊部分:( 如果只有一个网络节点位于圣保罗）”Sao Paulo”<h5 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h5>类型的参数<code>Instant</code>可以写成如下：<code>&quot;2017-12-22T00:00:00Z&quot;</code>。<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5>开始一个流程：我们将开始<code>CashIssue</code>流程如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow start CashIssueFlow amount: $1000, issuerBankPartyRef: 1234, notary: &quot;O=Controller, L=London, C=GB&quot;</span><br></pre></td></tr></table></figure></li></ul><p>这个分解如下：</p><ul><li><code>flow start</code> 是用于启动流的shell命令</li><li><code>CashIssue</code> 是我们想要开始的流程</li><li>之后的每一对都是流构造函数的参数<code>name: value</code></li></ul><p>该命令调用以下<code>CashIssue</code>构造函数：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CashIssueFlow</span></span>(<span class="keyword">val</span> amount: Amount&lt;Currency&gt;,</span><br><span class="line">                    <span class="keyword">val</span> issueRef: OpaqueBytes,</span><br><span class="line">                    <span class="keyword">val</span> recipient: Party,</span><br><span class="line">                    <span class="keyword">val</span> notary: Party) : AbstractCashFlow(progressTracker)</span><br></pre></td></tr></table></figure><p></p><h5 id="查询Vault"><a href="#查询Vault" class="headerlink" title="查询Vault"></a>查询Vault</h5><p>我们将按<code>IOUState</code>如下方式查询Vault的状态：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run vaultQuery contractStateType: com.template.IOUState</span><br></pre></td></tr></table></figure><p></p><p>这个分解如下：</p><ul><li><code>run</code> 是进行RPC调用的shell命令</li><li><code>vaultQuery</code> 是我们想要做的RPC调用</li><li><code>contractStateType: com.template.IOUState</code> 是我们查询的状态类型的完全限定名称</li></ul><h4 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h4><p>该shell可用于从节点上载和下载附件。要了解更多信息，请参阅教程“<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvdHV0b3JpYWwtYXR0YWNobWVudHMuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/tutorial-attachments.html">使用附件<i class="fa fa-external-link"></i></span> ”。</p><h4 id="获得帮助"><a href="#获得帮助" class="headerlink" title="获得帮助"></a>获得帮助</h4><p>您可以键入<code>help</code> shell以列出可用的命令，并<code>man</code>获得许多命令的交互式帮助。您还可以将该标志<code>--help</code>或<code>-h</code>标志传递给命令以获取有关它支持哪些开关的信息。</p><p>命令可能具有子命令，其格式与<code>git</code>。在这种情况下，自行运行命令将列出支持的子命令。</p><h3 id="扩展shell"><a href="#扩展shell" class="headerlink" title="扩展shell"></a>扩展shell</h3><p>可以使用以Java或Groovy（一种Java兼容的脚本语言）编写的命令来扩展shell 。这些命令可以完全访问节点的内部API，因此可以用来实现几乎所有的功能。</p><p>有关如何编写这些命令的完整教程不在本文档的范围之内。要了解更多信息，请参阅<span class="exturl" data-url="aHR0cDovL3d3dy5jcmFzaHViLm9yZy8=" title="http://www.crashub.org/">CRaSH<i class="fa fa-external-link"></i></span>文档。新命令放置在<code>shell-commands</code>节点目录的子目录中。现有命令的编辑将自动使用，但当前在节点启动后添加的命令不会被自动检测到。命令必须全部以小写字母<code>.java</code>或<code>.groovy</code>扩展名命名。</p><p><b style="color:#00f">警告:在Groovy中编写的命令会忽略Java安全检查，因此无论是否存在任何沙盒，都可以无限制地访问节点和JVM内部。不允许不受信任的用户编辑shell-commands目录中的文件！</b></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>随着时间的推移，Shell将得到增强。目前已知的限制包括：</p><ul><li>流或RPC没有命令完成</li><li>命令历史不会在重新启动时保留</li><li><code>jdbc</code>命令要求您首先明确登录到数据库</li><li>放置在<code>shell-commands</code>目录中的命令只有在节点重新启动后才会被注意到</li><li><code>jul</code>命令通告对日志的访问，但它不适用于我们正在使用的日志框架</li></ul><h2 id="节点数据库"><a href="#节点数据库" class="headerlink" title="节点数据库"></a>节点数据库</h2><p>目前，节点将其数据存储在H2数据库中。今后，我们计划支持各种各样的数据库。</p><p>您可以直接连接到正在运行的节点的数据库，以查看其存储的状态，交易和附件，如下所示：</p><ul><li>下载独立于<span class="exturl" data-url="aHR0cDovL3d3dy5oMmRhdGFiYXNlLmNvbS9odG1sL2Rvd25sb2FkLmh0bWw=" title="http://www.h2database.com/html/download.html">h2平台的zip文件<i class="fa fa-external-link"></i></span>，将zip解压缩，然后在终端窗口中导航到解压缩的文件夹</li><li>将目录更改为bin文件夹：<code>cd h2/bin</code></li><li>运行以下命令以在Web浏览器选项卡中打开h2 Web控制台：<code>sh h2.sh</code></li><li><p>找到节点的JDBC连接字符串。每个节点在启动时在终端窗口中输出其连接字符串。在运行节点的终端窗口中，查找以下字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Database connection URL is              : jdbc:h2:tcp://10.18.0.150:56736/node</span><br></pre></td></tr></table></figure></li><li><p>将此字符串粘贴到JDBC URL字段中，并使用默认用户名和密码单击<code>Connect</code>。</p></li><li>您将看到一个显示节点存储和Vault内容的Web界面，并提供一个界面供您使用SQL查询它们。</li></ul><h2 id="节点后台管理"><a href="#节点后台管理" class="headerlink" title="节点后台管理"></a>节点后台管理</h2><p>当一个节点正在运行时，它会暴露一个RPC接口，让您监视它，上传和下载附件等等。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>默认情况下，节点日志文件存储在工作目录的子目录<code>logs</code>中并随时进行旋转。您也可以通过传递<code>--log-to-console</code>命令行标志将日志打印到控制台。默认日志记录级别INFO可以通过<code>--logging-level</code>命令行参数进行调整。该配置选项将影响所有模块。</p><p>您可能需要修改特定子模块的日志级别（例如，如果您想仔细查看休眠活动）。因此，对于更多的定制日志配置，logger设置可以通过分配给<code>log4j.configurationFile</code>系统属性的Log4j 2配置文件完全覆盖。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>在当前工作目录中创建一个文件<code>sql.xml</code>。添加以下文本：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate"</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>请注意，添加了一个记录器，名为<code>org.hibernate</code>的记录器已将此特定记录器级别设置为<code>debug</code>。</p><p>现在像往常一样启动节点，但是如上所述将附加参数<code>log4j.configurationFile</code>设置为文件名，例如<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java &lt;Your existing startup options here&gt; -Dlog4j.configurationFile=sql.xml -jar corda.jar</span><br></pre></td></tr></table></figure><p></p><p>要确定记录器的名称，对于Corda对象，请使用完全限定名称（例如，查看更详细的节点输出，使用<code>net.corda.node.internal.Node</code>尽管请注意，由于我们标记了此类<code>internal</code>，因此我们保留移动和重命名它的权利，因为它是目前尚未成为公共API的一部分）。对于其他库，请参阅它们的日志名称构造。如果找不到需要参考的内容，请使用上述<code>--logging-level</code>选项，然后从控制台输出中确定记录模块名称。</p><h3 id="SSH访问"><a href="#SSH访问" class="headerlink" title="SSH访问"></a>SSH访问</h3><p>节点可以配置为运行SSH服务器。详情请参阅Shell。</p><h3 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h3><p>该节点通过套接字公开其内部数据库，该套接字可以使用任何可以使用JDBC驱动程序的工具来浏览。JDBC URL在节点启动期间打印到日志中，并且通常如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:h2:tcp://192.168.0.31:31339/node</span><br></pre></td></tr></table></figure><p></p><p>用户名和密码可以在节点配置中更改，但默认为用户名“sa”和空白密码。</p><p>任何支持JDBC的数据库浏览工具都可以使用，但是如果您有IntelliJ Ultimate版本，那么您的IDE中会集成一个工具。只需打开数据库窗口并添加一个H2数据源，并提供上述详细信息。您现在可以浏览其中的表格和行数据。</p><h3 id="监视你的节点"><a href="#监视你的节点" class="headerlink" title="监视你的节点"></a>监视你的节点</h3><p>与大多数Java服务器一样，节点通过行业标准的JMX基础架构导出各种有用的度量标准和管理操作 。JMX是注册所谓的MBeans …对象的标准API，其属性和方法用于服务器管理。它不需要任何特定的网络协议来输出。因此，这些数据可以通过各种方式从节点导出：一些监控系统提供了一个“Java代理”，它本质上是一个JVM插件，用于查找所有MBean并将它们发送到网络上的统计收集器。对于这些系统，请按照供应商提供的说明进行操作。</p><p>具体查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvbm9kZS1hZG1pbmlzdHJhdGlvbi5odG1sI21vbml0b3JpbmcteW91ci1ub2Rl" title="https://docs.corda.net/releases/release-V3.1/node-administration.html#monitoring-your-node">这里<i class="fa fa-external-link"></i></span>!</p><h3 id="内存使用和调整"><a href="#内存使用和调整" class="headerlink" title="内存使用和调整"></a>内存使用和调整</h3><p>所有垃圾收集程序可以运行得更快，如果你给他们更多的内存，因为他们需要收集更少的频率。作为默认的JVM，如果你愿意的话，它可以愉快地占用你系统上的所有内存，默认情况下，Corda配置了一个相对较小的200MB Java堆。当添加其他开销时，这会为一个节点产生大约500mb的总内存使用量（开销来自编译代码，元数据，堆外缓冲区，线程堆栈等）。</p><p>如果你想让你的节点变得更快，并且分析表明过多的GC开销是原因，或者如果你的节点内存不足，你可以通过运行节点来给它更多的东西：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m -jar corda.jar</span><br></pre></td></tr></table></figure><p></p><p>上面的示例命令会给出1千兆字节的Java堆。</p><h2 id="Out-of-process验证"><a href="#Out-of-process验证" class="headerlink" title="Out-of-process验证"></a>Out-of-process验证</h2><p>Corda节点通过<code>ServiceHub.transactionVerifierService</code>进行交易验证。这是默认情况下， <code>InMemoryTransactionVerifierService</code>它只是验证进程中的交易。</p><p>Corda可能被配置为不使用进程验证。任何数量的验证器都可以通过节点的暴露artemis SSL端口开始连接到节点。消息传递层负责负载平衡。</p><p><b style="color:#00f">注意: 我们计划在内核沙箱转义的情况下，将内核级沙箱引入进程验证程序外，作为额外的防线。</b></p><p>要配置节点以使用进程外验证，请在<code>node.conf</code>中指定该<code>verifierType</code>选项：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myLegalName : &quot;O=Bank A,L=London,C=GB&quot;</span><br><span class="line">p2pAddress : &quot;my-corda-node:10002&quot;</span><br><span class="line">webAddress : &quot;localhost:10003&quot;</span><br><span class="line">verifierType: &quot;OutOfProcess&quot;</span><br></pre></td></tr></table></figure><p></p><p>你可以使用构建一个验证器jar 。<code>./gradlew verifier:standaloneJar</code></p><p>并运行它。<code>java -jar verifier/build/libs/corda-verifier.jar &lt;PATH_TO_VERIFIER_BASE_DIR&gt;</code></p><p><code>PATH_TO_VERIFIER_BASE_DIR</code>应该包含一个类似于节点目录中的<code>certificates</code>文件夹，并且<code>verifier.conf</code>包含以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nodeHostAndPort: &quot;my-corda-node:10002&quot;</span><br><span class="line">keyStorePassword : &quot;cordacadevpass&quot;</span><br><span class="line">trustStorePassword : &quot;trustpass&quot;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cordapp基础知识</title>
      <link href="//blockchain/corda/Cordapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>//blockchain/corda/Cordapp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CorDapps（Corda分布式应用程序）是在Corda平台上运行的分布式应用程序。CorDapp的目标是允许节点就分类账更新达成一致。他们通过定义Corda节点所有者可以通过RPC调用调用的流程来实现此目标：</p><p><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/node-diagram.png"></p><p>Cordapps由以下关键组件组成：</p><ul><li>状态： 达成协议的事实</li><li>合约： 定义构成有效分类账更新的内容</li><li>服务： 在节点内提供长寿命的工具</li><li>序列化白名单： 限制节点从网络线路接收的类型</li></ul><p>每个Cordapp安装在单节点级别，而不是网络本身。例如，节点所有者可以选择安装Bond Trading CorDapp，并具有以下组件：</p><ul><li><code>BondState</code>: 用来代表债券，作为账本上的事实</li><li><code>BondContract</code>: 用来管理账本有效更新包括<code>BondState</code>状态</li><li>三个流程：<ul><li><code>IssueBondFlow</code>: 允许新的<code>BondState</code>状态发布到账本上</li><li><code>TradeBondFlow</code>: 允许存在的<code>BondState</code>状态在账本上进行买进和卖出。</li><li><code>ExitBondFlow</code>: 允许存在的<code>BondState</code>状态从账本上退出</li></ul></li></ul><p>安装此CorDapp后，节点所有者将能够使用CorDapp定义的流程来允许与发行，出售，购买和退出债券有关的分类帐更新。</p><h2 id="编写一个CorDapp"><a href="#编写一个CorDapp" class="headerlink" title="编写一个CorDapp"></a>编写一个CorDapp</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>每个CorDapp组件都采用JVM类的形式，该JVM类子类或实现Corda库类型：</p><ul><li>流程子类<code>FlowLogic</code></li><li>状态实现 <code>ContractState</code></li><li>合约实现 <code>Contract</code></li><li>服务子类 <code>SingletonSerializationToken</code></li><li>序列化白名单实现：<code>SerializationWhitelist</code></li></ul><h3 id="Web内容和RPC客户端"><a href="#Web内容和RPC客户端" class="headerlink" title="Web内容和RPC客户端"></a>Web内容和RPC客户端</h3><p>出于测试目的，CorDapps还可能包括：</p><ul><li>API和静态网页内容：由Corda内置的网络服务器提供。这个网络服务器不是生产就绪的，只能用于测试目的</li><li>RPC客户端：这些程序可以自动执行通过RPC与节点进行交互的过程</li></ul><p>在生产环境中，应该使用生产就绪的网络服务器，这些文件应该移到不同的模块或项目中，以便在构建时不会膨胀CorDapp。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>您应该将项目的结构基于Java或Kotlin模板：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhcHAtdGVtcGxhdGUtamF2YQ==" title="https://github.com/corda/cordapp-template-java">Java模板CorDapp<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRhL2NvcmRhcHAtdGVtcGxhdGUta290bGlu" title="https://github.com/corda/cordapp-template-kotlin">Kotlin模板CorDapp<i class="fa fa-external-link"></i></span></li></ul><p>该项目应该分为两个模块：</p><ul><li><code>cordapp-contracts-states</code>包含合约和状态等类的模块，将作为流程的一部分通过线路发送</li><li><code>cordapp</code>含有剩余的类模块</li></ul><p>每个模块将被编译到它自己的CorDapp中。当节点同意分类帐更新时，这可以最小化必须通过网络发送的JAR的大小。</p><h3 id="模块1-cordapp-contracts-states"><a href="#模块1-cordapp-contracts-states" class="headerlink" title="模块1 - cordapp-contracts-states"></a>模块1 - cordapp-contracts-states</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── main</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                ├── TemplateContract.java</span><br><span class="line">                └── TemplateState.java</span><br></pre></td></tr></table></figure><h3 id="模块2-cordapp"><a href="#模块2-cordapp" class="headerlink" title="模块2 - cordapp"></a>模块2 - cordapp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── template</span><br><span class="line">│   │           ├── TemplateApi.java</span><br><span class="line">│   │           ├── TemplateClient.java</span><br><span class="line">│   │           ├── TemplateFlow.java</span><br><span class="line">│   │           ├── TemplateSerializationWhitelist.java</span><br><span class="line">│   │           └── TemplateWebPlugin.java</span><br><span class="line">│   └── resources</span><br><span class="line">│       ├── META-INF</span><br><span class="line">│       │   └── services</span><br><span class="line">│       │       ├── net.corda.core.serialization.SerializationWhitelist</span><br><span class="line">│       │       └── net.corda.webserver.services.WebServerPluginRegistry</span><br><span class="line">│       ├── certificates</span><br><span class="line">│       └── templateWeb</span><br><span class="line">├── test</span><br><span class="line">│   └── java</span><br><span class="line">│       └── com</span><br><span class="line">│           └── template</span><br><span class="line">│               ├── ContractTests.java</span><br><span class="line">│               ├── FlowTests.java</span><br><span class="line">│               └── NodeDriver.java</span><br><span class="line">└── integrationTest</span><br><span class="line">    └── java</span><br><span class="line">        └── com</span><br><span class="line">            └── template</span><br><span class="line">                └── DriverBasedTest.java</span><br></pre></td></tr></table></figure><p>这里面需要注意的是<code>test</code>是包含示例单元测试，以及用于从IntelliJ运行CorDapp的节点驱动程序. <code>integrationTest</code>是包含一个示例集成测试。这里需要注意两者的区别。</p><p>在<code>main</code>中，有以下的几个目录：</p><ul><li><code>resources/META-INF/services</code> 包含CorDapp的序列化白名单和网页插件的注册管理机构</li><li><code>resources/certificates</code> 包含用于测试目的的虚拟证书</li><li><code>resources/templateWeb</code> 包含一个虚拟的前端</li><li><code>java</code>（或<code>kotlin</code>在Kotlin模板中），其中包括我们的CorDapp的源代码</li></ul><p>我们的CorDapp的源代码分解如下：</p><ul><li><code>TemplateFlow.java</code>，其中包含一个虚拟<code>FlowLogic</code>子类</li><li><code>TemplateState.java</code>，其中包含一个虚拟<code>ContractState</code>实现</li><li><code>TemplateContract.java</code>，其中包含一个虚拟<code>Contract</code>实现</li><li><code>TemplateSerializationWhitelist.java</code>，其中包含一个虚拟<code>SerializationWhitelist</code>实现</li></ul><p>在开发你的CorDapp时，你应该首先修改这些类来定义你的CorDapp的组件。一个单一的CorDapp可以定义多个流程，状态和合同。</p><p><b style="color:red">该模板还包含一个Web API和RPC客户端：</b></p><ul><li><code>TemplateApi.java</code></li><li><code>TemplateClient.java</code></li><li><code>TemplateWebPlugin.java</code></li></ul><p>这些用于测试目的，并将在生产CorDapp中删除。</p><h3 id="学习的资源"><a href="#学习的资源" class="headerlink" title="学习的资源"></a>学习的资源</h3><p>在编写CorDapp时，您应该查阅以下资源：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2V0dGluZy1zZXQtdXAuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/getting-set-up.html">快速设置<i class="fa fa-external-link"></i></span>来设置你的开发环境</li><li>你好，世界！教程来编写你的第一个CorDapp</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY29yZGFwcC1idWlsZC1zeXN0ZW1zLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/cordapp-build-systems.html">构建一个CorDapp<i class="fa fa-external-link"></i></span>来构建和运行您的CorDapp</li><li>该API文档阅读有关开发CorDapps可用的API<ul><li>还有一个<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY2hlYXQtc2hlZXQuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html">cheatsheet<i class="fa fa-external-link"></i></span>重新说明关键类型</li></ul></li><li>该<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZmxvdy1jb29rYm9vay5odG1s" title="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html">流程指南<i class="fa fa-external-link"></i></span>看如何执行常见任务流的代码示例</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29yZGEubmV0L3NhbXBsZXMv" title="https://www.corda.net/samples/">CorDapps实例程序<i class="fa fa-external-link"></i></span>显示Corda功能的各个部分</li></ul><h2 id="构建一个Cordapp"><a href="#构建一个Cordapp" class="headerlink" title="构建一个Cordapp"></a>构建一个Cordapp</h2><h3 id="CorDapp格式"><a href="#CorDapp格式" class="headerlink" title="CorDapp格式"></a>CorDapp格式</h3><p>Cordapp是一个semi-fat的jar包，它包含除 Corda核心库和其它依赖的任何其他CorDapps 之外的所有CorDapp依赖项。</p><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>在下面的说明中，我们假设你正在使用<code>gradle</code>和<code>cordformation</code>插件来构建你的CorDapp。</p><h3 id="设置依赖关系"><a href="#设置依赖关系" class="headerlink" title="设置依赖关系"></a>设置依赖关系</h3><h4 id="选择你的Corda，Quasar和Kotlin版本"><a href="#选择你的Corda，Quasar和Kotlin版本" class="headerlink" title="选择你的Corda，Quasar和Kotlin版本"></a>选择你的Corda，Quasar和Kotlin版本</h4><p>CorDapp的build.gradle文件中使用了几个变量来定义用于构建您的CorDapp的版本：</p><ul><li><code>ext.corda_release_version</code> 定义了Corda的版本</li><li><code>ext.corda_gradle_plugins_version</code> 定义了Corda Gradle插件的版本</li><li><code>ext.quasar_version</code> 定义了Quasar的版本</li><li><code>ext.kotlin_version</code> 定义Kotlin的版本（如果使用Kotlin编写您的CorDapp）</li></ul><h4 id="Corda依赖"><a href="#Corda依赖" class="headerlink" title="Corda依赖"></a>Corda依赖</h4><p><code>cordformation</code>和<code>cordapp</code>插件添加了两个新的gradle这个配置：</p><ul><li><code>cordaCompile</code>，这扩展了 <code>compile</code></li><li><code>cordaRuntime</code>，这扩展了 <code>runtime</code></li></ul><p><code>cordaCompile</code>和<code>cordaRuntime</code>指出不应包含在CorDapp JAR中的依赖关系。这些配置应该用于任何Corda依赖（例如corda-core，corda-node），以防止依赖包含两次（一次在CorDapp JAR中，一次在Corda JAR中）。</p><p>要针对Corda构建，您必须将以下内容添加到您的build.gradle文件中：</p><p>Cordapp插件应该适用于任何将要构建cordapp的项目，并且cordformation插件应该适用于希望在本地创建小型测试网络的项目。</p><p>这样做后，确保： net.corda:corda:$corda_release_version被定义为cordaRuntime依赖项，并且所有其他net.corda编译依赖项（例如，net.corda：corda-core：$ corda_release_version）被设置为cordaCompile依赖项。</p><p>您可能还想添加：</p><ul><li><code>net.corda:corda-test-utils:$corda_release_version</code>作为<code>testCompile</code>依赖项，以便使用Corda的测试框架</li><li><code>net.corda:corda-webserver:$corda_release_version</code>作为<code>cordaRuntime</code>依赖项，以便使用Corda的内置开发Web服务器</li></ul><h4 id="依赖其他CorDapps"><a href="#依赖其他CorDapps" class="headerlink" title="依赖其他CorDapps"></a>依赖其他CorDapps</h4><p>您的CorDapp也可能依赖于另一个CorDapp中定义的类，例如状态，合约和流程。有两种方法可以在CorDapp的build.gradle文件中添加另一个CorDapp作为依赖项：</p><ul><li><code>cordapp project(&quot;:another-cordapp&quot;)</code>（如果在同一个项目中的模块中定义了另一个CorDapp，则使用此方法）</li><li><code>cordapp &quot;net.corda:another-cordapp:1.0&quot;</code> （否则使用这个）</li></ul><p>该cordappgradle这个配置有两个目的：</p><ul><li>当使用<code>cordformation</code> Gradle插件时，<code>cordapp</code>配置表明该JAR应该作为CorDapp包含在您的节点中</li><li>当使用<code>cordapp</code> Gradle插件时，<code>cordapp</code>配置可防止CorDapp JAR中包含依赖项</li></ul><p>请注意，<code>cordformation</code>和<code>cordapp</code> Gradle插件可以一起使用。</p><h4 id="其他依赖关系"><a href="#其他依赖关系" class="headerlink" title="其他依赖关系"></a>其他依赖关系</h4><p>如果您的CorDapps有任何额外的外部依赖关系，可以像Gradle中的正常Kotlin / Java依赖关系那样指定它们。看下面的例子，特别是<code>apache-commons</code>包含。</p><p>有关管理依赖关系的更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdyYWRsZS5vcmcvY3VycmVudC91c2VyZ3VpZGUvZGVwZW5kZW5jeV9tYW5hZ2VtZW50Lmh0bWw=" title="https://docs.gradle.org/current/userguide/dependency_management.html">Gradle文档<i class="fa fa-external-link"></i></span>。</p><p>以下是CorDapp的Gradle依赖关系块的示例：<br></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Corda integration dependencies</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-core:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-finance:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-jackson:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-rpc:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-node-api:$corda_release_version"</span></span><br><span class="line">    cordaCompile <span class="string">"net.corda:corda-webserver-impl:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda:$corda_release_version"</span></span><br><span class="line">    cordaRuntime <span class="string">"net.corda:corda-webserver:$corda_release_version"</span></span><br><span class="line">    testCompile <span class="string">"net.corda:corda-test-utils:$corda_release_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corda Plugins: dependent flows and services</span></span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its module in the same project.</span></span><br><span class="line">    cordapp <span class="keyword">project</span>(<span class="string">":cordapp-contracts-states"</span>)</span><br><span class="line">    <span class="comment">// Identifying a CorDapp by its fully-qualified name.</span></span><br><span class="line">    cordapp <span class="string">"net.corda:bank-of-corda-demo:1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some other dependencies</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"org.jetbrains.kotlin:kotlin-test:$kotlin_version"</span></span><br><span class="line">    testCompile <span class="string">"junit:junit:$junit_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.apache.commons:commons-lang3:3.6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="创建CorDapp-Jar"><a href="#创建CorDapp-Jar" class="headerlink" title="创建CorDapp Jar"></a>创建CorDapp Jar</h3><p>一旦您的依赖关系设置正确，您可以使用gradle <code>jar</code>任务来构建您的CorDapp JAR ：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradlew jar</span><br></pre></td></tr></table></figure><p></p><p>CorDapp JAR将被输出到<code>build/libs</code>文件夹。</p><h3 id="安装CorDapp-JAR"><a href="#安装CorDapp-JAR" class="headerlink" title="安装CorDapp JAR"></a>安装CorDapp JAR</h3><p>在安装CorDapp之前，您必须创建一个或多个节点来安装它。有关说明，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZ2VuZXJhdGluZy1hLW5vZGUuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/generating-a-node.html">本地创建节点<i class="fa fa-external-link"></i></span>。</p><p>在运行时，节点将加载其<code>cordapps</code>文件夹中存在的任何CorDapps 。因此，为了在节点上安装CorDapp，必须将CorDapp JAR添加到该<code>&lt;node_dir&gt;/cordapps/</code>文件夹中，其中node_dir是存储节点的JAR和配置文件的文件夹。</p><h2 id="通过master分支编译"><a href="#通过master分支编译" class="headerlink" title="通过master分支编译"></a>通过master分支编译</h2><p>针对最新的Corda稳定版本开发CorDapps是明智的。但是，如果您使用的是最新功能，或者正在测试主代码库上的PR，则可能需要针对不稳定的Master分支进行构建。</p><h2 id="Corda-Api"><a href="#Corda-Api" class="headerlink" title="Corda Api"></a>Corda Api</h2><p>以下是用于开发CorDapps的核心API：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXN0YXRlcy5odG1s" title="https://docs.corda.net/releases/release-V3.1/api-states.html">API：状态 States<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1zdGF0ZXMv" title="http://cncorda.com/doc/apis/api-states/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXBlcnNpc3RlbmNlLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-persistence.html">API：持久化 Persistence<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1wZXJzaXN0ZW5jZS8=" title="http://cncorda.com/doc/apis/api-persistence/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWNvbnRyYWN0cy5odG1s" title="https://docs.corda.net/releases/release-V3.1/api-contracts.html">API：合约 Contracts<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1jb250cmFjdHMv" title="http://cncorda.com/doc/apis/api-contracts/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWNvbnRyYWN0LWNvbnN0cmFpbnRzLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-contract-constraints.html">API：合约约束 Contract Constraints<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1jb250cmFjdC1jb25zdHJhaW5zLw==" title="http://cncorda.com/doc/apis/api-contract-constrains/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXZhdWx0LXF1ZXJ5Lmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-vault-query.html">API：Vault查询<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXZhdWx0LXF1ZXJ5Lmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-vault-query.html">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXRyYW5zYWN0aW9ucy5odG1s" title="https://docs.corda.net/releases/release-V3.1/api-transactions.html">API：交易 Transaction<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS10cmFuc2FjdGlvbnMv" title="http://cncorda.com/doc/apis/api-transactions/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWZsb3dzLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-flows.html">API：流程 Flows<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1mbG93cy8=" title="http://cncorda.com/doc/apis/api-flows/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWlkZW50aXR5Lmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-identity.html">API：身份 Identity<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1pZGVudGl0eS8=" title="http://cncorda.com/doc/apis/api-identity/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXNlcnZpY2UtaHViLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/api-service-hub.html">API：ServiceHub<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1zZXJ2aWNlaHViLw==" title="http://cncorda.com/doc/apis/api-servicehub/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXJwYy5odG1s" title="https://docs.corda.net/releases/release-V3.1/api-rpc.html">API：RPC操作 RPC operations<i class="fa fa-external-link"></i></span> <span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tL2RvYy9hcGlzL2FwaS1ycGMtb3BlcmF0aW9ucy8=" title="http://cncorda.com/doc/apis/api-rpc-operations/">中文<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWNvcmUtdHlwZXMuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/api-core-types.html">API：核心类型<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXRlc3RpbmcuaHRtbCNmbG93LXRlc3Rpbmc=" title="https://docs.corda.net/releases/release-V3.1/api-testing.html#flow-testing">API：测试 Testing<i class="fa fa-external-link"></i></span></li></ul><h3 id="内部API和稳定性保证"><a href="#内部API和稳定性保证" class="headerlink" title="内部API和稳定性保证"></a>内部API和稳定性保证</h3><p>Corda 3.0提供稳定的wire协议并支持数据库升级。因此，您应该能够将持久数据从3.0迁移到未来版本。但是，在我们开始提供ABI稳定性之前，有必要针对未来版本的API重新编译应用程序。</p><p>此外，请注意，Corda 3.0版本已经过基本级别的安全审核，为确保节点安全得到维护，应遵循以下最佳做法：</p><ul><li>应该使用安全密码生成器创建RPC用户、数据库连接和shell用户的凭证，最好从节点主机的命令行创建。</li><li>绝不应使用默认或开发模式凭证部署节点。</li><li>Corda节点应该使用其中一个受支持的数据库平台，而不是仅用于开发目的的默认H2数据库。Postgres是一个支持的平台。</li><li>应该在安全的网络（如DMZ）内操作节点，将入站和出站流量限制为仅需要的端口（就是限定端口做一些事）。具体而言，节点运营商应该致力于允许从互联网上访问点对点流量。RPC和数据库连接应该仅限于内部。</li><li>节点Web服务器模块已弃用，因此不应将其部署到生产环境中，因为它不是与Corda节点相同的安全标准。</li></ul><p>可以从Java 9 Jigsaw模块中获得Corda工件。从<code>module-info.java</code>中可以引用其中一个模块，例如<code>requires net.corda.core;</code>。</p><h3 id="Corda稳定的模块"><a href="#Corda稳定的模块" class="headerlink" title="Corda稳定的模块"></a>Corda稳定的模块</h3><p>以下模块具有稳定的API，我们承诺不会在以下版本中中断，除非出于安全原因需要进行不兼容的更改：</p><ul><li>核心（net.corda.core）：核心Corda函数库，如加密函数、Corda构建模块的类型：状态，合约，交易，附件等，以及用于节点和协议的一些接口</li><li>客户端RPC（net.corda.client.rpc）：客户端RPC</li><li>客户端Jackson（net.corda.client.jackson）：对客户端应用程序的JSON支持</li><li>测试实用程序（net.corda.testing.core）：通用测试实用程序</li><li>测试节点驱动程序（net.corda.testing.node，net.corda.testing.driver）：测试实用程序以编程方式运行节点</li><li>Http Test Utils（net.corda.testing.http）：一组用于制作HttpCalls的实用程序，旨在演示和测试。</li><li>DSL Test Utils（net.corda.testing.dsl）：用于测试目的的用于构建伪交易（与有线协议不同）的简单DSL。</li><li>虚拟合约 Dummy Contracts（net.corda.testing.contracts）：用于测试目的的虚拟状态和合约</li><li>模拟服务 Mock Services（net.corda.testing.services）：用于测试目的的模拟服务实现</li></ul><h3 id="Corda孵化模块"><a href="#Corda孵化模块" class="headerlink" title="Corda孵化模块"></a>Corda孵化模块</h3><p>以下模块还没有完全稳定的API，但我们会尽最大努力最大限度地减少开发人员使用它们的中断，直到我们能够将其应用到公共API中：</p><ul><li>net.corda.confidential.identities：实验性支持分类账上的机密身份</li><li>net.corda.finance：一系列基本合同（及相关模式）和协议，如抽象可替代资产，现金，义务和商业票据</li><li>net.corda.client.jfx：支持Java FX UI</li><li>net.corda.client.mock：客户端模拟实用程序</li><li>Cordformation：Gradle集成插件</li></ul><h3 id="Corda不稳定模块"><a href="#Corda不稳定模块" class="headerlink" title="Corda不稳定模块"></a>Corda不稳定模块</h3><p>以下模块可用，但我们不承诺任何意义上的稳定性或延续性：</p><ul><li>net.corda.buildSrc：必要的gradle插件来构建Corda</li><li>net.corda.node：Corda节点的核心代码（例如节点驱动程序，节点服务，消息传递，持久性）</li><li>net.corda.node.api：节点和客户端模块之间共享的数据结构，例如通过RPC发送的类型</li><li>net.corda.samples.network.visualiser：一个网络可视化工具，它使用仿真来显示Corda网络上节点之间的交互和消息</li><li>net.corda.samples.demos.attachment：演示如何使用附件从一个节点发送一个事务到另一个节点，并且接收节点访问附件</li><li>net.corda.samples.demos.bankofcorda：模拟资产发行机构的角色（例如中央银行的现金）</li><li>net.corda.samples.demos.irs：展示两家银行之间的利率互换协议</li><li>net.corda.samples.demos.notary：一个节点获得多个事务的简单演示，由分布式（Raft或BFT SMaRt）公证人公证</li><li>net.corda.samples.demos.simmvaluation：SIMM评估和分布式账本协议的演示</li><li>net.corda.samples.demos.trader：演示了四个节点：公证人，现金发行人（Corda银行）和两个彼此进行交易的人，用现金交换商业票据</li><li>net.corda.node.smoke.test.utils：测试烟雾测试实用程序</li><li>net.corda.node.test.common：通用测试功能</li><li>net.corda.tools.demobench：一个GUI工具，允许在本地运行Corda节点进行演示</li><li>net.corda.tools.explorer：Corda的GUI前端</li><li>net.corda.tools.graphs：用于推断项目依赖性的实用程序</li><li>net.corda.tools.loadtest：Corda负载测试</li><li>net.corda.verifier：允许节点外交易验证，允许验证水平扩展</li><li>net.corda.webserver：是一个用于导出HTTP端点的CorDapps的servlet容器。该服务器是节点的RPC客户端</li><li>net.corda.sandbox-creator：沙箱实用程序</li><li>net.corda.quasar.hook：代理钩入Quasar并提供类型排除列表</li></ul><p><b style="color:#6ab0de"><code>net.corda</code>名称空间中包含<code>.internal</code>或<code>net.corda.node</code>仅供内部使用的任何软件包内的代码。未来版本将拒绝任何CorDapps使用这些包中的类型。</b></p><h3 id="DoNotImplement-注解"><a href="#DoNotImplement-注解" class="headerlink" title="@DoNotImplement 注解"></a><code>@DoNotImplement</code> 注解</h3><p>Corda API中的某些接口和抽象类已被标注为@DoNotImplement。虽然我们承诺不删除或修改任何这些类的现有功能，但注释是我们可能需要在将来版本的Corda中扩展它们的警告。因此，Cordapp开发人员应该“按原样”使用这些类，而不是试图扩展或实现它们中的任何一个。</p><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Corda普遍使用一种自定义形式的安全二进制序列化。这样做的目的是：</p><ul><li>希望有一个模式（schema）描述与实际数据一起被序列化的内容<ul><li>版本控制（以前的序列化数据也能被识别）</li><li>为了更容易编写泛型代码，例如可以导航序列化数据形式的用户接口。</li><li>支持跨平台（非JVM）交互，其中类文件的格式不容易解释。</li></ul></li><li>希望使用独立于平台并且不受第三方库升级等影响的文档化和静态线路格式。</li><li>希望支持开放式多态，其中超类的子类的数量可以随时间扩展并且子类不需要在模式中预先定义。这是很多Corda概念的关键，例如状态。</li><li>通过支持的构造函数构造反序列化对象来提高安全性，而不是直接将数据插入到其字段中，而没有机会验证一致性或拦截尝试操纵假定的不变量。</li><li>二进制格式比数字签名更适用于基于文本的格式，因为修改语法的范围要小得多，而不是语义。</li></ul><h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>经典的Java序列化，JVM类路径上的任何类都可以反序列化。通过利用类路径上的大量第三方库作为JVM应用程序依赖关系和精心设计的反序列字节流的一部分，这已被证明是漏洞利用和漏洞的来源。在Corda中，我们通过坚持每个对象的类属于允许的类的白名单中，阻止任何类被反序列化（并在序列化过程中主动）。</p><p>类通过三种机制之一进入白名单：</p><ul><li>通过<code>@CordaSerializable</code>注解。这个注解可能存在接口和超类的注解上。</li><li>通过实现<code>SerializationWhitelist</code>接口并指定白名单类别的列表。</li><li>通过内置的Corda白名单（见<code>DefaultWhitelist</code>类）。虽然这不是用户可编辑的，但它列出了为方便您而列入白名单的常见JDK类。</li></ul><p>注解的方式是加入白名单的首选方式。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvdHV0b3JpYWwtY2xpZW50cnBjLWFwaS5odG1s" title="https://docs.corda.net/releases/release-V3.1/tutorial-clientrpc-api.html">Using the client RPC API<i class="fa fa-external-link"></i></span>是一个实例。</p><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>目前，基于Kryo的格式仍然被客户端和服务器端的RPC框架所使用。但是，计划很快RPC框架将转向AMQP框架。</p><p>将序列化方案分离到不同的上下文中使我们能够为该上下文使用最合适的框架，而不是试图强制采取一刀切的方法。Kryo更适合于程序堆栈框架的序列化，因为它比我们的AMQP框架在构建和序列化方面更加灵活。但是，这种灵活性使得安全性变得异常困难。相反，我们的AMQP框架允许我们专注于可以推理的安全框架，从而使安全性更低，安全漏洞更少。</p><h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><p>本节介绍AMQP序列化格式支持的类和接口。</p><ul><li>集合类型</li><li>JVM原始类型</li><li>数组</li><li>JDK类型：支持的类型可以查阅原文</li><li>第三方的类型</li><li>Corda类型：<code>@CordaSerializable</code>注解的类和接口</li></ul><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>您自己的类型必须遵守以下支持的规则：</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h5><ol><li>该类必须使用包含在<code>.class</code>文件中的参数名称进行编译。这是Kotlin中的默认设置，但必须使用<code>javac</code>的<code>-parameters</code>命令行选项打开。</li><li>这个类必须要用<code>@CordaSerializable</code>注解</li><li>必须支持构造函数参数，getter和setter的声明类型，并且在使用泛型时，泛型参数必须是受支持的类型，开放式通配符（*）或有界通配符，该通配符目前被扩展为开放式通配符</li><li>任何超类都必须遵守相同的规则，但可以是抽象的</li><li>对象引用循环不受支持，因此对象无法直接或间接引用自身</li></ol><h4 id="构造函数实例化"><a href="#构造函数实例化" class="headerlink" title="构造函数实例化"></a>构造函数实例化</h4><p>Corda的AMQP序列化框架实例化对象的主要方式是通过指定的构造函数。这用于首先确定对象的哪些属性将被序列化，然后在反序列化时用于使用序列化值实例化对象。</p><p>建议Corda中的可序列化对象遵守以下规则，因为它们允许不可变状态对象被反序列化：</p><ol><li>一个Java Bean getter，用于构造函数中的每个属性，并具有表单的名称<code>getX</code>。</li><li>一个构造函数，它采用您希望以序列化形式记录的所有属性。这是序列化框架重建类的一个实例所必需的.</li><li>如果提供了多个构造函数，则序列化框架需要知道使用哪一个。<code>@ConstructorForDeserialization</code> 注释可以被用来指示哪一个。对于没有<code>@ConstructorForDeserialization</code>注解的Kotlin类，将选择主构造函数</li></ol><h4 id="Setter实例化"><a href="#Setter实例化" class="headerlink" title="Setter实例化"></a>Setter实例化</h4><p>作为基于构造函数初始化的替代，Corda还可以通过检查类中存在的getter和setter方法来确定对象的重要元素。如果一个类只有一个默认的构造函数和属性，那么可序列化的属性将由该属性的getter和setter的存在来确定，这些属性都是公开可见的（即该类遵守可变JavaBean 的经典成语）。</p><p>在反序列化中，首先会创建一个默认实例，然后调用该对象以使用正确的值填充它。</p><h4 id="无法访问的私有属性"><a href="#无法访问的私有属性" class="headerlink" title="无法访问的私有属性"></a>无法访问的私有属性</h4><p>虽然Corda AMQP序列化框架支持私有对象属性，但没有可公开访问的getter方法，但强烈建议不要使用此开发习惯用法。</p><h4 id="不匹配的类属性-构造函数参数"><a href="#不匹配的类属性-构造函数参数" class="headerlink" title="不匹配的类属性/构造函数参数"></a>不匹配的类属性/构造函数参数</h4><p>考虑一个例子，您希望确保类型为某种形式容器的类的属性总是按照某些特定条件进行排序，但您希望保持该类的不变性。</p><h4 id="可变容器"><a href="#可变容器" class="headerlink" title="可变容器"></a>可变容器</h4><p>因为Java从根本上不提供可以确定类的可变性的机制，所以这给序列化框架带来了问题。当用容器属性（列表，地图等）重新构建对象时，我们必须选择是创建可变对象还是不可变对象。考虑到这些限制，我们决定保留不可变对象的不变性更好，而不是强制推断不可变对象的可变性。</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>所有的枚举都支持，只要它们被<code>@CordaSerializable</code>注解。Corda支持枚举类型版本的互操作性。这允许这样的类型随时间改变而不破坏反向（或向前）兼容性。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvc2VyaWFsaXphdGlvbi1lbnVtLWV2b2x1dGlvbi5odG1s" title="https://docs.corda.net/releases/release-V3.1/serialization-enum-evolution.html">Enum Evolution<i class="fa fa-external-link"></i></span>讨论了这样做的规则和机制。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>以下规则适用于受支持的<code>Throwable</code>实现。</p><ol><li>如果你希望你的异常是可序列化和安全传输的，它应该继承自<code>CordaException</code>或者<code>CordaRuntimeException</code></li><li>如果不是，该<code>Throwable</code>遗嘱将反序列化为一个<code>CordaRuntimeException</code>包含其中的原件的详细信息 <code>Throwable</code>，包括原始的类名称<code>Throwable</code></li></ol><h4 id="Kotlin对象"><a href="#Kotlin对象" class="headerlink" title="Kotlin对象"></a>Kotlin对象</h4><p>略</p><h3 id="类合成"><a href="#类合成" class="headerlink" title="类合成"></a>类合成</h3><p>Corda序列化支持在反序列化时从提供的模式动态合成类，而不在类路径中存在支持类。在通用代码可能希望能够对反序列化的数据，在JVM上运行的脚本语言以及确保不在类路径上的类可以反序列化而不加载潜在的恶意代码的情况下，这可能是有用的。</p><p>未来可能的增强包括：</p><ol><li>Java单例支持。我们将添加支持以识别单身人士的类别，并确定负责返回单身人士实例的静态方法</li><li>实例内化支持。我们将添加对确定应根据实例映射解析的类的支持，以避免创建许多相同（类似于String.intern()）的重复实例，</li></ol><h3 id="类型演变"><a href="#类型演变" class="headerlink" title="类型演变"></a>类型演变</h3><p>类型演化是类可以随时间改变的机制，但仍然可以在所有类型的版本中保持序列化和反序列化。这确保了一个对象的序列化，它具有旧类型的“看起来像”类可以被反序列化的版本以及实例化类的当前状态的版本。</p><p>更多细节可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvc2VyaWFsaXphdGlvbi1kZWZhdWx0LWV2b2x1dGlvbi5odG1s" title="https://docs.corda.net/releases/release-V3.1/serialization-default-evolution.html">Default Class Evolution<i class="fa fa-external-link"></i></span>中找到。</p><h2 id="安全的编码准则"><a href="#安全的编码准则" class="headerlink" title="安全的编码准则"></a>安全的编码准则</h2><p>该平台通过默认设计确保安全。不幸的是，该平台无法防止各种安全错误。本文档描述了在编写应用程序以阻止各种攻击时需要考虑的问题。尽管假设没有合理的交易对手试图用流程级别的攻击来颠覆您的交易可能会很诱人，但是依靠信任来提高软件安全性会使您很难在稍后想要快速添加对手方并且没有广泛审查的情况下扩展您的业务。</p><h3 id="流动"><a href="#流动" class="headerlink" title="流动"></a>流动</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZmxvdy1zdGF0ZS1tYWNoaW5lcy5odG1s" title="https://docs.corda.net/releases/release-V3.1/flow-state-machines.html">编写流程<i class="fa fa-external-link"></i></span>是您的应用程序与网络上的其他各方进行通信的方式。因此，它们是恶意数据进入您应用程序的典型切入点，必须小心处理。</p><p>这些<code>receive</code>方法返回包装在<code>UntrustworthyData&lt;T&gt;</code>标记类型中的数据。这种类型不会添加任何功能，它只是提醒您正确验证从网络获得的所有内容。请记住，另一方可能没有运行您提供的用于参与流程的代码：他们被允许执行任何操作！需要注意的事项：</p><ul><li>例如，如果您建议为资产交易价值100美元的现金状态，并且签署的交易从另一方返回，则该交易与流程中较早建立或建议的部分交易不匹配，您必须检查它指向您实际请求的状态。否则，攻击者可以让你签署一项交易，如果他们知道一个ID的话，那么这笔交易将花费更多的时间给你。</li><li>一个不正确类型的交易。有两种交易类型：普通和公证变更。如果您希望获得一种类型，但获得另一种类型，则可能会发现自己签署了一项交易，将您的资产转移到敌对公证人的控制之下。</li><li>交易中各状态的意外更改。如果您有权访问所有需要的数据，则可以重新运行构建器逻辑并对结果状态进行比较，以确保它符合您的预期。例如，如果构建下一个状态所需的数据对双方都可用，则计算您想要相互同意的交易的函数可以在实现流程的两端的两个类之间共享。</li></ul><p>主题应该清楚：签名是一项非常敏感的操作，因此您需要确保您知道您要签名的是什么，并且输出没有任何变化！一旦您通过交易向交易对手提供了您的签名，就不再有任何事情可以阻止他们将其交付给分类账。</p><h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><p>合同是JVM沙箱内的任意函数，因此它们有很大的自由度。需要注意的事项：</p><ul><li>当前状态转换不应允许的状态更改。你会想要检查没有领域正在改变，除了预期的领域！</li><li>意外捕获并丢弃可能由验证逻辑抛出的异常。</li><li>如果您不知道其他合约是做什么或可能做什么，则通过虚拟方法调用其他合约。</li></ul><h2 id="流程cookbook"><a href="#流程cookbook" class="headerlink" title="流程cookbook"></a>流程cookbook</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZmxvdy1jb29rYm9vay5odG1s" title="https://docs.corda.net/releases/release-V3.1/flow-cookbook.html">该流程<i class="fa fa-external-link"></i></span>展示了如何在Java和Kotlin中使用Corda的API。</p><h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvY2hlYXQtc2hlZXQuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/cheat-sheet.html">这个网页<i class="fa fa-external-link"></i></span>是Corda知识的备忘单。</p><h2 id="Cordapp示例"><a href="#Cordapp示例" class="headerlink" title="Cordapp示例"></a>Cordapp示例</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYnVpbGRpbmctYS1jb3JkYXBwLXNhbXBsZXMuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/building-a-cordapp-samples.html">CorDapp samples<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda基础学习</title>
      <link href="//blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html"/>
      <url>//blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在上一篇的博客中，我提到了Corda的一些基础的知识，但是那个版本是比较旧的，这次针对新的版本，写一些笔记来完成相应的更新。</p><h2 id="Corda-Network"><a href="#Corda-Network" class="headerlink" title="Corda Network"></a>Corda Network</h2><p>关于Corda的网络，有以下几点：</p><ol><li>这个网络由运行Corda和CorDapps的节点组成。</li><li>网络是授权的，通过doorman控制权限</li><li>节点之间的通信是点对点的，不依赖全局广播。</li></ol><h3 id="Network结构"><a href="#Network结构" class="headerlink" title="Network结构"></a>Network结构</h3><p>Corda网络是一个认证的节点点对点网络，里面每一个节点都是有Corda服务并且执行CorDapps应用的JVM运行环境。</p><p><b style="color:red">节点之间的通信是直接的，通过AMQP/1.0发送TLS加密的信息。是点对点的，不采用广播的方式。</b></p><p><b style="color:#00f">每个网络存在网络映射(map)服务，可以发布网络上每个节点都可以访问的IP地址，以及这些节点的身份证书和它们提供的服务。</b></p><h3 id="doorman"><a href="#doorman" class="headerlink" title="doorman"></a>doorman</h3><p>Corda网络是半私人的。每个网络都有一个门卫服务，用于执行关于节点必须提供的信息的规则以及他们在被允许进入网络之前必须完成的了解您的客户(KYC)流程。</p><p>要加入网络，节点必须联系门卫并提供所需的信息。如果门卫感到满意，该节点将从网络的许可服务接收根权威机构签署的TLS证书。此证书在与网络上的其他参与者通信时验证节点的身份。</p><p><b style="color:red">注：在源码中发现就是发送http请求，而且还要设置一个URL。详细的信息可以参阅源码部分。</b></p><p>我们可以将网络可视化如下：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda%E7%BD%91%E7%BB%9C.png?raw=true"></p><h3 id="Network中的服务"><a href="#Network中的服务" class="headerlink" title="Network中的服务"></a>Network中的服务</h3><p>节点可以提供几种类型的服务：</p><ul><li>一个或多个可插式公证服务。公证人保证分类账更新的唯一性和可能性。每个公证服务可以在单个节点上运行，也可以在一组节点上运行。</li><li>零个或更多的Oracle服务。Oracle是一个众所周知的服务，<b style="color:red">如果他们陈述事实并且事实被认为是真实的，那么它就会签署交易。</b></li></ul><h2 id="账本Ledger"><a href="#账本Ledger" class="headerlink" title="账本Ledger"></a>账本Ledger</h2><p>概要</p><ul><li>分类账从每个节点的角度来看都是透明的对象</li><li>两个节点总是保证看到他们分享的任何分类账事实完全相同的版本</li></ul><h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在Corda，没有单一的中央数据存储。相反，每个节点都维护一个已知事实的单独数据库。因此，每个节点只能看到分类帐上的一小部分事实，并且没有节点完全知道分类账。</p><p>例如，想象一个具有五个节点的网络，其中每个彩色圆圈表示一个共享事实：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-venn.png?raw=true"></p><p>我们可以看到尽管Carl，Demi和Ed都感知了事实3，，但是Alice和Bob却不知道事实3的存在。</p><p>同样重要的是，Corda保证，无论何时这些事实中的一个在网络多个节点间共享，它在每个知道它的节点的数据库中以锁的方式发展。<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-table.png?raw=true"></p><p>例如，Alice和Bob都会看到共享事实1和7的相同版本。</p><h2 id="身份Identity"><a href="#身份Identity" class="headerlink" title="身份Identity"></a>身份Identity</h2><p>概要</p><ul><li>Corda中的身份可以代表合法身份或服务身份</li><li><b style="color:red">身份证明由门卫签署的X.509证书或公认的身份证明</b></li><li>众所周知的身份发布在网络地图(map)中（NetworkMapService，这个在源码中我们也可以看到）</li><li>机密身份仅在需要知道的基础上共享</li></ul><p>Corda中的身份可以表示：</p><ul><li>一个组织的法律身份</li><li>网络服务的服务标识（该节点只是提供服务而已）</li></ul><p><b style="color:red">法律身份用于交易中的各方，例如现金状态的所有者。服务标识用于提供与交易相关的服务的人员，例如公证人员或oracle。</b>服务身份与合法身份不同，因此分布式服务可以存在于不同组织所拥有的节点上。这种分布式服务身份是基于的<code>CompositeKeys</code>，它描述了服务签名的有效签名者集合。有关<code>CompositeKeys</code>的更多技术细节，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLWNvcmUtdHlwZXMuaHRtbA==" title="https://docs.corda.net/releases/release-V3.1/api-core-types.html">API：核心类型<i class="fa fa-external-link"></i></span>。</p><p><b style="color:red">身份是众所周知的还是保密的，取决于他们的X.509证书（和对应的证书路径是否可信的根证书）已发布：</b>.</p><ul><li>众所周知的身份是法律实体或服务的一般可识别的公钥，这使得它们不适用于需要参与者保密的交易。<b style="color:#00f">此证书已发布在网络地图服务中供任何人访问。</b></li><li>机密身份只发布给参与交易的人员。公钥可能暴露给第三方（例如公证服务），但名称和X.509证书的分发是受限的。</li></ul><p>虽然Corda交易隐私模式有几个要素，包括确保交易只与需要查看它们的用户共享以及有计划地使用英特尔SGX，但重要的是要提供深入的防御隐私攻击。机密身份用于确保即使第三方访问未加密的交易，他们也无法在没有附加信息的情况下识别参与者。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>节点必须能够验证使用X.509证书实现的公钥所有者的身份。<b style="color:red">首次运行时，节点生成密钥对并向网络门卫服务提交证书签名请求</b>（请参阅 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvcGVybWlzc2lvbmluZy5odG1s" title="https://docs.corda.net/releases/release-V3.1/permissioning.html">网络许可<i class="fa fa-external-link"></i></span>）。Doorman服务应用适当的身份检查，<b style="color:red">然后向用作节点认证中心（CA）的节点发放证书</b>。从该初始CA证书中，节点自动创建并签署两个其他证书，一个TLS证书(sslKeyStore)和一个用于该节点众所周知的身份的签名证书(nodeKeyStore)。最后，节点建立包含其地址和众所周知的身份的节点信息记录，并将其注册到网络地图服务。</p><p>组织可以从签署证书创建公开和机密身份。众所周知的身份的用例包括代表用于冗余目的的单个身份的节点集群，或者为组织单位创建身份。</p><p>组织需要决定他们希望在网络地图服务中发布哪些身份，使其广为人知，并且出于隐私原因（通常是为了避免暴露商业敏感的交易细节），他们希望将其保留为机密身份。<b style="color:red">在某些情况下，出于操作原因，除了主网络地图服务之外，节点还可能使用专用网络地图服务。</b>使用此类网络地图注册的身份必须被认为是众所周知的，并且将机密身份存储在中央目录中，而不在记录级别应用控制，以确保只有需要访问身份的人才能检索其证书。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>概要：</p><ul><li>状态代表了分类账事实</li><li>通过将当前状态标记为历史的并创建更新状态来进行状态演变</li><li>每个节点都有一个保管库（Vault，可以是放入数据库中，有相应接口，默认是放在内存中），它在其中存储任何相关的状态</li></ul><h3 id="概观-1"><a href="#概观-1" class="headerlink" title="概观"></a>概观</h3><p>状态可以包含任意数据，允许它们表示任何种类的事实（例如股票，债券，贷款，KYC数据，身份信息……）。例如，以下状态代表IOU - Alice欠Bob的协议金额X：</p><p><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/state.png"></p><p>除了关于事实本身的任何信息外，状态还包含对管理状态演变随时间推移的合约（Contract）的引用。</p><h3 id="状态序列"><a href="#状态序列" class="headerlink" title="状态序列"></a>状态序列</h3><p>共享事实随时间的生命周期由状态序列表示。当一个状态需要更新时，我们创建代表新状态的新版本状态，并将现有状态标记为历史状态。</p><p><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/state-sequence.png"></p><h3 id="金库-Vault"><a href="#金库-Vault" class="headerlink" title="金库(Vault)"></a>金库(Vault)</h3><p>网络上的每个节点都有一个保管库（Vault） - 一个数据库，用于追踪所有当前和历史状态，以及它认为与自身相关的所有当前状态和历史状态.</p><h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>概要</p><ul><li>每个输入和输出状态的合约都必须接受有效的交易</li><li>合约是用JVM编程语言（如Java或Kotlin）编写的，</li><li>合约执行是确定性的，其对交易的接受仅基于交易的内容</li></ul><h3 id="交易验证"><a href="#交易验证" class="headerlink" title="交易验证"></a>交易验证</h3><p>回想一下，交易只有在所有必需的签名者都进行了数字签名的情况下才有效。但是，即使交易收集了所有必需的签名，它也仅在合约有效的情况下才有效。</p><p>合约有效性定义如下：</p><ul><li><b style="color:red">每个状态都指向一份合约</b></li><li>一个合约需要一个交易作为输入，并指出根据合约的规则的交易是否被认为是有效的</li><li>只有当每个输入状态和每个输出状态的合约认为其有效时，交易才有效</li></ul><p><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/tx-validation.png"></p><p>合约代码可以用任何JVM语言编写，并且可以使用该语言的全部功能，包括：</p><ul><li><b style="color:red">检查输入，输出，命令，时间戳和/或附件的数量</b></li><li>检查这些组件的内容</li><li>循环结构，变量赋值，函数调用，辅助方法等</li><li>将类似的状态分组以验证它们是否为一组（例如，对所有现金状态的总价值施加一个规则）</li></ul><p>非合约有效的交易不是更新分类帐的有效提案，因此不能提交给分类账。通过这种方式，合约对状态随时间推移的演变规定了独立于所需签名人签署给定交易的意愿的规则。</p><h3 id="合约沙箱"><a href="#合约沙箱" class="headerlink" title="合约沙箱"></a>合约沙箱</h3><p>交易验证必须是确定性的 - 合约应始终接受或始终拒绝给定的交易。例如，交易有效性不能取决于进行验证的时间，也不取决于合作伙伴运行合约的信息量。这是确保网络上的所有同行对特定分类帐更新的有效性达成共识的必要条件。</p><p><b style="color:red">为了达到这个目的，合约评估确定性沙箱中的交易。沙盒有一个白名单（这就是在源码看到的WhiteList的作用了吧，不过这个白名单是针对附件的），可以防止合约导入可能成为非确定性来源的库</b>。这包括提供当前时间的库，随机数生成器，提供文件系统访问的库或网络库等。最终，验证交易时可用于合约的唯一信息是交易本身中包含的信息。</p><h3 id="合约限制"><a href="#合约限制" class="headerlink" title="合约限制"></a>合约限制</h3><p>由于合约无法获得外部信息，它只能检查交易的内部有效性。例如，它不能检查交易是否与最初与交易对手达成一致。</p><p>因此，节点在签署交易之前应检查交易内容，即使交易合约有效，以查看他们是否同意提议的分类帐更新。节点没有义务签署一项交易，只是因为它在合约中有效。例如，他们可能不愿意承担过大的贷款，或可能不同意为资产提供的现金数额。</p><h3 id="神谕（Oracle）"><a href="#神谕（Oracle）" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h3><p>有时，交易有效性将取决于一些外部信息，例如汇率。在这些情况下，需要一个oracle。有关更多详细信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjIva2V5LWNvbmNlcHRzLW9yYWNsZXMuaHRtbA==" title="https://docs.corda.net/releases/release-V3.2/key-concepts-oracles.html">Oracles<i class="fa fa-external-link"></i></span>。</p><h3 id="法律散文（legal-prose）"><a href="#法律散文（legal-prose）" class="headerlink" title="法律散文（legal prose）"></a>法律散文（legal prose）</h3><p>每份合约还涉及法律散文文件，其中规定了与传统法律体系兼容的随时间推移的状态演变规则。在法律纠纷的情况下，可以依靠这份文件。</p><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>概要</p><ul><li>交易是更新分类账的提案</li><li>交易提案承诺以下情况：<ul><li>它不包含双重花费</li><li>这是合约有效的</li><li>它由所需方签署</li></ul></li></ul><p>Corda使用UTXO（未使用的交易输出）模型。其中分类帐上的每个状态都是不可变的。分类账通过应用交易随着时间的推移而发展，交易通过将零个或多个现有分类账状态标记为历史（输入）并产生零个或多个新分类账状态（输出）来更新分类账。交易表示在状态中看到的状态序列中的单个链接。<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.2/_images/basic-tx.png"></p><p>交易可以包含任何数量任何类型的输入和输出：</p><ul><li>可以包含很多不同的状态类型（比如，包含现金和股票）</li><li><b style="color:red">可以是发行的（没有任何输入）或者退出（没有任何输出）</b></li><li>他们可以合并或者分割可替代资产（就像付10元收2元找8元）</li></ul><p>交易是原子的：要么所有交易的提议变更都被接受，要么都没有。</p><p>这里有两种基础交易类型：</p><ul><li>公证改变交易（用来改变一个状态的公证人，参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjIva2V5LWNvbmNlcHRzLW5vdGFyaWVzLmh0bWw=" title="https://docs.corda.net/releases/release-V3.2/key-concepts-notaries.html">Notaries<i class="fa fa-external-link"></i></span>）</li><li>普通的交易（其它的交易）</li></ul><h3 id="交易链"><a href="#交易链" class="headerlink" title="交易链"></a>交易链</h3><p>在创建新交易时，交易将申明的输出状态尚不存在，因此必须由交易提议者创建。但是，输入状态已作为先前交易的输出存在。因此，我们将其纳入拟议的交易中。</p><p>这些输入状态引用是下面的组合：</p><ul><li>交易创建输入的hash</li><li>输入的在上一个交易中的输出的索引</li></ul><p>这个情况可以使用下图来说明：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.2/_images/tx-chain.png"></p><p>这些输入状态引用（StateRef）将交易连接在一起，形成所谓的交易链。</p><h3 id="提交交易"><a href="#提交交易" class="headerlink" title="提交交易"></a>提交交易</h3><p>最初，交易只是更新分类帐的建议.<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/uncommitted_tx.png"></p><p>要成为现实，交易必须接收所有必需的签名者的签名（参见下面的命令）。每位必需的签名者将其签名附加到交易中以表明他们批准该提案：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/tx_with_sigs.png"></p><p>如果所有必需的签名都被收集起来，交易将变为已提交：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/committed_tx.png"></p><p>这意味着：</p><ul><li>交易的输入被标记为历史性的，并且不能用于任何未来的交易</li><li>交易的产出成为分类账当前状态的一部分</li></ul><h3 id="交易有效性"><a href="#交易有效性" class="headerlink" title="交易有效性"></a>交易有效性</h3><p>如果以下两个条件成立，每个必需的签名者只应签署交易：</p><ul><li>交易有效性：对于提议的交易以及创建当前提议的交易输入的交易链中的每个交易：<ul><li>交易由所有必要方进行数字签名</li><li>合约验证交易有效（查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjIva2V5LWNvbmNlcHRzLWNvbnRyYWN0cy5odG1s" title="https://docs.corda.net/releases/release-V3.2/key-concepts-contracts.html">Contracts<i class="fa fa-external-link"></i></span>）</li></ul></li><li>交易唯一性：没有其他交易已经消耗了我们建议交易的任何投入</li></ul><h3 id="其他交易组件"><a href="#其他交易组件" class="headerlink" title="其他交易组件"></a>其他交易组件</h3><p>除输入状态和输出状态外，交易可能包含：</p><ul><li>命令Commands</li><li>附件Attachments</li><li>时间戳Timestamps</li></ul><p>例如，一项交易，其中Alice使用5英镑的现金支付与Bob支付5英镑的欠条，由两个附件和时间戳支持，可能如下所示：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.2/_images/full-tx.png"></p><p>我们将探讨下面剩余交易组件所扮演的角色。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>假设我们有一个以现金状态和债券状态作为输入的交易，以现金状态和债券状态作为输出。该交易可能代表两种不同的情况：</p><ul><li>债券购买</li><li>债券上的息票支付</li></ul><p>我们可以想象，我们希望对构成有效交易的内容施加不同的规则，具体取决于这是购买还是优惠券付款。例如，在购买的情况下，我们需要改变债券的当前所有者，而在支付息票的情况下，我们会要求债券的所有权不变。</p><p>为此，我们有命令。在交易中包含命令可以让我们指出交易的意图，从而影响我们如何检查交易的有效性。</p><p>每个命令还与一个或多个签名者列表关联。通过将命令中列出的所有公钥的联合，我们得到交易所需的签名者列表。在我们的例子中，我们可以想象：</p><ul><li>在债券的息票付款中，只有债券所有者需要签署</li><li>在现金支付中，只需要现金的所有者签字</li></ul><p>我们可以看到这种情况如下：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/commands.png"></p><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>有时，我们有大量的数据可以在许多不同的交易中重用。一些例子：</p><ul><li>公众假期日历</li><li>支持法律文件</li><li>货币代码表</li></ul><p>对于这个用例，我们有附件。每个交易可以通过哈希引用零个或多个附件。这些附件是包含任意内容的ZIP/JAR文件。这些文件中的信息可以在检查交易的有效性时使用。</p><h3 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h3><p>在某些情况下，我们希望建议的交易只能在特定时间段内批准。例如：</p><ul><li>期权只能在特定日期后执行</li><li>债券只能在到期日前赎回</li></ul><p>在这种情况下，我们可以为交易添加一个时间窗口。时间窗口指定了可以提交交易的时间窗口。我们讨论时间窗口部分的时间窗口。</p><h2 id="流程（Flow）"><a href="#流程（Flow）" class="headerlink" title="流程（Flow）"></a>流程（Flow）</h2><p>概要</p><ul><li>流程自动化了同意分类帐更新的过程</li><li>节点之间的通信只发生在这些流程的上下文中，并且是点对点的</li><li>提供了内置流程来自动化常见任务</li></ul><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>Corda网络使用点对点消息而不是全局广播。这意味着协调分类帐更新需要网络参与者准确指定需要发送的信息，交易对手以及以何种顺序。</p><p>以下是在Alice和Bob之间就简单分类账更新达成一致的过程的可视化：</p><p><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/flow.gif"></p><h3 id="流程框架"><a href="#流程框架" class="headerlink" title="流程框架"></a>流程框架</h3><p>Corda不需要手动指定这些步骤，而是使用流程自动化流程。流程是一系列步骤，告诉节点如何实现特定的分类帐更新，例如发放资产或结算交易。</p><p>以下是上述简单分类账更新中涉及的流程步骤顺序：<br><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/flow-sequence.png"></p><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>一旦给定的业务流程被封装在流中并作为CorDapp的一部分安装在节点上，节点的所有者就可以指示节点随时使用RPC调用启动该业务流程。该流程将所有网络，I / O和并发问题从节点所有者中抽象出来。</p><p>节点上的所有活动都发生在这些流程的上下文中。与合约不同，流程不在沙箱中执行，这意味着节点可以执行诸如网络，I/O等操作，并在流程执行过程中使用随机源。</p><h4 id="节点间通信"><a href="#节点间通信" class="headerlink" title="节点间通信"></a>节点间通信</h4><p>节点通过在流之间传递消息进行通信。每个节点具有零个或多个流类，它们被注册为响应来自单个其他流的消息。</p><p>假设Alice是网络上的一个节点，并希望与另一个网络节点Bob同意分类帐更新。为了与Bob沟通，Alice必须：</p><ul><li>开始注册Bob回应的流程</li><li>在该流程的上下文中向Bob发送消息</li><li>鲍勃将开始注册的交易对手流程</li></ul><p>现在建立了一个连接，Alice和Bob可以通过传递一系列来回传递的消息来同意分类账更新，如流程步骤中所规定的那样。</p><h4 id="子流程"><a href="#子流程" class="headerlink" title="子流程"></a>子流程</h4><p>可以通过在另一个流程的上下文中将流程作为子流程启动来组成流程。作为子流程开始的流程称为子流程。父流程将一直等到子流程返回。</p><h4 id="流程库"><a href="#流程库" class="headerlink" title="流程库"></a>流程库</h4><p>Corda提供了一个处理常见任务的流程库，这意味着开发人员不必重新定义常见流程背后的逻辑，例如：</p><ul><li>公证和记录交易</li><li>从对手方节点收集签名</li><li>验证一系列交易</li></ul><p>有关可用内置流程的更多信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvZmxvdy1saWJyYXJ5Lmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/flow-library.html">Flow库<i class="fa fa-external-link"></i></span>。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>流程框架允许节点一次有多个活动流。这些流量可能持续数天，跨节点重启甚至升级。</p><p>这是通过将数据流序列化到磁盘来实现的，只要它们进入阻塞状态（例如，当它们正在等待I / O或网络呼叫时）。与其等待流程畅通无阻，节点立即开始处理任何其他计划流程，仅在以后返回到原始流程。</p><h2 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h2><p>概要</p><ul><li>承诺，交易必须达到有效性和唯一性共识</li><li>有效性共识需要交易及其所有依赖关系的合约有效性</li><li>唯一性共识可以防止双重花费</li></ul><h3 id="两种共识"><a href="#两种共识" class="headerlink" title="两种共识"></a>两种共识</h3><p>确定提议的交易是否是有效的分类帐更新涉及达成两种类型的共识：</p><ul><li>有效性共识 - 在签署交易前由每个必需签署者检查</li><li>唯一性共识 - 只有公证服务才能检查</li></ul><p>有效性共识是检查以下条件是否适用于拟议交易以及交易链中为交易提议交易产生输入的每个交易的过程：</p><ul><li>交易被每个输入和输出状态的合约所接受</li><li>交易拥有所有必需的签名</li></ul><p>验证提议的交易本身是不够的。我们还必须核实导致建立交易建议输入的交易链中的每一笔交易。</p><p>这就是所谓的走链。例如，假设网络上的一方提出将我们的国债转让给我们的交易。在下列情况下，我们只能确保债券转移有效：</p><ul><li>国债是由中央银行在有效的发行交易中发行的</li><li>债券交易后的每一次交易都是有效的</li></ul><h3 id="唯一性共识"><a href="#唯一性共识" class="headerlink" title="唯一性共识"></a>唯一性共识</h3><p>唯一性共识是要求所提议的交易的投入没有一个在另一笔交易中已经消耗。</p><p>如果一个或多个输入已经在另一个交易中被使用，这就是所谓的双重支出，并且交易提议被认为是无效的。</p><p>公证人提供了唯一性共识。请参阅公证人了解更多详情。</p><h2 id="公证人（Notary）"><a href="#公证人（Notary）" class="headerlink" title="公证人（Notary）"></a>公证人（Notary）</h2><p>概要</p><ul><li>公证人防止“双花”</li><li>公证员也可以选择验证交易</li><li>一个网络可以有几个公证人，每个公证人都运行不同的共识算法</li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个公证是一种网络服务，它提供了独特的共识被证明的是，对于一个给定的交易，它尚未签署消耗任何拟议中的交易的输入状态的其他交易。</p><p>在被要求公证交易时，公证人可以：</p><ul><li>如果交易尚未签署其他消耗建议交易输入状态的交易，请签署交易</li><li>拒绝该交易并标记双重支出尝试已经发生</li></ul><p>这样做，公证人提供了系统中的终点。在获得公证人的签名之前，各方不能确定同等有效但冲突的交易不会被视为花费给定输入状态的“有效”尝试。但是，在获得公证人的签名后，我们可以确定提议的交易的输入状态尚未被先前的交易消耗。因此，公证是系统中的终点。</p><p>每个状态都有一个指定的公证人，如果公证人是所有交易输入状态的指定公证人，公证人只会公证一项交易。</p><h3 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h3><p>Corda具有“可插入”的共识，允许公证人根据隐私，可扩展性，法律系统兼容性和算法敏捷性的要求选择一致的算法。</p><p>特别是，公证人在以下方面可能会有所不同：</p><ul><li>结构 - 公证可能是单个网络节点，相互信任的节点群或相互不信任的节点群</li><li>共识算法 - 公证服务可以选择运行高速，高可信度算法，如RAFT，低速低信任算法（如BFT），或者其他任何其他共识算法</li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>公证服务还必须在提交之前通过确认每笔交易来决定是否提供有效性共识。在作出这个决定时，他们面临以下的交易：</p><ul><li><b style="color:red">如果一个交易没有被检查有效性，它会产生“拒绝状态”攻击的风险，在这种情况下，一个节点明知地建立一个无效的事务，消耗一些现有状态并将其发送给公证人，导致这些状态被标记为已消耗。（这是攻击风险，需要验证交易合法性以抵制这种攻击）</b>.</li><li>如果交易被检查的有效性，公证员将需要看到交易及其依赖的全部内容。这泄露了可能的私人数据给公证人</li></ul><p>在评估这种折衷时，还有几点需要注意。在非验证模型的情况下，Corda的受控数据分布模型意味着关于未消费状态的信息并未广泛共享。此外，Corda的许可网络意味着公证人可以存储创建“拒绝状态”交易的一方的身份，从而使得攻击能够逐个解决。</p><p>在验证模型的情况下，使用匿名的，新近生成的公钥而不是法定身份来识别交易中的当事方会限制公证人看到的信息。</p><h3 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h3><p>每个Corda网络可以有多个公证员，每个公证员可能运行不同的共识算法。这提供了几个好处：</p><ul><li>隐私 - 我们可以在同一网络上同时具有验证和非验证公证服务，每个都运行不同的算法。这使得节点能够按照每个交易选择首选公证人</li><li>负载平衡 - 通过多个公证处理交易负载可以为整个平台提供更高的交易吞吐量</li><li>低等待时间 - 等待时间可以通过选择与交易双方身体接近的公证员来最小化</li></ul><h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>请记住，如果公证人是所有交易输入状态的指定公证人，则公证人只会签署交易。但是，有些情况下我们可能需要更换状态的指定公证人。这些包括：</p><ul><li>当单个交易需要消耗具有不同指定公证人的多个状态时</li><li>由于隐私或效率问题，节点宁愿为给定的交易使用不同的公证人</li></ul><p>在这些交易可以创建之前，必须首先将各状态重新命名为全部具有相同的公证人。这是通过使用特殊的公证人更改交易来实现的，该交易需要：</p><ul><li>单个输入状态</li><li><b style="color:red">与输入状态相同的输出状态，但指定的公证人已更改（将输入的公证人更改掉作为输入即可）</b></li></ul><p>输入状态的指定公证人将签署交易，如果它不构成双重花费，此时一个状态将进入具有旧状态所有财产的存在，但具有不同的指定公证人。</p><h2 id="时间窗口-1"><a href="#时间窗口-1" class="headerlink" title="时间窗口"></a>时间窗口</h2><p>概要</p><ul><li>如果交易包含时间窗口，则只能在该窗口期间提交</li><li>公证人是时间戳管理机构，拒绝在该窗口之外提交交易</li><li>时间窗口可以有开始和结束时间，也可以在任何一端打开</li></ul><h3 id="在分布式系统中的时间"><a href="#在分布式系统中的时间" class="headerlink" title="在分布式系统中的时间"></a>在分布式系统中的时间</h3><p>公证人还充当时间戳的权力，验证在公证之前在特定时间窗口发生的交易。</p><p>创建交易的一方和公证人之间永远不会有精确的时钟同步。这不仅仅是由于物理和网络延迟的问题，而且还因为在插入命令和获得公证签名之间可能有许多其他步骤（例如将交易发送给交易中涉及的其他方，请求人签字…）。因此交易发送给公证人的时间可能与交易创建时间大不相同。</p><p>假设公证人的时间馈送是由美国海军天文台的原子钟定义的GPS / NaviStar时间。这个是非常准确的，全球免费提供。</p><h2 id="神谕（Oracle）-1"><a href="#神谕（Oracle）-1" class="headerlink" title="神谕（Oracle）"></a>神谕（Oracle）</h2><p>概要</p><ul><li>事实可以作为命令的一部分包含在交易中</li><li>如果包含的事实是真实的，则oracle是一种仅签署交易的服务</li></ul><h3 id="概观-2"><a href="#概观-2" class="headerlink" title="概观"></a>概观</h3><p>在很多情况下，交易的合约效力取决于一些外部数据，例如当前的汇率。但是，如果我们要让每个参与者根据他们自己对当前汇率的看法来评估交易的有效性，那么合同的执行将是非确定性的：一些签名者会认为交易是有效的，而另一些则认为它是无效的。因此，会在分类账的真实状态上产生分歧。</p><p>Corda使用oracles解决了这个问题。神谕（Oracle）是网络服务，根据请求提供封装特定事实（例如，时间x时的汇率）的命令，并将神谕列为必需的签名者。</p><p><b style="color:red">如果一个节点希望在交易中使用某个事实，他们会请求一个命令，从oracle中断言这个事实。如果oracle认为事实是真的，他们会发回所需的命令。然后节点将这个命令包含在他们的交易中，并且oracle将签署该交易来断言事实是真实的。</b></p><p>如果他们希望将他们的服务货币化，神谕可以选择只签署一笔交易，并证明其收取的费用是有效的。</p><h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p><a href="/2018/05/30/blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E4%BA%A4%E6%98%93%E6%8B%86%E5%88%86">交易拆分</a></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>概要</p><ul><li>节点是JVM运行时间，具有运行Corda软件的唯一网络标识</li><li>该节点有两个与外界的接口：<ul><li>网络层，用于与其他节点交互</li><li>RPC，用于与节点的所有者进行交互</li></ul></li><li>通过在插件注册表中安装CorDapps来扩展节点的功能</li></ul><h3 id="节点架构"><a href="#节点架构" class="headerlink" title="节点架构"></a>节点架构</h3><p>Corda节点是一个JVM运行时环境，在网络上具有唯一身份，用于承载Corda服务和CorDapps。</p><p>我们可以将节点的内部架构可视化如下：</p><p><img alt="" data-src="https://docs.corda.net/releases/release-V3.1/_images/node-architecture.png"></p><p>该体系结构的核心要素是：</p><ul><li>用于存储数据的持久层</li><li>用于与其他节点交互的网络接口</li><li>用于与节点所有者进行交互的RPC接口</li><li>一个服务中心（ServiceHub），用于允许节点的流程调用节点的其他服务</li><li>通过安装CorDapps扩展节点的cordapp界面和提供程序</li></ul><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><p>持久层有两部分：</p><ul><li>Vault，其中节点存储任何相关的当前和历史状态</li><li>存储服务（StorageService），它存储数据，附件和流程检查点（checkpoints）</li></ul><p>节点的所有者可以使用RPC接口查询节点的存储（见下文）。</p><h3 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h3><p>作为运行流程的一部分，与网络中其他节点的所有通信都由节点本身处理。节点的所有者不直接与其他网络节点交互。</p><h3 id="RPC接口"><a href="#RPC接口" class="headerlink" title="RPC接口"></a>RPC接口</h3><p>节点的所有者通过远程过程调用（RPC）与节点交互。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXJwYy5odG1s" title="https://docs.corda.net/releases/release-V3.1/api-rpc.html">API：RPC操作<i class="fa fa-external-link"></i></span>记录了节点公开的关键<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvYXBpLXJwYy5odG1s" title="https://docs.corda.net/releases/release-V3.1/api-rpc.html">RPC操作<i class="fa fa-external-link"></i></span>。</p><h3 id="服务中心（ServiceHub）"><a href="#服务中心（ServiceHub）" class="headerlink" title="服务中心（ServiceHub）"></a>服务中心（ServiceHub）</h3><p>在内部，节点可以访问在流程执行期间使用的一组丰富的服务，以协调分类帐更新。提供的主要服务是：</p><ul><li>有关网络上其他节点及其提供的服务的信息</li><li>访问保管库（Vault）内容和存储（Storage）服务</li><li>访问和生成节点的公钥 - 私钥对</li><li>关于节点本身的信息</li><li>当前时间，由节点跟踪</li></ul><h3 id="CorDapp提供商"><a href="#CorDapp提供商" class="headerlink" title="CorDapp提供商"></a>CorDapp提供商</h3><p>CorDapp提供程序是安装新的CorDapps以扩展节点行为的地方。</p><p>该节点还默认安装了几个CorDapps来处理常见任务，例如：</p><ul><li>检索交易对方的交易和附件</li><li>升级合同</li><li>广播商定的分类账更新以供对手方记录</li></ul><h4 id="排水模式（Draining-mode）"><a href="#排水模式（Draining-mode）" class="headerlink" title="排水模式（Draining mode）"></a>排水模式（Draining mode）</h4><p>为了使节点能够干净关闭，重要的是没有流程正在运行中，这意味着不应该坚持检查点。该节点能够处于流程排放模式，在此期间：</p><ul><li>需要通过RPC启动新流程的命令将被拒绝。</li><li>预计将要执行将被忽略。（那么这些流程应该如何进行处理呢？）</li><li>最初的P2P会话消息将不会被处理，这意味着对等方将无法发起涉及该节点的新流程。</li><li>所有其他活动将照常进行，确保机内流程的数量将严格减少。</li></ul><p>由于它们的数量（可以通过RPC进行监控）达到零，所以关闭节点是安全的。该属性是持久的，这意味着重新启动节点不会将其重置为默认值，并且需要RPC命令。</p><h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>概要</p><ul><li>权限的网络更适合财务用例</li><li>点对点通信允许共享需要知道的信息</li><li>UTXO模型允许每秒更多的交易处理</li></ul><h3 id="Permissioned-vs-permissionless"><a href="#Permissioned-vs-permissionless" class="headerlink" title="Permissioned vs. permissionless"></a>Permissioned vs. permissionless</h3><p>传统blockchain网络是permissionless。网络上的各方都是匿名的，可以随意加入和离开。</p><p>相比之下，Corda网络获得许可。网络上的每一方都有一个已知的身份，他们在与交易对手进行交流时使用，网络访问由门卫控制。这有几个好处：</p><ul><li>对于涉及受监管金融机构的大多数情况，匿名方不适用</li><li>了解您的交易对手的身份可以使用现有的法律体系，以分类方式解决冲突</li><li>如果没有使用诸如工作证明等昂贵的机制，Sybil攻击就可以避免</li></ul><h3 id="点对点与全球广播"><a href="#点对点与全球广播" class="headerlink" title="点对点与全球广播"></a>点对点与全球广播</h3><p>传统的区块链网络向每个参与者传播每一条消息。其原因有两方面：</p><ul><li>交易对手身份未知，因此必须将消息发送给每位参与者以确保其到达其预期接收者</li><li>让每个参与者意识到每一笔交易都可以让网络防止双重花费</li></ul><p>缺点是所有参与者都能看到其他人的数据。这在许多使用情况下是不可接受的。</p><p>在Corda中，每条消息都会发送给特定的对方，并且不会被任何无关的第三方看到。开发人员可以完全控制发送什么消息，向谁发送消息，以及按照什么顺序。因此，数据仅在需要知道的基础上共享。为了防止这种制度出现双重花费，我们聘请公证人作为工作证明的替代方案。</p><p>Corda还使用其他几种技术来最大化网络上的隐私：</p><ul><li>交易拆分：交易的结构方式允许他们在不公开交易内容的情况下进行数字签名。这是通过使用名为Merkle树的数据结构实现的。你可以在merkle-trees中阅读关于这种技术的更多信息。</li><li>密钥随机化：交易双方仅通过其公钥识别，并为每个交易生成新密钥对。因此，旁观者无法确定哪一方参与了某个交易。（公钥大家都可以看到，但是不会公布私钥，但是如何保证通信的安全是个问题）</li></ul><h3 id="UTXO与账户模式"><a href="#UTXO与账户模式" class="headerlink" title="UTXO与账户模式"></a>UTXO与账户模式</h3><p>Corda使用UTXO（未使用的交易输出）模型。每个交易消耗一组现有状态来产生一组新状态。</p><p>替代方案将是一个账户模型。在账户模型中，有状态对象存储在分类账上，事务采取请求的形式来更新这些对象的当前状态。</p><p>UTXO模型的主要优点是可以并行应用具有不同输入的交易，极大地增加了网络每秒潜在的交易量。在账户模型中，每秒交易数量受限于对给定对象的更新必须按顺序应用的事实。</p><h3 id="Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）"><a href="#Code-is-law（代码即法律）-vs-existing-legal-systems（现有法律系统）" class="headerlink" title="Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）"></a>Code-is-law（代码即法律） vs. existing legal systems（现有法律系统）</h3><p>金融机构需要有能力利用传统的法律制度解决冲突。Corda旨在通过以下方式使其成为可能：</p><ul><li>拥有许可的网络，意味着参与者知道他们在每次交易中处理的是谁</li><li>所有的代码合约都有一份法律文件的支持，这些文件描述了可以依靠解决冲突的合约的预期行为</li></ul><h3 id="构建与重用"><a href="#构建与重用" class="headerlink" title="构建与重用"></a>构建与重用</h3><p>只要有可能，Corda就会重新使用现有技术，使整个平台更加强健。例如，Corda重复使用：</p><ul><li>用于开发CorDapps的标准JVM编程语言</li><li>现有的SQL数据库</li><li>现有的消息队列实现</li></ul><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEva2V5LWNvbmNlcHRzLmh0bWw=" title="https://docs.corda.net/releases/release-V3.1/key-concepts.html">https://docs.corda.net/releases/release-V3.1/key-concepts.html<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Corda基础知识</title>
      <link href="//blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>//blockchain/corda/Corda%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>corda是分布式账本技术的一种，另一种大家已经熟知的就是HyperLedger的Fabric。当然这种插件化的开发也有公共链上的石墨烯技术，这种技术也是插件化的挖矿节点的实现，但是石墨烯技术是C++语言的实现，这里我就不做更多的说明了，关于石墨烯更多的介绍可以点击<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b25vbWV4L2dyYXBoZW5lcw==" title="https://github.com/cryptonomex/graphenes">这里<i class="fa fa-external-link"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly9zdGVlbWl0LmNvbS9ibG9ja2NoYWluL0Byb2Jpbndlbi9idHMtc3RlZW0tZW9z" title="https://steemit.com/blockchain/@robinwen/bts-steem-eos">这篇文章<i class="fa fa-external-link"></i></span>也做了详细的介绍。</p><p>Corda与Fabric的区别，官网的说法是Corda专注于金融这块，而Fabric是基于组织联盟的，但是不管怎样分布式账本技术都是借鉴了区块链的设计思想的；Fabric是插件化的，而Corda是模块化的，我觉得这点在软件设计上有很大的区别。Corda是基于Kotlin开发的，而Fabric主力语言是Go，但是也可以使用其他语言，并不限制。</p><p>如果你想了解更多的Corda知识，可以参阅官网的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLU03LjAvX3N0YXRpYy9jb3JkYS1pbnRyb2R1Y3Rvcnktd2hpdGVwYXBlci5wZGY=" title="https://docs.corda.net/releases/release-M7.0/_static/corda-introductory-whitepaper.pdf">技术白皮书<i class="fa fa-external-link"></i></span>。这个白皮书介绍了，这个系统最终的方案，现在还有很多未实现，正在实现中，当然在实现中可能会有与白皮书不一样的地方。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="包含的实现"><a href="#包含的实现" class="headerlink" title="包含的实现"></a>包含的实现</h3><p>Corda原型机目前包括：</p><ul><li>具有消息持久性和递送重试的对等网络。</li><li>用于定义合同和状态的关键数据结构。</li><li>智能合约，您可以在合约目录中找到。</li><li>与它们一起工作的算法，如序列化，散列，签名和签名验证。</li><li>API文档和教程（您正在阅读的内容）。</li><li>业务流程编排框架。</li><li>公证基础设施用于精确时间戳，并且在没有区块链的情况下消除双重花费。</li><li>一个简单的REST API和一个Web应用程序演示，用它来呈现IRS交易的前端。</li></ul><p>现在不包括，但是后面会进行实现的部分：</p><ul><li>沙盒，分销或发布智能合同代码</li><li>用于管理的用户界面</li></ul><p>现在的Corda版本仍然是创意的快速探索，所以为了提高开发的速度，会采取一些捷径，注意以下的一些事项：</p><ul><li>它使用一个对象映射序列化框架，而不是一个明确的，供应商中立的协议。</li><li>目前没有权限框架。（shiro或者Spring auth）</li><li>一些隐私技术尚未实施</li><li>它使用嵌入式SQL数据库，但尚未支持主流SQL供应商（Oracle，Postgres，MySQL，SQL Server等）的连接。</li></ul><h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>在corda项目下定义了一些示例程序，这些程序在samples目录下，运行的命令如官网的命令，这里就不做更多说明了。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLU03LjAvcnVubmluZy10aGUtZGVtb3MuaHRtbA==" title="https://docs.corda.net/releases/release-M7.0/running-the-demos.html">运行演示<i class="fa fa-external-link"></i></span></p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>corda网络是由运行Corda和CorDapps的节点组成</li><li>网络是授权网络，通过doorman控制访问</li><li>节点之间是点对点的交互，而不是一个全局的广播网络<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4>Corda网络是一个认证的节点点对点网络，里面每一个节点都是有Corda服务并且执行CorDapps应用的JVM运行环境。</li></ul><p>节点之间的交流都是直接的，通过AMQP/1.0发送TLS-加密的信息。这意味着数据只在需要知道的节点间共享，并没有全局广播。</p><p><b style="color:red">每个网络都有一个网络映射（map）服务，这个服务发布可以访问的节点IP地址，还有这些节点的身份证书和节点提供的服务。</b></p><h4 id="门卫（doorman）"><a href="#门卫（doorman）" class="headerlink" title="门卫（doorman）"></a>门卫（doorman）</h4><p><b style="color:red">Corda网络是半私有化的。每个网络都有一个门卫服务，门卫强制实施关于节点必须提供信息和在被准入网络前必须完成的KYC进程的规则。</b></p><p><b style="color:red">为了加入网络，节点必须联系门卫并提供需必要的信息。如果门卫同意了，节点会从网络权限服务收到一个根授权签名的TLS证书。当与其他参与交互时，这个证书用于证明节点的身份。</b></p><p>我们可以想象如下一个网络：<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda%E7%BD%91%E7%BB%9C.png?raw=true"></p><h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><p>节点提供几种类型的服务：</p><ul><li>一个或更多可插拔公证（Notary）服务。公证者保证账本更新的唯一性、可能性的有效性。每一个公证服务可能是在单个节点上运行，或者跨越节点集群。</li><li>零个或更多的神谕（oracle）服务。神谕是一个知名服务，如果他们阐明一个事实并且这个事实是真的，那么就签署交易。</li></ul><h3 id="账本Ledger"><a href="#账本Ledger" class="headerlink" title="账本Ledger"></a>账本Ledger</h3><ul><li>账本是每个节点透明的对象</li><li>两个节点总是被保证可以看到账本上他们共享事实的完全相同版本。</li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在Corda中，没有一个单独的中心数据存储。替代的是，每个节点维护一个独立的已知事实的数据库。所以，每个节点只会看到账本上事实的子集，并且没有节点可以感知到整个账本。</p><p>例如，想象一个拥有5个节点的网络；在这个网络上，每个彩色的圆代表一个共享的事实：<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-venn.png?raw=true"></p><p>我们可以看到尽管Carl，Demi和Ed都感知了事实3，，但是Alice和Bob却不知道事实3的存在。</p><p>同样重要的是，Corda保证，无论何时这些事实中的一个在网络多个节点间共享，它在每个知道它的节点的数据库中以锁的方式发展。<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/corda/ledger-table.png?raw=true"></p><p>例如，Alice和Bob都会看到共享事实1和7的相同版本。</p><h3 id="身份Identity"><a href="#身份Identity" class="headerlink" title="身份Identity"></a>身份Identity</h3><ul><li>Corda中的身份代表合法的身份或者服务识别。</li><li><b style="color:red">身份是通过Doorman签署的X.509证书签名或者一个已知证书。</b></li><li><b style="color:red">众所周知的身份发布在网络地图(map)中</b></li><li>机密身份仅在需要知道的基础上共享</li></ul><p>Corda中的身份代表：</p><ul><li>组织的合法身份</li><li>一个网络服务的服务身份</li></ul><p>合法身份是为交易的参与者使用，比如一个Cash状态的拥有者。服务身份是给这些提供交易相关服务使用，比如Notary，或者Oracle。服务身份与和合法身份是不同的，以至于一个节点上存在不同组织的服务。这些分散的服务身份是基于<code>CompositeKeys</code>;<code>CompositeKeys</code>为服务的签名描述有效的签名者集合。查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjIvYXBpLWNvcmUtdHlwZXMuaHRtbA==" title="https://docs.corda.net/releases/release-V3.2/api-core-types.html">API: Core types<i class="fa fa-external-link"></i></span>，了解更多关于<code>CompositeKeys</code>的知识。</p><p><b style="color:red">身份是众所周知的还是保密的，取决于他们的X.509证书（和对应的证书路径是否可信的根证书）已发布：</b>.</p><ul><li>众所周知的身份是法律实体或服务的一般可识别的公钥，这使得它们不适用于需要参与者保密的交易。此证书已发布在网络地图服务中供任何人访问。</li><li>机密身份只发布给参与交易身份的人员。公钥可能暴露给第三方（例如公证服务），但名称和X.509证书的分发是有限的。</li></ul><p>虽然Corda交易隐私模式有几个要素，包括确保交易只与需要查看它们的用户共享以及有计划地使用英特尔SGX，但重要的是要提供深入的防御隐私攻击。机密身份用于确保即使第三方访问未加密的交易，他们也无法在没有附加信息的情况下识别参与者。</p><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>节点必须能够验证使用X.509证书实现的公钥所有者的身份。<b style="color:red">首次运行时，节点生成密钥对并向网络门卫服务提交证书签名请求</b>（请参阅 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjEvcGVybWlzc2lvbmluZy5odG1s" title="https://docs.corda.net/releases/release-V3.1/permissioning.html">网络许可<i class="fa fa-external-link"></i></span>）。Doorman服务应用适当的身份检查，然后向用作节点认证中心（CA）的节点发放证书。从该初始CA证书中，节点自动创建并签署两个其他证书，一个TLS证书(sslKeyStore)和一个用于该节点众所周知的身份的签名证书(nodeKeyStore)。最后，节点建立包含其地址和众所周知的身份的节点信息记录，并将其注册到网络地图服务。</p><p>组织可以从签署证书创建公开和机密身份。众所周知的身份的用例包括代表用于冗余目的的单个身份的节点集群，或者为组织单位创建身份。</p><p>组织需要决定他们希望在网络地图服务中发布哪些身份，使其广为人知，并且出于隐私原因（通常是为了避免暴露商业敏感的交易细节），他们希望将其保留为机密身份。在某些情况下，出于操作原因，除了主网络地图服务之外，节点还可能使用专用网络地图服务。使用此类网络地图注册的身份必须被认为是众所周知的，并且将机密身份存储在中央目录中，而不在记录级别应用控制，以确保只有需要访问身份的人才能检索其证书。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>这里需要介绍状态（State）、交易（Transaction）和合约（Contract），以及它们之间的交互关系。</p><p>首先，交易消费的是状态（State），交易的作用就是将一个状态变换为一个新的状态。分类账被定义为一组不可变状态，由数字签名的交易创建和销毁。每个交易指向一组将要消耗/销毁的状态，这些状态称为<strong>输入</strong>，并且包含一组将会创建的新状态，这些状态称为<strong>输出</strong>。</p><p>其次，合约定义了一个验证函数，这是一个纯函数，以交易为输入。要被视为有效，交易必须被输入和输出状态所指向的每个合约的验证功能所接受。</p><p>除了输入和输出之外，交易还可能包括命令，小数据包，平台不会自行解释，但可以参数化执行合约。<b style="color:#00f">它们可以被认为是验证函数的参数。每个命令都有一个与之关联的公钥列表。该平台确保交易在合约开始执行之前由命令中列出的每个密钥签署。该平台确保交易在合同开始执行之前由命令中列出的每个密钥签署。因此，验证功能可以相信所有列出的密钥都签名了交易，但是负责验证交易从验证功能角度看是否有效所需的任何密钥都包含在列表中.</b></p><p><b style="color:red">命令总是嵌入在交易中。有时候，有很多数据可以在许多不同的交易中重复使用。这种使用的例子就是我们的附件。每个交易可以通过哈希引用0个或多个附件。附件始终都是ZIP/JAR文件，可能包含任何内容。这里可以看出命令与附件相关。</b></p><p><b style="color:red">请注意交易中可以有输入、输出、命令（Command）和附件（Attachment）。但是这些东西可能有也可能没有。交易中的数据需要合约来进行解释，并确保它们正确地结合在一起。</b></p><p><b style="color:red">交易有时可能需要提供带有外界数据的合约。可能包括以下的列子：股票价格、关于事件的事实或者法律实体的状态（例如破产）等等。这些事实的提供者称为神谕（oracles），他们通过签署包含他们已知的命令的交易或通过创建签名附件来为账本提供事实。这些命令包含事实和签名来彰显对此事实的一致。</b></p><p>时间也被建模为一个事实，并且有一种称为公证的特殊服务的签名。公证人是一种很有可能的分散式服务，<b style="color:red">它履行在其他区块链系统中矿工的作用</b>：公证人确保只有一项交易可以消耗任何给定的输出。此外，他们可以验证放置在交易中的时间戳命令，该命令指定交易被认为对公证有效的时间窗口。时间窗口可以是开放式的（即开始但不结束或反之亦然）。通过这种方式，交易可以与公证人的时钟相关联。</p><p>一个Corda网络可能有多个竞争公证人。每个状态（State）都指向控制它的公证人。虽然单个交易只有在全部由同一公证人控制的情况下才会消耗状态，但是提供了将一个状态（或一组状态）从一个公证转移到另一个公证的特殊类型的交易。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Amount"><a href="#Amount" class="headerlink" title="Amount"></a>Amount</h4><p>Amount类是用来表示一些可替代的资产的量。它是一个通用类，它包装用于定义基础产品的类型，称为Token。它可以是JDK的Currency类型，或者Issued，或者是更复杂的类型（例如义务合同签发定义（其中包含用于解决义务的标记定义）。）</p><p>使用示例如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// A quantity of some specific currency like pounds, euros, dollars etc.</span><br><span class="line">Amount&lt;Currency&gt;</span><br><span class="line">// A quantity of currency that is issued by a specific issuer, for instance central bank vs other bank dollars</span><br><span class="line">Amount&lt;Issued&lt;Currency&gt;&gt;</span><br><span class="line">// A quantity of obligations to deliver currency of any issuer.</span><br><span class="line">Amount&lt;Obligation.State&lt;Currency&gt;&gt;</span><br></pre></td></tr></table></figure><p></p><h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>Corda合约由三部分组成; 代表特定交易或资产细节的可执行代码、法律散文（legal prose）和状态对象。<b style="color:red">在关系数据库术语中，状态就像数据库中的一行。</b>分类帐中的状态参考（无论是否已消费）用<code>StateRef</code>对象表示。如果状态引用（state ref）已经能从存储中找到，你将有一个<code>StateAndRef</code>，这是一个简单的<code>StateRef</code>加上数据。</p><p><code>ContractState</code>类是所有状态必须实现的接口。<code>TransactionState</code>是一个简单的<code>ContractState</code>容器（一个合约程序使用的自定义数据）和附加的平台级别的状态信息，比如notary指针。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContractState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A _participant_ is any party that is able to consume this state in a valid transaction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The list of participants is required for certain types of transactions. For example, when changing the notary</span></span><br><span class="line"><span class="comment">     * for this state, every participant has to be involved and approve the transaction</span></span><br><span class="line"><span class="comment">     * so that they receive the updated state, and don't end up in a situation where they can no longer use a state</span></span><br><span class="line"><span class="comment">     * they possess, since someone consumed that state during the notary change process.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The participants list should normally be derived from the contents of the state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> participants: List&lt;AbstractParty&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些接口继承了<code>ContractState</code>，代表常见状态的标准化功能：</p><ul><li><p><code>OwnableState</code><br>拥有所有者的状态（表示为一个<code>PublicKey</code>，就是状态里面包含拥有者的<code>PublicKey</code>）。公开所有者和用于替换所有者的功能，例如当资产被出售时。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OwnableState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/** There must be a MoveCommand signed by this key to claim the amount. */</span></span><br><span class="line">    <span class="keyword">val</span> owner: AbstractParty</span><br><span class="line">    <span class="comment">/** Copies the underlying data structure, replacing the owner field with this new value and leaving the rest alone. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwner</span><span class="params">(newOwner: <span class="type">AbstractParty</span>)</span></span>: CommandAndState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>LinearState</code><br>一种链接回到其先前状态的状态，随着时间的推移创建一个状态线程。对特定交易或不可拆分资产（如罕见艺术品）进行建模时，线性状态非常有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LinearState</span> : <span class="type">ContractState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unique id shared by all LinearState states throughout history within the vaults of all parties.</span></span><br><span class="line"><span class="comment">     * Verify methods should check that one input and one output share the id in a transaction,</span></span><br><span class="line"><span class="comment">     * except at issuance/termination.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> linearId: UniqueIdentifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>DealState</code><br>一个<code>LinearState</code>(通过继承实现)表示两方或多方之间的协议。旨在简化实施操纵许多协议类型的通用流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface DealState : LinearState &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Generate a partial transaction representing an agreement (command) to this deal, allowing a general</span><br><span class="line">     * deal/agreement flow to generate the necessary transaction for potential implementations.</span><br><span class="line">     *</span><br><span class="line">     * TODO: Currently this is the &quot;inception&quot; transaction but in future an offer of some description might be an input state ref</span><br><span class="line">     *</span><br><span class="line">     * TODO: This should more likely be a method on the Contract (on a common interface) and the changes to reference a</span><br><span class="line">     * Contract instance from a ContractState are imminent, at which point we can move this out of here.</span><br><span class="line">     */</span><br><span class="line">    fun generateAgreement(notary: Party): TransactionBuilder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>FixableDealState</code><br>一个交易状态，进一步的功能暴露以支持固定利率。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FixableDealState</span> : <span class="type">DealState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When is the next fixing and what is the fixing for?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextFixingOf</span><span class="params">()</span></span>: FixOf?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * What oracle service to use for the fixing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> oracle: Party</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a fixing command for this deal and fix.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> This would also likely move to methods on the Contract once the changes to reference</span></span><br><span class="line"><span class="comment">     * the Contract from the ContractState are in.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generateFix</span><span class="params">(ptx: <span class="type">TransactionBuilder</span>, oldState: <span class="type">StateAndRef</span>&lt;*&gt;, fix: <span class="type">Fix</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="NamedByHash和UniqueIdentifier"><a href="#NamedByHash和UniqueIdentifier" class="headerlink" title="NamedByHash和UniqueIdentifier"></a>NamedByHash和UniqueIdentifier</h4><p>散列作为标识的事物（如交易和附件）应该实现<code>NamedByHash</code>接口，这个接口标准化提取ID的操作。请注意，散列不是全局唯一标识符：它总是对基础数据内容的派生摘要。<b style="color:red">有时候这不是你想要的：两个具有完全相同参数并且同时生成但是在逻辑上不同的交易不能通过散列识别，因为它们的内容将是相同的。相反，你会使用<code>UniqueIdentifier</code>。</b> 这是一个（Java）UUID表示一个全球唯一的128位随机数，以及一个可与之配对的任意字符串。例如，为了方便起见，该字符串可以代表现有的“weak”（不保证唯一）标识符。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamedByHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: SecureHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueIdentifier</span></span>(<span class="keyword">val</span> externalId: String? = <span class="literal">null</span>, <span class="keyword">val</span> id: UUID = UUID.randomUUID()) : Comparable&lt;UniqueIdentifier&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用UUID标识，但是可以使用配对的字符串进行拼接</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (externalId != <span class="literal">null</span>) <span class="string">"<span class="subst">$&#123;externalId&#125;</span>_<span class="variable">$id</span>"</span> <span class="keyword">else</span> id.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">/** Helper function for unit tests where the UUID needs to be manually initialised for consistency. */</span></span><br><span class="line">        <span class="meta">@VisibleForTesting</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromString</span><span class="params">(name: <span class="type">String</span>)</span></span>: UniqueIdentifier = UniqueIdentifier(<span class="literal">null</span>, UUID.fromString(name))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">UniqueIdentifier</span>)</span></span>: <span class="built_in">Int</span> = id.compareTo(other.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (other <span class="keyword">is</span> UniqueIdentifier)</span><br><span class="line">            id == other.id</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = id.hashCode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="FungibleAssets-and-Cash"><a href="#FungibleAssets-and-Cash" class="headerlink" title="FungibleAssets and Cash"></a>FungibleAssets and Cash</h4><p><code>FungibleAsset</code>(可替代资产)是可模拟可替代资产的合约的一个共同的超类，它也为其子类的状态对象提供了一个标准接口来实现。将典型的用例就是<code>Cash</code>，然而<code>FungibleAsset</code>意图是容易扩展到覆盖其它资产，例如商品可以根据需要通过使用一个子类，其状态的对象包括进一步的细节（商品，产地，等级的位置等）进行建模。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FungibleAsset</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">OwnableState &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Amount represents a positive quantity of some issued product which can be cash, tokens, assets, or generally</span></span><br><span class="line"><span class="comment">     * anything else that's quantifiable with integer quantities. See [Issued] and [Amount] for more details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> amount: Amount&lt;Issued&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * There must be an ExitCommand signed by these keys to destroy the amount. While all states require their</span></span><br><span class="line"><span class="comment">     * owner to sign, some (i.e. cash) also require the issuer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> exitKeys: Collection&lt;PublicKey&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies the underlying data structure, replacing the amount and owner fields with the new values and leaving the</span></span><br><span class="line"><span class="comment">     * rest (exitKeys) alone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">withNewOwnerAndAmount</span><span class="params">(newAmount: <span class="type">Amount</span>&lt;<span class="type">Issued</span>&lt;<span class="type">T</span>&gt;&gt;, newOwner: <span class="type">AbstractParty</span>)</span></span>: FungibleAsset&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意这里<code>Cash</code>其实是一个<code>Contract</code>，里面包含<code>FungibleAssets</code>的状态子类，由于代码比较长，这里就不展示了。</p><h4 id="Transaction-生命周期类型"><a href="#Transaction-生命周期类型" class="headerlink" title="Transaction 生命周期类型"></a>Transaction 生命周期类型</h4><p><code>WireTransaction</code>类包含一个没有签名交易的核心，并带有附件的引用以代表附件本身。一旦对交易签名就封装成<code>SignedTransaction</code>类。为了处理交易（即验证它），它首先被转换为<code>LedgerTransaction</code>，这涉及到验证签名并将它们关联到相关命令，并对附件的引用进行附件解析。具有有效签名的命令被封装在<code>AuthenticatedObject</code>类中(新版中，这个类被重命名为<code>CommandWithParties</code>)。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WireTransaction</span></span>(componentGroups: List&lt;ComponentGroup&gt;, <span class="keyword">val</span> privacySalt: PrivacySalt = PrivacySalt()) : TraversableTransaction(componentGroups) &#123;</span><br><span class="line">    <span class="meta">@Deprecated(<span class="meta-string">"Required only in some unit-tests and for backwards compatibility purposes."</span>, ReplaceWith(<span class="meta-string">"WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)"</span>)</span>, DeprecationLevel.WARNING)</span><br><span class="line">    <span class="keyword">constructor</span>(inputs: List&lt;StateRef&gt;, <span class="comment">// 输入</span></span><br><span class="line">                attachments: List&lt;SecureHash&gt;, <span class="comment">// 附件hash集合</span></span><br><span class="line">                outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, <span class="comment">// 输出，这里我们可以看到TransactionState的意义了</span></span><br><span class="line">                commands: List&lt;Command&lt;*&gt;&gt;, <span class="comment">// 命令集合</span></span><br><span class="line">                notary: Party?,   <span class="comment">// 见证者</span></span><br><span class="line">                timeWindow: TimeWindow?, <span class="comment">// 时间窗口</span></span><br><span class="line">                privacySalt: PrivacySalt = PrivacySalt() <span class="comment">// 私钥密码</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们看一下<code>SignedTransaction</code>的定义<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">SignedTransaction</span></span>(<span class="keyword">val</span> txBits: SerializedBytes&lt;CoreTransaction&gt;,</span><br><span class="line">                             <span class="keyword">override</span> <span class="keyword">val</span> sigs: List&lt;TransactionSignature&gt;</span><br><span class="line">) : TransactionWithSignatures &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来看一下LedgerTransaction的定义。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LedgerTransaction</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="comment">/** The resolved input states which will be consumed/invalidated by the execution of this transaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;,           <span class="comment">// 输入</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;,     <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">/** Arbitrary data passed to the program of each input state. */</span></span><br><span class="line">        <span class="keyword">val</span> commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;,             <span class="comment">// 命令（具有有效签名的命令）</span></span><br><span class="line">        <span class="comment">/** A list of [Attachment] objects identified by the transaction that are needed for this transaction to verify. */</span></span><br><span class="line">        <span class="keyword">val</span> attachments: List&lt;Attachment&gt;,                               <span class="comment">// 解析好的附件</span></span><br><span class="line">        <span class="comment">/** The hash of the original serialised WireTransaction. */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> id: SecureHash,                                     <span class="comment">// id，交易的hash</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> notary: Party?,                                     <span class="comment">// 见证者</span></span><br><span class="line">        <span class="keyword">val</span> timeWindow: TimeWindow?,                                     <span class="comment">// 时间窗口</span></span><br><span class="line">        <span class="keyword">val</span> privacySalt: PrivacySalt,                                    <span class="comment">// 密码盐，这个是不是太暴露了</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> networkParameters: NetworkParameters? = <span class="literal">null</span>         <span class="comment">// 网络配置参数</span></span><br><span class="line">) : FullTransaction() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>AuthenticatedObject</code>类被重命名为<code>CommandWithParties</code>，这个类比较简单，具体的内容如下：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CordaSerializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandWithParties</span>&lt;<span class="type">out T : CommandData</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> signers: List&lt;PublicKey&gt;,   <span class="comment">// 签署人，其实就是公钥</span></span><br><span class="line">        <span class="comment">/** If any public keys were recognised, the looked up institutions are available here */</span></span><br><span class="line">        <span class="keyword">val</span> signingParties: List&lt;Party&gt;, <span class="comment">// 找到签署人所属的Party</span></span><br><span class="line">        <span class="keyword">val</span> value: T</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#6ab0de">注意：<code>LedgerTransaction</code>没有必要运行它的合约，因此合约可以是无效的（但不是签名无效的）。您可以使用如下所示的verify方法运行合约。</b></p><p>可以使用<code>TransactionBuilder</code>构建新的交易，这是一个可修改的交易，一旦内部修改完成，就可以对其进行签名。合约类通常会暴露帮助方法，这些方法对<code>TransactionBuilder</code>会有所帮助。</p><p>以下是一个构建交易的例子，该交易创建了bananas的发行（请注意，bananas不是库中真正的合约类型）：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> notaryToUse: Party = ... <span class="comment">// 见证者Party</span></span><br><span class="line"><span class="comment">// 创建交易，加入了State</span></span><br><span class="line"><span class="keyword">val</span> txb = TransactionBuilder(notary = notaryToUse).withItems(BananaState(Amount(<span class="number">20</span>, Bananas), fromCountry = <span class="string">"Elbonia"</span>))</span><br><span class="line"><span class="comment">// 使用私钥进行交易签名</span></span><br><span class="line">txb.signWith(myKey)</span><br><span class="line"><span class="comment">// 设置时间窗口</span></span><br><span class="line">txb.setTime(Instant.now(), notaryToUse, <span class="number">30.</span>seconds)</span><br><span class="line"><span class="comment">// We must disable the check for sufficient signatures, because this transaction is not yet notarised.</span></span><br><span class="line"><span class="comment">// 转化为SignedTransaction</span></span><br><span class="line"><span class="keyword">val</span> stx = txb.toSignedTransaction(checkSufficientSignatures = <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// Alternatively, let's just check it verifies pretending it was fully signed. To do this, we get</span></span><br><span class="line"><span class="comment">// a WireTransaction, which is what the SignedTransaction wraps. Thus by verifying that directly we</span></span><br><span class="line"><span class="comment">// skip signature checking.</span></span><br><span class="line">txb.toWireTransaction().toLedgerTransaction(services).verify()</span><br></pre></td></tr></table></figure><p></p><h4 id="Party和PublicKey"><a href="#Party和PublicKey" class="headerlink" title="Party和PublicKey"></a>Party和PublicKey</h4><p>使用网络的实体称为参与方（Party）。各方可以使用密钥签署结构，并且一方可以在其控制下拥有许多密钥。</p><p>Party有时候可能被伪名识别，例如，作为监管链的一部分发送给你的节点的交易中，重要的是你可以说服你自己了解交易的有效性，但是同样重要的是，你不知道在那次交易中涉及的是谁。在这些情况下，公钥可能不存在关于谁拥有它的任何标识信息。</p><p>参与签署交易的参与方(Party)的身份可以简单地用<code>PublicKey</code>表示，或者通过使用Party类的更多信息（如姓名）来表示。<code>CommandWithParties</code>表示由一组参与方签署的对象（如命令）。</p><p><b style="color:#6ab0de">注意: 这些类型是临时的，将来随着身份框架变得更加充实而将发生重大变化。</b></p><h4 id="多签名支持"><a href="#多签名支持" class="headerlink" title="多签名支持"></a>多签名支持</h4><p>Corda支持需要多个密钥或参与方授权进行状态对象转换的情况，例如：“首席执行官或其中三分之一的助理都需要提供签名”。</p><h5 id="CompositeKey-复合键"><a href="#CompositeKey-复合键" class="headerlink" title="CompositeKey(复合键)"></a>CompositeKey(复合键)</h5><p>这是通过使用树结构的公钥组合来实现的<code>CompositeKey</code>。<code>CompositeKey</code>是一棵树，<b style="color:red">它将密码公钥基元存储在其树叶中，并在中间节点中存储组合逻辑。每个中间节点指定它需要多少个孩子签名的阈值。</b></p><p>“Alice和Bob或Charlie”组合键的例证：</p><p><img alt="" data-src="https://docs.corda.net/releases/release-M7.0/_images/composite-key.png"></p><p>为了提供更大的灵活性，每个子节点都可以有一个相关的自定义权重（默认值为1）。该阈值 然后指定所需的所有子节点的最小总权重。我们之前的例子也可以表示为：</p><p><img alt="" data-src="https://docs.corda.net/releases/release-M7.0/_images/composite-key-2.png"></p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>签名验证分两个阶段进行：</p><ol><li>给定一个签名列表，每个签名都会根据预期的内容进行验证。</li><li>将与签名相对应的公钥与所讨论的组合密钥树的树叶进行匹配，并且针对每个中间节点计算所有孩子的总组合权重。如果所有阈值都满足，则认为组合密钥要求得到满足。</li></ol><h4 id="日期支持"><a href="#日期支持" class="headerlink" title="日期支持"></a>日期支持</h4><p>有许多支持接口和类供合约处理日期（特别是在截止日期范围内）使用。由于合约谈判通常涉及诸如“overnight”，“T+3”等期限的最后期限，因此希望允许将这些条款转换为相应的截止日期。<code>Tenor</code>在截止日期之前（例如3天等）对间隔进行建模，同时<code>DateRollConvention</code>描述如何修改最后期限以考虑银行假期或修改正常工作日的其他事件。</p><p>根据工作日计算期限的延期需要有关所涉银行假期的信息（以及合同各方在不同的国家/地区，例如，这可能涉及多套不同的银行假期）。<code>BusinessCalendar</code>类模拟这些商业假期的日历; 目前它从磁盘上的文件加载这些文件，但将来这可能涉及参考数据库，以确保所用日期的一致性。</p><h4 id="加密和数学支持"><a href="#加密和数学支持" class="headerlink" title="加密和数学支持"></a>加密和数学支持</h4><p><code>SecureHash</code>类代表未知算法的安全散列。我们目前只定义一个子类，<code>SecureHash.SHA256</code>。有实用的方法来创建它们，解析它们等等。</p><p>我们还提供了一些数学实用工具，特别是一组插值器和用于样条线的类。这些可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLU03LjAvYXBpL25ldC5jb3JkYS5jb3JlLm1hdGgvaW5kZXguaHRtbA==" title="https://docs.corda.net/releases/release-M7.0/api/net.corda.core.math/index.html">数学包<i class="fa fa-external-link"></i></span>中找到。</p><h3 id="交易拆分"><a href="#交易拆分" class="headerlink" title="交易拆分"></a>交易拆分</h3><p>我们平台的基本数据结构之一就是交易。它可以通过签名和验证，也可以由第三方进行验证。交易的构建假定它们构成一个具有输入和输出状态，命令和附件的完整实体。但是，所有敏感数据都不应该透露给参与验证级别交易创建的其他节点（这种情况的一个很好的例子是只验证嵌入式命令的Oracle）。如何以一种让对方信服他们获得签名数据的方式来实现这一点，确实构成了交易的一部分？</p><p>我们决定使用众所周知的密码方案来提供包含和数据完整性的证明。Merkle树广泛用于点对点网络，区块链系统和git。</p><h4 id="Corda的Merkle树"><a href="#Corda的Merkle树" class="headerlink" title="Corda的Merkle树"></a>Corda的Merkle树</h4><p>交易分为叶子，每个叶子都包含输入，输出，命令或附件。计算中不使用时间戳或签名者等其他字段。接下来，Merkle树以正常方式构建，方法是将当前节点下方的节点散列连接在一起。它在下面的示例图像中可见，其中<code>H</code>表示sha256函数，“+” – 级联。</p><p><img alt="" data-src="https://docs.corda.net/releases/release-M7.0/_images/merkleTree.png"></p><p>该交易有一个输入状态，一个输出和三个命令。如果树不是完整的二叉树，则在散列计算（虚线）中重复最右边的节点。</p><p><b style="color:#00f">最后，根的散列是交易的标识符，它也用于数据完整性的签名和验证。每个叶级别的更改都会改变交易的标识符。</b></p><h4 id="隐藏数据"><a href="#隐藏数据" class="headerlink" title="隐藏数据"></a>隐藏数据</h4><p><b style="color:red">隐藏数据并提供它构成交易一部分的证据通过构建部分Merkle树（或Merkle分支）来完成。</b>Merkle分支是一组散列，根据叶子的数据来计算根的散列。然后将该散列与整个交易的散列进行比较，如果它们匹配，则意味着我们获得的数据属于该特定交易。</p><p><img alt="" data-src="https://docs.corda.net/releases/release-M7.0/_images/partialMerkle.png"></p><p>在上面的例子中，红色节点是持有Oracle服务签名数据的节点。蓝色节点的哈希形成部分梅克尔树，不包括虚线的哈希。有了应该在红色节点位置和分支中的命令，我们可以计算这棵树的根，并将它与原始交易标识符进行比较 - 我们证明此命令属于此交易。</p><h3 id="共识模型"><a href="#共识模型" class="headerlink" title="共识模型"></a>共识模型</h3><p>Corda的基本共识单位是状态。共识的概念可以分为两部分：</p><ol><li>对状态有效性达成共识 - 各方可以确定定义输出状态的交易被各状态指定的合约接受并具有所有必需的签名。这是通过各方独立运行相同的合约代码和验证逻辑来​​实现的。</li><li>关于状态唯一性的共识 - 各方可以确定交易中创建的输出状态是该交易消耗的输入状态的唯一继承者（换句话说 - 一个状态未被用作多个交易的输入）</li></ol><h4 id="公证人"><a href="#公证人" class="headerlink" title="公证人"></a>公证人</h4><p>我们介绍了公证人（notary）的概念，该公证人是负责证明对于给定的交易没有签署另一个消耗其任何输入状态的交易的机构。数据模型被扩展，以便每个状态都有一个指定的公证人：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data class TransactionState&lt;out T : ContractState&gt;(</span><br><span class="line">        /** The custom contract state */</span><br><span class="line">        val data: T,</span><br><span class="line">        /** Identity of the notary that ensures the state is not used as an input to a transaction more than once */</span><br><span class="line">        val notary: Party) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所有交易都必须由其输入状态公证人签名，以使输出状态有效（除了发行交易，不包含输入状态）。</p><p>当公证人被要求签署交易时，它要么签署交易，证明输出是输入的唯一后继者，要么提供已经被之前签署的另一个交易消耗的任何输入状态的冲突信息。这样做，公证人提供了系统中的终点。在获得公证人签名之前，各方不能确定同等有效但冲突的交易不会被视为确认。获得签名后，双方知道该交易的输入已被该交易独有消耗。因此，这是我们可以说终结发生的地步。</p><h4 id="多个公证人"><a href="#多个公证人" class="headerlink" title="多个公证人"></a>多个公证人</h4><p>网络中可以存在一个以上的公证人。这提供了以下好处：</p><ol><li>自定义行为。我们可以同时拥有验证和隐私保护公证人 - 各方可以根据他们的具体要求做出选择</li><li>负载平衡。将事务处理负载分摊到多个公证处将会在整个平台中实现更高的事务吞吐量</li><li>低延迟。通过选择公证员与交易方更接近，延迟时间可以缩短</li></ol><p><b style="color:#00f">如果一个交易的所有输入状态指向一个交易，交易只能由公证人签名。在交易涉及由多个公证人控制的状态的情况下，各状态首先必须被重新委托给同一公证人。这是通过使用一种特殊类型的交易来实现的，该交易不会修改任何内容，而是修改状态的公证指针。确保所有投入状态都指向同一公证人是每个相关方的责任（这是交易输出状态有效的另一个条件）</b></p><h4 id="改变公证人"><a href="#改变公证人" class="headerlink" title="改变公证人"></a>改变公证人</h4><p>要更改输入状态的公证，请使用NotaryChangeFlow。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Suspendable</span><br><span class="line">fun changeNotary(originalState: StateAndRef&lt;ContractState&gt;,</span><br><span class="line">                 newNotary: Party): StateAndRef&lt;ContractState&gt; &#123;</span><br><span class="line">    val flow = NotaryChangeFlow.Instigator(originalState, newNotary)</span><br><span class="line">    return subFlow(flow)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>流程如下：</p><ol><li>将旧状态作为输入，将新状态作为输出进行构建</li><li>从所有参与者获取签名（参与者是能够在有效交易中消费此状态的任何一方，如由状态本身定义的那样）</li><li>获得旧的公证人签名</li><li>记录并向参与者分发最终交易，以便每个人都拥有新的状态</li></ol><h4 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h4><p>公证人的设计决定之一是在提交输入状态之前是否验证交易。</p><p>如果一个交易没有被检查有效性，它会打开平台进行“拒绝状态”攻击，任何人都可以建立一个无效的交易，消耗其他人的状态并将其提交给公证员以使状态“被阻止”。但是，对交易的验证需要公证人能够看到有问题交易的全部内容及其依赖关系。这是一个明显的隐私泄露。</p><p>我们的平台非常灵活，目前我们支持验证和非验证公证实施 - 一方可以根据自己的隐私要求选择使用哪一个。</p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>在这个模型中，公证人还充当时间戳机构，验证交易时间戳命令。</p><h2 id="涉及的技术"><a href="#涉及的技术" class="headerlink" title="涉及的技术"></a>涉及的技术</h2><h3 id="corda网站"><a href="#corda网站" class="headerlink" title="corda网站"></a>corda网站</h3><p>这里是corda的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29yZGEubmV0L3poLWhhbnQv" title="https://www.corda.net/zh-hant/">官方网站<i class="fa fa-external-link"></i></span>。<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmRh" title="https://github.com/corda">这个网站<i class="fa fa-external-link"></i></span>是corda的github主页，你可在里面找到我们的corda项目，入门的cordapp example也可以在这里找到，还是比较实用的。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>最后这里列一下Kotlin的学习的一些资料。</p><p>最棒的就是<span class="exturl" data-url="aHR0cHM6Ly90cnkua290bGlubGFuZy5vcmcvIy9Lb3RsaW4lMjBLb2Fucy9JbnRyb2R1Y3Rpb24vU3RyaW5ncy9UYXNrLmt0" title="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Strings/Task.kt">这个网站<i class="fa fa-external-link"></i></span>的在线练习，做的的确棒极了。</p><p>当然对于Kotlin，我们不得不研究一下它的<span class="exturl" data-url="aHR0cDovL2tvdGxpbmxhbmcub3JnL2RvY3MvcmVmZXJlbmNlL2NvZGluZy1jb252ZW50aW9ucy5odG1s" title="http://kotlinlang.org/docs/reference/coding-conventions.html">官方指南<i class="fa fa-external-link"></i></span>. 你可以在这里查询文档和Api的说明文档，另外里面还做了一个全局的搜索，不管是文档，博客还是Api文档，你都可以一键搜索，很是方便。</p><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>这个是志愿者翻译的<span class="exturl" data-url="aHR0cHM6Ly9kb25nY2h1YW4uZ2l0Ym9va3MuaW8vZ3JhZGxlLXVzZXItZ3VpZGUtL2NvbnRlbnQvb3ZlcnZpZXcvZmVhdHVyZXMuaHRtbA==" title="https://dongchuan.gitbooks.io/gradle-user-guide-/content/overview/features.html">Gradle User Guide中文版<i class="fa fa-external-link"></i></span></p><p>当然如果你想自定义Gradle插件的话，就不得不研究<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdyYWRsZS5vcmcvY3VycmVudC9kc2wvb3JnLmdyYWRsZS5hcGkuUHJvamVjdC5odG1sI29yZy5ncmFkbGUuYXBpLlByb2plY3Q6YnVpbGRzY3JpcHQoZ3Jvb3Z5LmxhbmcuQ2xvc3VyZQ==" title="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildscript(groovy.lang.Closure">Gradle的文档<i class="fa fa-external-link"></i></span>)，里面有相关的Api和概念。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLVYzLjIva2V5LWNvbmNlcHRzLWVjb3N5c3RlbS5odG1s" title="https://docs.corda.net/releases/release-V3.2/key-concepts-ecosystem.html">https://docs.corda.net/releases/release-V3.2/key-concepts-ecosystem.html<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvcmRhLm5ldC9yZWxlYXNlcy9yZWxlYXNlLU03LjAvaW5kZXguaHRtbA==" title="https://docs.corda.net/releases/release-M7.0/index.html">Corda API reference<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2NvcmRhL3BlZXItdG8tcGVlci1lbnRlcnByaXNlLWJsb2NrY2hhaW4tbmV0d29ya2luZy13aXRoLXRoZS1jb3JkYS1maXJld2FsbC00ZjZhNDI3ZWJkOTc=" title="https://medium.com/corda/peer-to-peer-enterprise-blockchain-networking-with-the-corda-firewall-4f6a427ebd97">Peer-to-Peer Enterprise Blockchain Networking with the Corda Firewall.<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2NuY29yZGEuY29tLw==" title="http://cncorda.com/">Corda中文网<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> corda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> corda </tag>
            
            <tag> r3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProcessBuilder简介</title>
      <link href="//java/ProcessBuilder%E7%AE%80%E4%BB%8B.html"/>
      <url>//java/ProcessBuilder%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>学过C语言的都知道如何开启一个新的进行。自从我们学习了java之后，很少会开启新的进程，因为我们绝大部分的使用都是开启线程，以至于线程池的知识成了现在java面试的宝典了。</p><p>最近在研究Corda的源码，发现里面的启动都是通过相应的ProcessBuilder，这个类开启了若干进程，当然进程都是执行的shell代码，这里就不做更多说明了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ProcessBuilder类是J2SE 1.5在java.lang中新添加的一个新类，此类用于创建操作系统进程，它提供一种启动和管理进程（也就是应用程序）的方法。在J2SE 1.5之前，都是由Process类处理实现进程的控制管理。每个 ProcessBuilder 实例管理一个进程属性集。它的start() 方法利用这些属性创建一个新的 Process 实例。start() 方法可以从同一实例重复调用，以利用相同的或相关的属性创建新的子进程。</p><p>每个进程生成器（即ProcessBuilder对象）管理这些进程属性：</p><ul><li><p>命令 command<br>是一个字符串列表，它表示要调用的外部程序文件及其参数（如果有）。在此，表示有效的操作系统命令的字符串列表是依赖于系统的。例如，每一个总体变量，通常都要成为此列表中的元素，但有一些操作系统，希望程序能自己标记命令行字符串——在这种系统中，Java 实现可能需要命令确切地包含这两个元素。</p></li><li><p>环境 environment<br>是从变量 到值 的依赖于系统的映射。初始值是当前进程环境的一个副本（请参阅 System.getenv()）。</p></li><li><p>工作目录 working directory<br>默认值是当前进程的当前工作目录，通常根据系统属性 user.dir 来命名。</p></li><li><p>redirectErrorStream属性<br>最初，此属性为 false，意思是子进程的标准输出和错误输出被发送给两个独立的流，这些流可以通过 Process.getInputStream() 和 Process.getErrorStream() 方法来访问。如果将值设置为 true，标准错误将与标准输出合并。这使得关联错误消息和相应的输出变得更容易。在此情况下，合并的数据可从 Process.getInputStream() 返回的流读取，而从 Process.getErrorStream() 返回的流读取将直接到达文件尾。</p></li></ul><h2 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h2><p>Process类是一个抽象类（所有的方法均是抽象的），封装了一个进程（即一个执行程序）。</p><p>Process 类提供了执行从进程输入、执行输出到进程、等待进程完成、检查进程的退出状态以及销毁（杀掉）进程的方法。创建进程的方法可能无法针对某些本机平台上的特定进程很好地工作，比如，本机窗口进程，守护进程，Microsoft Windows 上的 Win16/DOS 进程，或者 shell 脚本。创建的子进程没有自己的终端或控制台。它的所有标准 io（即 stdin、stdout 和 stderr）操作都将通过三个流 (getOutputStream()、getInputStream() 和 getErrorStream()) 重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为有些本机平台仅针对标准输入和输出流提供有限的缓冲区大小，如果读写子 进程的输出流或输入流迅速出现失败，则可能导致子进程阻塞，甚至产生死锁。 当没有 Process 对象的更多引用时，不是删掉子进程，而是继续异步执行子进程。 对于带有 Process 对象的 Java 进程，没有必要异步或并发执行由 Process 对象表示的进程。</p><p>Process抽象类有以下6个抽象方法：</p><ul><li>destroy()<br>杀掉子进程。</li><li>exitValue()<br>返回子进程的出口值。</li><li>InputStream getErrorStream()<br>获得子进程的错误流。</li><li>InputStream getInputStream()<br>获得子进程的输入流。</li><li>OutputStream getOutputStream()<br>获得子进程的输出流。</li><li>waitFor()<br>导致当前线程等待，如果必要，一直要等到由该 Process 对象表示的进程已经终止。</li></ul><h3 id="如何创建Process对象？"><a href="#如何创建Process对象？" class="headerlink" title="如何创建Process对象？"></a>如何创建Process对象？</h3><p>一般有两种方法：</p><ol><li>使用命令名和命令的参数选项构造ProcessBuilder对象，它的start方法执行命令，启动一个进程，返回一个Process对象。</li><li>Runtime.exec() 方法创建一个本机进程，并返回 Process 子类的一个实例。</li></ol><h2 id="Runtime-exec"><a href="#Runtime-exec" class="headerlink" title="Runtime.exec()"></a>Runtime.exec()</h2><p>ProcessBuilder与Runtime.exec()的区别?</p><p>ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。</p><p>ProcessBuilder.start() 和 Runtime.exec()传递的参数有所不同，Runtime.exec()可接受一个单独的字符串，这个字符串是通过空格来分隔可执行命令程序和参数的；也可以接受字符串数组参数。而ProcessBuilder的构造函数是一个字符串列表或者数组。列表中第一个参数是可执行命令程序，其他的是命令行执行是需要的参数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTY4MTYvYXJ0aWNsZS9kZXRhaWxzLzU0NjAzOTEw" title="https://blog.csdn.net/u013256816/article/details/54603910">浅析ProcessBuilder<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程状态的分析</title>
      <link href="//java/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%86%E6%9E%90.html"/>
      <url>//java/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近阅读了《深入理解Linux内核》这本书，对于线程和进程的知识有了比较深入的理解，这里我就不做更多的介绍了，如果你想了解更多的知识可以阅读一下这本书，虽然阅读起来比较麻烦，但是确实是一本比较不错的书籍，里面的很多知识都是值得深入学习的。做好攻坚的准备就是了。</p><h2 id="关于线程的状态"><a href="#关于线程的状态" class="headerlink" title="关于线程的状态"></a>关于线程的状态</h2><p>以下是java的线程状态：</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NEW</td><td style="text-align:center">初始状态。线程刚刚被创建，并且start()方法还未被调用</td></tr><tr><td style="text-align:center">RUNNABLE</td><td style="text-align:center">运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td></tr><tr><td style="text-align:center">BLOCKED</td><td style="text-align:center">阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td></tr><tr><td style="text-align:center">WAITING</td><td style="text-align:center">等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td></tr><tr><td style="text-align:center">TIMED_WAITING</td><td style="text-align:center">超时等待。与WAITING的不同在于，该状态有超时时间</td></tr><tr><td style="text-align:center">TERMINATED</td><td style="text-align:center">终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><h2 id="改变线程状态"><a href="#改变线程状态" class="headerlink" title="改变线程状态"></a>改变线程状态</h2><p>大家都知道Thread类内部提供了几个方法可以改变线程的状态。</p><p>当然Future里面也有不少的改变线程状态的实现。</p><p>但是这些基础知识就不做更多的介绍了，这也不是我要说明的重点。</p><h2 id="sun-misc-Unsafe"><a href="#sun-misc-Unsafe" class="headerlink" title="sun.misc.Unsafe"></a>sun.misc.Unsafe</h2><p>今天主要是来说明这个类的作用的。这个类里面有很多的内容，今天就重点介绍里面的park方法。</p><p>因为park方法可以改变线程的状态，这种改变时操作系统级别的，这种调用一定是使用了系统调用，主要是你要明白这一点才能里面AQS里面的实现，这里就是简单的记录一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cub25seWNhdGNoLmNvbS9wb3N0L2phdmElRTQlQjglQUQlRTclQkElQkYlRTclQTglOEIlRTclOUElODQlRTclOEElQjYlRTYlODAlODElRTQlQkIlQTUlRTUlOEYlOEElRTclQkElQkYlRTclQTglOEIlRTYlQTAlODglRTUlODglODYlRTYlOUUlOTA=" title="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90">java中线程的状态以及线程栈分析<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存行与计算机缓存结构</title>
      <link href="//java/%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
      <url>//java/%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近在读《深入理解Linux内核》读了不少关于计算机缓存的体系结构设计，这里就不做更多的说明，下面我们来看看这里面的知识吧！</p><p>计算机分为多级缓存，但是主要的还是要从内存条说起。</p><p>其实系统会在系统内存上单独开一片cache，而且这片的cache和普通的内存管理策略不同。这应该算是第一级缓存，但是这种提升不是很大。下面我们来讲高速缓存块cache。</p><p>对于高速缓存块cache也是有多种分法。一是主板级别的高速cache，这种是多CPU共享的。再上面一层就是CPU专用的高速cache块了。再上一层就是每个CPU核共享的高速cache。再上面一层就是寄存器了。</p><p>这就是背景知识。</p><h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><p>高速缓存块不是按照每一个字节进行缓存，而是按照一个内存块进行缓存。可是一旦这块中任何一个内容改变，都会导致整个块的Refresh。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>这里主要是指程序的改进，比如说你定义一个对象。以前这个对象在一个缓存行中，但是对象中改变的字段就是一个两个频繁改变，这样每次refresh的块比较大。所以方法就是将可变的属性放入一个缓存块中，将不可变的放入另一个缓存块中，这样刷新的少了，速度自然提升了。这就是缓存块的具体说明，具体可以查看具体的引用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cDovL2dlZWsuY3Nkbi5uZXQvbmV3cy9kZXRhaWwvMTE0NjE5" title="http://geek.csdn.net/news/detail/114619">认识CPU Cache<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Java的AQS</title>
      <link href="//java/%E7%90%86%E8%A7%A3Java%E7%9A%84AQS.html"/>
      <url>//java/%E7%90%86%E8%A7%A3Java%E7%9A%84AQS.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>一提到java的锁机制，大家都会想到AQS（AbstractQueuedSynchronizer），意思就是抽象的同步队列，感觉就是使用队列来进行同步操作而已。（Java8版本）</p><h2 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h2><p>AbstractQueuedSynchronizer是继承自AbstractOwnableSynchronizer。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 独占模式同步的当前所有者。</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个说明还是比较简单的，就是说这个同步独占这个线程而已。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>当然AbstractOwnableSynchronizer是队列，所以里面有内部类表示节点（Node），其实就是一个双向链表。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    // 标记以指示节点正在以共享模式等待</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 标记以指示节点正在以独占模式等待</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line"></span><br><span class="line">    // 表示线程已取消的waitStatus值</span><br><span class="line">    static final int CANCELLED =  1;</span><br><span class="line">    // waitStatus值指示后继者的线程需要暂停</span><br><span class="line">    static final int SIGNAL    = -1;</span><br><span class="line">    // waitStatus值指示线程正在等待状态</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    // waitStatus值指示下一个acquireShared应无条件传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Status field, taking on only the values:</span><br><span class="line">    *   SIGNAL: 值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</span><br><span class="line">    *   CANCELLED:  值为1，表示当前的线程被取消；</span><br><span class="line">    *   CONDITION:  值为-2，表示当前节点在等待condition，也就是在condition队列中；</span><br><span class="line">    *   PROPAGATE:  值为-3，表示当前场景下后续的acquireShared能够得以执行；</span><br><span class="line">    *   0:        None of the above 表示当前节点在sync队列中，等待着获取锁。</span><br><span class="line">    */</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    volatile Node prev;</span><br><span class="line">    volatile Node next;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter; // 存储condition队列中的后继节点。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Returns true if node is waiting in shared mode.</span><br><span class="line">    */</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        if (p == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">        this.nextWaiter = mode;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; // Used by Condition</span><br><span class="line">        this.waitStatus = waitStatus;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">首先这是一个双向链表，从这里我们可以看出AQS的功能可以分为两类：独占功能和共享功能</b>。另外，排队的节点有5中状态，就是<code>waitStatus</code>的值，Node需要记录排队的线程和下一个等待的节点（线程）。</p><p>##</p><p>未完待续！！！！！</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS9pbnRyb2R1Y2UtYWJzdHJhY3RxdWV1ZWRzeW5jaHJvbml6ZXIv" title="http://ifeve.com/introduce-abstractqueuedsynchronizer/">AbstractQueuedSynchronizer的介绍和原理分析<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cub25seWNhdGNoLmNvbS9wb3N0L2phdmElRTQlQjglQUQlRTclQkElQkYlRTclQTglOEIlRTclOUElODQlRTclOEElQjYlRTYlODAlODElRTQlQkIlQTUlRTUlOEYlOEElRTclQkElQkYlRTclQTglOEIlRTYlQTAlODglRTUlODglODYlRTYlOUUlOTA=" title="http://blog.onlycatch.com/post/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%88%86%E6%9E%90">java中线程的状态以及线程栈分析<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcS5jb20vY24vYXJ0aWNsZXMvamF2YTgtYWJzdHJhY3RxdWV1ZWRzeW5jaHJvbml6ZXI=" title="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer">深度解析Java 8：AbstractQueuedSynchronizer的实现分析（下）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcS5jb20vY24vYXJ0aWNsZXMvamRrMS44LWFic3RyYWN0cXVldWVkc3luY2hyb25pemVy" title="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer">深度解析Java 8：JDK1.8 AbstractQueuedSynchronizer的实现分析（上）<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> aqs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入java类加载器</title>
      <link href="//java/%E6%B7%B1%E5%85%A5java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html"/>
      <url>//java/%E6%B7%B1%E5%85%A5java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>对于java的类加载机制，我想大家一定都知道双亲委派模型和JDK类中的加载器。主要有Bootstrap ClassLoader、Extension ClassLoader、Application ClassLoader和User Defined ClassLoader。这些基础知识就不多说了。</p><ul><li>启动类加载器(Bootstrap ClassLoader)：<br>这个类加载器使用C++语言实现，并非ClassLoader的子类。主要负责加载存放在<code>JAVA_HOME/jre/lib/rt.jar</code>里面所有的class文件，或者被<code>-Xbootclasspath</code>参数所指定路径中以rt.jar命名的文件。</li><li>扩展类加载器(Extension ClassLoader)：<br>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>JAVA_HOME/lib/ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li><li>应用程序类加载器(Application ClassLoader)：<br>这个加载器由sun.misc.Launcher$AppClassLoader实现，它负责加载<code>classpath</code>对应的jar及目录。一般情况下这个就是程序中默认的类加载器。</li><li>自定义类加载器(User Defined ClassLoader)：<br>开发人员继承ClassLoader抽象类自行实现的类加载器，基于自行开发的ClassLoader可用于并非加载classpath中(例如从网络上下载的jar或二进制字节码)、还可以在加载class文件之前做些小动作 如：加密等。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>类加载器(ClassLoader)用来加载 class字节码到 Java 虚拟机中，并转换成 java.lang.Class 类的一个实例。当然class字节码的来源可能有多种，一种就是自己拼写class文件的内容。</p><p>Java中如何比较两个类相等呢？这里所指的“相等”包括代表类的Class对象的equal方法、isAssignableFrom()、isInstance()方法及instance关键字返回的结果。</p><p>其实在Java中，一个类是否是相同的，主要取决于类加载器和包名+类名，只有以上条件都满足了，我们才说这两个类是相等的。我并没有在class文件中发现equals方法，这说明类加载的去重完全是在definedClass方法中，调用了底层的一些C代码实现的。也就是说，我们无法自己实例化一个Class实例，这需要JVM底层帮我们处理，每个Class实例的去重，完全是JVM的底层代码帮忙处理的。但是我们可以在class类中发现一个ClassLoader类的成员。</p><h2 id="ParallelLoaders"><a href="#ParallelLoaders" class="headerlink" title="ParallelLoaders"></a>ParallelLoaders</h2><p>这是ClassLoader里面的一个内部类，用来封装一组并行能力的加载器类型。这个一般是用不到的，有兴趣可以先看一下。但是需要知道ClassLoader是支持并行加载的。</p><h2 id="类加载过程与双亲委派"><a href="#类加载过程与双亲委派" class="headerlink" title="类加载过程与双亲委派"></a>类加载过程与双亲委派</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123; // 获得要用的锁</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); // 检查这个类有没有被加载</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime(); // 时间</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123; // 如果父类加载器，就用父类加载器加载</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 默认的父类加载器是启动类加载器</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123; // 如果最终没有加载到这个类</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime(); // 取得系统时间</span><br><span class="line">                c = findClass(name); // 如果没有父类加载器就自己加载</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很清楚，就不用过多解释了。双亲委派不是基于继承实现的，而是基于组合的方式实现的，默认使用启动类加载器作为父类加载器。如果类加器的父类加载器没有帮助我们加载到相应的类，那么就会调用findClass这个方法，所以为啥我们定义类加载器的时候需要重写findClass方法的原因就在这里。</p><p>默认的findClass实现是这样的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    throw new ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以发现，如果加载不了类就抛异常，我们进行重写的时候，也应该注意这点（这是典型的模板方法模式）。</p><p>其次我们发现loadClass不是final方法，也就是说我们可以打破双亲委派的模型，直接使用自己的类加载器，但这样会出现无法使用系统类的问题了，这个只是我的猜测，但是如果我想ClassLoader中会不会相应的信息，也许需要以后研究JVM底层的时候，才会有答案了。</p><h2 id="重写findClass"><a href="#重写findClass" class="headerlink" title="重写findClass"></a>重写findClass</h2><p>我们可以发现重写findClass完全达不到自己生成Class的目的。然后你会发现defineClass也是返回Class类型的，所以我们需要在方法中调用这个方法进行相应的处理。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    // 从codeSource中获取类所在文件路径</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>有趣发现这里也有模板方法模式，如果你想前后处理一些事情，可以重写preDefineClass、postDefineClass这两个方法，但是注意原来的方法时private的，你无法调用super里面的方法，这会带来很多的问题。</p><p>当然defineClass本省就是一个重载方法，所以详细的信息请查看源码，这里就不多说明了，其实用到才关注，一般的时候是不用管的。</p><h2 id="resolveClass方法"><a href="#resolveClass方法" class="headerlink" title="resolveClass方法"></a>resolveClass方法</h2><p>resolveClass 此方法负责完成Class对象的链接，如果链接过，则直接返回。</p><h2 id="findLibrary-loadLiberay"><a href="#findLibrary-loadLiberay" class="headerlink" title="findLibrary/loadLiberay"></a>findLibrary/loadLiberay</h2><p>这两个方法其实是为了加载动态链接库使用的，以前我也分析过里面的代码，有些印象，这里就不做更多的解释了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM语言参考手册(类型系统到其他值)</title>
      <link href="//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C(%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%85%B6%E4%BB%96%E5%80%BC).html"/>
      <url>//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C(%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%88%B0%E5%85%B6%E4%BB%96%E5%80%BC).html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><p>LLVM类型系统是中间表示的最重要的特征之一。类型化使得可以直接对中间表示执行许多优化，而不必在转换之前在侧面进行额外的分析。强大的类型系统使读取生成的代码变得更加容易，并且支持新的分析和转换，这些分析和转换在普通的三个地址代码表示上不可行。</p><h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>概述：void类型不代表任何值并且没有大小。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void</span><br></pre></td></tr></table></figure><p></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>概述： 函数类型可以被认为是函数签名。它由一个返回类型和一个形式参数类型列表组成。函数类型的返回类型是void类型或第一类类型 - <span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtbGFiZWw=" title="http://llvm.org/docs/LangRef.html#t-label">标签<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtbWV0YWRhdGE=" title="http://llvm.org/docs/LangRef.html#t-metadata">元数据<i class="fa fa-external-link"></i></span>类型除外。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;returntype&gt; (&lt;parameter list&gt;)</span><br></pre></td></tr></table></figure><p></p><p>…其中<code>&lt;parameter list&gt;</code>是逗号分隔的类型说明符列表。可选地，参数列表可以包括类型…，该类型指示该函数采用可变数目的参数。变量参数函数可以通过<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ludC12YXJhcmdz" title="http://llvm.org/docs/LangRef.html#int-varargs">处理内部函数的变量参数<i class="fa fa-external-link"></i></span>来访问它们的参数。<code>&lt;returntype&gt;</code>是除<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtbGFiZWw=" title="http://llvm.org/docs/LangRef.html#t-label">标签<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtbWV0YWRhdGE=" title="http://llvm.org/docs/LangRef.html#t-metadata">元数据<i class="fa fa-external-link"></i></span>之外的任何类型。</p><p>例子：<br><code>i32 (i32)</code> 函数接受i32，返回一个i32<br><code>float (i16, i32 *) *</code> 指针，以接受一个函数i16和一个i32指针来返回float。<br><code>i32 (i8*, ...)</code> 可变参数函数，它有至少一个指针到i8（在C中是char），它返回一个整数。LLVM中这是printf的签名。<br><code>{i32, i32} (i32)</code> 一个函数i32，返回一个包含两个i32值的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Qtc3RydWN0" title="http://llvm.org/docs/LangRef.html#t-struct">结构<i class="fa fa-external-link"></i></span></p><h2 id="第一类类型（First-Class-Types）"><a href="#第一类类型（First-Class-Types）" class="headerlink" title="第一类类型（First Class Types）"></a>第一类类型（First Class Types）</h2><p>第一类的类型可能是最重要的。这些类型的值是唯一可以通过指令产生的类型。</p><h3 id="单值类型"><a href="#单值类型" class="headerlink" title="单值类型"></a>单值类型</h3><p>这些是从CodeGen的角度来看在寄存器中有效的类型。</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>概述： 整数类型是一个非常简单的类型，它简单地为所需的整数类型指定一个任意的位宽。可以指定从1位到2<sup>23</sup>-1（约8百万）的任何位宽。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iN</span><br></pre></td></tr></table></figure><p></p><p>整数将占据的位数由该<code>N</code>值指定。</p><p>例子：<br><code>i1</code> 一个单位整数。<br><code>i32</code> 一个32位整数。<br><code>i1942652</code> 一个超过100万位的大整数。</p><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>half</td><td>16位浮点值</td></tr><tr><td>float</td><td>32位浮点值</td></tr><tr><td>double</td><td>64位浮点值</td></tr><tr><td>fp128</td><td>128位浮点值（112位尾数）</td></tr><tr><td>x86_fp80</td><td>80位浮点值（X87）</td></tr><tr><td>ppc_fp128</td><td>128位浮点值（两个64位）</td></tr></tbody></table><p>half，float，double和fp128的二进制格式分别对应于binary16，binary32，binary64和binary128的IEEE-754-2008规范。</p><h4 id="X86-mmx类型"><a href="#X86-mmx类型" class="headerlink" title="X86_mmx类型"></a>X86_mmx类型</h4><p>概述： x86_mmx类型表示在x86机器上的MMX寄存器中保存的值。允许的操作相当有限：参数和返回值，load和store以及bitcast。用户指定的<code>MMX</code>指令表示为具有参数<code>and/or</code>此类型结果的内部调用或asm调用。没有这种类型的数组、向量或常量。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_mmx</span><br></pre></td></tr></table></figure><p></p><h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>概述： 指针类型用于指定内存位置。指针通常用于引用内存中的对象。</p><p>指针类型可能有一个可选的地址空间属性，用于定义指向对象所在的编号地址空间。默认地址空间是数字零。非零地址空间的语义是特定于目标的。</p><p>请注意，LLVM不允许指向<code>void（void*）</code>的指针，也不允许指向标签<code>（label*）</code>的指针。改为使用<code>i8*</code>。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; *</span><br></pre></td></tr></table></figure><p></p><p>例子：<br><code>[4 x i32]*</code> 4个的i32值数组的指针。<br><code>i32 (i32*) *</code> 函数指针，它接受一个<code>i32*</code>，并返回i32。<br><code>i32 addrspace(5)*</code> i32值的指针，驻留在地址空间<code>#5</code>中的值。</p><h4 id="矢量类型"><a href="#矢量类型" class="headerlink" title="矢量类型"></a>矢量类型</h4><p>概述： 矢量类型是表示元素矢量的简单派生类型。当使用单个指令（SIMD）并行操作多个原始数据时，使用矢量类型。矢量类型需要大小（元素数量）和基础原始数据类型。矢量类型被认为是<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtZmlyc3RjbGFzcw==" title="http://llvm.org/docs/LangRef.html#t-firstclass">第一类<i class="fa fa-external-link"></i></span>。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; &lt;# elements&gt; x &lt;elementtype&gt; &gt;</span><br></pre></td></tr></table></figure><p></p><p>元素的数量是一个大于0的常数整数值; <code>elementtype</code>可以是任何整数、浮点或指针类型。大小为零的矢量是不允许的。</p><p>例子：<br><code>&lt;4 x i32&gt;</code> 4个32位整数值的向量。<br><code>&lt;8 x float&gt;</code> 8个32位浮点值的向量。<br><code>&lt;2 x i64&gt;</code> 2个64位整数值的向量。<br><code>&lt;4 x i64*&gt;</code> 4个64位整数值指针的向量。</p><h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><p>概述： 标签类型代表代码标签。<br>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label</span><br></pre></td></tr></table></figure><p></p><h3 id="令牌-token-类型"><a href="#令牌-token-类型" class="headerlink" title="令牌(token)类型"></a>令牌(token)类型</h3><p>概述： 当值与指令相关联时使用token类型，但该值的所有用法不得试图反思或模糊它。因此，具有<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcGhp" title="http://llvm.org/docs/LangRef.html#i-phi">phi<i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktc2VsZWN0" title="http://llvm.org/docs/LangRef.html#i-select">select<i class="fa fa-external-link"></i></span>类型令牌是不合适的。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token</span><br></pre></td></tr></table></figure><p></p><h3 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h3><p>概述： 元数据类型表示嵌入的元数据。除函数参数外，不得从元数据创建派生类型。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metadata</span><br></pre></td></tr></table></figure><p></p><h3 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h3><p>聚合类型是派生类型的一个子集，可以包含多个成员类型。<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtYXJyYXk=" title="http://llvm.org/docs/LangRef.html#t-array">数组<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Qtc3RydWN0" title="http://llvm.org/docs/LangRef.html#t-struct">结构<i class="fa fa-external-link"></i></span>是聚合类型。<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtdmVjdG9y" title="http://llvm.org/docs/LangRef.html#t-vector">向量<i class="fa fa-external-link"></i></span>不被视为聚合类型。</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>概述： 数组类型是一种非常简单的派生类型，它将元素按顺序排列在内存中。数组类型需要大小（元素数量）和基础数据类型。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;# elements&gt; x &lt;elementtype&gt;]</span><br></pre></td></tr></table></figure><p></p><p>元素的数量是一个常数整数值; <code>elementtype</code>可以是任何尺寸的类型。</p><p>例子：<br><code>[40 x i32]</code> 包含40个32位整数值的数组。<br><code>[41 x i32]</code> 41个32位整数值的数组。<br><code>[4 x i8]</code> 包含4个8位整数值的数组。<br>以下是多维数组的一些示例：<br><code>[3 x [4 x i32]]</code> 3x4 32位整数值数组。<br><code>[12 x [10 x float]]</code> 单精度浮点值的12×10数组。<br><code>[2 x [3 x [4 x i16]]]</code> 2x3x4的16位整数值数组。</p><p>除了静态类型隐含的数组末尾之外，没有对索引的限制（尽管在某些情况下索引超出了分配对象的范围）。这意味着可以在零长度数组类型的LLVM中实现单维“可变大小数组”。例如，在LLVM中实现“pascal样式数组”可以使用类型“<code>{ i32, [0 x float]}</code>”。</p><h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>概述： 结构类型用于在内存中一起表示数据成员的集合。结构的元素可以是任何具有大小的类型。</p><p>使用’<code>load</code>‘和’<code>store</code>‘通过使用’<code>getelementptr</code>‘指令获取指向字段的指针来访问内存中的结构。使用’<code>extractvalue</code>‘和’<code>insertvalue</code>‘指令访问寄存器中的结构。</p><p>结构可以选择是“压缩”结构，其指示结构的对齐是一个字节，并且元素之间没有填充。在非压缩结构中，字段类型之间的填充按照DataLayout字符串在模块中定义的方式插入，该模块需要与基础代码生成器的预期匹配。</p><p>结构可以是“文字”或“识别符”。字面结构与其他类型（例如<code>{i32, i32}*</code>）内联定义，而标识类型始终在顶层使用名称定义。文字类型被其内容所独占，因为没有办法编写它们，所以永远不会递归或不透明。识别符的类型可以是递归的，可以是不透明的，并且永远不会被分离。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%T1 = type &#123; &lt;type list&gt; &#125;     ; Identified normal struct type</span><br><span class="line">%T2 = type &lt;&#123; &lt;type list&gt; &#125;&gt;   ; Identified packed struct type</span><br></pre></td></tr></table></figure><p></p><p>例子：<br><code>{ i32, i32, i32 }</code> 三个i32值的结构<br><code>{ float, i32 (i32) * }</code> 一对，其中第一个元素是a float，第二个元素是一个指向函数的指针，该函数接受一个i32返回值i32。<br><code>&lt;{ i8, i32 }&gt;</code> 一个已知为5字节大小的打包结构。</p><h4 id="不透明结构类型"><a href="#不透明结构类型" class="headerlink" title="不透明结构类型"></a>不透明结构类型</h4><p>概述： 不透明结构类型用于表示没有指定主体的命名结构类型。这符合（例如）正向声明结构的C概念。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%X = type opaque</span><br><span class="line">%52 = type opaque</span><br></pre></td></tr></table></figure><p></p><p>例子：<br><code>opaque</code> 一种不透明的类型。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>LLVM有几种不同的基本类型的常量。本节介绍它们的全部和它们的语法。</p><h2 id="简单常量"><a href="#简单常量" class="headerlink" title="简单常量"></a>简单常量</h2><ul><li>布尔常量: 两个字符串’ true’和’ false’都是该i1类型的有效常量。</li><li>整型常量: 标准整数（如’4’）是整数类型的常量 。负数可能与整数类型一起使用。</li><li>浮点常量: 浮点常量使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e + 2）或更精确的十六进制表示法（请参见下文）。汇编器需要浮点常量的精确十进制值。例如，汇编程序接受1.25，但拒绝1.3，因为1.3是二进制中的重复小数。浮点常量必须具有 浮点类型。</li><li>空指针常量: 标识符’<code>null</code>‘被识别为空指针常量，并且必须是指针类型。</li><li>令牌(Token)常量: 标识符’none’被识别为空的标记常量，并且必须是标记类型。</li></ul><p>常量的一个非直观符号是浮点常量的十六进制形式。例如，形式为’<code>double 0x432ff973cafa8000</code>‘等同于（但难以阅读）’<code>double 4.5e+15</code>‘。唯一需要十六进制浮点常量（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能用合理数目的十进制浮点数表示的浮点常量数字。例如，<code>NaN&#39;s</code>，<code>infinities</code>和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位发生更改。</p><p>当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字形式表示（与IEEE754表示符合double）; 然而，half和float值必须分别精确表示为IEEE 754的半精度和单精度。十六进制格式总是用于长双，并有三种形式的长双。x86使用的80位格式表示0xK后跟20个十六进制数字。PowerPC使用的128位格式（两个相邻的双精度） 0xM由32个十六进制数字表示。IEEE 128位格式0xL由32个十六进制数字表示。长双打只有在你的目标上的长双重格式匹配时才有效。IEEE 16位格式（半精度）由表示0xH 后跟4个十六进制数字。所有的十六进制格式都是big-endian（左边的符号位）。</p><p>没有<code>x86_mmx</code>类型的常量。</p><h2 id="复杂（Complex）常量"><a href="#复杂（Complex）常量" class="headerlink" title="复杂（Complex）常量"></a>复杂（Complex）常量</h2><p>复杂常量是简单常量和较小复常量的（可能递归）组合。</p><h3 id="结构常数"><a href="#结构常数" class="headerlink" title="结构常数"></a>结构常数</h3><p>结构常量用类似于结构类型定义的符号表示（逗号分隔的元素列表，用大括号（{}）括起来）。例如：“<code>{ i32 4, float 17.0, i32* @G }</code>”，其中“<code>@G</code>”被声明为“<code>@G = external global i32</code>”。结构常量必须具有<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Qtc3RydWN0" title="http://llvm.org/docs/LangRef.html#t-struct">结构类型<i class="fa fa-external-link"></i></span>，并且元素的数量和类型必须与该类型指定的类型匹配。</p><h3 id="数组常量"><a href="#数组常量" class="headerlink" title="数组常量"></a>数组常量</h3><p>数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号（[]）括起来）。例如：“<code>[ i32 42, i32 11, i32 74 ]</code>”。数组常量必须具有<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtYXJyYXk=" title="http://llvm.org/docs/LangRef.html#t-array">数组类型<i class="fa fa-external-link"></i></span>，并且元素的数量和类型必须与该类型指定的数量和类型相匹配。作为一种特殊情况，字符数组常量也可以用 前缀表示为双引号字符串。例如：“c<code>&quot;Hello World\0A\00&quot;</code>”。</p><h3 id="矢量-Vector-常量"><a href="#矢量-Vector-常量" class="headerlink" title="矢量(Vector)常量"></a>矢量(Vector)常量</h3><p>向量常量用类似于向量类型定义的符号表示（逗号分隔的元素列表，由小于/大于（（&lt;&gt;））围绕）。例如：“<code>&lt; i32 42, i32 11, i32 74, i32 100 &gt;</code>”。向量常量必须具有向量类型，并且元素的数量和类型必须与该类型指定的类型匹配。</p><h3 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h3><p>字符串“<code>zeroinitializer</code>‘可用于将零值初始化为任何类型的零，包括标量和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtYWdncmVnYXRl" title="http://llvm.org/docs/LangRef.html#t-aggregate">聚合类型<i class="fa fa-external-link"></i></span>。这通常用于避免必须打印大型零初始化器（例如，用于大型数组），并且始终完全等同于使用显式零初始化器。</p><h3 id="元数据节点"><a href="#元数据节点" class="headerlink" title="元数据节点"></a>元数据节点</h3><p>元数据节点是一个没有类型的常量元组。例如：“<code>!{!0, !{!2, !0}, !&quot;test&quot;}</code>”。元数据可以引用常量值，例如：“<code>!{!0, i32 0, i8* @global, i64 (i64)* @function, !&quot;str&quot;}</code>”。与其他类型化的常量不同，它们被解释为指令流的一部分，元数据是附加附加信息的地方，例如调试信息。</p><h2 id="全局变量和函数地址"><a href="#全局变量和函数地址" class="headerlink" title="全局变量和函数地址"></a>全局变量和函数地址</h2><p><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2dsb2JhbHZhcnM=" title="http://llvm.org/docs/LangRef.html#globalvars">全局变量<i class="fa fa-external-link"></i></span>和 <span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2Z1bmN0aW9uc3RydWN0dXJl" title="http://llvm.org/docs/LangRef.html#functionstructure">函数<i class="fa fa-external-link"></i></span>总是隐式有效（链接时间）常量。当使用<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2lkZW50aWZpZXJz" title="http://llvm.org/docs/LangRef.html#identifiers">全局标识符<i class="fa fa-external-link"></i></span>并且总是有指针类型时，这些常量被明确引用。例如，以下是合法的LLVM文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@X = global i32 17</span><br><span class="line">@Y = global i32 42</span><br><span class="line">@Z = global [2 x i32*] [ i32* @X, i32* @Y ]</span><br></pre></td></tr></table></figure><p></p><h2 id="未定义的值"><a href="#未定义的值" class="headerlink" title="未定义的值"></a>未定义的值</h2><p>字符串’<code>undef</code>‘可以用于任何需要常量的地方，并且表示该值的用户可能会收到未指定的位模式。未定义的值可以是任何类型（除了’<code>label</code>‘或’<code>void</code>‘），并且可以在任何允许常量的地方使用。</p><p>未定义的值非常有用，因为它们向编译器指出，无论使用什么值，该程序都已定义良好。这为编译器提供了更多的优化自由度。下面是一些有效的（可能令人惊讶的）转换的例子（在伪IR中）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  %A = add %X, undef</span><br><span class="line">  %B = sub %X, undef</span><br><span class="line">  %C = xor %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure><p></p><p>这是安全的，因为所有的输出位都受<code>undef</code>位的影响。任何输出位都可以有一个零或一个依赖的输入位。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = or %X, undef</span><br><span class="line">  %B = and %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = -1</span><br><span class="line">  %B = 0</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X  ;; By choosing undef as 0</span><br><span class="line">  %B = %X  ;; By choosing undef as -1</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br></pre></td></tr></table></figure><p></p><p>这些逻辑操作的位不总是受输入的影响。例如，如果%X有一个零位，那么“<code>and</code>‘操作的输出将始终为该位的零，而不管”<code>undef</code>‘ 的相应位是什么。因此，优化或假设<code>and</code>的结果是<code>undef</code>是不安全的。但是，假设<code>undef</code>的所有位都可以是0，并且将’<code>and</code>‘优化为0是安全的。同样，假设可以设置<code>undef</code>的<code>or</code>操作的所有位是安全的，允许’<code>or</code>‘被折叠为-1。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  %A = select undef, %X, %Y</span><br><span class="line">  %B = select undef, 42, %Y</span><br><span class="line">  %C = select %X, %Y, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = %X     (or %Y)</span><br><span class="line">  %B = 42     (or %Y)</span><br><span class="line">  %C = %Y</span><br><span class="line">Unsafe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br></pre></td></tr></table></figure><p></p><p>这组例子表明，未定义的’<code>select</code>‘（和条件分支）条件可以采取任何方式，但它们必须来自两个操作数中的一个。在<code>%A</code>例子中，如果<code>%X</code>和<code>%Y</code>是两个已知具有明显的低位，那么<code>%A</code>就必须有一个清除低位。然而，在这个<code>%C</code>例子中，优化器被允许假设’<code>undef</code>‘操作可以是和<code>%Y</code>相同的，允许整个’<code>select</code>‘被消除。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  %A = xor undef, undef</span><br><span class="line"></span><br><span class="line">  %B = undef</span><br><span class="line">  %C = xor %B, %B</span><br><span class="line"></span><br><span class="line">  %D = undef</span><br><span class="line">  %E = icmp slt %D, 4</span><br><span class="line">  %F = icmp gte %D, 4</span><br><span class="line"></span><br><span class="line">Safe:</span><br><span class="line">  %A = undef</span><br><span class="line">  %B = undef</span><br><span class="line">  %C = undef</span><br><span class="line">  %D = undef</span><br><span class="line">  %E = undef</span><br><span class="line">  %F = undef</span><br></pre></td></tr></table></figure><p></p><p>这个例子指出两个<code>undef</code>操作不一定相同。这对于人们来说可能是令人惊讶的（并且也匹配C语义），他们认为“<code>X^X</code>”总是零，即使 X未定义也是如此。由于多种原因，这是不正确的，但简单的答案是，一个<code>undef</code>“变量”可以在其“生存范围”内随意改变它的值。这是真的，因为这个变量实际上并没有生存范围。相反，该值是从任意寄存器中逻辑读取的，这些寄存器恰好在需要时发生变化，因此该值不一定随时间变化。事实上，<code>%A</code>和<code>%C</code>需要有相同的语法或核心LLVM“全部替换与使用”的概念将不成立。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = sdiv undef, %X</span><br><span class="line">  %B = sdiv %X, undef</span><br><span class="line">Safe:</span><br><span class="line">  %A = 0</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure><p></p><p>这些示例显示了未定义的值 和未定义的行为之间的关键区别。一个未定义的值（如’<code>undef</code>‘）允许有一个任意的位模式。这意味着<code>%A</code>操作可以不断折叠为’0’，因为’<code>undef</code>‘可能为零，并且零除以任何值为零。但是，在第二个例子中，我们可以做一个更积极的假设：因为<code>undef</code>允许它是一个任意值，我们可以假设它可能为零。由于被零除以具有未定义的行为，我们被允许假设该操作根本不执行。这允许我们删除分割和所有代码。由于未定义的操作“不可能发生”，因此优化器可以假定它发生在死代码中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a:  store undef -&gt; %X</span><br><span class="line">b:  store %X -&gt; undef</span><br><span class="line">Safe:</span><br><span class="line">a: &lt;deleted&gt;</span><br><span class="line">b: unreachable</span><br></pre></td></tr></table></figure><p></p><p>存储的未定义的值可以被假设为不具有任何影响; 我们可以假设这个值被恰好与已经存在的相匹配的位覆盖。然而，一个存储到一个未定义的位置可能破坏任意的内存，因此，它具有未定义行为。</p><h2 id="毒药（Poison）值"><a href="#毒药（Poison）值" class="headerlink" title="毒药（Poison）值"></a>毒药（Poison）值</h2><p>毒性（Poison）值与undef值相似，但它们也表示这样的事实，即不能引起副作用的指令或常量表达式已经检测到导致未定义行为的条件。</p><p>目前在IR中无法表示毒物值; 它们只存在于某些操作的调用，如带有<code>nsw</code>标志的<code>add</code>操作。</p><p>毒药值行为是根据值依赖来定义的：</p><ul><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcGhp" title="http://llvm.org/docs/LangRef.html#i-phi">phi<i class="fa fa-external-link"></i></span>节点以外的值取决于它们的操作数。</li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcGhp" title="http://llvm.org/docs/LangRef.html#i-phi">Phi<i class="fa fa-external-link"></i></span>节点取决于对应于其动态前驱基本块的操作数。</li><li>函数参数取决于其函数的动态调用者中相应的实际参数值。</li><li>调用(<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktY2FsbA==" title="http://llvm.org/docs/LangRef.html#i-call">call<i class="fa fa-external-link"></i></span>)指令取决于将控制动态传回给它们的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcmV0" title="http://llvm.org/docs/LangRef.html#i-ret">ret<i class="fa fa-external-link"></i></span>指令。</li><li>调用(<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktaW52b2tl" title="http://llvm.org/docs/LangRef.html#i-invoke">invoke<i class="fa fa-external-link"></i></span>)指令取决于ret， <span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcmVzdW1l" title="http://llvm.org/docs/LangRef.html#i-resume">resume<i class="fa fa-external-link"></i></span>或异常抛出调用指令，动态地将控制权交还给它们。</li><li>非易失性加载和存储取决于所有引用的内存地址的最新存储，遵循IR中的命令（包括由<span class="exturl" data-url="bWFpbHRvOmBAbGx2bS5tZW1jcHk=" title="mailto:`@llvm.memcpy">`@llvm.memcpy<i class="fa fa-external-link"></i></span>`等内在函数隐含的加载和存储）。</li><li>具有外部可见副作用的指令取决于最近的先前的指令，其具有外部可见的副作用，遵循IR中的顺序。（这包括易失性操作。）</li><li>指令控制依赖于一个终止指令，如果终止子指令有多个后继者和指令总是被执行时控制转移到后继的一个，并且当控制被转移到另一个可以不执行。</li><li>此外，指令也是控制 - 取决于终止指令，如果终止指令已将控制权转移给不同的后继者，则其所依赖的指令集将会不​​同。</li><li>依赖性是传递性的。</li></ul><p>Poison值具有与undef值相同的行为，另外的效果是任何依赖poison值的指令都具有未定义的行为。</p><p>这里有些例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  %poison = sub nuw i32 0, 1           ; Results in a poison value.</span><br><span class="line">  %still_poison = and i32 %poison, 0   ; 0, but also poison.</span><br><span class="line">  %poison_yet_again = getelementptr i32, i32* @h, i32 %still_poison</span><br><span class="line">  store i32 0, i32* %poison_yet_again  ; memory at @h[0] is poisoned</span><br><span class="line"></span><br><span class="line">  store i32 %poison, i32* @g           ; Poison value stored to memory.</span><br><span class="line">  %poison2 = load i32, i32* @g         ; Poison value loaded back from memory.</span><br><span class="line"></span><br><span class="line">  store volatile i32 %poison, i32* @g  ; External observation; undefined behavior.</span><br><span class="line"></span><br><span class="line">  %narrowaddr = bitcast i32* @g to i16*</span><br><span class="line">  %wideaddr = bitcast i32* @g to i64*</span><br><span class="line">  %poison3 = load i16, i16* %narrowaddr ; Returns a poison value.</span><br><span class="line">  %poison4 = load i64, i64* %wideaddr  ; Returns a poison value.</span><br><span class="line"></span><br><span class="line">  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.</span><br><span class="line">  br i1 %cmp, label %true, label %end  ; Branch to either destination.</span><br><span class="line"></span><br><span class="line">true:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This is control-dependent on %cmp, so</span><br><span class="line">                                       ; it has undefined behavior.</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  %p = phi i32 [ 0, %entry ], [ 1, %true ]</span><br><span class="line">                                       ; Both edges into this PHI are</span><br><span class="line">                                       ; control-dependent on %cmp, so this</span><br><span class="line">                                       ; always results in a poison value.</span><br><span class="line"></span><br><span class="line">  store volatile i32 0, i32* @g        ; This would depend on the store in %true</span><br><span class="line">                                       ; if %cmp is true, or the store in %entry</span><br><span class="line">                                       ; otherwise, so this is undefined behavior.</span><br><span class="line"></span><br><span class="line">  br i1 %cmp, label %second_true, label %second_end</span><br><span class="line">                                       ; The same branch again, but this time the</span><br><span class="line">                                       ; true block doesn&apos;t have side effects.</span><br><span class="line"></span><br><span class="line">second_true:</span><br><span class="line">  ; No side effects!</span><br><span class="line">  ret void</span><br><span class="line"></span><br><span class="line">second_end:</span><br><span class="line">  store volatile i32 0, i32* @g        ; This time, the instruction always depends</span><br><span class="line">                                       ; on the store in %end. Also, it is</span><br><span class="line">                                       ; control-equivalent to %end, so this is</span><br><span class="line">                                       ; well-defined (ignoring earlier undefined</span><br><span class="line">                                       ; behavior in this example).</span><br></pre></td></tr></table></figure><p></p><h2 id="基本块的地址"><a href="#基本块的地址" class="headerlink" title="基本块的地址"></a>基本块的地址</h2><p><code>blockaddress(@function, %block)</code></p><p>在“<code>blockaddress</code>”常数计算在指定函数指定的基本块的地址，并总是有一个<code>i8*</code>类型。取出输入块的地址是非法的。</p><p>当用作’<code>indirectbr</code>‘指令的操作指令时，或者用于与空值进行比较时，该值仅具有已定义的行为。标签地址之间的指针相等测试会导致未定义的行为 - 但是，再次，与null进行比较是可以的，并且没有标签等于空指针。只要这些位未被检查，这可以作为不透明的指针大小值传递。ptrtoint只要原始值在indirectbr 指令之前重新构成，就允许和计算这些值。</p><p>最后，有些目标可能会在使用该值作为内联程序集的操作数时提供定义的语义，但这是目标特定的。</p><h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>常量表达式用于允许涉及其他常量的表达式用作常量。常量表达式可以是任何<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3QtZmlyc3RjbGFzcw==" title="http://llvm.org/docs/LangRef.html#t-firstclass">第一类类型<i class="fa fa-external-link"></i></span>，并且可能涉及没有副作用的任何LLVM操作（例如，不支持加载和调用）。以下是常量表达式的语法：</p><ul><li><code>trunc (CST to TYPE)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktdHJ1bmM=" title="http://llvm.org/docs/LangRef.html#i-trunc">trunc操作<i class="fa fa-external-link"></i></span>。</li><li><code>zext (CST to TYPE)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktemV4dA==" title="http://llvm.org/docs/LangRef.html#i-zext">zext操作<i class="fa fa-external-link"></i></span>。</li><li><code>sext (CST to TYPE)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktc2V4dA==" title="http://llvm.org/docs/LangRef.html#i-sext">sext操作<i class="fa fa-external-link"></i></span>。</li><li><code>fptrunc (CST to TYPE)</code>: 将浮点常量截断为另一个浮点类型。CST的大小必须大于TYPE的大小。这两种类型都必须是浮点型。</li><li><code>fpext (CST to TYPE)</code>: 浮点将常量扩展为另一种类型。CST的大小必须小于或等于TYPE的大小。这两种类型都必须是浮点型。</li><li><code>fptoui (CST to TYPE)</code>: 将浮点常量转换为相应的无符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li><li><code>fptosi (CST to TYPE)</code>: 将浮点常量转换为相应的有符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。</li><li><code>uitofp (CST to TYPE)</code>: 将无符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li><li><code>sitofp (CST to TYPE)</code>: 将有符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。</li><li><code>ptrtoint (CST to TYPE)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcHRydG9pbnQ=" title="http://llvm.org/docs/LangRef.html#i-ptrtoint">ptrtoint操作<i class="fa fa-external-link"></i></span>。</li><li><code>inttoptr (CST to TYPE)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktaW50dG9wdHI=" title="http://llvm.org/docs/LangRef.html#i-inttoptr">inttoptr操作<i class="fa fa-external-link"></i></span>。这个真的很危险！</li><li><code>bitcast (CST to TYPE)</code>: 将常数CST转换为另一个TYPE。操作数的限制与<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktYml0Y2FzdA==" title="http://llvm.org/docs/LangRef.html#i-bitcast">bitcast指令<i class="fa fa-external-link"></i></span>的限制相同 。</li><li><code>addrspacecast (CST to TYPE)</code>: 将指针CST的常量指针或常量向量转换为另一个地址空间中的另一个TYPE。操作数的约束与<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktYWRkcnNwYWNlY2FzdA==" title="http://llvm.org/docs/LangRef.html#i-addrspacecast">addrspacecast指令<i class="fa fa-external-link"></i></span>的约束相同。</li><li><code>getelementptr (TY, CSTPTR, IDX0, IDX1, ...)， getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZ2V0ZWxlbWVudHB0cg==" title="http://llvm.org/docs/LangRef.html#i-getelementptr">getelementptr操作<i class="fa fa-external-link"></i></span>。与<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZ2V0ZWxlbWVudHB0cg==" title="http://llvm.org/docs/LangRef.html#i-getelementptr">getelementptr<i class="fa fa-external-link"></i></span> 指令一样，索引列表可能有一个或多个索引，这些索引对于“指向TY的指针”类型是有意义的。</li><li><code>select (COND, VAL1, VAL2)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktc2VsZWN0" title="http://llvm.org/docs/LangRef.html#i-select">选择操作<i class="fa fa-external-link"></i></span>。</li><li><code>icmp COND (VAL1, VAL2)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktaWNtcA==" title="http://llvm.org/docs/LangRef.html#i-icmp">icmp操作<i class="fa fa-external-link"></i></span>。</li><li><code>fcmp COND (VAL1, VAL2)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZmNtcA==" title="http://llvm.org/docs/LangRef.html#i-fcmp">fcmp操作<i class="fa fa-external-link"></i></span>。</li><li><code>extractelement (VAL, IDX)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZXh0cmFjdGVsZW1lbnQ=" title="http://llvm.org/docs/LangRef.html#i-extractelement">extractelement操作<i class="fa fa-external-link"></i></span>。</li><li><code>insertelement (VAL, ELT, IDX)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktaW5zZXJ0ZWxlbWVudA==" title="http://llvm.org/docs/LangRef.html#i-insertelement">insertelement操作<i class="fa fa-external-link"></i></span>。</li><li><code>shufflevector (VEC1, VEC2, IDXMASK)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktc2h1ZmZsZXZlY3Rvcg==" title="http://llvm.org/docs/LangRef.html#i-shufflevector">shufflevector操作<i class="fa fa-external-link"></i></span>。</li><li><code>extractvalue (VAL, IDX0, IDX1, ...)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZXh0cmFjdHZhbHVl" title="http://llvm.org/docs/LangRef.html#i-extractvalue">extractvalue操作<i class="fa fa-external-link"></i></span>。索引列表的解释方式与“<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZ2V0ZWxlbWVudHB0cg==" title="http://llvm.org/docs/LangRef.html#i-getelementptr">getelementptr<i class="fa fa-external-link"></i></span>”操作中的索引类似。至少必须指定一个索引值。</li><li><code>insertvalue (VAL, ELT, IDX0, IDX1, ...)</code>: 对常量执行<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktaW5zZXJ0dmFsdWU=" title="http://llvm.org/docs/LangRef.html#i-insertvalue">insertvalue操作<i class="fa fa-external-link"></i></span>。索引列表的解释方式与“<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZ2V0ZWxlbWVudHB0cg==" title="http://llvm.org/docs/LangRef.html#i-getelementptr">getelementptr<i class="fa fa-external-link"></i></span>”操作中的索引类似。至少必须指定一个索引值。</li><li><code>OPCODE (LHS, RHS)</code>: 执行LHS和RHS常量的指定操作。操作码可以是任何<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2JpbmFyeW9wcw==" title="http://llvm.org/docs/LangRef.html#binaryops">二进制<i class="fa fa-external-link"></i></span>或<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2JpdHdpc2VvcHM=" title="http://llvm.org/docs/LangRef.html#bitwiseops">按位二进制<i class="fa fa-external-link"></i></span>操作。操作数的限制与相应指令的限制相同（例如，不允许对浮点值进行按位操作）。</li></ul><h1 id="其他值"><a href="#其他值" class="headerlink" title="其他值"></a>其他值</h1><h2 id="内嵌汇编表达式"><a href="#内嵌汇编表达式" class="headerlink" title="内嵌汇编表达式"></a>内嵌汇编表达式</h2><p>LLVM 通过使用特殊值支持内联汇编表达式（与模块级内联汇编相反）。该值表示内联汇编程序作为模板字符串（包含要发出的指令），操作数约束列表（存储为字符串），指示内联asm表达式是否具有副作用的标志以及指示是否包含asm的函数需要保守地调整堆栈。</p><p>模板字符串支持使用<code>$</code>后跟一个数字的参数替换，以指示由约束字符串指定的给定寄存器/内存位置的替换。“<code>${NUM:MODIFIER}</code>”也可以使用，其中MODIFIER是如何打印操作数的特定于目标的注释（请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2lubGluZS1hc20tbW9kaWZpZXJz" title="http://llvm.org/docs/LangRef.html#inline-asm-modifiers">Asm模板参数修饰符<i class="fa fa-external-link"></i></span>）。</p><p>字符<code>$</code>可以在模板中使用“<code>$$</code>”。要在输出中包含其他特殊字符，可以使用通常的“<code>\XX</code>”转义符，就像在其他字符串中一样。请注意，在模板替换之后，生成的汇编字符串将由LLVM的集成汇编器进行分析，除非它被禁用 - 即使发出<code>.s</code>文件 - 也必须包含LLVM已知的汇编语法。</p><p>LLVM还支持一些有用的内联汇编代码：</p><ul><li><code>${:uid}</code>：扩展为这个内联汇编blob唯一的十进制整数。在声明本地标签时，这种替换很有用。许多标准的编译器优化（如内联）可能会复制内联asm blob。添加blob唯一标识符可确保这两个标签在装配过程中不会发生冲突。这用于实现<span class="exturl" data-url="aHR0cHM6Ly9nY2MuZ251Lm9yZy9vbmxpbmVkb2NzL2djYy9FeHRlbmRlZC1Bc20uaHRtbA==" title="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">GCC的％=特殊格式字符串<i class="fa fa-external-link"></i></span>。</li><li><code>${:comment}</code>：扩展为当前目标的汇编方言的注释字符。这通常是<code>#</code>，但很多指标使用其他字符串，例如<code>;</code>，<code>//</code>或<code>!</code>。</li><li><code>${:private}</code>：扩展为汇编器专用标签前缀。带有此前缀的标签不会出现在组装对象的符号表中。通常前缀是<code>L</code>，但目标可能使用其他字符串。<code>.L</code>是比较受欢迎的。</li></ul><p>LLVM对inline asm的支持与Clang的GCC兼容的inline-asm支持的要求紧密相关。因此，这里列出的特征集以及约束和修饰符代码与GCC内联asm支持中的代码类似或相同。然而，要清楚的是，这里描述的模板和约束字符串的语法与GCC和Clang所接受的语法并不相同，并且尽管大多数约束字母是通过Clang原样传递的，但当从C源代码转换为LLVM程序集时，有些字符会被转换为其他代码。</p><p>一个内联汇编表达式的例子是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i32 (i32) asm &quot;bswap $0&quot;, &quot;=r,r&quot;</span><br></pre></td></tr></table></figure><p></p><p>内联汇编程序表达式只能用作调用(call)或调用(invoke)指令的被调用者操作数。因此，通常我们有：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%X = call i32 asm &quot;bswap $0&quot;, &quot;=r,r&quot;(i32 %Y)</span><br></pre></td></tr></table></figure><p></p><p>带有在约束列表中不可见的副作用的内联asms必须标记为具有副作用。这是通过使用’sideeffect’关键字完成的，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure><p></p><p>在某些情况下，内联asms将包含无法工作的代码，除非堆栈以某种方式对齐，例如x86上的调用或SSE指令，但不会包含在asm中执行对齐的代码。编译器应该对asm可能包含的内容做出保守的假设，并且如果’alignstack’关键字存在，应该在序言中生成其通常的堆栈对齐代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm alignstack &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure><p></p><p>内联asms也支持使用非标准汇编方言。假定的方言是ATT。当’<code>inteldialect</code>‘关键字存在时，内联asm使用英特尔方言。目前，ATT和Intel是唯一支持的方言。一个例子是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call void asm inteldialect &quot;eieio&quot;, &quot;&quot;()</span><br></pre></td></tr></table></figure><p></p><p>如果出现多个关键字，则’<code>sideeffect</code>‘关键字必须首先出现，’<code>alignstack</code>‘关键字第二关键字和’<code>inteldialect</code>‘关键字最后出现。</p><h3 id="内联汇编约束字符串"><a href="#内联汇编约束字符串" class="headerlink" title="内联汇编约束字符串"></a>内联汇编约束字符串</h3><p>约束列表是逗号分隔的字符串，每个元素包含一个或多个约束代码。</p><p>对于约束列表中的每个元素，将选择一个适当的寄存器或内存操作数，并且将对<code>$0</code>列表中的第一个约束，<code>$1</code>第二个等将使其可用于组件模板字符串扩展。</p><p>有三种不同类型的约束，它们通过约束代码前面的前缀符号进行区分：输出，输入和Clobber。必须始终按照以下顺序给出约束：先输出，然后输入，然后是clobbers。他们不能混在一起。</p><p>还有三种不同类型的约束代码：</p><ul><li>注册约束。这是一个寄存器类，或者是一个固定的物理寄存器。这种约束将分配一个寄存器，并且如果必要的话，将该参数或结果进行bitcast到适当的类型。</li><li>内存约束。这种约束用于获取内存操作数的指令。不同的约束允许目标使用不同的寻址模式。</li><li>立即值限制。这种约束是针对整数或其他立即值的，它可以直接渲染到指令中。各种特定于目标的约束条件允许为您希望使用的指令选择合适范围内的值。</li></ul><h4 id="输出约束"><a href="#输出约束" class="headerlink" title="输出约束"></a>输出约束</h4><p>输出约束由“<code>=</code>”前缀（例如“<code>=r</code>”）指定。这表示程序集将写入此操作数，然后操作数将作为asm表达式的返回值提供。输出约束不会消耗调用指令中的参数。（除了下面关于间接输出的内容）。</p><p>通常，在读取所有输入之前，预计没有输出位置被汇编表达式写入。因此，LLVM可以将相同的寄存器分配给输出和输入。如果这不安全（例如，如果程序集包含两条指令，其中第一条写入一个输出，第二条读取输入并写入第二条输出），则必须使用“<code>&amp;</code>”修饰符（例如“<code>=&amp;r</code>”）来指定输出是“早期破坏”输出。将输出标记为“<code>early-clobber</code>”可确保LLVM不会对任何输入（除了与此输出关联的输入）使用相同的寄存器。</p><h4 id="输入约束"><a href="#输入约束" class="headerlink" title="输入约束"></a>输入约束</h4><p><b style="color:green">输入约束没有前缀 - 只是约束代码。每个输入约束将从调用指令中消耗一个参数。asm不允许写入任何输入寄存器或存储单元（除非该输入连接到输出）。还要注意，如果LLVM可以确定它们必然都包含相同的值，则可以将多个输入全部分配给相同的寄存器。</b></p><p>通过提供一个整数作为约束字符串，输入约束可以将它们自己绑定到输出约束，而不是提供约束代码。被绑定的输入仍然会从调用指令中消耗一个参数，并且按照通常的方式在asm模板编号中占据一个位置 - 它们将被简单地限制为始终使用与其绑定的输出相同的寄存器。例如，一个约束字符串“<code>=r,0</code>”表示为输出分配一个寄存器，并将该寄存器用作输入（它是第<code>0</code>个约束）。</p><p>允许将输入连接到“早期破坏(early-clobber)”输出。在这种情况下，没有 其他输入可能与连接到早期触发器的输入共享相同的寄存器（即使其他输入具有相同的值）。</p><p>您只能将输入绑定到具有寄存器约束但不受内存约束的输出。只有一个输入可能与输出相关联。</p><p>还有一个“有趣”的特性，值得一点解释：如果寄存器类约束分配的寄存器对于作为输入提供的值类型操作数来说太小，则输入值将被分成多个寄存器，并且所有寄存器传递给内联asm。</p><p>但是，此功能通常不如您想象的那么有用。</p><p>首先，寄存器不保证连续。因此，在那些具有多条连续指令操作指令的体系结构上，这不是支持它们的适当方式。（例如，32位SparcV8具有64位加载，该指令只需要一个32位寄存器，然后硬件将加载到指定的寄存器和下一个寄存器中。内联asm的此功能对于此的支持将不会有用。）</p><p>几个目标提供了一个模板字符串修改，允许两寄存器操作数的第二个寄存器明确的访问（例如MIPS L，M和 D）。在这样的体系结构中，您实际上可以访问第二个已分配的寄存器（但是，仍然没有任何后续的寄存器）。但是，在这种情况下，为了清晰起见，将这个值简化为两个独立的操作数仍然可能更好。（例如，请参阅AX86 上的约束描述，尽管该特性仅用于此功能，但使用并不是一个好主意）</p><h4 id="间接投入和产出"><a href="#间接投入和产出" class="headerlink" title="间接投入和产出"></a>间接投入和产出</h4><p>间接输出或输入约束可以由“<code>*</code>”修饰符（在输出的情况下在“<code>=</code>”之后）指定。这表明asm将写入或读取作为输入参数提供的地址的内容。（注意，在这种方式，间接输出更像一个输入而不是输出：只是像输入，它们消耗的调用表达式的参数，而不是产生一个返回值。间接输出约束是“输出”仅是希望在asm可以写入输入内存位置的内容，而不是从中读取）。</p><p><b style="color:green">这通常用于内存约束，例如“<code>=*m</code>”，以将变量的地址作为值传递。</b></p><p>也可以使用间接寄存器约束，但仅限于输出（例如“<code>=*r</code>”）。这会导致LLVM正常地为输出值分配一个寄存器，然后在提供的内联asm之后，单独发送一个存储到作为输入提供的地址。（与在asm语句后明确写入store相比，此功能提供了什么值尚不清楚，而且它只能生成更糟糕的代码，因为它绕过了许多优化过程，我建议不要使用它。）</p><h4 id="Clobber约束"><a href="#Clobber约束" class="headerlink" title="Clobber约束"></a>Clobber约束</h4><p>一个clobber约束由一个“<code>~</code>”前缀表示。clobber不会消耗输入操作数，也不会生成输出。Clobbers不能使用任何一般的约束代码字母 - 它们可能只使用明确的寄存器约束，例如“<code>~{eax}</code>”。一个例外是，“<code>~{memory}</code>” 的clobber字符串表示程序集写入任意未声明的内存位置 - 不仅是由声明的间接输出指向的内存。</p><p>请注意，输出约束中也存在的clobbering命名寄存器是不合法的。</p><h4 id="约束代码"><a href="#约束代码" class="headerlink" title="约束代码"></a>约束代码</h4><p>潜在的前缀来了约束代码或代码之后。</p><p>约束代码可以是单个字母（例如“<code>r</code>”），“<code>^</code>”字符后跟两个字母（例如“<code>^wc</code>”）或“<code>{”寄存器名称“ }</code>”（例如“<code>{eax}</code>”）。</p><p>通常选择单字母和双字母约束代码与GCC的约束代码相同。</p><p>一个约束可能包含一个或多个约束代码，而让LLVM选择使用哪一个约束代码。这主要包括与来自clang的GCC inline asm的翻译兼容。</p><p>有两种方式可以指定替代方案，并且可以在内联asm约束列表中使用其中之一或两者。</p><ol><li>相互追加代码，制作约束代码集。例如“<code>im</code>”或“ <code>{eax}m</code>”。这意味着“选择集合中的任何选项”。对约束列表中的每个约束独立进行约束的选择。</li><li>在约束代码集之间使用“<code>|</code>”，创建替代方案。约束列表中的每个约束都必须具有相同数量的备选集。使用这种语法，约束列表中所有项目中的相同备选项将一起选择。</li></ol><p>把它们放在一起，你可能会有两个操作数约束字符串,像”<code>rm|r,ri|rm</code>“。这表明如果操作数0是r或m，则操作数1可以是r或i。如果操作数0是r，则操作数1可以是r或m。但是，操作数0和1不能都是m类型。</p><p>但是，不推荐使用其中任何一种替代功能，因为LLVM无法对使用哪种替代功能做出明智选择。（在当前需要选择的时候，没有足够的信息可以用聪明的方式来实现。）因此，它只是试图做出最有可能编译的选择，而不是最优性能的选择。（例如，给定“rm”，它总是选择使用内存，而不是寄存器）。而且，如果给定多个寄存器或多个寄存器类，它将简单地选择第一个。（实际上，目前它甚至不确保明确指定的物理寄存器是唯一的，因此指定多个物理寄存器作为替代，例如 {r11}{r12},{r11}{r12}，将r11分配给两个操作数，而不是所有打算的。）</p><h4 id="支持的约束代码列表"><a href="#支持的约束代码列表" class="headerlink" title="支持的约束代码列表"></a>支持的约束代码列表</h4><p>一般来说，约束代码的行为与GCC中的一样。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p><p>所有目标通常都支持一些约束代码：</p><ul><li>r：目标通用寄存器类中的寄存器。</li><li>m：存储器地址操作数。它支持哪些寻址模式，典型的例子是寄存器，寄存器+寄存器偏移量，或寄存器+直接偏移量（某些目标特定的大小）。</li><li>i：一个整数常量（目标特定宽度）。允许简单的即时或可重定位的值。</li><li>n：一个整数常量 - 不包括可重定位值。</li><li>s：一个整数常量，但只允许重定位值。</li><li>X：允许任何类型的操作数，不受任何限制。通常用于为asm分支或call传递标签。</li><li>{register-name}：需要完整的指定物理寄存器。</li></ul><p>其他约束是针对具体目标的：</p><p>AArch64：</p><ul><li>z：一个立即数整数0.输出WZR或者XZR视情况而定。</li><li>I：对一个ADD或SUB指令有效的立即整数，即0到4095，可选的移位12。</li><li>J：一个立即数，取反时对一个ADD或 SUB指令有效，即-1到-4095，可选左移12。</li><li>K：一个直接整数，它是有效的“位掩码即时32”的逻辑指令等AND，EOR或ORR与32位寄存器。</li><li>L：一个直接整数，它是有效的“位掩码即时64”的逻辑指令等AND，EOR或ORR与64位寄存器。</li><li>M：与MOV32位寄存器上的程序集别名一起使用的立即整数。这是一个超集K：除了bitmask立即数，还允许立即可以装载单个MOVZ或MOVL指令的整数 。</li><li>N：用于MOV64位寄存器上的程序集别名的立即整数。这是一个超集L。</li><li>Q：存储器地址操作数必须位于单个寄存器中（无偏移量）。（但是，LLVM目前也为m约束做了这个。）</li><li>r：32位或64位整数寄存器（W <em>或X </em>）。</li><li>w：一个32,64或128位浮点/ SIMD寄存器。</li><li>x：较低的128位浮点/ SIMD寄存器（V0至V15）。</li></ul><p>AMDGPU：</p><ul><li>r：32位或64位整数寄存器。</li><li>[0-9]v：32位VGPR寄存器，编号0-9。</li><li>[0-9]s：32位SGPR寄存器，编号0-9。</li></ul><p>所有ARM模式：</p><ul><li>Q，Um，Un，Uq，Us，Ut，Uv，Uy：内存地址的操作数。目前处理方式与操作数相同m。</li></ul><p>ARM和ARM的Thumb2模式：</p><ul><li>j：0到65535之间的一个立即数（有效MOVW）</li><li>I：对数据处理指令有效的立即整数。</li><li>J：一个介于-4095和4095之间的直接整数。</li><li>K：一个立即数，它的位反转对数据处理指令有效。（可以与模板修饰符“ B”一起使用以打印反转的值）。</li><li>L：一个立即整数，其否定对数据处理指令有效。（可以与模板修饰符“ n”一起使用以打印否定值）。</li><li>M：2的幂或0到32之间的整数。</li><li>N：无效的即时约束。</li><li>O：无效的即时约束。</li><li>r：一个通用的32位整数寄存器（r0-r15）。</li><li>l：在Thumb2模式下，低32位GPR寄存器（r0-r7）。在ARM模式下，与r。</li><li>h：在Thumb2模式下，一个高32位的GPR寄存器（r8-r15）。在ARM模式下，无效。</li><li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li><li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li><li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li></ul><p>ARM的Thumb1模式：</p><ul><li>I：0到255之间的立即数。</li><li>J：-255和-1之间的立即数。</li><li>K：0到255之间的直接整数，可选左移一定数量。</li><li>L：-7和7之间的立即数。</li><li>M：0到1020之间的整数，是4的倍数。</li><li>N：0到31之间的立即数。</li><li>O：在-508和508之间的立即数，是4的倍数。</li><li>r：一个低32位的GPR寄存器（r0-r7）。</li><li>l：一个低32位的GPR寄存器（r0-r7）。</li><li>h：高GPR寄存器（r0-r7）。</li><li>w：一个32，64或128位浮点/ SIMD寄存器：s0-s31， d0-d31，或q0-q15。</li><li>x：一个32，64或128位浮点/ SIMD寄存器：s0-s15， d0-d7，或q0-q3。</li><li>t：一个低浮点/ SIMD寄存器：s0-s31，d0-d16，或 q0-q8。</li></ul><p>Hexagon：</p><ul><li>o，v：此时存储器地址操作数，与约束一样对待m。</li><li>r：一个32位或64位寄存器。</li></ul><p>MSP430：</p><ul><li>r：一个8位或16位寄存器。</li></ul><p>MIPS：</p><ul><li>I：一个直接带符号的16位整数。</li><li>J：一个立即整数零。</li><li>K：一个直接无符号的16位整数。</li><li>L：一个直接的32位整数，其中低16位是0。</li><li>N：-65535和-1之间的立即数。</li><li>O：一个立即有符号的15位整数。</li><li>P：1到65535之间的立即数。</li><li>m：存储器地址操作数。在MIPS-SE模式下，允许一个基址寄存器加上16位立即数偏移量。在MIPS模式下，只需一个基址寄存器。</li><li>R：存储器地址操作数。在MIPS-SE模式下，允许一个基地址寄存器加上一个9位有符号偏移量。在MIPS模式下，与约束相同 m。</li><li>ZC：一个存储器地址操作数，适用于使用pref，ll或 sc在给定的子目标指令（细节有所不同）。</li><li>r，d， y：一个32位或64位GPR寄存器。</li><li>f：一个32位或64位FPU寄存器（F0-F31）或一个128位MSA寄存器（W0-W31）。在MSA寄存器的情况下，建议使用w 参数修饰符与GCC兼容。</li><li>c：适用于间接跳转（始终25）的32位或64位GPR寄存器 。</li><li>l：lo寄存器，32或64位。</li><li>x：无效。</li></ul><p>NVPTX：</p><ul><li>b：1位整数寄存器。</li><li>c或者h：一个16位整数寄存器。</li><li>r：一个32位整数寄存器。</li><li>l或者N：一个64位整数寄存器。</li><li>f：一个32位浮点寄存器。</li><li>d：一个64位的浮点寄存器。</li></ul><p>PowerPC的：</p><ul><li>I：一个直接带符号的16位整数。</li><li>J：直接无符号的16位整数，左移16位。</li><li>K：一个直接无符号的16位整数。</li><li>L：立即带符号的16位整数，左移16位。</li><li>M：大于31的立即数。</li><li>N：是2的精确幂的立即数。</li><li>O：立即整数常量0。</li><li>P：一个立即整型常量，其否定是一个有符号的16位常量。</li><li>es，o，Q，Z，Zy：一个存储器地址操作数，目前一样对待m。</li><li>r：32位或64位整数寄存器。</li><li>b：32位或64位整数寄存器，不包括R0（即 ：）R1-R31。</li><li>f：32位或64位浮点寄存器（F0-F31）或QPX使能时，128位或256位QPX寄存器（Q0-Q31;用于别名F寄存器）。</li><li>v：对于或类型，当启用QPX时，为128或256位QPX寄存器（），否则为128位altivec向量寄存器（）。4 x f324 x f64Q0-Q31V0-V31</li><li>y：条件寄存器（CR0-CR7）。</li><li>wc：CR寄存器中的单独CR位。</li><li>wa，wd，wf：任何128位VSX向量寄存器，从全VSX寄存器组（重叠两个浮点和向量寄存器文件）。</li><li>ws：来自完整的VSX寄存器组的32位或64位浮点寄存器。</li></ul><p>SPARC：</p><ul><li>I：一个立即的13位有符号整数。</li><li>r：一个32位整数寄存器。</li><li>f：SparcV8上的任何浮点寄存器或SparcV9上“低”一半寄存器中的浮点寄存器。</li><li>e：任何浮点寄存器。（与fSparcV8 相同。）</li></ul><p>SystemZ：</p><ul><li>I：直接无符号的8位整数。</li><li>J：直接无符号的12位整数。</li><li>K：一个直接带符号的16位整数。</li><li>L：一个直接签名的20位整数。</li><li>M：立即整数0x7fffffff。</li><li>Q：具有基地址和12位立即无符号位移的存储器地址操作数。</li><li>R：一个带有基地址的内存地址操作数，一个12位立即无符号位移和一个索引寄存器。</li><li>S：一个内存地址操作数，带有一个基址和一个20位立即带符号的位移。</li><li>T：一个带有基地址的内存地址操作数，一个20位立即带符号位移和一个索引寄存器。</li><li>r或者d：一个32位，64位或128位整数寄存器。</li><li>a：32,64或128位整数地址寄存器（不包括地址上下文中评估为0的R0）。</li><li>h：64位数据寄存器高位部分的32位值（LLVM专用）</li><li>f：一个32,64或128位浮点寄存器。</li></ul><p>X86：</p><ul><li>I：0到31之间的立即数。</li><li>J：0到64之间的立即数。</li><li>K：一个立即有符号的8位整数。</li><li>L：立即整数，0xff或0xffff或（仅在64位模式下）0xffffffff。</li><li>M：0到3之间的立即数。</li><li>N：直接无符号的8位整数。</li><li>O：0到127之间的立即数。</li><li>e：一个立即的32位有符号整数。</li><li>Z：一个立即的32位无符号整数。</li><li>o，v：目前处理方式与此相同m。</li><li>q：一个8,16,32或64位寄存器，可以作为8位 l整数寄存器访问。在X86-32，这是a，b，c，和d 寄存器，以及X86-64，它是所有的整数寄存器。</li><li>Q：一个8,16,32或64位寄存器，可以作为8位 h整数寄存器访问。这是a，b，c，和d寄存器。</li><li>r或者l：8,16,32或64位整数寄存器。</li><li>R：8,16,32或64位“传统”整数寄存器 - 自i386以来一直存在，并且可以在没有REX前缀的情况下访问。</li><li>f：一个32,64或80位’387 FPU堆栈伪寄存器。</li><li>y：如果启用MMX，则为64位MMX寄存器。</li><li>x：如果启用SSE：SSE寄存器中的32位或64位标量操作数或128位向量操作数。如果AVX也被使能，也可以是AVX寄存器中的256位向量操作数。如果AVX-512也被使能，也可以是AVX512寄存器中的512位向量操作数，否则会出错。</li><li>Y：同x，如果SSE2被启用，否则会出现错误。</li><li>A：特殊情况：首先为EAX分配EAX，然后再为EDX分配单个操作数（在32位模式下，64位整数操作数将分成两个寄存器）。不建议使用此约束，因为在64位模式下，64位操作数只会分配给RAX - 如果需要两个32位操作数，则最好在将其分配给它之前自行分割asm声明。</li></ul><p>XCore：</p><ul><li>r：一个32位整数寄存器。</li></ul><h3 id="Asm模板参数修饰符"><a href="#Asm模板参数修饰符" class="headerlink" title="Asm模板参数修饰符"></a>Asm模板参数修饰符</h3><p>在asm模板字符串中，可以在操作数引用上使用修饰符，如“<code>${0:n}</code>”。</p><p>一般来说，修饰符的行为与GCC中的相同。LLVM的支持通常是在’按需’的基础上实现的，以支持GCC支持的C inline代码。LLVM和GCC之间的行为不匹配可能表明LLVM存在错误。</p><p>目标无关的：</p><ul><li>c：不带目标特定的直接标点符号（例如无$前缀）打印一个立即的整数常量。</li><li>n：取消并打印立即数整数常量，不带目标特定的直接标点符号（例如无$前缀）。</li><li>l：打印为无标签的标签，没有特定于目标的标签标点（例如无$前缀）。</li></ul><p>AArch64：</p><ul><li>w：用w<em>名称而不是x</em>名称打印GPR寄存器。例如，而不是x30打印w30。</li><li>x：用x*名称打印GPR寄存器。（无论如何，这是默认的）。</li><li>b，h，s，d，q：打印浮点/ SIMD寄存器有 b<em>，h</em>，s<em>，d</em>，或q<em>名称，而不是默认的 v</em>。</li></ul><p>AMDGPU：</p><ul><li>r： 没有效果。</li></ul><p>ARM：</p><ul><li>a：打印操作数作为一个地址（[和]周围的寄存器）。</li><li>P： 没有效果。</li><li>q： 没有效果。</li><li>y：将VFP单精度寄存器作为索引双精度打印（例如打印d4[1]而不是s9）</li><li>B：按位反转并打印不带# 前缀的立即整数常量。</li><li>L：打印立即整数常量的低16位。</li><li>M：打印为适合ldm / stm的寄存器组。同时打印 指定的一个（！）后面的所有寄存器操作数，请谨慎使用。</li><li>Q：打印寄存器对的低位寄存器或双寄存器操作数的低位寄存器。</li><li>R：打印寄存器对的高位寄存器或双寄存器操作数的高位寄存器。</li><li>H：打印寄存器对的第二个寄存器。（在大端系统上， H相当于Q小端系统，H相当于R。）</li><li>e：打印NEON四路寄存器的低双字寄存器。</li><li>f：打印NEON四路寄存器的高位双字寄存器。</li><li>m：打印没有[和] 装饰的内存操作数的基址寄存器。</li></ul><p>Hexagon：</p><ul><li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li><li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li></ul><p>MSP430：</p><ul><li>没有额外的修饰符。</li></ul><p>MIPS：</p><ul><li>X：以十六进制形式打印一个立即数</li><li>x：以十六进制形式打印立即数的低16位。</li><li>d：以小数形式打印一个立即数。</li><li>m：减去一个并以十进制形式打印一个立即数。</li><li>z：如果立即为零，则打印$ 0，否则正常打印。</li><li>L：打印双寄存器操作数的低位寄存器，或打印双字存储器操作数的低位字的地址。</li><li>M：打印双寄存器操作数的高位寄存器，或者打印双字存储器操作数的高位字的地址。</li><li>D：打印双寄存器操作数的第二个寄存器，或打印双字存储器操作数的第二个字。（在大端系统上，D相当于L小端系统，D相当于 M。）</li><li>w： 没有效果。为了与需要此修饰符的GCC兼容才能打印W0-W31具有f 约束条件的MSA寄存器（）。</li></ul><p>NVPTX：</p><ul><li>r： 没有效果。</li></ul><p>PowerPC的：</p><ul><li>L：打印双寄存器操作数的第二个寄存器。要求它已被连续分配到第一个。</li><li>I：如果操作数是一个整数常量，则打印字母’i’，否则不打印。用于打印’addi’和’add’指令。</li><li>y：对于内存操作数，打印双寄存器X-form指令的格式化程序。（目前始终打印r0,OPERAND）。</li><li>U：如果内存操作数是更新形式，则打印’u’，否则不打印。（注意：LLVM不支持更新表单，所以它现在总是不会打印任何内容）</li><li>X：如果内存操作数是索引形式，则打印’x’。（注意：LLVM不支持索引形式，所以目前这总是不会打印任何东西）</li></ul><p>SPARC：</p><ul><li>r： 没有效果。</li></ul><p>SystemZ：</p><ul><li>SystemZ仅实现n，并且也不会支持任何其他目标无关的改性剂。</li></ul><p>X86：</p><ul><li>c：打印一个无用的整数或符号名称。（后者是这个典型的与目标无关的修饰符的目标特定行为）。</li><li>A：*在它之前用一个“ ‘ 打印一个注册名称。</li><li>b：打印一个8位寄存器名称（例如al）; 内存操作数不做任何事情。</li><li>h：打印上面的8位寄存器名称（例如ah）; 内存操作数不做任何事情。</li><li>w：打印16位寄存器名称（例如ax）; 内存操作数不做任何事情。</li><li>k：打印32位寄存器名称（例如eax）; 内存操作数不做任何事情。</li><li>q：打印64位寄存器名称（例如rax），如果64位寄存器可用，则返回32位寄存器名称; 内存操作数不做任何事情。</li><li>n：取反并打印一个未修饰的整数，或者，对于非立即整数的操作数（例如可重定位符号表达式），在操作数前面打印一个’ - ‘。（可重定位符号表达式的行为是针对此通常与目标无关的修饰符的目标特定行为）</li><li>H：用额外的偏移量+8打印存储器引用。</li><li>P：打印内存引用或操作数以用作调用指令的参数。（例如(rip)，即使它是PC相对的，也省略。）</li></ul><p>XCore：</p><ul><li>没有额外的修饰符。</li></ul><h3 id="内联Asm元数据"><a href="#内联Asm元数据" class="headerlink" title="内联Asm元数据"></a>内联Asm元数据</h3><p>包装内联asm节点的调用指令可能会附加一个“<code>!srcloc</code>”MDNode，它包含一个常量整数列表。如果存在，则当通过LLVMContext 错误报告机制报告错误时，代码生成器将使用该整数作为位置cookie值。这允许前端将内联asm中发生的后端错误与产生它的源代码关联起来。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call void asm sideeffect &quot;something bad&quot;, &quot;&quot;(), !srcloc !42</span><br><span class="line">...</span><br><span class="line">!42 = !&#123; i32 1234567 &#125;</span><br></pre></td></tr></table></figure><p></p><p>直到前端才能理解它在IR中的神奇数字。如果MDNode包含多个常量，则代码生成器将使用与发生错误的asm行相对应的那个常量。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM语言参考手册(开始至高级结构)</title>
      <link href="//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C(%E5%BC%80%E5%A7%8B%E8%87%B3%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%84).html"/>
      <url>//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C(%E5%BC%80%E5%A7%8B%E8%87%B3%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%84).html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文档是LLVM汇编语言的参考手册。LLVM是一种基于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlEJTk5JUU2JTgwJTgxJUU1JThEJTk1JUU4JUI1JThCJUU1JTgwJUJDJUU1JUJEJUEyJUU1JUJDJThG" title="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F">静态单赋值<i class="fa fa-external-link"></i></span>（SSA）的表现形式的语言。它提供类型安全、底层指令、灵活性以及干净地表示“所有”高级语言的能力。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><b style="color:green">LLVM代码表示被设计为以三种不同的形式使用：作为内存中编译器IR（中间码），作为磁盘上的位代码表示（适用于即时编译器进行快速加载）以及作为人可读汇编语言表达。这允许LLVM为有效的编译器的转换和分析提供强大的中间表示，同时提供调试和可视化转换的自然方式。LLVM的三种不同形式都是等价的。本文档描述了人类可读的表示形式和符号。</b></p><p>LLVM表示旨在轻量级和低级别，同时具有表现力，类型化和可扩展性。它的目标是成为一种“通用的IR”，通过处于足够低的水平，可以将高层次的想法清晰地映射到它（类似于微处理器是“通用IR”），允许将许多源语言映射到它们）。通过提供类型信息，LLVM可以用作优化的目标：例如，通过指针分析，可以证明C自动变量从不在当前函数之外访问，从而允许将它提升为简单的SSA值而不是一个内存位置。</p><h2 id="良好的格式"><a href="#良好的格式" class="headerlink" title="良好的格式"></a>良好的格式</h2><p>重要的是要注意，本文档描述了“良好格式”的LLVM汇编语言。 解析器接受什么和被认为是“良好格式”之间是有区别。例如，下面的指令在语法上没问题，但不是良好形式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%x = add i32 1, %x</span><br></pre></td></tr></table></figure><p></p><p>因为<code>％x</code>的定义并不控制它的所有用途。 LLVM基础架构提供了一个验证过程，可用于验证LLVM模块是否格式良好。在解析输入的汇编程序之后和优化程序在输出bitcode之前，该过程由解析器自动运行。验证程序验证过程中指出的违规暗示转换过程中的错误或输入到解析器中的错误。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>LLVM标识符有两种基本类型：全局和本地。全局标识符（函数，全局变量）以<code>&#39;@&#39;</code>字符开头。本地标识符（寄存器名称，类型）以<code>&#39;%&#39;</code>字符开头 。此外，有三种不同的标识符格式，用于不同的目的：</p><ol><li>命名值用一串字符和前缀表示。例如<code>%foo</code>，<code>@DivisionByZero</code>， <code>%a.really.long.identifier</code>。实际使用的正则表达式是 <code>&#39;[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*&#39;</code>。在名称中需要其他字符的标识符可以用引号包裹起来。通过使用<code>&quot;\xx&quot;</code>，特殊字符可以被转义，<code>xx</code>是ASCII代码的十六进制字符的表示。这样，任何字符都可以用于名称值，甚至可以引用它们自己。全局变量可以使用前缀”\01”来阻止截断。</li><li>未命名的值用前缀表示为无符号数值。例如<code>%12</code>，<code>@2</code>，<code>%44</code>。</li><li>常量，在下面的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2NvbnN0YW50cw==" title="http://llvm.org/docs/LangRef.html#constants">常量<i class="fa fa-external-link"></i></span>章节中进行了介绍。</li></ol><p>LLVM要求值以一个前缀开始，原因有两个：编译器不需要担心名称与保留字的冲突，并且保留字的集合可能在将来被扩展而不会产生什么不利。此外，未命名标识符允许编译器快速创建临时变量，而不必设法避免符号表冲突。</p><p>LLVM中的保留字与其他语言中的保留字非常相似。对于不同的操作码（<code>&#39;add&#39;</code>，<code>&#39;bitcast&#39;</code>，<code>&#39;ret&#39;</code>等等），对于原始类型名称（<code>&#39;void&#39;</code>，<code>&#39;i32&#39;</code>等等），以及其他的关键字。这些保留字不能与变量名冲突，因为它们都没有以前缀字符（<code>&#39;%&#39;</code>或<code>&#39;@&#39;</code>）开始。</p><p>以下是将整数变量“%X’乘以8的LLVM代码示例：<br>简单的方式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = mul i32 %X, 8</span><br></pre></td></tr></table></figure><p></p><p>减少强度之后（也是最推荐的方式）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%result = shl i32 %X, 3</span><br></pre></td></tr></table></figure><p></p><p>最复杂的方式是(很有意思)：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = add i32 %X, %X           ; yields i32:%0</span><br><span class="line">%1 = add i32 %0, %0           ; yields i32:%1</span><br><span class="line">%result = add i32 %1, %1</span><br></pre></td></tr></table></figure><p></p><p><code>%X</code>乘以8的最后一种方式说明了LLVM的几个重要的词法特征：</p><ol><li>注释用分号<code>&#39;;&#39;</code>分隔，直到行尾。</li><li>当计算结果未分配给指定命名值时，将创建未命名的临时对象。</li><li>未命名的临时对象按序号进行编号（使用预处理函数递增计数器，从0开始）。<b style="color:green">请注意，此编号中包含基本块和未命名的函数参数。例如，如果基本块入口没有给出标签名称并且所有函数参数都被命名，则它将得到编号0。</b></li></ol><p>它也显示了我们在本文件中遵循的惯例。在展示说明时，我们将按照说明书的注释来说明所产生值的类型和名称。</p><h2 id="高级结构"><a href="#高级结构" class="headerlink" title="高级结构"></a>高级结构</h2><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>LLVM程序由<code>Module&#39;s</code>组成，每个模块都是输入程序的翻译单元。每个模块由函数，全局变量和符号表入口（symbol table entries）组成。模块可以与LLVM链接器组合在一起，LLVM链接器合并函数（和全局变量）定义，解析前置声明并合并符号表入口。以下是“hello world”模块的示例：<br></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Declare the string constant as a global constant.</span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; External declaration of the puts function</span></span><br><span class="line"><span class="comment">declare i32 @puts(i8* nocapture) nounwind</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Definition of main function</span></span><br><span class="line"><span class="comment">define i32 @main() &#123;   ; i32()*</span></span><br><span class="line"><span class="comment">  ; Convert [13 x i8]* to i8*...</span></span><br><span class="line"><span class="comment">  %cast210 = getelementptr [13 x i8], [13 x i8]* @.str, i64 0, i64 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ; Call puts function to write out the string to stdout.</span></span><br><span class="line"><span class="comment">  call i32 @puts(i8* %cast210)</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Named metadata</span></span><br><span class="line"><span class="comment">!0 = !&#123;i32 42, null, !"string"&#125;</span></span><br><span class="line"><span class="comment">!foo = !&#123;!0&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>这个例子由一个名为<code>.str</code>的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2dsb2JhbHZhcnM=" title="http://llvm.org/docs/LangRef.html#globalvars">全局变量<i class="fa fa-external-link"></i></span>，<code>“puts”</code>函数的外部声明，<code>&quot;main&quot;</code>的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2Z1bmN0aW9uc3RydWN0dXJl" title="http://llvm.org/docs/LangRef.html#functionstructure">函数定义<i class="fa fa-external-link"></i></span>和<code>”foo“</code>的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI25hbWVkbWV0YWRhdGFzdHJ1Y3R1cmU=" title="http://llvm.org/docs/LangRef.html#namedmetadatastructure">命名元数据<i class="fa fa-external-link"></i></span>组成。</p><p><b style="color:green">通常，模块由全局值列表组成（其中函数和全局变量都是全局值）。全局值由指向内存位置的指针表示（在本例中，指向char数组的指针和指向函数的指针），并且具有以下<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xpbmthZ2U=" title="http://llvm.org/docs/LangRef.html#linkage">链接类型<i class="fa fa-external-link"></i></span>之一。</b></p><h3 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a><span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtY24vbGlicmFyeS8weXc2YXQ4ZS5hc3B4" title="https://msdn.microsoft.com/zh-cn/library/0yw6at8e.aspx">链接类型<i class="fa fa-external-link"></i></span></h3><p>所有全局变量和函数都具有以下链接类型之一：</p><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>具有<code>“private”</code>连接的全局值只能由当前模块中的对象直接访问。特别是，将代码链接到具有private全局值的模块中可能会导致private变量重新命名以避免冲突。由于符号对模块是私有的，因此所有引用都可以更新。这不会在对象文件的任何符号表中显示。</p><h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>与私有类似，但该值在对象文件中显示为本地符号（STB_LOCAL在ELF的情况下）。这就像<code>C</code>中的<code>&#39;static&#39;</code>关键字。</p><h4 id="available-externally"><a href="#available-externally" class="headerlink" title="available_externally"></a>available_externally</h4><p>具有<code>“available_externally”</code>链接的全局程序永远不会被发送到对应于LLVM模块的目标文件中。从链接器的角度来看，<code>available_externally</code>全局相当于external声明。它们的存在是为了允许内联和其他优化在知道全局变量（函数或语句块）的定义的情况下发生，这被称为模块之外的某个地方。具有<code>available_externally</code>链接的全局值可以随意丢弃，并允许内联和其他优化。这种连接类型只允许定义，而不允许声明。</p><h4 id="linkonce"><a href="#linkonce" class="headerlink" title="linkonce"></a>linkonce</h4><p><code>linkonce</code>连接的全局值在链接发生时，可以与其他同名的全局值合。这可以用来实现某些形式的内联函数，模板（templates）或其他代码，这些代码必须在使用它的每个翻译单元中生成，但是稍后可能会在更明确的定义中覆盖正文。未引用的<code>linkonce</code>全局变量允许被丢弃。请注意，<code>linkonce</code>链接实际上并不允许优化器将此函数的主体内联到调用者中，因为它不知道该函数的定义是否是程序中的权威定义，或者是否会被更强的定义覆盖。要启用内联和其他优化器，请使用<code>“linkonce_odr”</code>链接。</p><h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><p><code>“weak”</code>链接具有与<code>linkonce</code>链接相同的合并语义，除了未引用<code>weak</code>链接的全局可能不会被丢弃。这用于在C源代码中声明为<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9oZ2ZyemgvcC80MDY0MDk4Lmh0bWw=" title="http://www.cnblogs.com/hgfrzh/p/4064098.html"><code>weak</code><i class="fa fa-external-link"></i></span>的全局变量。</p><h4 id="common"><a href="#common" class="headerlink" title="common"></a>common</h4><p><code>common</code>连接与<code>weak</code>连接最为相似，但它们用于C中的临时定义，例如：全局作用域的<code>int x</code>。带有<code>common</code>连接的符号与<code>weak</code>是相同的方式合并；如果未引用<code>common</code>符号，它们可能不会被删除。<code>common</code>符号可能没有明确的部分，必须具有零初始化器，并且可能未被标记为“<code>constant</code>”。函数和别名可能没有共同的连接。</p><h4 id="appending"><a href="#appending" class="headerlink" title="appending"></a>appending</h4><p>“<code>appending</code>”链接可能只适用于指向数组类型的全局变量。当两个具有appending链接的全局变量链接在一起时，这两个全局数组被附加在一起。这是LLVM类型安全的，当<code>.o</code>文件被链接时，系统链接器将具有相同的名称的<code>“sections”</code>附加在一起。</p><p>不幸的是，这不符合<code>.o</code>文件中的任何特性，所以它只能用于像<code>llvm.global_ctors</code>的变量，<code>llvm</code>专门解释这样的变量。</p><h4 id="extern-weak"><a href="#extern-weak" class="headerlink" title="extern_weak"></a>extern_weak</h4><p>这个链接的语义遵循<code>ELF</code>目标文件模型：符号在链接之前是弱的，如果不链接，符号变为空，而不是未定义的引用。</p><h4 id="linkonce-odr，-weak-odr"><a href="#linkonce-odr，-weak-odr" class="headerlink" title="linkonce_odr， weak_odr"></a><code>linkonce_odr</code>， <code>weak_odr</code></h4><p>有些语言允许合并不同的全局变量，比如两个具有不同语义的函数。其他语言，例如C++，确保只有等效的全局变量被合并（“一个定义规则(one definition rule)” - “ODR”）。这些语言可以使用<code>linkonce_odr</code>和<code>weak_odr</code>连接类型来表示全局将仅与等效的全局变量合并。对于其他不支持<code>ODR</code>的语言，这些链接类型与其<code>非odr</code>的链接相同。</p><h4 id="external"><a href="#external" class="headerlink" title="external"></a>external</h4><p>如果没有使用上述标识符，则全局变量是外部可见的，这意味着它参与链接并可用于解析外部符号引用。</p><p><b style="color:red">对于函数声明，除<code>external</code>或<code>extern_weak</code>之外的任何链接类型都是非法的。</b></p><h3 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUIwJTgzJUU3JTk0JUE4JUU3JUJBJUE2JUU1JUFFJTlB" title="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">调用约定<i class="fa fa-external-link"></i></span></h3><p>LLVM<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2Z1bmN0aW9uc3RydWN0dXJl" title="http://llvm.org/docs/LangRef.html#functionstructure">函数(functions)<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktY2FsbA==" title="http://llvm.org/docs/LangRef.html#i-call">调用(calls)<i class="fa fa-external-link"></i></span>和 <span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktaW52b2tl" title="http://llvm.org/docs/LangRef.html#i-invoke">调用(invokes)<i class="fa fa-external-link"></i></span>都可以为该调用指定一个可选的调用约定。任何一对动态<code>调用者(caller)/被调用者(callee)</code>的调用约定都必须匹配，否则程序的行为是未定义的。<b style="color:green">LLVM支持以下调用约定，未来还可能添加更多调用约定：</b></p><h4 id="ccc-C调用约定"><a href="#ccc-C调用约定" class="headerlink" title="ccc - C调用约定"></a><code>ccc</code> - <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseTJrNS9hcnRpY2xlL2RldGFpbHMvNTQ0MTEy" title="https://blog.csdn.net/fly2k5/article/details/544112">C调用约定<i class="fa fa-external-link"></i></span></h4><p>这个调用约定（如果没有指定其他调用约定，则默认是这个调用约定）匹配目标C调用约定。这个调用约定支持可变参数函数调用，并且允许在声明的原型和实现的函数声明中存在一些不匹配（就像普通的C一样）。</p><h4 id="“fastcc”-快速调用约定"><a href="#“fastcc”-快速调用约定" class="headerlink" title="“fastcc” - 快速调用约定"></a>“<code>fastcc</code>” - 快速调用约定</h4><p>这个调用约定试图尽可能快地进行调用（例如通过在寄存器中传递参数）。这个调用约定允许目标使用任何想要为目标生成快速代码的技巧，而不必遵守外部指定的<code>ABI</code>（应用程序二进制接口）。<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29kZUdlbmVyYXRvci5odG1sI2lkODA=" title="http://llvm.org/docs/CodeGenerator.html#id80">只有在使用此调用约定、<code>GHC</code>调用约定或<code>HiPE</code>调用约定时，才能<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener"><b style="color:red">优化尾部调用</b></a><i class="fa fa-external-link"></i></span>。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。</p><h4 id="“coldcc”-冷调用约定"><a href="#“coldcc”-冷调用约定" class="headerlink" title="“coldcc” - 冷调用约定"></a>“<code>coldcc</code>” - 冷调用约定</h4><p>这个调用约定尝试在调用不是共同执行的条件下尽可能高效地在调用者中编写代码。因此，这些调用通常会保留所有的寄存器，以便调用不会破坏调用方的任何实时范围（live range）。此调用约定不支持可变参数，并要求所有被调用者的原型与函数定义的原型完全匹配。此外，内联器不考虑这种内联函数调用。</p><h4 id="“cc-10”-GHC约定"><a href="#“cc-10”-GHC约定" class="headerlink" title="“cc 10” - GHC约定"></a>“<code>cc 10</code>” - <code>GHC</code>约定</h4><p>这个调用约定专门供<span class="exturl" data-url="aHR0cDovL3d3dy5oYXNrZWxsLm9yZy9naGM=" title="http://www.haskell.org/ghc">格拉斯哥Haskell编译器（GHC）<i class="fa fa-external-link"></i></span>使用。它在寄存器中的传递所有内容，通过禁用被调用者保存寄存器来达到极限。这种调用约定不应该被轻率使用，而只能用于特定情况下，例如替代实现函数式编程语言时经常使用的寄存器锁定性能技术。目前只有X86支持这种约定，它有以下限制：</p><ul><li>在X86-32上最多只支持4位类型参数。不支持浮点类型。</li><li>在X86-64上最多只支持10位类型参数和6个浮点参数。</li></ul><p>这种调用约定支持<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMDQvdGFpbC1jYWxsLmh0bWw=" title="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部调用优化<i class="fa fa-external-link"></i></span>，但要求主调方和被调方都在使用它。</p><h4 id="“cc-11”-HiPE调用约定"><a href="#“cc-11”-HiPE调用约定" class="headerlink" title="“cc 11” - HiPE调用约定"></a>“<code>cc 11</code>” - <code>HiPE</code>调用约定</h4><p>该调用约定专门用于<span class="exturl" data-url="aHR0cDovL3d3dy5pdC51dS5zZS9yZXNlYXJjaC9ncm91cC9oaXBlLw==" title="http://www.it.uu.se/research/group/hipe/">高性能Erlang（HiPE）<i class="fa fa-external-link"></i></span>编译器，即<span class="exturl" data-url="aHR0cDovL3d3dy5lcmxhbmcub3JnL2Rvd25sb2FkLnNodG1s" title="http://www.erlang.org/download.shtml">爱立信开源Erlang/OTP系统<i class="fa fa-external-link"></i></span>的本地代码编译器。它比通常的C调用约定使用更多的寄存器进行参数传递，并且不定义被调者使用的保存寄存器。调用约定正确支持<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMDQvdGFpbC1jYWxsLmh0bWw=" title="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾部调用优化<i class="fa fa-external-link"></i></span>，但要求调用者和被调用者都使用它。它使用寄存器固定机制，与<code>GHC</code>调用约定类似，用于将频繁访问的运行时组件固定到特定的硬件寄存器。目前只有X86支持这种约定（32位和64位）。</p><h4 id="“webkit-jscc”-WebKit的JavaScript调用约定"><a href="#“webkit-jscc”-WebKit的JavaScript调用约定" class="headerlink" title="“webkit_jscc” - WebKit的JavaScript调用约定"></a>“<code>webkit_jscc</code>” - WebKit的JavaScript调用约定</h4><p>此调用约定已针对<span class="exturl" data-url="aHR0cHM6Ly90cmFjLndlYmtpdC5vcmcvd2lraS9GVExKSVQ=" title="https://trac.webkit.org/wiki/FTLJIT">WebKit FTL JIT<i class="fa fa-external-link"></i></span>实施。它将堆栈上的参数从右向左传递（如<code>cdecl</code>那样），并在平台的惯用返回寄存器中返回一个值。</p><h4 id="“anyregcc”-代码修补的动态调用约定"><a href="#“anyregcc”-代码修补的动态调用约定" class="headerlink" title="“anyregcc” - 代码修补的动态调用约定"></a>“<code>anyregcc</code>” - 代码修补的动态调用约定</h4><p>这是一个特殊的约定，它支持在调用点增补任意代码序列。这个约定强制调用参数进入寄存器，但允许它们动态分配。目前只能用于调用<code>llvm.experimental.patchpoint</code>，因为只有这个内部函数将其参数的位置记录在旁边表中。请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvU3RhY2tNYXBzLmh0bWw=" title="http://llvm.org/docs/StackMaps.html">LLVM中的堆栈映射和修补程序点<i class="fa fa-external-link"></i></span>。</p><h4 id="“preserve-mostcc”-PreserveMost调用约定"><a href="#“preserve-mostcc”-PreserveMost调用约定" class="headerlink" title="“preserve_mostcc” - PreserveMost调用约定"></a>“<code>preserve_mostcc</code>” - <code>PreserveMost</code>调用约定</h4><p>此调用约定会尽可能使调用方中的代码尽可能是非侵入性的。该约定的行为与C 调用约定的参数和返回值的传递方式相同，但它使用了一组不同的调用方/被调用方保存的寄存器。<b style="color:green">这减轻了在调用者调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</b></p><ul><li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。浮点寄存器（<code>XMMs/YMMs</code>）不会保留，需要由调用者保存。</li></ul><p>这个约定背后的想法是支持对具有热路径和冷路径的运行时（Runtime）函数调用。<b style="color:green">热路径通常是一小段不使用多个寄存器的代码。冷路径可能需要调用另一个函数，因此只需要保留调用者保存的寄存器，这些寄存器还未被调用者保存</b>。就调用者/被调用者保存的寄存器方面，<code>PreserveMost</code>调用约定是与冷（cold）调用约定非常相似的，但它们用于不同类型的函数调用。<code>coldcc</code>适用于很少执行的函数调用，而<code>preserve_mostcc</code>函数调用旨在处于热路径上，并且相对执行更多一些。此外<code>preserve_mostcc</code>不会阻止内联器的内联函数调用。</p><p>这个调用约定将被未来版本的ObjectiveC运行时使用，因此此时应该仍被认为是实验性的。虽然此惯例是为了优化对ObjectiveC运行时的某些运行时调用而创建的，但它并不局限于此运行时，并且在将来也可能会被其他运行时使用。目前的实现只支持X86-64，但其目的是在未来支持更多架构。</p><h4 id="“preserve-allcc”-PreserveAll调用约定"><a href="#“preserve-allcc”-PreserveAll调用约定" class="headerlink" title="“preserve_allcc” - PreserveAll调用约定"></a>“<code>preserve_allcc</code>” - <code>PreserveAll</code>调用约定</h4><p>此调用约定会尝试使调用方中的代码比<code>PreserveMost</code>调用约定更不具侵入性。此调用约定的行为与C调用约定的参数和返回值的传递方式相同，但它使用一组不同的调用方/被调用方保存的寄存器。这消除了在调用者的调用之前和之后保存和恢复大型寄存器组的负担。如果参数在被调用方保存的寄存器中传递，那么它们将在整个调用过程中由被调用方保存。这不适用于在被调用方保存的寄存器中返回的值。</p><ul><li>在X86-64上，被调用方保存所有通用寄存器，<code>R11</code>除外。<code>R11</code>可以用作临时寄存器。此外，它还保留所有浮点寄存器（<code>XMM/YMM</code>）。</li></ul><p>这个约定背后的想法是支持对不需要调用任何其他函数的运行时(Runtime)函数的调用。</p><p>此调用约定与<code>PreserveMost</code>调用约定一样，将被未来版本的ObjectiveC运行时使用，此时应视为实验性的。</p><h4 id="“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定"><a href="#“cxx-fast-tlscc”-访问函数的CXX-FAST-TLS调用约定" class="headerlink" title="“cxx_fast_tlscc” - 访问函数的CXX_FAST_TLS调用约定"></a>“<code>cxx_fast_tlscc</code>” - 访问函数的<code>CXX_FAST_TLS</code>调用约定</h4><p>Clang生成一个访问函数来访问C++风格的TLS。访问函数通常有一个入口块，一个出口块和一个初次运行的初始化块。入口和出口块可以访问一些TLS IR变量，每个访问将被降低到平台特定的序列。</p><p>此调用约定旨在通过保留尽可能多的寄存器（所有寄存器保存在快速路径中，由入口和出口块组成）来尽量减少调用者的开销。</p><p>这个调用约定的行为与C调用约定在参数和返回值的传递方式上是一样的，但它使用了一组不同的调用者/被调用者保存的寄存器。</p><p>鉴于每个平台都有自己的降序序列，因此它有自己的一组保存的寄存器，所以我们不能使用现有的<code>PreserveMost</code>。</p><ul><li>在X86-64上，被调用方保存所有通用寄存器，<code>RDI</code>和<code>RAX</code>除外。</li></ul><h4 id="“swiftcc”-这个调用约定用于Swift语言。"><a href="#“swiftcc”-这个调用约定用于Swift语言。" class="headerlink" title="“swiftcc” - 这个调用约定用于Swift语言。"></a>“<code>swiftcc</code>” - 这个调用约定用于Swift语言。</h4><ul><li>在X86-64上，<code>RCX</code>和<code>R8</code>可用于额外的整数返回，并且<code>XMM2</code>和<code>XMM3</code>可用于其他<code>FP/vector</code>返回。</li><li>在iOS平台上，我们使用<code>AAPCS-VFP</code>调用约定。<br>“<code>cc &lt;n&gt;</code>” - 编号调用约定<br>任何调用约定都可以用数字指定，从而允许使用特定于目标的调用约定。目标特定调用约定从64开始。</li></ul><p>可以根据需要添加/定义更多调用约定，以支持<code>Pascal</code>约定或任何其他众所周知的目标独立的调用约定。</p><h3 id="可见性风格"><a href="#可见性风格" class="headerlink" title="可见性风格"></a>可见性风格</h3><p>所有全局变量和函数都具有以下可见性样式之一：</p><h4 id="“default”-默认风格"><a href="#“default”-默认风格" class="headerlink" title="“default” - 默认风格"></a>“<code>default</code>” - 默认风格</h4><p>在使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veG1waG9lbml4L2FyY2hpdmUvMjAxMS8xMC8yMy8yMjIxODc5Lmh0bWw=" title="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html">ELF（Executable and Linking Format,可执行文件）<i class="fa fa-external-link"></i></span>对象文件格式的目标上，默认可见性意味着该声明对其他模块可见，并且在共享库中，意味着声明的实体可能被覆盖。在Darwin上，default可见性意味着该声明对其他模块可见。default可见性对应于语言中的“外部链接”。</p><h4 id="“hidden”-隐藏的风格"><a href="#“hidden”-隐藏的风格" class="headerlink" title="“hidden” - 隐藏的风格"></a>“<code>hidden</code>” - 隐藏的风格</h4><p>具有隐藏可见性的对象的两个声明指向同一个对象，如果它们在同一个共享对象中。通常，隐藏的可见性表示该符号不会被放入动态符号表中，因此其他模块（可执行文件或共享库）不能直接引用它。</p><h4 id="“protected”-受保护的风格"><a href="#“protected”-受保护的风格" class="headerlink" title="“protected” - 受保护的风格"></a>“<code>protected</code>” - 受保护的风格</h4><p>在<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veG1waG9lbml4L2FyY2hpdmUvMjAxMS8xMC8yMy8yMjIxODc5Lmh0bWw=" title="https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html">ELF<i class="fa fa-external-link"></i></span>上，protected可见性表示该符号将被放置在动态符号表中，但定义的模块内的引用将绑定到本地符号。也就是说，该符号不能被另一个模块覆盖。</p><p>带有<code>internal</code>或<code>private</code>链接类型的符号必须具有<code>default</code>可见性。</p><h3 id="DLL存储类"><a href="#DLL存储类" class="headerlink" title="DLL存储类"></a>DLL<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUQlOTglRTUlODIlQTglRTclQjElQkIvMTA0MjAwNzI=" title="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B1%BB/10420072">存储类<i class="fa fa-external-link"></i></span></h3><p>所有全局变量，函数和别名都可以具有以下DLL存储类之一：</p><h4 id="dllimport"><a href="#dllimport" class="headerlink" title="dllimport"></a><span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtY24vbGlicmFyeS8xNnlhNXhhZS5hc3B4" title="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx"><code>dllimport</code><i class="fa fa-external-link"></i></span></h4><p>“<code>dllimport</code>”会导致编译器通过全局指针引用函数或变量，该全局指针指向由导出符号的DLL设置的指针。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。</p><h4 id="dllexport"><a href="#dllexport" class="headerlink" title="dllexport"></a><span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtY24vbGlicmFyeS8xNnlhNXhhZS5hc3B4" title="https://msdn.microsoft.com/zh-cn/library/16ya5xae.aspx"><code>dllexport</code><i class="fa fa-external-link"></i></span></h4><p>“<code>dllexport</code>”会导致编译器提供一个指向DLL中的指针的全局指针，以便它可以引用<code>dllimport</code>属性。在Microsoft Windows目标上，指针名称由<code>__imp_</code>和函数或变量名称组成。由于这个存储类是为了定义dll接口而存在，因此编译器，汇编器和链接器知道它是从外部引用的，并且不会删除该符号。</p><p>其实这个指令是用来加载动态链接库，相关的信息可以查看：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU4NjAyMy9kbGxpbXBvcnQtZG9lc250LXdvcmstYXMtYWR2ZXJ0aXNlZC1pbi1tb25vLWxpbnV4LWM=" title="https://stackoverflow.com/questions/3586023/dllimport-doesnt-work-as-advertised-in-mono-linux-c">DllImport doesn’t work as advertised in Mono (Linux, C#)<i class="fa fa-external-link"></i></span></p><h3 id="线程局部存储-TLS-模型"><a href="#线程局部存储-TLS-模型" class="headerlink" title="线程局部存储(TLS)模型"></a>线程局部存储(TLS)模型</h3><p><b style="color:green">一个变量可以被定义为<span class="exturl" data-url="aHR0cDovL3poLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2Uvc3RvcmFnZV9kdXJhdGlvbg==" title="http://zh.cppreference.com/w/cpp/language/storage_duration"><code>thread_local</code><i class="fa fa-external-link"></i></span>，这意味着它不会被线程共享（每个线程将有一个变量的分离副本）</b>。并非所有的目标机都支持线程局部变量。可选地，可以指定<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vY2QvRTE5MjUzLTAxLzgxOS03MDUwLzZuOTE4ajhvMC9pbmRleC5odG1s" title="https://docs.oracle.com/cd/E19253-01/819-7050/6n918j8o0/index.html">TLS模型<i class="fa fa-external-link"></i></span>：</p><ul><li><code>localdynamic</code>: 对于仅在当前共享库中使用的变量。</li><li><code>initialexec</code>: 对于模块中不会动态加载的变量。</li><li><code>localexec</code>: 对于在可执行文件中定义的变量，只能在其中使用。</li></ul><p>如果没有给出显式模型，则使用“general dynamic”模型。</p><p>这些模型对应于ELF TLS模型; 请参阅<span class="exturl" data-url="aHR0cDovL3Blb3BsZS5yZWRoYXQuY29tL2RyZXBwZXIvdGxzLnBkZg==" title="http://people.redhat.com/drepper/tls.pdf">ELF对thread_local存储的处理<i class="fa fa-external-link"></i></span>获取更多信息，在这篇文章中提到的不同的场景下可能使用不同的模型。如果指定的TLS模型不受支持，或者可以选择一个更好的模型，则目标机可能会选择不同的TLS模型。</p><p>模型也可以在别名中指定，但它只能控制别名的访问方式。这对使用别名的地方不会有任何影响。</p><p>对于没有ELF TLS模型链接器支持的平台，<code>-femulated-tls</code>标志可用于生成GCC兼容的模拟TLS代码。</p><h3 id="运行时抢占说明"><a href="#运行时抢占说明" class="headerlink" title="运行时抢占说明"></a>运行时抢占说明</h3><p>全局变量，函数和别名可以有一个可选的运行时抢占说明符。如果没有明确给出抢先说明符，则假定符号是<code>dso_preemptable</code>。</p><h4 id="dso-preemptable"><a href="#dso-preemptable" class="headerlink" title="dso_preemptable"></a><code>dso_preemptable</code></h4><p>表示在运行时，可以用链接单元外部的符号替换该函数或变量。</p><h4 id="dso-local"><a href="#dso-local" class="headerlink" title="dso_local"></a><code>dso_local</code></h4><p>编译器可以假定标记为<code>dso_local</code>的函数或变量将解析为相同链接单元中的符号。即使定义不在此编译单元中，也会生成直接访问。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>LLVM IR（中间码）允许您指定“可识别（identified）”和“文字（Literal）”<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Qtc3RydWN0" title="http://llvm.org/docs/LangRef.html#t-struct">结构类型<i class="fa fa-external-link"></i></span>。文字类型在结构上是独一无二的，但是identified类型从来都不是独一无二的。一个<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Qtb3BhcXVl" title="http://llvm.org/docs/LangRef.html#t-opaque">不透明的结构类型<i class="fa fa-external-link"></i></span>也可以用来向前声明一个还不能使用的类型。</p><p>identified（可识别的）结构规范的一个例子是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%mytype = type &#123; %mytype*, i32 &#125;</span><br></pre></td></tr></table></figure><p></p><p>在LLVM 3.0发布之前，identified类型在结构上是独一无二的。在最新版本的LLVM中，只有文字类型是唯一的。</p><h3 id="非整型指针类型"><a href="#非整型指针类型" class="headerlink" title="非整型指针类型"></a>非整型指针类型</h3><p>注意：非整型指针类型是正在进行的工作，并且此时它们应该被认为是实验性的。</p><p>LLVM IR可选地允许前端通过<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xhbmdyZWYtZGF0YWxheW91dA==" title="http://llvm.org/docs/LangRef.html#langref-datalayout">数据布局字符串<i class="fa fa-external-link"></i></span>将某些地址空间中的指针表示为“非整数” 。非整型指针类型表示具有未指定的按位表示的指针; 也就是说，完整性表示可能是目标机相关的或不稳定（不由固定整数支持）。</p><p><code>inttoptr</code>指令将整数转换为非整型指针类型的ptrtoint指令是错误类型(ill-typed)的，<code>ptrtoint</code>指令将非整型指针类型的值转换为整数。所述指令的矢量版本也是不正确的(ill-typed)。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量定义了编译时分配的内存区域，而不是运行期。</p><p>全局变量定义必须被初始化。</p><p>其他编译单元中的全局变量也可以声明，在这种情况下，它们没有初始化程序。</p><p>无论是全局变量定义还是声明都可以有一个显式的部分放在里面，并且可以有一个可选的显式对齐。如果变量声明的显式或推断区段信息与其定义之间存在不匹配，则结果行为未定义。</p><p>一个变量可以被定义为一个全局<code>constant</code>，它表示变量的内容永远不会被修改（开启更好的优化，允许全局数据被放置在可执行文件的只读部分等）。请注意，需要运行时初始化的变量不能标记<code>constant</code>,因为变量在存储区中。</p><p>LLVM明确允许将全局变量的声明标记为常量，即使全局变量的定义中没有指定。此功能可用于对程序进行稍微更好的优化，但需要语言定义以保证基于“constantness”的优化对于在定义中不包含<code>constant</code>的编译单元有效。</p><p>作为SSA（静态单赋值）值，全局变量定义了程序中所有基本块的范围内的指针值（即它们是可控的）。全局变量总是定义一个指向其“内容”类型的指针，因为它们描述了一个内存区域，并且LLVM中的所有内存对象都是通过指针访问的。</p><p>全局变量可以用<code>unnamed_addr</code>来标记，表示地址不重要，只有内容。如果它们具有相同的初始化程序，标记为<code>unnamed_addr</code>的常量可以与其他常量合并。请注意，一个具有显着地址的常量可以与一个<code>unnamed_addr</code>常量合并，结果是一个地址明确的(significant)常量。</p><p>如果给出<code>local_unnamed_addr</code>属性，则这个属性的地址在模块内是不明确的。</p><p>全局变量可能被声明为驻留在特定目标机的编号地址空间中。对于支持它们的目标机，地址空间可能会影响优化的执行方式，可能也会影响使用什么目标机指令访问变量。默认地址空间为零。地址空间限定符必须在任何其他属性之前。</p><p>LLVM允许为全局指定显式部分（section）。如果目标机支持它，它会将globals发送到指定的section。此外，如果目标机有必要的支持，全局变量可以放在一个comdat中。</p><p>外部声明可能有明确的section指定。对于使用此信息的目标机器，section信息保留在LLVM IR中。将section信息附加到外部声明是一个断言，其定义位于指定的section。如果定义位于不同的section，则行为是未定义的。</p><p>默认情况下，全局初始化器通过假设在全局初始化器开始之前在模块内定义的全局变量未从其初始值修改而得到优化。即使对于可能从模块外部访问的变量（包括具有外部链接的或者出现在<code>@llvm.used</code>或<code>dllexported</code>中的变量）也是如此。这个假设可以通过将变量标记为<code>externally_initialized</code>来消除。</p><p>可以为全局变量指定明确的<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9iYWthcmkvYXJjaGl2ZS8yMDEyLzEwLzIzLzI3MzQ3NzIuaHRtbA==" title="http://www.cnblogs.com/bakari/archive/2012/10/23/2734772.html">对齐方式<i class="fa fa-external-link"></i></span>，它必须是2的幂。如果不存在，或者如果对齐方式设置为零，则全局对齐由目标机器设置为任何方便的方式。如果指定了明确的对齐，则全局被强制完全按照指定的对齐方式。如果全局变量具有分配的section，则不允许目标机和优化器过度对齐（over-align）全局变量。在这种情况下，额外的对齐方式可以被观察到：例如，代码可以假定全局变量被密集包装在它们的section中，并尝试将它们作为数组进行迭代，对齐填充将会破坏这个迭代。最大对齐是<code>1 &lt;&lt; 29</code>.</p><p>全局变量还可以具有<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2RsbHN0b3JhZ2VjbGFzcw==" title="http://llvm.org/docs/LangRef.html#dllstorageclass">DLL存储类<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3J1bnRpbWUtcHJlZW1wdGlvbi1tb2RlbA==" title="http://llvm.org/docs/LangRef.html#runtime-preemption-model">运行时抢占说明符<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2dsYXR0cnM=" title="http://llvm.org/docs/LangRef.html#glattrs">全局属性<i class="fa fa-external-link"></i></span>和可选的附加<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI21ldGFkYXRh" title="http://llvm.org/docs/LangRef.html#metadata">元数据<i class="fa fa-external-link"></i></span>列表。</p><p>变量和别名可以有一个<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Rscy1tb2RlbA==" title="http://llvm.org/docs/LangRef.html#tls-model">线程本地存储模型<i class="fa fa-external-link"></i></span>。</p><p><b style="color:red">句法(这个例子要好好学习，也包含了上面的知识)：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@&lt;GlobalVarName&gt; = [Linkage] [PreemptionSpecifier] [Visibility]</span><br><span class="line">                   [DLLStorageClass] [ThreadLocal]</span><br><span class="line">                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]</span><br><span class="line">                   [ExternallyInitialized]</span><br><span class="line">                   &lt;global | constant&gt; &lt;Type&gt; [&lt;InitializerConstant&gt;]</span><br><span class="line">                   [, section &quot;name&quot;] [, comdat [($name)]]</span><br><span class="line">                   [, align &lt;Alignment&gt;] (, !name !N)*</span><br></pre></td></tr></table></figure><p></p><p>例如，下面在带有初始值设定项，节(section)和对齐的编号地址空间中定义全局变量：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = addrspace(5) constant float 1.0, section &quot;foo&quot;, align 4</span><br></pre></td></tr></table></figure><p></p><p>以下示例仅声明一个全局变量<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = external global i32</span><br></pre></td></tr></table></figure><p></p><p><b style="color:green">以下示例使用<code>initialexec</code>TLS模型定义了一个thread-local全局变量：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@G = thread_local(initialexec) global i32 0, align 4</span><br></pre></td></tr></table></figure><p></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>LLVM函数定义包括了“的define”关键字，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xpbmthZ2U=" title="http://llvm.org/docs/LangRef.html#linkage">链接类型<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3J1bnRpbWUtcHJlZW1wdGlvbi1tb2RlbA==" title="http://llvm.org/docs/LangRef.html#runtime-preemption-model">运行时间抢占标识符<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQml0Q29kZUZvcm1hdC5odG1sI3Zpc2liaWxpdHk=" title="http://llvm.org/docs/BitCodeFormat.html#visibility">可见风格<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2RsbHN0b3JhZ2VjbGFzcw==" title="http://llvm.org/docs/LangRef.html#dllstorageclass">DLL存储类<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2NhbGxpbmdjb252" title="http://llvm.org/docs/LangRef.html#callingconv">调用约定<i class="fa fa-external-link"></i></span>，一个可选的<code>unnamed_addr</code>属性，返回类型，可选的返回类型<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3BhcmFtYXR0cnM=" title="http://llvm.org/docs/LangRef.html#paramattrs">参数属性<i class="fa fa-external-link"></i></span>，函数名称，（可能为空的）参数列表（每个参数都带有可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3BhcmFtYXR0cnM=" title="http://llvm.org/docs/LangRef.html#paramattrs">参数属性<i class="fa fa-external-link"></i></span>），可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ZuYXR0cnM=" title="http://llvm.org/docs/LangRef.html#fnattrs">函数属性<i class="fa fa-external-link"></i></span>，可选的section(节)，可选的对齐，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xhbmdyZWYtY29tZGF0cw==" title="http://llvm.org/docs/LangRef.html#langref-comdats">comdat<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2dj" title="http://llvm.org/docs/LangRef.html#gc">垃圾收集器名称<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3ByZWZpeGRhdGE=" title="http://llvm.org/docs/LangRef.html#prefixdata">前缀<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Byb2xvZ3VlZGF0YQ==" title="http://llvm.org/docs/LangRef.html#prologuedata">序言<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3BlcnNvbmFsaXR5Zm4=" title="http://llvm.org/docs/LangRef.html#personalityfn">个性<i class="fa fa-external-link"></i></span>，附加<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI21ldGFkYXRh" title="http://llvm.org/docs/LangRef.html#metadata">元数据<i class="fa fa-external-link"></i></span>的可选列表，开启大括号，基本块列表以及关闭大括号。</p><p>LLVM函数声明由“<code>declare</code>”关键字，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xpbmthZ2U=" title="http://llvm.org/docs/LangRef.html#linkage">链接类型<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQml0Q29kZUZvcm1hdC5odG1sI3Zpc2liaWxpdHk=" title="http://llvm.org/docs/BitCodeFormat.html#visibility">可见性样式<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2RsbHN0b3JhZ2VjbGFzcw==" title="http://llvm.org/docs/LangRef.html#dllstorageclass">DLL存储类<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2NhbGxpbmdjb252" title="http://llvm.org/docs/LangRef.html#callingconv">调用约定<i class="fa fa-external-link"></i></span>，可选的<code>unnamed_addr</code>或<code>local_unnamed_addr</code>属性，返回类型，返回类型的可选<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3BhcmFtYXR0cnM=" title="http://llvm.org/docs/LangRef.html#paramattrs">参数属性<i class="fa fa-external-link"></i></span>，函数名称，可能为空的参数列表，可选的对齐方式，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2dj" title="http://llvm.org/docs/LangRef.html#gc">垃圾收集器名称<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3ByZWZpeGRhdGE=" title="http://llvm.org/docs/LangRef.html#prefixdata">前缀<i class="fa fa-external-link"></i></span>以及可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Byb2xvZ3VlZGF0YQ==" title="http://llvm.org/docs/LangRef.html#prologuedata">序言<i class="fa fa-external-link"></i></span>。</p><p>一个函数定义包含一个基本块列表，形成该函数的<code>CFG</code>（控制流图）。每个基本块可以有选择地以一个标签开始（赋予基本块一个符号表入口），包含指令列表，并以<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Rlcm1pbmF0b3Jz" title="http://llvm.org/docs/LangRef.html#terminators">终止<i class="fa fa-external-link"></i></span>指令（如分支或函数返回）结束。如果未提供显式标签，一个块被赋值给一个隐含的编号标签，编号使用从计数器中返回下一个值，就像用于未命名的临时对象那样（<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2lkZW50aWZpZXJz" title="http://llvm.org/docs/LangRef.html#identifiers">参见上文<i class="fa fa-external-link"></i></span>）。例如，如果函数入口块没有明确的标签，则会分配标签“<code>％0</code>”，那么该块中的第一个未命名的临时块将为“<code>％1</code>”，以此类推。</p><p>函数中的第一个基本块在两个方面是特殊的：在函数入口时立即执行，并且不允许有祖先基本块（即不能有任何分支到函数的入口块）。由于该块可以没有前驱，它也不能有任何<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktcGhp" title="http://llvm.org/docs/LangRef.html#i-phi">PHI节点<i class="fa fa-external-link"></i></span>。</p><p>LLVM允许为函数指定显式section。如果目标机支持它，它将函数发送给指定的section。另外，该函数可以放置在COMDAT中。</p><p>可以为函数指定明确的对齐方式。如果不存在，或者如果对齐方式设置为零，则函数的对齐由目标机设置为任何感觉方便的方式。如果指定了明确的对齐方式，则该函数被强制至少具有那么多的对齐。所有对齐必须是2的幂。</p><p>如果<code>unnamed_addr</code>给出该属性，则知道该地址不重要，并且可以合并两个相同的函数。</p><p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内是不明显的。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [fn Attrs] [section &quot;name&quot;]</span><br><span class="line">       [comdat [($name)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>参数列表是逗号分隔的参数序列，其中每个参数具有以下形式：</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; [parameter Attrs] [name]</span><br></pre></td></tr></table></figure><p></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>与函数或变量不同，别名不会创建任何新数据。它们只是现有位置的新符号和元数据。</p><p>别名有一个名称和别名，可以是全局值或常量表达式。</p><p>别名可能具有可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xpbmthZ2U=" title="http://llvm.org/docs/LangRef.html#linkage">链接类型<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3J1bnRpbWUtcHJlZW1wdGlvbi1tb2RlbA==" title="http://llvm.org/docs/LangRef.html#runtime-preemption-model">运行时抢占说明符<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQml0Q29kZUZvcm1hdC5odG1sI3Zpc2liaWxpdHk=" title="http://llvm.org/docs/BitCodeFormat.html#visibility">可见性样式<i class="fa fa-external-link"></i></span>，可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2RsbHN0b3JhZ2VjbGFzcw==" title="http://llvm.org/docs/LangRef.html#dllstorageclass">DLL存储类<i class="fa fa-external-link"></i></span>和可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3Rscy1tb2RlbA==" title="http://llvm.org/docs/LangRef.html#tls-model">tls模型<i class="fa fa-external-link"></i></span>。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias &lt;AliaseeTy&gt;, &lt;AliaseeTy&gt;* @&lt;Aliasee&gt;</span><br></pre></td></tr></table></figure><p></p><p>链接必须是一个<code>private</code>，<code>internal</code>，<code>linkonce</code>，<code>weak</code>，<code>linkonce_odr</code>，<code>weak_odr</code>，<code>external</code>。请注意，某些系统链接器可能无法正确处理丢弃具有别名的弱符号(就是内存溢出的问题)。</p><p>不是<code>unnamed_addr</code>的别名保证具有与别名表达式相同的地址。<code>unnamed_addr</code>只保证指向相同的内容。</p><p>如果<code>local_unnamed_addr</code>给出该属性，则该地址在模块内不显著。</p><p>由于别名只是第二个名称，因此有些限制适用，其中一些只能在生成对象文件时进行检查：</p><ul><li>定义别名的表达式必须在汇编时可计算。因为它只是一个名字，不能使用重定位。</li><li>表达式中的别名不会很弱，因为中间别名被覆盖的可能性无法在对象文件中表示。</li><li>表达式中的全局值不能是一个声明，因为这需要重定位，这是不可能的。</li></ul><h3 id="IFuncs"><a href="#IFuncs" class="headerlink" title="IFuncs"></a>IFuncs</h3><p>IFuncs就像别名一样，不会创建任何新的数据或func。它们只是动态链接器通过调用解析器函数在运行时解析的一个新符号。</p><p>IFuncs有一个名称和一个解析器，它是动态链接器调用的函数，它返回与该名称关联的另一个函数的地址。</p><p>IFunc可能具有可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2xpbmthZ2U=" title="http://llvm.org/docs/LangRef.html#linkage">链接类型<i class="fa fa-external-link"></i></span>和可选的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQml0Q29kZUZvcm1hdC5odG1sI3Zpc2liaWxpdHk=" title="http://llvm.org/docs/BitCodeFormat.html#visibility">可见性样式<i class="fa fa-external-link"></i></span>。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&lt;Name&gt; = [Linkage] [Visibility] ifunc &lt;IFuncTy&gt;, &lt;ResolverTy&gt;* @&lt;Resolver&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="Comdats"><a href="#Comdats" class="headerlink" title="Comdats"></a>Comdats</h3><p>Comdat IR提供对COFF和ELF目标文件COMDAT功能的访问。</p><p><b style="color:red">关于什么是COMDAT，在<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi5rYW54dWUuY29tL2FydGljbGUtNDI5OS5odG0=" title="https://zhuanlan.kanxue.com/article-4299.htm">这篇文章<i class="fa fa-external-link"></i></span>中提到<code>COMDAT</code>，即<code>common data</code>. 编译器将一些函数（具体是哪些函数，编译器自行决定）打包放到单独的section中，这有个专有名词叫COMDAT,即common data，意思是打包的函数或者打包的数据。按微软大拿Raymond Chen的说法，COMDAT这个概念最早来自FORTRAN语言。gcc和llvm对COMDAT都有对应的支持。链接器在链接阶段，可以对COMDAT中重复的函数进行消重（folding，折叠）。如果编译器不把函数打包成COMDAT项，链接器是不敢贸然优化掉对应的函数的，因为缺少这些函数的引用信息。</b></p><p>Comdats有一个代表COMDAT键的名称。如果链接器选择了某个其他键的键，则指定的这个键的所有全局对象只会在最终的对象文件中结束。如果有别名，别名将放置在相同的COMDAT中以及进行别名计算。</p><p>Comdats有一种选择类型来提供关于链接器如何在两个不同对象文件中的键之间进行选择的输入。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&lt;Name&gt; = comdat SelectionKind</span><br></pre></td></tr></table></figure><p></p><p>选择种类必须是以下之一：</p><ul><li><code>any</code>: 链接器可以选择任何COMDAT键，选择是任意的。</li><li><code>exactmatch</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同的数据。</li><li><code>largest</code>: 链接器将选择包含最大值COMDAT键的section。</li><li><code>noduplicates</code>: 链接器要求只有具有此COMDAT密钥的section存在。</li><li><code>samesize</code>: 链接器可以选择任何COMDAT键，但这些section必须包含相同数量的数据。</li></ul><p>请注意，Mach-O平台不支持COMDAT key，而ELF和WebAssembly仅支持<code>any</code>作为选择类型。</p><p><b style="color:green">这里是<code>COMDAT</code>组的一个例子，其中只有当COMDAT键的section最大时才会选择一个函数：</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat largest</span><br><span class="line">@foo = global i32 2, comdat($foo)</span><br><span class="line"></span><br><span class="line">define void @bar() comdat($foo) &#123;</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为一个语法糖，$name如果名称与全局名称相同，则可以省略：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">@foo = global i32 2, comdat</span><br></pre></td></tr></table></figure><p></p><p>在COFF对象文件中，这将创建一个COMDAT section，它的选择类型是<code>IMAGE_COMDAT_SELECT_LARGEST</code>，包含<code>@foo</code>符号的内容和另一个COMDAT section；这个section的选择类型是<code>IMAGE_COMDAT_SELECT_ASSOCIATIVE</code>,这个选择类型与第一个COMDAT section相关并包含在<code>@bar</code>符号的内容。</p><p>全局对象的属性有一些限制。它或它的别名在定位COFF时必须与COMDAT组具有相同的名称。COFF对象的内容和大小可以在链接期间使用，根据选择种类确定选择哪个COMDAT组。因为对象的名称必须与COMDAT组的名称相匹配，所以全局对象的链接不能是本地的; 如果符号表中发生冲突，则可以重命名本地符号。</p><p>组合使用COMDATS和段(section)属性可能会产生令人惊讶的结果。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$foo = comdat any</span><br><span class="line">$bar = comdat any</span><br><span class="line">@g1 = global i32 42, section &quot;sec&quot;, comdat($foo)</span><br><span class="line">@g2 = global i32 42, section &quot;sec&quot;, comdat($bar)</span><br></pre></td></tr></table></figure><p></p><p>从对象文件的角度来看，这需要创建具有相同名称的两个段（section）。这是必要的，因为全局变量属于不同的COMDAT组，在对象文件级别，COMDAT由段（section）表示。</p><p>请注意，除了使用COMDAT IR指定的内容之外，某些IR结构（如全局变量和函数）可能会在对象文件中创建COMDAT。当代码生成器配置为在各个段（section）中发出全局变量时（例如， 向llc提供<code>-data-sections</code>或<code>-function-sections</code>选项时），就会出现这种情况。</p><h3 id="命名元数据"><a href="#命名元数据" class="headerlink" title="命名元数据"></a>命名元数据</h3><p>命名的元数据是元数据的集合。<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI21ldGFkYXRh" title="http://llvm.org/docs/LangRef.html#metadata">元数据节点<i class="fa fa-external-link"></i></span>（但不是元数据字符串）是命名元数据的唯一有效操作数。</p><ol><li>命名的元数据被表示为一个带有元数据前缀的字符串。元数据名称的规则与标识符相同，但引用的名称不被允许。”\xx”类型转义仍然有效，它允许任何字符成为名称的一部分。</li></ol><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; Some unnamed metadata nodes, which are referenced by the named metadata.</span><br><span class="line">!0 = !&#123;!&quot;zero&quot;&#125;</span><br><span class="line">!1 = !&#123;!&quot;one&quot;&#125;</span><br><span class="line">!2 = !&#123;!&quot;two&quot;&#125;</span><br><span class="line">; A named metadata.</span><br><span class="line">!name = !&#123;!0, !1, !2&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>返回类型和函数类型的每个参数都可能具有一组与其关联的参数属性。参数属性用于传递有关函数结果或参数的附加信息。参数属性被认为是函数的一部分，而不是函数类型，所以具有不同参数属性的函数可以具有相同的函数类型。</p><p>参数属性是遵循指定类型的简单关键字。如果需要多个参数属性，则它们是空格分隔的。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @printf(i8* noalias nocapture, ...)</span><br><span class="line">declare i32 @atoi(i8 zeroext)</span><br><span class="line">declare signext i8 @returns_signed_char()</span><br></pre></td></tr></table></figure><p></p><p>请注意，<code>function result (nounwind, readonly)</code>的任何属性都会立即出现在参数列表之后。</p><p>目前，仅定义了以下参数属性：</p><ul><li><code>zeroext</code>: 这向代码生成器指示参数或返回值应该被调用者（对于参数）或被调用者（对于返回值）被零扩展到目标机ABI所需的范围。</li><li><code>signext</code>: 这向代码生成器指示参数或返回值应该由调用方（对于参数）或被调用方（对于返回值）进行符号扩展到目标机的ABI（通常为32位）所需的范围内。</li><li><code>inreg</code>: 这表明这个参数或返回值应该以特定的与目标机相关的方式处理，同时为函数调用或返回发送代码（通常通过将其放入寄存器而不是内存中，尽管有些目标机使用它来区分两个不同类型的寄存器）。使用此属性是特定于目标机的。</li><li><code>byval</code>: 这表明指针参数应该真的按值传递给函数。该属性意味着指向者的隐藏拷贝在调用者和被调用者之间建立，所以被调用者无法修改调用者中的值。该属性仅对LLVM指针参数有效。它通常用于按值传递结构和数组，但在指向标量的指针上也是有效的。复制被认为属于调用者而不是被调用者（例如，readonly函数不应写入byval参数）。这不是返回值的有效属性。<br>byval属性还支持使用align属性指定对齐方式。它指示要形成的堆栈槽的对齐以及指定给调用点的指针的已知对齐。如果未指定对齐，则代码生成器会进行特定于目标机的假设。</li><li><code>inalloca</code>: inalloca参数属性允许调用者采取传出栈参数的地址。一个inalloca参数必须是堆栈内存指针，<code>alloca</code>指令生成堆栈内存。alloca或参数分配也必须使用<code>inalloca</code>关键字进行标记。只有最后一个参数可能具有该<code>inalloca</code>属性，并且该参数保证在内存中传递。<br>参数分配最多可以由一个调用使用一次，因为调用可能会释放它。影响参数存储的属性，象<code>inreg</code>，<code>nest</code>，<code>sret</code>，或<code>byval</code>，<code>inalloca</code>属性不能结合这些属性一起使用。<code>inalloca</code>属性还禁止LLVM隐式降低大型聚合返回值，这意味着前端作者必须用<code>sret</code>指针降低它们(意思就是不要直接返回大型的值，改用返回指针)。<br>到达呼叫点时，参数分配必须是最新的还存活的堆栈分配，否则结果未定义。可以在参数分配之后、其调用点之前分配额外的堆栈空间，但必须使用<code>[llvm.stackrestore](http://llvm.org/docs/LangRef.html#int-stackrestore)</code>清除它。<br>有关如何使用此属性的更多信息，请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvSW5BbGxvY2EuaHRtbA==" title="http://llvm.org/docs/InAlloca.html">InAlloca属性的设计和使用<i class="fa fa-external-link"></i></span>。</li><li><code>sret</code>: 这表明指针参数指定了作为源程序中函数返回值的结构地址。该指针必须由调用者保证是有效的：加载和存储到结构可以由被调用者假定不要陷入并且被正确对齐。这不是返回值的有效属性。</li><li><code>align &lt;n&gt;</code>: 这表明优化器可能会假定指针值具有指定的对齐方式。<br>请注意，该属性在与<code>byval</code>属性组合时具有额外的语义 。</li><li><code>noalias</code>: 这表明，通过<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI3BvaW50ZXJhbGlhc2luZw==" title="http://llvm.org/docs/LangRef.html#pointeraliasing">基于<i class="fa fa-external-link"></i></span>所述参数或返回值的指针值访问的对象不可以访问，该函数的执行过程中，通过不基于所述参数或返回值的指针值。返回值的属性也具有下面描述的附加语义。调用方与被调用方分担责任，确保满足这些要求。有关更多详细信息，请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQWxpYXNBbmFseXNpcy5odG1sI211c3QtbWF5LW9yLW5v" title="http://llvm.org/docs/AliasAnalysis.html#must-may-or-no">别名分析<i class="fa fa-external-link"></i></span>中 NoAlias回应的讨论。<br>请注意，这个<code>noalias</code>定义有意地类似于C99中用于函数参数的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQxNjUzNzc1" title="https://www.zhihu.com/question/41653775"><code>restrict</code><i class="fa fa-external-link"></i></span>定义。<br>对于函数返回值，C99的restrict意义不大，而对LLVM的<code>noalias</code>是有意义的。此外，在函数参数上使用时，返回值上的<code>noalias</code>属性的语义强于该属性的语义。在函数返回值上，<code>noalias</code>属性指示该函数的作用类似于系统内存分配函数，它返回一个指针，指向调用者可访问的任何其他对象的存储器的已分配存储空间。</li><li><code>nocapture</code>: 这表明被调用者不会创建超出被调用者本身的指针的任何副本。这不是返回值的有效属性。在易变的操作中使用的地址被认为是被捕获的。</li><li><code>nest</code>: 这表明指针参数可以使用弹性（trampoline）内联函数删除 。这不是返回值的有效属性，只能应用于一个参数。</li><li><code>returned</code>: 这表明函数总是返回参数作为其返回值。这是在生成调用者时使用的优​​化器和代码生成器的提示，允许值传播，尾部调用优化以及在某些情况下省略寄存器保存和恢复; 在生成被调用者时不检查或强制执行。该参数和函数返回类型必须是<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktYml0Y2FzdA==" title="http://llvm.org/docs/LangRef.html#i-bitcast">bitcast指令<i class="fa fa-external-link"></i></span>的有效操作数 。这不是返回值的有效属性，只能应用于一个参数。</li><li><code>nonnull</code>: 这表明参数或返回指针不为null。该属性可能只适用于指针型参数。这不是LLVM检查或执行的，调用者必须确保传入的指针非空，或者被调用者必须确保返回的指针非空。</li><li><code>dereferenceable(&lt;n&gt;)</code>: 这表明参数或返回指针是可逆向引用的(dereferenceable，就是用*pr引用值)。该属性可能只适用于指针型参数。一个可逆向引用的指针可以从投机加载而没有陷入的风险。已知可逆向引用的字节数必须在括号中提供。字节数小于指点人类型的大小是合法的。该nonnull属性并不意味着可引用性（考虑一个指向数组末尾的一个元素的指针），但是<code>dereferenceable(&lt;n&gt;)</code>暗含<code>nonnull</code>在 <code>addrspace(0)</code>中（这是默认地址空间）。</li><li><code>dereferenceable_or_null(&lt;n&gt;)</code>: 这表明参数或返回值不能同时为非空和不可逆向引用(达到<code>&lt;n&gt;</code>字节）。标记为<code>dereferenceable_or_null(&lt;n&gt;)</code>的所有非空指针是<code>dereferenceable(&lt;n&gt;)</code>。对于地址空间0 <code>dereferenceable_or_null(&lt;n&gt;)</code>意味着一个指针是正好一个<code>dereferenceable(&lt;n&gt;)</code>或null; 在其它的地址空间<code>dereferenceable_or_null(&lt;n&gt;)</code> 意味着一个指针中的至少一个<code>dereferenceable(&lt;n&gt;)</code>或<code>null</code>（它也可以是<code>null</code>和<code>dereferenceable(&lt;n&gt;)</code>）。该属性可能只适用于指针型参数。</li><li><code>swiftself</code>: 这表明该参数是<code>self/context</code>参数。这不是返回值的有效属性，只能应用于一个参数。</li><li><code>swifterror</code>: 这个属性被激发来模拟和优化Swift错误处理。它可以应用于指针指向指针类型或指针大小的alloca的参数。在调用点，与参数相对应的实际<code>swifterror</code>参数必须来自<code>swifterroralloca</code>或<code>swifterror</code>调用者的参数。甲swifterror值（参数或ALLOCA）只能加载和存储的，或用作一个swifterror参数。这不是返回值的有效属性，只能应用于一个参数。<br>这些约束允许调用约定swifterror通过将它们与在调用边界的特定寄存器相关联来优化对变量的访问， 而不是将它们放置在内存中。由于这确实改变了调用约定，所以swifterror在参数上使用属性的函数不是ABI兼容的。<br>这些约束条件还允许LLVM假定swifterror参数不会在函数swifterror中使其他内存可见，并且作为参数传递的 alloca不会转义。</li></ul><h3 id="垃圾收集器策略的名称"><a href="#垃圾收集器策略的名称" class="headerlink" title="垃圾收集器策略的名称"></a>垃圾收集器策略的名称</h3><p>每个函数都可以指定一个垃圾收集器策略名称，它只是一个字符串：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() gc &quot;name&quot; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>名称的支持值包括<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvR2FyYmFnZUNvbGxlY3Rpb24uaHRtbCNidWlsdGluLWdjLXN0cmF0ZWdpZXM=" title="http://llvm.org/docs/GarbageCollection.html#builtin-gc-strategies">LLVM内置的<i class="fa fa-external-link"></i></span>值以及由加载的插件提供的值。指定GC策略将导致编译器更改其输出以支持指定的垃圾回收算法。请注意，LLVM本身不包含垃圾收集器，此功能仅限于生成可与外部提供的收集器互操作的机器代码。</p><h3 id="前缀数据"><a href="#前缀数据" class="headerlink" title="前缀数据"></a>前缀数据</h3><p>前缀数据是与函数关联的数据，代码生成器在函数入口点之前立即发出的。此功能的目的是允许前端（frontends）将语言特定的运行时元数据与特定函数相关联，并通过函数指针使其可用，同时仍允许调用函数指针。</p><p>要访问给定函数的数据，程序可以将函数指针bitcast到指向常量类型和取消逆向引用索引(dereference index，可能是指内容-1处的索引)-1的指针。这意味着IR符号刚刚超过前缀数据的末尾。例如，以单个<code>i32</code>注释的函数为例，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prefix i32 123 &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>前缀数据可以被引用为，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = bitcast void* () @f to i32*</span><br><span class="line">%a = getelementptr inbounds i32, i32* %0, i32 -1</span><br><span class="line">%b = load i32, i32* %a</span><br></pre></td></tr></table></figure><p></p><p>前缀数据的布局就好像它是前缀数据类型的全局变量的初始化程序。该函数将被放置为使得前缀数据的开始对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点不会对齐。如果需要对齐函数的入口点，则必须将填充添加到前缀数据中。</p><p>一个函数可能有前缀数据但没有主体。这与available_externally链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标机文件中发送数据。</p><h3 id="序言（Prologue）资料"><a href="#序言（Prologue）资料" class="headerlink" title="序言（Prologue）资料"></a>序言（Prologue）资料</h3><p>该prologue属性允许在函数体之前插入任意代码（以字节编码）。这可以用于启用函数热修补和仪器。</p><p>为了保持普通函数调用的语义，序言数据必须有特定的格式。具体来说，它必须以一系列字节开始，该字节序列解码为一系列机器指令，对模块的目标代码有效，将控制转移到紧接在序言数据之后的位置，而不执行任何其他可见动作。这允许内联和其他传递推理函数定义的语义，而不需要推理序言数据。显然这使得序言数据的格式高度依赖于目标。</p><p>x86体系结构的有效序言数据的一个简单示例是<code>i8 144</code>, 对指令<code>nop</code>进行编码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define void @f() prologue i8 144 &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>通常，可以通过对跳过元数据的相对分支指令进行编码来形成序言数据，如x86_64体系结构的有效序言数据的示例，其中前两个字节编码为：<code>jmp .+10</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%0 = type &lt;&#123; i8, i8, i8* &#125;&gt;</span><br><span class="line"></span><br><span class="line">define void @f() prologue %0 &lt;&#123; i8 235, i8 8, i8* @md&#125;&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>一个函数可能有序言数据，但没有主体。这与<code>available_externally</code>链接具有相似的语义，因为优化器可能会使用这些数据，但不会在目标文件中发送数据。</p><h3 id="Personality功能"><a href="#Personality功能" class="headerlink" title="Personality功能"></a>Personality功能</h3><p>该<code>personality</code>属性允许函数指定用于异常处理的函数。</p><h3 id="属性组"><a href="#属性组" class="headerlink" title="属性组"></a>属性组</h3><p>属性组是由IR内的对象引用的属性组。它们对于保持<code>.ll</code>文件可读性很重要，因为许多函数将使用同一组属性。在与单个.c文件相对应的<code>.ll</code>文件的退化(degenerative)情况下，单个属性组将捕获用于构建该文件的重要命令行标志。</p><p>一个属性组是一个模块级别的对象。要使用属性组，对象引用属性组的ID（例如<code>#37</code>）。一个对象可能涉及多个属性组。在这种情况下，来自不同组的属性被合并。</p><p>下面是一个应该总是内联的函数的属性组的示例，其堆栈对齐方式为4，不应使用SSE指令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; Target-independent attributes:</span><br><span class="line">attributes #0 = &#123; alwaysinline alignstack=4 &#125;</span><br><span class="line"></span><br><span class="line">; Target-dependent attributes:</span><br><span class="line">attributes #1 = &#123; &quot;no-sse&quot; &#125;</span><br><span class="line"></span><br><span class="line">; Function @f has attributes: alwaysinline, alignstack=4, and &quot;no-sse&quot;.</span><br><span class="line">define void @f() #0 #1 &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><p>函数属性被设置为传递关于函数的附加信息。函数属性被认为是函数的一部分，而不是函数类型的一部分，因此具有不同函数属性的函数可以具有相同的函数类型。</p><p>函数属性是遵循指定类型的简单关键字。如果需要多个属性，它们是空格分隔的。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define void @f() noinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline &#123; ... &#125;</span><br><span class="line">define void @f() alwaysinline optsize &#123; ... &#125;</span><br><span class="line">define void @f() optsize &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><code>alignstack(&lt;n&gt;)</code>: 这个属性表明，当发布序言和尾声(epilogue)时，后端应该强制堆栈指针对齐。在圆括号中指定所需的对齐方式，该对齐方式必须是2的幂。</li><li><code>allocsize(&lt;EltSizeParam&gt;[, &lt;NumEltsParam&gt;])</code>: 该属性指示注释的函数将始终返回至少给定数量的字节（或null）。它的参数是零索引参数号; 如果提供了一个参数，则假定至少有<code>CallSite.Args[EltSizeParam]</code>字节在返回的指针处可用。如果提供了两个参数，则假定<code>CallSite.Args[EltSizeParam] * CallSite.Args[NumEltsParam]</code>字节可用。引用的参数必须是整数类型。没有关于返回的内存块的内容的假设。</li><li><code>alwaysinline</code>: 该属性表示内联器应尽可能将该函数内联到调用者中，而忽略此调用者的任何活动内联大小阈值。</li><li><code>builtin</code>: 这表明，即使函数的声明使用<code>nobuiltin</code>属性，调用点上的被调用函数也应该被识别为内置函数。这仅在调用点有效，才能直接调用<code>nobuiltin</code>属性声明的函数。</li><li><code>cold</code>: 这个属性表明这个函数很少被调用。在计算边权重时，由冷函数调用后支配的基本块也被认为是冷的; 因此，轻量级。</li><li><code>convergent</code>: 在一些并行执行模型中，存在无法根据任何附加值进行控制的操作。我们称之为这样的操作<code>convergent</code>，并用这个属性标记它们。<br><code>convergent</code>属性可能出现在函数或<code>call/invoke</code>指令上。当它出现在一个函数上时，它表示对这个函数的调用不应该取决于附加值的控制。例如，内在的<code>llvm.nvvm.barrier0</code>是<code>convergent</code>，所以对这个内在的调用不能取决于附加值的控制。<br>当它出现在一个<code>call/invoke</code>中时，<code>convergent</code>属性表明我们应该把这个调用看作是我们正在调用一个收敛函数。这对间接调用特别有用; 没有这个，我们可以把这样的调用视为目标不收敛。<br>当可以证明函数不执行任何收敛操作时，优化器可以删除函数的<code>convergent</code>属性。同样，优化程序可以在<code>call/invoke</code>不能调用收敛函数时删除<code>calls/invokes</code>上的<code>convergent</code>。</li><li><code>inaccessiblememonly</code>: 该属性表明该函数只能访问正在编译的模块而无法访问的内存。这是一种较弱的<code>readnone</code>形式。</li><li><code>inaccessiblemem_or_argmemonly</code>: 该属性表明该函数只能访问被编译的模块而无法访问的内存，或者其指针参数指向的内存。这是一种较弱的<code>argmemonly</code>形式。</li><li><code>inlinehint</code>: 这个属性表明源代码包含一个暗示这个函数内联的提示是可取的（比如C / C ++中的“inline”关键字）。这只是一个暗示; 它对内联没有要求。</li><li><code>jumptable</code>: 该属性表示应该在代码生成时将函数添加到跳转指令表中，并且应将所有对此函数的地址引用引用替换为对相应的跳转指令表函数指针的引用。请注意，这会为原始函数创建一个新指针，这意味着依赖于函数指针标识的代码可能会中断。所以，<code>jumptable</code>注解的任何函数也必须是<code>unnamed_addr</code>。</li><li><code>minsize</code>: 此属性表明，优化途径（passes）和代码生成器途径之间进行选择，以使该函数的代码大小尽可能小，并执行可能牺牲运行时性能的优化，以最小化生成的代码的大小。</li><li><code>naked</code>: 该属性禁用该函数的序言/尾声(prologue/epilogue)发射。这可能会导致系统特定的后果。</li><li><code>no-jump-tables</code>: 当此属性设置为true时，可以从生成的跳转表和查找表被禁用。这些表都是会转换为小写的字母。</li><li><code>nobuiltin</code>: 这表明调用点的被调用方函数不被识别为内置函数。除非调用点使用该<code>builtin</code>属性，否则LLVM将保留原始调用并且不会使用基于内置函数的语义的等效代码替换它。这在调用点以及函数声明和定义中是有效的。</li><li><code>noduplicate</code>: 此属性表示对函数的调用不能重复。对<code>noduplicate</code>函数的调用可能会在其父函数内移动，但不能在其父函数内复制。<br>包含<code>noduplicate</code>调用的函数可能仍然是内联候选人，前提是调用不通过内联复制。这意味着该功能具有内部链接功能，并且只有一个调用点，所以原始调用在内联后死亡。</li><li><code>noimplicitfloat</code>: 该属性禁用隐式浮点指令。</li><li><code>noinline</code>: 该属性表示内联器在任何情况下都不应该内联该函数。该属性不能与<code>alwaysinline</code>属性一起使用。</li><li><code>nonlazybind</code>: 该属性禁止该函数的延迟符号绑定。如果在程序启动期间未调用该函数，则可能会以更多的程序启动时间为代价来更快地调用该函数。</li><li><code>noredzone</code>: 该属性指示代码生成器不应使用红色区域，即使目标特定的ABI通常允许它。</li><li><code>noreturn</code>: 该函数属性指示函数永远不会正常返回。如果函数在动态返回时会在运行时产生未定义的行为。</li><li><code>norecurse</code>: 该函数属性指示该函数不会直接或间接地调用自己的任何可能的调用路径。如果该函数执行递归，这会在运行时产生未定义的行为。</li><li><code>nounwind</code>: 该函数属性指示该函数不会引发异常。如果该函数确实引发异常，则其运行时行为未定义。但是，标记为<code>nounwind</code>的函数仍可能陷入或生成异步异常。由LLVM识别以处理异步异常（如SEH）的异常处理方案仍将提供其实现定义的语义。</li><li><code>optforfuzzing</code>: 该属性表示该函数应该针对最大模糊信号进行优化。</li><li><code>optnone</code>: 该函数属性指示大多数优化过程将跳过此函数，但过程间优化过程除外。代码生成默认为“<code>fast</code>”指令选择器。该属性不能与<code>alwaysinline</code>属性一起使用; 此属性也与<code>minsize</code>属性和<code>optsize</code>属性不兼容。<br>这个属性需要在<code>noinline</code>函数中指定属性，所以函数不会被内联到任何调用者中。只有具有该<code>alwaysinline</code>属性的函数才是用于内联到此函数主体中的有效候选项。</li><li><code>optsize</code>: 此属性表明，优化传递(passes)和代码生成器传递之间进行选择，以保持此函数的代码大小较低，否则，只要不会显着影响运行时性能，就会专门减少代码大小进行优化。</li><li>“<code>patchable-function</code>“: 这个属性告诉代码生成器，为这个函数生成的代码需要遵循特定的约定，以便运行时函数稍后可以修补它。该属性本身并不意味着对程序间优化的限制。所有修补语义效应可能必须通过连接类型单独传送。该属性的确切效果取决于其字符串值，目前有一个合法的可能性：<ul><li>“<code>prologue-short-redirect</code>“ - 这种类型的可修补函数旨在支持修补函数序言，以线程安全的方式将控制权重定向到函数之外。它保证函数的第一条指令足够大以容纳短跳转指令，并且将被充分对齐以允许通过原子比较和交换指令进行完全更改。尽管可以通过插入足够大的<code>NOP</code>来满足第一个要求，但LLVM可以并且将尝试将现有指令（即，不得不被发射的指令）重新用作大于短跳跃的可修改指令。<br>“<code>prologue-short-redirect</code>“目前仅在x86-64上受支持。</li></ul></li><li>“<code>probe-stack</code>“: 该属性表明该函数将在堆栈的末尾触发一个防护区域。它确保对堆栈的访问必须不会远离保护区域的大小，保护域是堆栈的先前访问。它需要一个必需的字符串值，即将被调用的堆栈探测函数的名称。<br>如果具有”<code>probe-stack</code>“属性的函数内联到另一个”<code>probe-stack</code>“属性的函数中，对调用者而言，则结果函数具有”<code>probe-stack</code>“属性。如果具有”<code>probe-stack</code>“属性的函数被内联到完全没有”<code>probe-stack</code>“属性的函数中，则结果函数具有”<code>probe-stack</code>“被调用者的属性。</li><li><code>readnone</code>: 在一个函数上，这个属性表明函数严格基于它的参数来计算它的结果（或者决定展开一个异常），而不需要逆向引用任何指针参数或者访问任何对调用者函数可见的可变状态（例如内存，控制寄存器等）。它不写任何指针参数（包括<code>byval</code>参数），也不会改变调用者可见的任何状态。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在参数上，该属性指示该函数不会对指针参数进行逆向引用，即使它可以读取或写入指针指向的内存（如果通过其他指针访问的话）。</li><li><code>readonly</code>: 在一个函数中，这个属性表明函数不会通过任何指针参数（包括<code>byval</code>参数）进行写入，也不会修改调用者函数可见的任何状态（例如内存，控制寄存器等）。它可能会逆向引用（就是*号操作）指针参数并读取调用者可能设置的状态。readonly函数在调用相同的参数集和全局状态时始终返回相同的值（或者展开相同的异常）。这意味着虽然它不能通过调用C++异常抛出方法来展开异常（因为它们会写入内存），但可能会有非C++机制在不写入LLVM可见内存的情况下抛出异常。<br>在一个参数上，这个属性表明函数不会通过这个指针参数写入，即使它可能写入指针指向的内存。</li><li>“<code>stack-probe-size</code>“: 该属性控制堆栈探测器的行为：”<code>probe-stack</code>“属性或ABI所需的堆栈探测器（如果有的话）。它定义了防护区的大小。它确保如果函数可能会使用比保护区大小更多的堆栈空间，则会发出堆栈探测序列。它需要一个必需的整数值，默认为<code>4096</code>。<br>如果具有”<code>stack-probe-size</code>“属性的函数内联到另一个”<code>stack-probe-size</code>“属性函数中，则生成的函数具有”<code>stack-probe-size</code>“数值较小的属性。如果具有”<code>stack-probe-size</code>“属性的函数被内联到完全没有”stack-probe-size”属性的函数中，则结果函数具有”<code>stack-probe-size</code>“被调用者的属性。</li><li>“<code>no-stack-arg-probe</code>“: 该属性禁用ABI所需的堆栈探测器（如果有的话）。</li><li><code>writeonly</code>: 在一个函数上，这个属性表明函数可以写入但不从内存中读取。<br>在一个参数上，这个属性表明函数可以写入但不读取这个指针参数（即使它可以从指针指向的内存中读取）。</li><li><code>argmemonly</code>: 这个属性表明函数内部唯一的内存访问是加载并存储指针类型参数所指向的对象的任意偏移量。换句话说，函数中的所有内存操作都可以仅使用基于其函数参数的指针来引用内存。请注意，<code>argmemonly</code>可以与<code>readonly</code>属性一起使用，以便指定该函数只从其参数中读取。</li><li><code>returns_twice</code>: 该属性表示该函数可以返回两次。C的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvU2V0am1wLmg=" title="https://zh.wikipedia.org/wiki/Setjmp.h"><code>setjmp</code><i class="fa fa-external-link"></i></span>（<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9oYXppci9wL2Nfc2V0am1wX2xvbmdqbXAuaHRtbA==" title="http://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html">这里<i class="fa fa-external-link"></i></span>有一个更好的例子）是这种功能的一个例子。编译器在这些函数的调用者中禁用某些优化（如tail调用）。</li><li><code>safestack</code>: 此属性表示已为此函数启用<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvU2FmZVN0YWNrLmh0bWw=" title="http://clang.llvm.org/docs/SafeStack.html">SafeStack<i class="fa fa-external-link"></i></span>保护。<br>如果具有<code>safestack</code>属性的函数被内联到一个函数，这个函数不具有<code>safestack</code>属性或具有一个<code>ssp</code>，<code>sspstrong</code>或<code>sspreq</code>属性，然后将所得的函数将有一个<code>safestack</code>属性。</li><li><code>sanitize_address</code>: 此属性表明已为此函数启用<code>AddressSanitizer</code>检查（动态地址安全分析）。</li><li><code>sanitize_memory</code>: 此属性表示对此函数启用<code>MemorySanitizer</code>检查（对未初始化内存的访问的动态检测）。</li><li><code>sanitize_thread</code>: 此属性表示为此函数启用了<code>ThreadSanitizer</code>检查（动态线程安全分析）。</li><li><code>sanitize_hwaddress</code>: 此属性表示为此函数启用了<code>HWAddressSanitizer</code>检查（基于标记指针的动态地址安全分析）。</li><li><code>speculatable</code>: 这个函数属性表明函数除了计算结果之外没有任何影响，并且没有未定义的行为。请注意，这<code>speculatable</code>还不足以断定沿着任何特定的执行路径，对此函数的调用次数不会在外部可观察到。该属性仅适用于函数和声明，而不适用于单个调用点。如果一个函数被错误地标记为<code>speculatable</code>，并且确实表现出未定义的行为，即使该调用点是死代码，也可能会观察到未定义的行为。</li><li><p><code>ssp</code>: 该属性表示该函数应该发出一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hbnRpc18xOTg0L2FydGljbGUvZGV0YWlscy83MjExOTU3NQ==" title="https://blog.csdn.net/mantis_1984/article/details/72119575">堆栈溢出保护器(stack smashing detected)<i class="fa fa-external-link"></i></span>。它的形式是“canary” - 在从函数返回时检查局部变量以查看它是否被覆盖之前放置在堆栈上的随机值。启发式用于确定函数是否需要堆栈保护器。使用的启发式将使保护器具有以下特性的函数：</p><ul><li>大于<code>ssp-buffer-size</code>（默认8）的字符数组。</li><li>包含大于<code>ssp-buffer-size</code>的字符数组的聚合。</li><li>大小大于<code>ssp-buffer-size</code>的变量或者常量调用<code>alloca()</code>.</li></ul><p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。<br>如果一个具有<code>ssp</code>属性的函数被内联到一个没有<code>ssp</code>属性的函数中，那么结果函数将具有一个<code>ssp</code>属性。</p></li><li><p><code>sspreq</code>: 该属性表示该函数应该始终发出堆栈溢出保护器。这覆盖了<code>ssp</code>函数属性。<br>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p><ol><li>大型数组和包含大型数组（&gt;= ssp-buffer-size）的结构最接近堆栈保护器。</li><li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li><li>已经取得地址的变量是第三接近保护者。</li></ol><p>如果其具有<code>sspreq</code>属性的函数被内联到一个函数，它不具有<code>sspreq</code>属性或具有一个<code>ssp</code>或<code>sspstrong</code>属性，然后将所得的函数将有一个<code>sspreq</code>属性。</p></li><li><p><code>sspstrong</code>: 该属性表示该函数应该发出一个堆栈溢出保护器。该属性在确定函数是否需要堆栈保护器时会使用强启发式。强大的启发式功能可以为以下函数提供保护：</p><ul><li>任何大小和类型的阵列</li><li>包含任何大小和类型的数组的聚合。</li><li>调用alloca（）。</li><li>已经取得地址的局部变量。</li></ul><p>被确定为需要保护器的变量将被安排在堆栈上，以便它们与堆栈保护器防护装置相邻。具体的布局规则是：</p><ol><li>大型数组和包含大型数组的结构（&gt;= ssp-buffer-size）最接近堆栈保护器。</li><li>小数组和包含小数组（&lt; ssp-buffer-size）的结构距离保护器第二近。</li><li>已经取得地址的变量是第三接近保护者。</li></ol><p>这覆盖了<code>ssp</code>函数属性。<br>如果一个具有<code>sspstrong</code>属性的函数被内联到一个没有<code>sspstrong</code>属性的函数中，那么结果函数将具有一个<code>sspstrong</code>属性。</p></li><li><code>strictfp</code>: 该属性指示该函数是从需要严格浮点语义的作用域调用的。LLVM不会尝试任何需要假设浮点舍入模式的优化，或者可能会改变可能通过调用此函数来设置或清除的浮点状态标志的状态。</li><li>“<code>thunk</code>“: 该属性表示该函数将通过尾部调用委托给某个其他函数。不应将<code>thunk</code>的原型用于优化目的。预计调用者将投掷<code>thunk</code>原型以匹配<code>thunk</code>目标原型。</li><li><code>uwtable</code>: 这个属性表明被定位的ABI需要为这个函数生成一个展开的表入口，即使我们能够证明没有异常通过它。这通常适用于ELF x86-64 abi，​​但对于某些编译单元可以禁用它。</li><li><code>nocf_check</code>: 此属性表示不会对属性实体执行控制流检查。它会禁用特定实体的<code>-fcf-protection = &lt;&gt;</code>以细化HW控制流保护机制。该标志是目标独立的，并且当前属于函数或函数指针。</li><li><code>shadowcallstack</code>: 此属性表示为该函数启用了<code>ShadowCallStack</code>检查。仪器检查（instrumentation checks）函数的返回地址在函数<code>prolog</code>和<code>eiplog</code>之间没有改变。它目前是x86_64特定的。</li></ul><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>可以设置属性来传达关于全局变量的附加信息。与<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ZuYXR0cnM=" title="http://llvm.org/docs/LangRef.html#fnattrs">函数属性<i class="fa fa-external-link"></i></span>不同，全局变量上的属性被分组到单个<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2F0dHJncnA=" title="http://llvm.org/docs/LangRef.html#attrgrp">属性组中<i class="fa fa-external-link"></i></span>。</p><h3 id="操作数捆绑-Operand-Bundles"><a href="#操作数捆绑-Operand-Bundles" class="headerlink" title="操作数捆绑(Operand Bundles)"></a>操作数捆绑(Operand Bundles)</h3><p>操作数捆绑是可与某些LLVM指令相关联的SSA值的标签set集（当前仅包含calls和invokes）。在某种程度上，它们就像元数据，但删除它们是不正确的，并且会改变程序的语义。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operand bundle set ::= &apos;[&apos; operand bundle (, operand bundle )* &apos;]&apos;</span><br><span class="line">operand bundle ::= tag &apos;(&apos; [ bundle operand ] (, bundle operand )* &apos;)&apos;</span><br><span class="line">bundle operand ::= SSA value</span><br><span class="line">tag ::= string constant</span><br></pre></td></tr></table></figure><p></p><p>操作数绑定不是函数签名的一部分，并且可以从具有不同类型操作数绑定的多个位置调用给定函数。这反映了操作数绑定在概念上是call（或invoke）的一部分，而不是被调度的被调用者。</p><p>操作数绑定是一种通用机制，旨在支持托管语言的类似运行时自反功能。虽然操作数绑定的确切语义取决于绑定标记，但操作数绑定的存在可以影响程序的语义有一定的限制。这些限制被描述为“unknown”操作数绑定的语义。只要操作数绑定的行为可以在这些限制内进行描述，LLVM就不需要对操作数绑定有特殊的了解，就不会错误地编译包含它的程序。</p><ul><li>未知操作数绑定的捆绑操作数在控制权转移给被调用者或调用者之前以未知方式转义。</li><li>使用操作数绑定进行调用和调用对入口和出口处的堆（即使调用目标是readnone或readonly）在堆上具有未知的读/写效果 ，除非它们被特定于调用点的属性覆盖。</li><li>调用点的操作数绑定不能更改被调用函数的实现。只要它们考虑到头两个属性，程序间优化就像往常一样工作。</li></ul><p>下面描述了更具体的操作数绑定类型。</p><h4 id="逆优化（Deoptimization）操作数绑定"><a href="#逆优化（Deoptimization）操作数绑定" class="headerlink" title="逆优化（Deoptimization）操作数绑定"></a>逆优化（Deoptimization）操作数绑定</h4><p>逆优化（Deoptimization）操作数绑定由”<code>deopt</code>“操作数绑定标签表征。这些操作数绑定表示它们所连接的调用点的替代“安全”延续，并且可以由适当的运行时使用，以便在指定的调用点对编译后的帧进行去优化。最多可以有一个”<code>deopt</code>“操作数绑定附加到调用点。逆优化（Deoptimization）的确切细节超出了语言参考的范围，但它通常涉及将编译帧重写为一组解释帧。</p><p>从编译器的角度来看，逆优化（Deoptimization）操作数绑定使得它们所连接的调用点至少是<code>readonly</code>。他们通读他们所有的指针类型操作数（即使它们没有被转义）和整个可见的堆。逆优化操作数绑定不会捕获它们的操作数，除非在逆优化过程中，在这种情况下，控制将不会返回到编译帧。</p><p>内联器知道如何通过具有逆优化操作数绑定的调用进行内联。就像通过一个正常的调用点进行内联，包括构成正常的和特殊的延续一样，通过调用点内联去耦优化操作数捆绑定需要适当地组成“安全”去优化延续。内联器通过在内联体中对每个逆优化延续预先实现父代的逆优化延续。例如内联<code>@f</code>到<code>@g</code>在下面的例子中:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define void @f() &#123;</span><br><span class="line">  call void @x()  ;; no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @g() &#123;</span><br><span class="line">  call void @f() [ &quot;deopt&quot;(i32 20) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会导致<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define void @g() &#123;</span><br><span class="line">  call void @x()  ;; still no deopt state</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10) ]</span><br><span class="line">  call void @y() [ &quot;deopt&quot;(i32 20, i32 10), &quot;unknown&quot;(i8* null) ]</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>前端(frontend)的责任是以句法上将调用者的逆最优化状态预先加入到被调用者的逆最优化状态的方式来构造或编码逆最优化状态，这在语义上等同于在被调用者的逆最佳化延续之后构成调用者的逆最佳化延续。</p><h4 id="Funclet操作数捆绑"><a href="#Funclet操作数捆绑" class="headerlink" title="Funclet操作数捆绑"></a>Funclet操作数捆绑</h4><p>Funclet操作数绑定由”<code>funclet</code>“操作数绑定标签表征。这些操作数绑定表明调用点位于特定<code>funclet</code>内。最多可以有一个”<code>funclet</code>“操作数绑定附加到调用点，并且它必须只有一个捆绑操作数。</p><p>如果任何<code>funclet</code> EH焊盘(pads)已被“entered”但不是“exited”（根据<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvRXhjZXB0aW9uSGFuZGxpbmcuaHRtbCN3aW5laC1jb25zdHJhaW50cw==" title="http://llvm.org/docs/ExceptionHandling.html#wineh-constraints">EH文档中的描述<i class="fa fa-external-link"></i></span>），则对下面的执行一个call或者invoke是未定义的行为：</p><ul><li>没有”<code>funclet</code>“捆绑，并且不是对nounwind intrinsic的call，或者</li><li>有一个”<code>funclet</code>绑定，它的操作数不是最近输入的尚未退出funclet EH板（pad）。</li></ul><p>类似地，如果没有funclet EH焊盘（pads）进入但尚未退出，在一个”<code>funclet</code>“bundle中执行一个call或invoke是未定义的行为。</p><h4 id="GC转换操作数绑定"><a href="#GC转换操作数绑定" class="headerlink" title="GC转换操作数绑定"></a>GC转换操作数绑定</h4><p>GC转换操作数绑定由”gc-transition”操作数绑定标记表征。这些操作数绑定将一个调用标记为具有一个GC策略的函数与具有不同GC策略的函数之间的过渡。如果协调GC策略之间的转换需要在调用点生成额外的代码，则这些软件绑定可能包含生成的代码所需的任何值。有关更多详细信息，请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvU3RhdGVwb2ludHMuaHRtbCNnYy10cmFuc2l0aW9uLWFyZ3M=" title="http://llvm.org/docs/Statepoints.html#gc-transition-args">GC转场<i class="fa fa-external-link"></i></span>。</p><h3 id="模块级内联汇编"><a href="#模块级内联汇编" class="headerlink" title="模块级内联汇编"></a>模块级内联汇编</h3><p>模块可能包含“模块级内联asm”块，它对应于GCC“文件范围inline asm”块。这些块由LLVM内部连接并作为一个单元进行处理，但如果需要可以在<code>.ll</code>文件中分开。语法非常简单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module asm &quot;inline asm code goes here&quot;</span><br><span class="line">module asm &quot;more can go here&quot;</span><br></pre></td></tr></table></figure><p></p><p>字符串可以通过转义不可打印的字符来包含任何字符。使用的转义序列只是“\xx”，其中“xx”是数字的两位十六进制代码。</p><p>请注意，汇编字符串必须由LLVM的集成汇编程序解析（除非它被禁用），即使在发送<code>.s</code>文件时也是如此。</p><h3 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h3><p>模块可以指定目标特定数据布局字符串，该字符串指定数据如何布置在内存中。数据布局的语法很简单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target datalayout = &quot;layout specification&quot;</span><br></pre></td></tr></table></figure><p></p><p>该布局规范包括规范用减号字符分隔（“-”）的列表中。每个规范都以字母开头，并可能在字母后包含其他信息以定义数据布局的某些方面。接受的规格如下：</p><ul><li><code>E</code>: 指定目标以big-endian格式显示数据。也就是说，最重要的位具有最低的地址位置。</li><li><code>e</code>: 指定目标以little-endian形式显示数据。也就是说，具有最低重要性的位具有最低的地址位置。</li><li><code>S&lt;size&gt;</code>: 指定堆栈的自然对齐位数。堆栈变量的对齐提升仅限于自然堆栈对齐，以避免动态堆栈重新对齐。堆栈对齐必须是8位的倍数。如果省略，则自然堆栈对齐默认为“未指定”，这不会阻止任何对齐升级。</li><li><code>P&lt;address space&gt;</code>: 指定对应于程序内存的地址空间。哈佛（Harvard）体系结构可以使用它来指定LLVM应该在哪些空间放置诸如函数之类的东西。如果省略，程序存储器空间默认为默认地址空间0，这对应于具有相同空间中的代码和数据的冯诺依曼体系结构。</li><li><code>A&lt;address space&gt;</code>: 指定由’<code>alloca</code>‘创建的对象的地址空间。默认为默认地址空间0。</li><li><code>p[n]:&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;:&lt;idx&gt;</code>: 这将指定大小的指针和它的<code>&lt;abi&gt;</code>和 <code>&lt;pref&gt;</code>错误的地址的空间对齐n。第四个参数<code>&lt;idx&gt;</code>是用于地址计算的索引大小。如果未指定，则默认索引大小等于指针大小。所有尺寸都是位。地址空间n是可选的，如果未指定，则表示默认地址空间0.值n必须在<code>[1,2^23)</code>范围内。</li><li><code>i&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的整数类型的对齐方式。值<code>&lt;size&gt;</code>必须在<code>[1,2^23)</code>范围内。</li><li><code>v&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的向量类型的对齐方式。</li><li><code>f&lt;size&gt;:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了给定<code>&lt;size&gt;</code>位的浮点类型的对齐方式。只有目标支持的<code>&lt;size&gt;</code>值才有效。所有目标都支持32（浮动）和64（双）。一些目标也支持80或128（不同长度的双重版本）。</li><li><code>a:&lt;abi&gt;:&lt;pref&gt;</code>: 这指定了聚合类型对象的对齐方式。</li><li><code>m:&lt;mangling&gt;</code>: 如果存在，则指定llvm名称在输出中被损坏。以mangling转义字符作为前缀的符号<code>\01</code>直接传递给汇编器而不使用转义字符。mangling风格选项是<ul><li><code>e</code>：ELF mangling：专用符号获取<code>.L</code>前缀。</li><li><code>m</code>：Mips mangling：私有符号获取<code>$</code>前缀。</li><li><code>o</code>：Mach-O修改：专用符号获取<code>L</code>前缀。其他符号会得到一个<code>_</code>前缀。</li><li><code>x</code>：Windows x86 COFF mangling：私有符号获取通常的前缀。普通的C符号会得到一个<code>_</code>前缀。带有<code>__stdcall</code>，<code>__fastcall</code>，和<code>__vectorcall</code>的函数具有附加的自定义修剪(mangling)，<code>@N</code>其中N是用于传递参数的字节数。以<code>?</code>开头的C++符号不会以任何方式的变形（mangling）。</li><li><code>w</code>：Windows COFF mangling：类似于<code>x</code>，除了普通的C符号不接受<code>_</code>前缀。</li></ul></li><li><code>n&lt;size1&gt;:&lt;size2&gt;:&lt;size3&gt;...</code>: 这为位目标CPU指定了一组本地整数宽度。例如，它可能包含32位PowerPC的n32，对于PowerPC 64是<code>n32:64</code>或对于X86-64是<code>n8:16:32:64</code>。这组元素被认为可以有效地支持大多数一般的算术运算。</li><li><code>ni:&lt;address space0&gt;:&lt;address space1&gt;:&lt;address space2&gt;...</code>: 这指定具有指定地址空间的指针类型作为<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI25vaW50cHRydHlwZQ==" title="http://llvm.org/docs/LangRef.html#nointptrtype">非整体指针类型<i class="fa fa-external-link"></i></span>。该<code>0</code>地址空间不能被指定为非积分(non-integral)。</li></ul><p>在每个采用的<code>&lt;abi&gt;:&lt;pref&gt;</code>规范上，指定<code>&lt;pref&gt;</code>对齐是可选的。如果省略，则前面的内容也应该省略, 并且<code>&lt;pref&gt;</code>等于<code>&lt;abi&gt;</code>。</p><p>在为给定目标构建数据布局时，LLVM从默认的一组规范开始，然后（可能）由<code>datalayout</code>关键字中的规范覆盖。默认规格在此列表中给出：</p><ul><li><code>E</code> - 大端</li><li><code>p:64:64:64</code> - 与64位对齐的64位指针。</li><li><code>p[n]:64:64:64</code> - 其他地址空间被假定为与默认地址空间相同。</li><li><code>S0</code> - 自然堆栈对齐未指定</li><li><code>i1:8:8</code> - i1是8位（字节）对齐</li><li><code>i8:8:8</code> - i8是8位（字节）对齐</li><li><code>i16:16:16</code> - i16是16位对齐的</li><li><code>i32:32:32</code> - i32是32位对齐的</li><li><code>i64:32:64</code> - i64具有32位的ABI对齐，但优选对齐64位</li><li><code>f16:16:16</code> - 一半是16位对齐的</li><li><code>f32:32:32</code> - 浮点数是32位对齐的</li><li><code>f64:64:64</code> - 双是64位对齐</li><li><code>f128:128:128</code> - 四位是128位对齐</li><li><code>v64:64:64</code> - 64位向量是64位对齐的</li><li><code>v128:128:128</code> - 128位向量是128位对齐的</li><li><code>a:0:64</code> - 聚合是64位对齐</li></ul><p>当LLVM确定给定类型的对齐时，它使用以下规则：</p><ol><li>如果所寻找的类型与其中一个规格完全匹配，则使用该规格。</li><li>如果未找到匹配项，并且所查找的类型是整数类型，则使用大于所查找类型的位宽的最小整数类型。如果没有任何规格大于位宽，则使用最大的整数类型。例如，给定上面的默认规格，<code>i7</code>类型将使用<code>i8</code>（次大）的对齐，而<code>i65</code>和<code>i256</code>将使用<code>i64</code>（最大指定）的对齐。</li><li>如果找不到匹配，并且所寻找的类型是矢量类型，那么将使用小于所寻找的矢量类型的最大矢量类型作为回退。发生这种情况是因为<code>&lt;128 x double&gt;</code>可以用<code>64 &lt;2 x double&gt;</code>来实现，例如。</li></ol><p>数据布局字符串的功能可能不是您所期望的。值得注意的是，这不是来自代码生成器应该使用的对齐前端(frontend)的规范。</p><p>相反，如果指定，则需要目标数据布局来匹配最终代码生成器所期望的内容。这个字符串被中级优化器用来改进代码，这只有在它与最终的代码生成器使用的匹配时才有效。没有办法生成IR，这并不会将这个特定于目标的细节嵌入到IR中。如果您未指定字符串，则将使用默认规格来生成数据布局，并且优化阶段将相应地运行，并针对这些默认规格向IR中引入目标特异性。</p><h3 id="目标机三重表示法-Target-Triple"><a href="#目标机三重表示法-Target-Triple" class="headerlink" title="目标机三重表示法(Target Triple)"></a>目标机三重表示法(Target Triple)</h3><p>模块可以指定描述目标主机的目标机三元字符串。目标三元组的语法很简单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target triple = &quot;x86_64-apple-macosx10.7.0&quot;</span><br></pre></td></tr></table></figure><p></p><p>该目标机三重串包括由减号（“<code>-</code>”）字符分隔的一系列标识符。规范形式是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM</span><br><span class="line">ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT</span><br></pre></td></tr></table></figure><p></p><p>这些信息被传递到后端，以便为适当的架构生成代码。可以使用<code>-mtriple</code>命令行选项在命令行上覆盖它。</p><h3 id="指针别名规则"><a href="#指针别名规则" class="headerlink" title="指针别名规则"></a>指针别名规则</h3><p>任何内存访问都必须通过与内存访问的地址范围关联的指针值来完成，否则行为是不确定的。根据以下规则，指针值与地址范围相关联：</p><ul><li>指针值与关联基于任何值的地址相关联。（这其实是比较绕口的废话）</li><li>全局变量的地址与变量存储的地址范围相关联。</li><li>分配指令的结果值与分配的存储器的地址范围相关联。</li><li>默认地址空间中的空指针与无地址相关联。</li><li>一个非零整数常量或从未在LLVM中定义的函数返回的指针值可能与通过LLVM提供的机制以外的机制分配的地址范围关联。这些范围不得与由LLVM提供的机制分配的任何地址范围重叠。</li></ul><p>根据以下规则，指针值基于另一个指针值：</p><ul><li>由标量<code>getelementptr</code>操作符形成的指针值基于指针类型的操作符<code>getelementptr</code>。</li><li>在车道(lane)中的指针/升的矢量的结果的<code>getelementptr</code>操作是基于对车道(lane)指针升的的类型的载体的指针操作符<code>getelementptr</code>。</li><li><code>bitcast</code>的结果值是基于操作符<code>bitcast</code>。</li><li>由<code>inttoptr</code>形成的指针值是基于对造成（直接或间接）到指针的值的计算中的所有指针值。</li><li>“基于”的关系是传递性的。</li></ul><p>请注意，这个“based”的定义有意地类似于C99 中“based”的定义，尽管它稍微弱一些。</p><p>LLVM IR不会将类型与内存相关联。<code>load</code>的结果类型仅指示要加载的内存的大小和对齐方式，以及对值的解释。类似的第一个操作数类型store仅指示存储的大小和对齐方式。</p><p>因此，基于类型的别名分析，又名TBAA，也就是说<code>-fstrict-aliasing</code>，不适用于通用的非LLVM IR。<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI21ldGFkYXRh" title="http://llvm.org/docs/LangRef.html#metadata">元数据<i class="fa fa-external-link"></i></span>可用于编码额外的信息，专门的优化过程可用于实现基于类型的别名分析。</p><h3 id="易失性-volatile-内存访问"><a href="#易失性-volatile-内存访问" class="headerlink" title="易失性(volatile)内存访问"></a>易失性(volatile)内存访问</h3><p>某些内存访问，如<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktbG9hZA==" title="http://llvm.org/docs/LangRef.html#i-load">load<i class="fa fa-external-link"></i></span>‘s，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktc3RvcmU=" title="http://llvm.org/docs/LangRef.html#i-store">store<i class="fa fa-external-link"></i></span>‘s和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ludC1tZW1jcHk=" title="http://llvm.org/docs/LangRef.html#int-memcpy">llvm.memcpy<i class="fa fa-external-link"></i></span>‘s可能被标记<code>volatile</code>。优化器不得更改易失性操作的数量或更改其相对于其他volatile操作的执行顺序。优化器可以改变相对于非volatile操作的易失性操作的顺序。<b style="color:red">这不是Java的“volatile”，并且没有跨线程同步行为。</b></p><p>即使那些内部函数被标记为<code>volatile</code>，IR级别的volatile加载和存储也不能安全地优化到<code>llvm.memcpy</code>或<code>llvm.memmove</code>内在函数中。同样，后端不应该拆分或合并目标机器合法的易失性加载/存储指令。</p><table><thead><tr><th>合理</th></tr></thead><tbody><tr><td>平台可能依赖volatile加载，并且本地支持的数据宽度存储将作为单条指令执行。例如，在C中，这适用于具有本地硬件支持的易失性基本类型的l值，但不一定适用于聚合类型。前端支持这些预期，这在IR中是故意没有说明的。上述规则确保IR转换不会违反前端（应该是前置的语言）与该语言的合同。</td></tr></tbody></table><h3 id="并发操作的内存模型"><a href="#并发操作的内存模型" class="headerlink" title="并发操作的内存模型"></a>并发操作的内存模型</h3><p>LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有特定于平台的方式来创建它们，并且我们定义LLVM IR他们存在的行为。该模型受C++ 0x内存模型的启发。</p><p>有关此模型的更多非正式介绍，请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQXRvbWljcy5odG1s" title="http://llvm.org/docs/Atomics.html">LLVM原子指令和并发指南<i class="fa fa-external-link"></i></span>。</p><p>我们将发生之前的偏序定义为最小偏序(partial order).</p><ul><li>是单线程程序顺序的超集，并且</li><li>当同步<code>b</code>时，包含一个从<code>a</code>到<code>b</code>的边缘。通过特定于平台的技术（如pthread锁，线程创建，线程连接等）以及原子指令引入同步对。（另请参<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI29yZGVyaW5n" title="http://llvm.org/docs/LangRef.html#ordering">阅原子内存排序约束<i class="fa fa-external-link"></i></span>）。</li></ul><p>请注意，程序顺序不会在线程和该线程内执行的信号之间引入边界之前发生的事件。</p><p>每个（定义的）读取操作（加载指令，memcpy，原子加载/读取-修改-写入等）<code>R</code>读取由（定义的）写入操作写入的一系列字节（存储指令，原子存储/读取-修改-写入，memcpy等）。就本节而言，已初始化的全局变量被认为是写入了初始化程序，它是原子化的，并且在任何其他读或写有问题的内存之前发生。对于读R的每个字节，R<sub>byte</sub> 可能会看到对相同字节的任何写入，除了：</p><ul><li>如果write<sub>1</sub> 发生在write<sub>2</sub>之前，并且write<sub>2</sub>发生在R<sub>byte</sub>之前，则R<sub>byte</sub>不会看到Write<sub>1</sub>。</li><li>如果R<sub>byte</sub>在write<sub>3</sub>之前发生，则R<sub>byte</sub>不会看到write<sub>3</sub>。</li></ul><p>鉴于该定义，R<sub>byte</sub>定义如下：</p><ul><li>如果R是volatile的，则结果与目标相关。（Volatile应该提供可以在C/C++中支持<code>sig_atomic_t</code>的保证，并且可以用于访问不像正常内存那样行为的地址，它通常不会提供跨线程同步。）</li><li>否则，如果没有写入R<sub>byte</sub>发生之前的相同字节，则R<sub>byte</sub>会对该字节返回<code>undef</code>。</li><li>否则，如果R<sub>byte</sub>可能只看到一次写入，则R<sub>byte</sub>将返回该写入写入的值。</li><li>否则，如果R是原子的，并且所有写入的R<sub>byte</sub>可能看到的都是原子的，它将选择其中一个写入的值。请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI29yZGVyaW5n" title="http://llvm.org/docs/LangRef.html#ordering">原子内存排序约束<i class="fa fa-external-link"></i></span>部分了解如何进行选择的其他限制条件。</li><li>否则R<sub>byte</sub>返回undef。</li></ul><p>R返回由它读取的一系列字节组成的值。这意味着该值内的一些字节可能是<code>undef</code>，没有整个值的<code>undef</code>。请注意，这只定义了操作的语义; 这并不意味着目标将发出多个指令来读取一系列字节。</p><p>请注意，在没有使用任何原子内在函数的情况下，此模型仅对单线程执行所需的IR转换放置一个限制：将store引入可能不会被存储的字节一般是不允许的。（具体来说，在另一个线程可以写入和读取地址的情况下，引入一个store可以改变一个load，可以看到只有一个写入可能看到多个写入的load。）</p><h3 id="原子内存排序约束"><a href="#原子内存排序约束" class="headerlink" title="原子内存排序约束"></a>原子内存排序约束</h3><p>原子指令（<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktY21weGNoZw==" title="http://llvm.org/docs/LangRef.html#i-cmpxchg">cmpxchg<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktYXRvbWljcm13" title="http://llvm.org/docs/LangRef.html#i-atomicrmw">atomicrmw<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZmVuY2U=" title="http://llvm.org/docs/LangRef.html#i-fence">fence<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktbG9hZA==" title="http://llvm.org/docs/LangRef.html#i-load">atomic load<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktc3RvcmU=" title="http://llvm.org/docs/LangRef.html#i-store">atomic store<i class="fa fa-external-link"></i></span>）使用排序参数来确定与它们同步的同一地址上的其他原子指令。这些语义是从Java和C ++ 0x中借用的，但是更通俗一点。如果这些描述不够精确，请检查这些规格（请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQXRvbWljcy5odG1s" title="http://llvm.org/docs/Atomics.html">Atomic指南<i class="fa fa-external-link"></i></span>中的规格参考）。<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZmVuY2U=" title="http://llvm.org/docs/LangRef.html#i-fence">fence<i class="fa fa-external-link"></i></span>指令对待这些排序有些不同，因为他们没有收到地址。有关详细信息，请参阅该说明文档。</p><p>有关排序约束的更简单介绍，请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQXRvbWljcy5odG1s" title="http://llvm.org/docs/Atomics.html">LLVM原子指令和并发指南<i class="fa fa-external-link"></i></span>。</p><ul><li><code>unordered</code>: 可以读取的一组值由发生前的部分顺序决定。除非某些操作写入，否则无法读取值。这旨在提供足够强大的保证来模拟Java的非volatile共享变量。此顺序不能指定为读取-修改-写入操作; 它不足以使它们以任何有趣的方式成为原子。</li><li><code>monotonic</code>: 除了保证<code>unordered</code>之外，每个地址上的<code>monotonic</code>操作都有单个总顺序。所有修改顺序都必须与先发生的订单兼容。不能保证修改顺序可以合并到整个程序的全局总顺序中（而这通常是不可能的）。原子读取-修改-写入操作（<code>cmpxchg</code>和<code>atomicrmw</code>）中的读取会在写入值之前立即读取修改顺序中的值。如果在同一地址的另一个原子读取之前发生一次原子读取，则稍后的读取必须在地址的修改顺序中看到相同的值或更高的值。这不允许重新排序<code>monotonic</code>（或更强大）的操作。如果地址是由一个线程<code>monotonic-ally</code>写入和其他线程monotonic-ally读取的 - 反复读取该地址，其他线程最终必须看到写入。这对应于C++ 0x/C1x的<code>memory_order_relaxed</code>。</li><li><code>acquire</code>: 除了<code>monotonic</code>的保障，一个进行同步边缘可以与形成release操作。这是为了模拟C++的<code>memory_order_acquire</code>。</li><li><code>release</code>: 除了保证<code>monotonic</code>，如果此操作写入随后由<code>acquire</code>操作读取的值，则与该操作同步。（这不是一个完整的描述;请参阅发布序列的C++0x定义。）这对应于C ++ 0x/C1x的<code>memory_order_release</code>。</li><li><code>acq_rel （获取+释放）</code>: <code>acquire</code>和<code>release</code>操作作为地址的一部分。这对应于C ++ 0x / C1x <code>memory_order_acq_rel</code>。</li><li><code>seq_cst （顺序一致）</code>: 除了保证<code>acq_rel</code>（<code>acquire</code>对于仅读取的操作，<code>release</code>对于仅写入的操作），对于所有地址上的所有顺序一致的操作，存在全局总顺序，这与在部分顺序之前发生的以及与所有受影响地址的修改顺序一致。每个按顺序一致的读取将按照此全局顺序查看最后一个先前写入相同地址的内容。这对应于C ++ 0x / C1x <code>memory_order_seq_cst</code>和Java <code>volatile</code>。</li></ul><p>如果标记了一个原子操作<code>syncscope(&quot;singlethread&quot;)</code>，它只会同步并仅参与在同一线程中运行的其他操作（例如，在信号处理程序中）的<code>seq_cst</code>总排序。</p><p>如果标记了一个原子操作<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>，其中 <code>&lt;target-scope&gt;</code>是目标特定的同步范围，那么它与目标相关，如果它与其他操作的<code>seq_cst</code>总排序同步并参与其中。</p><p>否则，未标记的原子操作<code>syncscope(&quot;singlethread&quot;)</code> 或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code> 与同步和参与未标记<code>syncscope(&quot;singlethread&quot;)</code>或<code>syncscope(&quot;&lt;target-scope&gt;&quot;)</code>的其它操作的<code>seq_cst</code>总排序 。</p><h3 id="浮点环境"><a href="#浮点环境" class="headerlink" title="浮点环境"></a>浮点环境</h3><p>默认的LLVM浮点环境假定浮点指令没有副作用。结果假设为舍入到舍入模式。此环境中不保留浮点异常状态。因此，在这些示例中，不会尝试创建或保留无效操作（SNaN）或零除异常：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  %A = fdiv 0x7ff0000000000001, %X  ; 64-bit SNaN hex value</span><br><span class="line">  %B = fdiv %X, 0.0</span><br><span class="line">Safe:</span><br><span class="line">  %A = NaN</span><br><span class="line">  %B = NaN</span><br></pre></td></tr></table></figure><p></p><p>这种无异常假设的好处是可以自由推测浮点运算，而无需对浮点模型进行任何其他快速数学放松(fast-math relaxations)。</p><p>需要与此不同的行为的代码应使用<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2NvbnN0cmFpbmVkZnA=" title="http://llvm.org/docs/LangRef.html#constrainedfp">约束浮点内部函数<i class="fa fa-external-link"></i></span>。</p><h3 id="快速数学标志"><a href="#快速数学标志" class="headerlink" title="快速数学标志"></a>快速数学标志</h3><p>LLVM IR浮点运算（<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZmFkZA==" title="http://llvm.org/docs/LangRef.html#i-fadd"><code>fadd</code><i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZnN1Yg==" title="http://llvm.org/docs/LangRef.html#i-fsub"><code>fsub</code><i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZm11bA==" title="http://llvm.org/docs/LangRef.html#i-fmul"><code>fmul</code><i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZmRpdg==" title="http://llvm.org/docs/LangRef.html#i-fdiv"><code>fdiv</code><i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZnJlbQ==" title="http://llvm.org/docs/LangRef.html#i-frem"><code>frem</code><i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktZmNtcA==" title="http://llvm.org/docs/LangRef.html#i-fcmp"><code>fcmp</code><i class="fa fa-external-link"></i></span>）和<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1sI2ktY2FsbA==" title="http://llvm.org/docs/LangRef.html#i-call"><code>call</code><i class="fa fa-external-link"></i></span>可以使用以下标志来启用其他不安全的浮点转换。</p><ul><li><code>nnan</code>: 没有NaNs - 允许优化假设参数和结果不是NaN。需要进行这样的优化才能在NaN上保留已定义的行为，但结果的值未定义。</li><li><code>ninf</code>: 无Infs - 允许优化假设参数和结果不是<code>+/-Inf</code>。需要进行这样的优化才能在<code>+/-Inf</code>上保留已定义的行为，但结果的值未定义。</li><li><code>nsz</code>: 无签名零 - 允许优化将零参数或结果的符号视为无关紧要。</li><li><code>arcp</code>: 允许互惠(Reciprocal) - 允许优化使用参数的倒数而不是执行除法。</li><li><code>contract</code>: 允许浮点收缩（例如，融合乘法，然后将加法融合为融合乘加）。</li><li><code>afn</code>: 近似函数 - 允许用近似计算代替函数（<code>sin</code>，<code>log</code>，<code>sqrt</code>等）。有关可应用于LLVM的内在数学函数的位置，请参阅浮点内在定义。</li><li><code>reassoc</code>: 允许重新关联转换为浮点指令。这可能会显着改变浮点结果。</li><li><code>fast</code>: 这个标志暗示其他所有的。</li></ul><h3 id="使用列表顺序指令"><a href="#使用列表顺序指令" class="headerlink" title="使用列表顺序指令"></a>使用列表顺序指令</h3><p>使用列表指令对每个使用列表的内存顺序进行编码，从而允许重新创建订单。<code>&lt;order-indexes&gt;</code>是分配给引用值用途的索引的逗号分隔列表。引用值的使用列表会立即按这些索引排序。</p><p>Use-List指令可能出现在函数作用域或全局作用域中。它们不是指令，对IR的语义没有影响。当它们在函数范围内时，它们必须出现在最终基本块的终止符之后。</p><p>如果基本块的地址是通过<code>blockaddress()</code>表达式获取的， <code>uselistorder_bb</code>则可用于从其函数范围之外对其使用列表重新排序。</p><p>句法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uselistorder &lt;ty&gt; &lt;value&gt;, &#123; &lt;order-indexes&gt; &#125;</span><br><span class="line">uselistorder_bb @function, %block &#123; &lt;order-indexes&gt; &#125;</span><br></pre></td></tr></table></figure><p></p><p>例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define void @foo(i32 %arg1, i32 %arg2) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line">bb:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line"></span><br><span class="line">  ; At function scope.</span><br><span class="line">  uselistorder i32 %arg1, &#123; 1, 0, 2 &#125;</span><br><span class="line">  uselistorder label %bb, &#123; 1, 0 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; At global scope.</span><br><span class="line">uselistorder i32* @global, &#123; 1, 2, 0 &#125;</span><br><span class="line">uselistorder i32 7, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder i32 (i32) @bar, &#123; 1, 0 &#125;</span><br><span class="line">uselistorder_bb @foo, %bb, &#123; 5, 1, 3, 2, 0, 4 &#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="源文件名"><a href="#源文件名" class="headerlink" title="源文件名"></a>源文件名</h3><p>源文件名字符串设置为原来的模块标识符，当通过clang前端从源代码编译时，例如，这将是编译的源文件的名称。然后通过IR和比特码进行保存。</p><p>目前，这对于为配置文件数据中使用的本地函数生成一致的唯一全局标识符是非常必要的，该配置文件将源文件名预先设置为本地函数名称。</p><p>源文件名的语法很简单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_filename = &quot;/path/to/source.c&quot;</span><br></pre></td></tr></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章，翻译起来的确是非常麻烦，由于没有通读全文，里面应该有不少错误的地方，日后会重新修改。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM简介</title>
      <link href="//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%E7%AE%80%E4%BB%8B.html"/>
      <url>//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LLVM%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="什么是LLVM"><a href="#什么是LLVM" class="headerlink" title="什么是LLVM"></a>什么是LLVM</h2><p>官方的解释是：LLVM可以被看作是一系列的编译器和工具链技术的集合，而且它们是模块化并且是可重用的。官方网站是：<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnLw==" title="http://llvm.org/">http://llvm.org/<i class="fa fa-external-link"></i></span> 。 不过从名称上看像一个虚拟机，然而与虚拟机没有一点关系，LLVM是这个项目的名称而已。</p><p>LLVM最初是伊利诺伊大学的一个研究项目，其目标是提供一种现代的，基于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlEJTk5JUU2JTgwJTgxJUU1JThEJTk1JUU4JUI1JThCJUU1JTgwJUJDJUU1JUJEJUEyJUU1JUJDJThG" title="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F">SSA<i class="fa fa-external-link"></i></span>（static single assignment form，静态单赋值形式）的编译策略，能够支持任意编程语言的静态和动态编译。 从那时起，LLVM已经发展成为一个由多个子项目组成的综合项目，其中许多子项目正在各种商业和开源项目的生产中使用，并且被广泛用于学术研究。 LLVM项目中的代码遵循“UIUC”BSD-Style许可证.</p><p>LLVM的主要子项目有：</p><ol><li>LLVM核心库提供了一个独立于现代的源和目标的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvUGFzc2VzLmh0bWw=" title="http://llvm.org/docs/Passes.html">优化器<i class="fa fa-external-link"></i></span>，以及支持许多流行CPU的<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29kZUdlbmVyYXRvci5odG1s" title="http://llvm.org/docs/CodeGenerator.html">代码生成<i class="fa fa-external-link"></i></span>（以及一些不太常见的CPU）。这些库是围绕一个<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvTGFuZ1JlZi5odG1s" title="http://llvm.org/docs/LangRef.html">良好规范<i class="fa fa-external-link"></i></span>的代码表示而建立的，称为LLVM<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU5JTk2JTkzJUU4JUFBJTlFJUU4JUE4JTgw" title="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%96%93%E8%AA%9E%E8%A8%80">中间语言<i class="fa fa-external-link"></i></span>（“LLVM IR”）。 LLVM Core库有<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3Mv" title="http://llvm.org/docs/">详细的文档<i class="fa fa-external-link"></i></span>，并且<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvdHV0b3JpYWwv" title="http://llvm.org/docs/tutorial/">使用LLVM用作优化器和代码生成器<i class="fa fa-external-link"></i></span>，将使你特别容易地将创建自己的语言（或移植现有的编译器）。</li><li><span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnLw==" title="http://clang.llvm.org/">Clang<i class="fa fa-external-link"></i></span>是一种“LLVM原生”的C/C++/Objective-C编译器，它旨在提供惊人的快速编译（例如，在编译调试配置中编译Objective-C代码时<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2ZlYXR1cmVzLmh0bWwjcGVyZm9ybWFuY2U=" title="http://clang.llvm.org/features.html#performance">比GCC快大约3倍<i class="fa fa-external-link"></i></span>），非常有用的<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RpYWdub3N0aWNzLmh0bWw=" title="http://clang.llvm.org/diagnostics.html">错误和警告消息<i class="fa fa-external-link"></i></span>，为构建优秀的源代码级工具提供了一个平台。<span class="exturl" data-url="aHR0cDovL2NsYW5nLWFuYWx5emVyLmxsdm0ub3JnLw==" title="http://clang-analyzer.llvm.org/">Clang静态分析器<i class="fa fa-external-link"></i></span>是一个可以自动发现代码中的错误的工具，并且它是使用Clang前端作为库来解析C/C++代码的工具。</li><li><span class="exturl" data-url="aHR0cDovL2xsZGIubGx2bS5vcmcv" title="http://lldb.llvm.org/">LLDB<i class="fa fa-external-link"></i></span>项目建立在由LLVM和Clang提供的库上，以提供一个出色的本地调试器。 它使用Clang AST和表达式解析器，LLVM JIT，LLVM反汇编器等，以便提供“正常工作”的体验。 在加载符号时，它比GDB更快速，内存效率更高。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmN4eC5sbHZtLm9yZy8=" title="http://libcxx.llvm.org/">libc++<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL2xpYmN4eGFiaS5sbHZtLm9yZy8=" title="http://libcxxabi.llvm.org/">libc++ ABI<i class="fa fa-external-link"></i></span>项目提供了C++标准库的标准一致性和高性能实现，包括对C++11的全面支持。</li><li><span class="exturl" data-url="aHR0cDovL2NvbXBpbGVyLXJ0Lmxsdm0ub3JnLw==" title="http://compiler-rt.llvm.org/">编译器rt<i class="fa fa-external-link"></i></span>项目提供高级优化的低级代码生成器支持例程的实现，例如<code>“__fixunsdfdi”</code>以及当目标没有执行核心IR操作的短序列本机指令时生成的其他调用。 它还为动态测试工具（如<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvQWRkcmVzc1Nhbml0aXplci5odG1s" title="http://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvVGhyZWFkU2FuaXRpemVyLmh0bWw=" title="http://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvTWVtb3J5U2FuaXRpemVyLmh0bWw=" title="http://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL2NsYW5nLmxsdm0ub3JnL2RvY3MvRGF0YUZsb3dTYW5pdGl6ZXIuaHRtbA==" title="http://clang.llvm.org/docs/DataFlowSanitizer.html">DataFlowSanitizer<i class="fa fa-external-link"></i></span>）提供了运行时库的实现。</li><li><span class="exturl" data-url="aHR0cDovL29wZW5tcC5sbHZtLm9yZy8=" title="http://openmp.llvm.org/">OpenMP<i class="fa fa-external-link"></i></span>子项目提供<span class="exturl" data-url="aHR0cDovL3d3dy5vcGVubXAub3JnLw==" title="http://www.openmp.org/">OpenMP<i class="fa fa-external-link"></i></span> Runtime，以便与Clang中的OpenMP实现一起使用。</li><li><span class="exturl" data-url="aHR0cDovL3BvbGx5Lmxsdm0ub3JnLw==" title="http://polly.llvm.org/">polly<i class="fa fa-external-link"></i></span>项目实现了一套缓存局部优化以及使用多面体模型的自动并行和向量化。</li><li><span class="exturl" data-url="aHR0cDovL2xpYmNsYy5sbHZtLm9yZy8=" title="http://libclc.llvm.org/">libclc<i class="fa fa-external-link"></i></span>项目旨在实现OpenCL标准库。</li><li><span class="exturl" data-url="aHR0cDovL2tsZWUubGx2bS5vcmcv" title="http://klee.llvm.org/">klee<i class="fa fa-external-link"></i></span>项目实现了一个“符号虚拟机”，它使用定理证明器来尝试评估程序中的所有动态路径，以努力寻找错误并证明函数的属性。 klee的一个主要特点是它可以在检测到错误的情况下生成一个测试用例。</li><li><span class="exturl" data-url="aHR0cDovL3NhZmVjb2RlLmNzLmlsbGlub2lzLmVkdS8=" title="http://safecode.cs.illinois.edu/">SAFECode<i class="fa fa-external-link"></i></span>项目是用于C/C++程序的内存安全编译器。它使用运行时检查代码来检测运行时的内存安全错误（例如，缓冲区溢出）。它可以用来保护软件免受安全攻击，也可以用作Valgrind之类的内存安全错误调试工具。</li><li><span class="exturl" data-url="aHR0cDovL2xsZC5sbHZtLm9yZy8=" title="http://lld.llvm.org/">lld<i class="fa fa-external-link"></i></span>项目旨在成为clang/llvm的内置链接器。目前，clang必须调用系统链接器来生成可执行文件。</li></ol><p>除了LLVM的官方子项目之外，还有各种各样<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL1Byb2plY3RzV2l0aExMVk0v" title="http://llvm.org/ProjectsWithLLVM/">使用LLVM组件执行各种任务的其他项目<i class="fa fa-external-link"></i></span>。 通过这些外部项目，您可以使用LLVM编译Ruby，Python，Haskell，Java，D，PHP，Pure，Lua和一些其他语言。 LLVM的一个主要优势是其多功能性，灵活性和可重用性，这就是为什么它被用于如此广泛的各种不同任务的原因：从Lua等嵌入式语言的轻量级JIT编译到编译Fortran代码以实现大规模超级电脑。</p><p>和其他所有事情一样，LLVM拥有广泛而友好的社区，他们对构建优秀的底层工具感兴趣。如果您有兴趣参与，首先要浏览<span class="exturl" data-url="aHR0cDovL2Jsb2cubGx2bS5vcmcv" title="http://blog.llvm.org/">LLVM博客<i class="fa fa-external-link"></i></span>并注册<span class="exturl" data-url="aHR0cDovL2xpc3RzLmxsdm0ub3JnL21haWxtYW4vbGlzdGluZm8vbGx2bS1kZXY=" title="http://lists.llvm.org/mailman/listinfo/llvm-dev">LLVM Developer邮件列表<i class="fa fa-external-link"></i></span>。 有关如何发送补丁程序，获取提交权限以及版权和许可证主题的信息，请参阅<span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvRGV2ZWxvcGVyUG9saWN5Lmh0bWw=" title="http://llvm.org/docs/DeveloperPolicy.html">LLVM开发者规则<i class="fa fa-external-link"></i></span>。</p><h2 id="关于LLVM"><a href="#关于LLVM" class="headerlink" title="关于LLVM"></a><b style="color:red">关于LLVM</b></h2><p><b style="color:green">看上面的说明可能有点懵，但其实就是LLVM定义了一种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUFEJUU5JTk2JTkzJUU4JUFBJTlFJUU4JUE4JTgw" title="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%96%93%E8%AA%9E%E8%A8%80">中间语言<i class="fa fa-external-link"></i></span>或称<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgwJTlBJUU3JTk0JUE4JUU0JUI4JUFEJUU5JTk3JUI0JUU4JUFGJUFEJUU4JUE4JTgw" title="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80">通用中间语言<i class="fa fa-external-link"></i></span>,提供了丰富的中间码(IR),这样就为我们创建自己的语言提供了极大的便利，其实就是感觉自己用IR去生成自己的命令，类似于CPU中的微指令了。另外就是将自己的语言转成对应的LLVM IR，那么就可以直接使用LLVM子项目中的JIT，这样你就不用自己写虚拟机了，的确是带来了极大的遍历。</b></p><p><b style="color:#00f">再比如像solidity这样的语言需要运行在以太坊的CPP节点，Go节点，Parity的Scala节点，这样的话我们要写很多的编译器和虚拟机，但是有了LLVM后，一切都不用担心了，实现起来还是比较靠谱的，不是吗？</b></p><p><b style="color:green">另外通过LLVM我们可以实现不同语言之间的互转，比如C++代码转成node代码。中间只要通过LLVM就可以了。以前不明白微软怎么支持多种语言实现在win10上安装，现在终于有思路了，只是微软要写多种编译器，可能这个过程比较难吧，他们放弃了。还有就比如以太坊的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3NvbGMtYmlu" title="https://github.com/ethereum/solc-bin">solc-bin<i class="fa fa-external-link"></i></span>里面有用的文件只有一个7M多的js文件，而且还是压缩的，从ReadMe中我们可以发现，这个项目中的文件都是通过emscripten生成的；而emscripten是将LLVM中间语言转化为node代码，一切已然明了。</b></p><p><b style="color:#00f">所以我觉得学习LLVM语言还是很有必要的过程，应该深入去学习一下。</b></p><h2 id="关于emscripten"><a href="#关于emscripten" class="headerlink" title="关于emscripten"></a>关于emscripten</h2><p>这是一个很棒的项目，将LLVM中间语言转化为node的代码。更多的东西就不用多介绍了，也不进行深入地学习了，这要精通node的编译器和语法知识才行，我就读读Readme、WIKI和api文档就好了。下面列一下学习的资料吧！<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbg==" title="https://github.com/kripken/emscripten">官方github项目<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tyaXBrZW4vZW1zY3JpcHRlbi93aWtp" title="https://github.com/kripken/emscripten/wiki">Emscripten Wiki<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2tyaXBrZW4uZ2l0aHViLmlvL2Vtc2NyaXB0ZW4tc2l0ZS9pbmRleC5odG1s" title="http://kripken.github.io/emscripten-site/index.html">Emscripten 文档<i class="fa fa-external-link"></i></span></p><h2 id="LLVM的命令指南"><a href="#LLVM的命令指南" class="headerlink" title="LLVM的命令指南"></a>LLVM的命令指南</h2><p>以下文档是所有LLVM工具的命令描述。 这些页面描述如何使用LLVM命令以及它们的选项。 请注意，这些页面没有描述所有工具可用的所有选项。 要获得完整列表，请将–help（常规选项）或–help-hidden（常规和调试选项）参数传递给您感兴趣的工具。</p><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tYXMuaHRtbA==" title="http://llvm.org/docs/CommandGuide/llvm-as.html">llvm-as - LLVM汇编程序<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tZGlzLmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-dis.html">llvm-dis - LLVM反汇编程序<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL29wdC5odG1s" title="http://llvm.org/docs/CommandGuide/opt.html">opt - LLVM优化器<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsYy5odG1s" title="http://llvm.org/docs/CommandGuide/llc.html">llc - LLVM静态编译器<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsaS5odG1s" title="http://llvm.org/docs/CommandGuide/lli.html">lli - 直接从LLVM位码执行程序<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tbGluay5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-link.html">llvm-link - LLVM位码链接器<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tYXIuaHRtbA==" title="http://llvm.org/docs/CommandGuide/llvm-ar.html">llvm-ar - LLVM归档打包 archiver<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tbGliLmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-lib.html">llvm-lib - LLVM lib.exe lib.exe兼容库工具<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tbm0uaHRtbA==" title="http://llvm.org/docs/CommandGuide/llvm-nm.html">llvm-nm - 列出LLVM位码和目标文件的符号表<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tY29uZmlnLmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-config.html">llvm-config - 打印LLVM编译选项<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tZGlmZi5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-diff.html">llvm-diff - LLVM结构差异<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tY292Lmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-cov.html">llvm-cov - 发布覆盖信息<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tcHJvZmRhdGEuaHRtbA==" title="http://llvm.org/docs/CommandGuide/llvm-profdata.html">llvm-profdata - 配置数据工具<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tc3RyZXNzLmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-stress.html">llvm-stress - 生成随机的.ll文件<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tc3ltYm9saXplci5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-symbolizer.html">llvm-symbolizer - 将地址转换为源代码位置<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tZHdhcmZkdW1wLmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-dwarfdump.html">llvm-dwarfdump - 转储并验证DWARF调试信息<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2RzeW11dGlsLmh0bWw=" title="http://llvm.org/docs/CommandGuide/dsymutil.html">dsymutil - 处理归档的DWARF调试符号文件<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tbWNhLmh0bWw=" title="http://llvm.org/docs/CommandGuide/llvm-mca.html">llvm-mca - LLVM机器代码分析器<i class="fa fa-external-link"></i></span></li></ul><h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2J1Z3BvaW50Lmh0bWw=" title="http://llvm.org/docs/CommandGuide/bugpoint.html">bugpoint - 自动测试案例缩减工具<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tZXh0cmFjdC5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-extract.html">llvm-extract - 从LLVM模块中提取函数<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tYmNhbmFseXplci5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html">llvm-bcanalyzer - LLVM位码分析器<i class="fa fa-external-link"></i></span></li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL0ZpbGVDaGVjay5odG1s" title="http://llvm.org/docs/CommandGuide/FileCheck.html">FileCheck - 灵活的模式匹配文件验证器<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL3RibGdlbi5odG1s" title="http://llvm.org/docs/CommandGuide/tblgen.html">tblgen - 目标描述到C ++代码生成器<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xpdC5odG1s" title="http://llvm.org/docs/CommandGuide/lit.html">lit - LLVM综合测试仪<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tYnVpbGQuaHRtbA==" title="http://llvm.org/docs/CommandGuide/llvm-build.html">llvm-build - LLVM项目构建实用程序<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tZXhlZ2VzaXMuaHRtbA==" title="http://llvm.org/docs/CommandGuide/llvm-exegesis.html">llvm-exegesis - LLVM机器指令基准<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tcGRidXRpbC5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-pdbutil.html">llvm-pdbutil - PDB文件取证和诊断<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlL2xsdm0tcmVhZG9iai5odG1s" title="http://llvm.org/docs/CommandGuide/llvm-readobj.html">llvm-readobj - LLVM对象读取器<i class="fa fa-external-link"></i></span></li></ul><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnLw==" title="http://llvm.org/">The LLVM Compiler Infrastructure<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2xsdm0ub3JnL2RvY3MvQ29tbWFuZEd1aWRlLw==" title="http://llvm.org/docs/CommandGuide/">LLVM Command Guide<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nuc24xOTg0L2FydGljbGUvZGV0YWlscy84MjMyOTQz" title="https://blog.csdn.net/snsn1984/article/details/8232943">LLVM每日谈之七 Clang<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nuc24xOTg0L2FydGljbGUvZGV0YWlscy84NTkzMzgw" title="https://blog.csdn.net/snsn1984/article/details/8593380">七天LLVM零基础入门（Linux版本）——第一天<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的汇编程序快速指南</title>
      <link href="//golang/Go%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97.html"/>
      <url>//golang/Go%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>近日在研究solidity语言的时候，发现了很多关于汇编的有趣知识，感觉知识无涯，勤奋是道呀！要学习的东西还是很多的，今天就来研究一下这个Go语言的汇编。本文是参考Go语言官方的文档，好像这个没有详细的文档，就先入个门吧！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档提到里面的内容是不全面的，试问全面的在哪？</p><p>Go的汇编语言基于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUIyJTlEJUU3JTg4JUJFJUU1JUFGJUE2JUU5JUE5JTk3JUU1JUFFJUE0JUU0JUI5JTlEJUU4JTk5JTlGJUU4JUE4JTg4JUU3JTk1JUFC" title="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB">Plan 9<i class="fa fa-external-link"></i></span>的汇编，<span class="exturl" data-url="aHR0cHM6Ly85cC5pby9wbGFuOS8=" title="https://9p.io/plan9/">Plan 9网站<i class="fa fa-external-link"></i></span>的页面上有详细描述。如果你想编写汇编语言，你应该读<span class="exturl" data-url="aHR0cHM6Ly85cC5pby9zeXMvZG9jL2FzbS5odG1s" title="https://9p.io/sys/doc/asm.html">这篇文档<i class="fa fa-external-link"></i></span>，虽然它是Plan 9相关的。这边文档总结了汇编的语法，并且描述了使用汇编语言和Go程序交互时的特殊之处。</p><p>有一点是很重要的是，Go的汇编中没有直接体现出底层的机器。有些汇编细节能直接对应到机器，但有些不是。这是因为编译器套件在常规过程中不需要汇编语言。取而代之的是，编译器产生二进制的不完整的汇编指令集，链接器会完成它。<b style="color:#00f">实际上，链接器做了汇编指令的选择，所以当你看到类似于MOV这样的指令，链接器的实际操作可能不是一个移动指令，也许是清除或者载入</b>。或者可能会根据指令的名字对应到真实的机器指令。总体上，机器相关的指令操作趋向于体现出真实的机器指令，但是一些通用的概念类似于移动内存数据、调用子例程、返回等操作就更抽象了。具体的细节和架构相关，我们为这种不精确性道歉;情况并不明确。</p><p>汇编程序是生成中间码的一种方法，未完整定义的指令集作为链接器的输入。如果你想看到特定CPU架构下的汇编指令集，如amd64，在Go标准库的源文件中就有许多例子，在<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9ydW50aW1lLw==" title="https://golang.org/pkg/runtime/">runtime<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9tYXRoL2JpZy8=" title="https://golang.org/pkg/math/big/">math/big<i class="fa fa-external-link"></i></span>包中。 或者你还可以参照下面的程序，来检查编译器的汇编输出：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat x.go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">println(3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> GOOS=linux GOARCH=amd64 go tool compile -S x.go        <span class="comment"># or: go build -gcflags -S x.go</span></span></span><br><span class="line"></span><br><span class="line">--- prog list "main" ---</span><br><span class="line">0000 (x.go:3) TEXT    main+0(SB),$8-0</span><br><span class="line">0001 (x.go:3) FUNCDATA $0,gcargs·0+0(SB)</span><br><span class="line">0002 (x.go:3) FUNCDATA $1,gclocals·0+0(SB)</span><br><span class="line">0003 (x.go:4) MOVQ    $3,(SP)</span><br><span class="line">0004 (x.go:4) PCDATA  $0,$8</span><br><span class="line">0005 (x.go:4) CALL    ,runtime.printint+0(SB)</span><br><span class="line">0006 (x.go:4) PCDATA  $0,$-1</span><br><span class="line">0007 (x.go:4) PCDATA  $0,$0</span><br><span class="line">0008 (x.go:4) CALL    ,runtime.printnl+0(SB)</span><br><span class="line">0009 (x.go:4) PCDATA  $0,$-1</span><br><span class="line">0010 (x.go:5) RET     ,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><p>FUNCDATA和PCDATA指令包含一些垃圾收集器需要的信息。它们由编译器产生。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>尽管汇编程序从Plan 9汇编程序中获得了指导，但它是一个独特的程序，因此存在一些差异。一个是不断的评估。汇编器中的常量表达式使用Go的运算符优先级解析，而不是原始的类C优先级。因此<code>3&amp;1&lt;&lt;2</code>是4，而不是0–它解析为<code>(3&amp;1)&lt;&lt;2</code> 不是<code>3&amp;(1&lt;&lt;2)</code>。而且，常量总是被评估为64位无符号整数。因此-2，不是整数值负2，而是具有相同位模式的无符号64位整数。这种区别无关紧要，但是这是为了当右操作数的高位被设置，避免除法或右移的歧义性。</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>一些符号（如R1或LR）是预定义的，并且指的是寄存器。确切的集合取决于体系结构。</p><p><b style="color:red">有四个预先标记的符号表示伪寄存器。这些不是真正的寄存器，而是由工具链维护的虚拟寄存器，例如帧指针</b>。所有体系结构的伪寄存器组都是相同的：</p><ul><li>FP：帧（frame）指针：参数和本地变量。</li><li>PC：程序计数器：跳转和分支。</li><li>SB：静态基址指针：全局符号。</li><li>SP：堆栈指针：堆栈顶部。</li></ul><p>所有用户定义的符号都被写为伪寄存器FP（参数和本地变量）和SB（全局）的偏移量 。</p><p>SB伪寄存器可以被认为是内存的原点，所以符号<code>foo(SB)</code>的名称是foo在内存中的地址。这种格式用于命名全局函数和数据。在名称中添加&lt;&gt;，就像<code>foo&lt;&gt;(SB)</code>一样，那么该名称只能在当前源文件中看到，就像C文件中的<code>static</code>顶级声明。给名称添加一个偏移量就是指符号地址的偏移量，因此<code>foo+4(SB)</code>是foo开始处的四个字节。</p><p><code>FP</code>伪寄存器是用来指向函数参数的虚拟帧指针。编译器维护一个虚拟帧指针，并将堆栈中的参数作为该伪寄存器的偏移量。因此<code>0(FP)</code>是函数的第一个参数，<code>8(FP)</code>第二个参数（在64位机器上）等等。但是，当以这种方式引用函数参数时，有必要在开始处放置一个名称，如<code>first_arg+0(FP)</code>和<code>second_arg+8(FP)</code>。（帧指针的偏移量，偏移量的含义 - 与其使用SB的偏移量不同，它是与符号的偏移量。）有些汇编程序强制执行这个约定，拒绝普通的<code>0(FP)</code>和<code>8(FP)</code>。实际名称在语义上不相关，但应该用来记录参数的名称。值得强调的是<code>FP</code>始终是伪寄存器，而不是硬件寄存器，即使在具有硬件帧指针的体系结构中也是如此。</p><p>对于使用Go的汇编函数，<code>go vet</code>将检查参数名称和偏移量是否匹配。在32位系统上，64位值的低32位和高32位通过在名称中添加<code>_lo</code>或<code>_hi</code>后缀来区分，如<code>arg_lo+0(FP)</code>或<code>arg_hi+4(FP)</code>。如果Go原型没有命名它的结果，那么预期的汇编名称是<code>ret</code>。</p><p><code>SP</code>伪寄存器是虚拟堆栈指针，用来指向帧局部变量和为函数调用准备的参数。它指向本地堆栈帧的顶部，因此引用应使用负数表示的范围<code>[-framesize，0）</code>中：例如：<code>x-8(SP)</code>，<code>y-4(SP)</code>等等。</p><p><b style="color:#00f">在名<code>SP</code>为硬件寄存器的体系结构中，名称前缀将对虚拟堆栈指针的引用与对帧（frame）SP寄存器的引用进行区分。即，<code>x-8(SP)</code>和<code>-8(SP)</code> 是不同的存储位置：所述第一指虚拟堆栈指针伪寄存器，而第二指硬件的SP寄存器。</b></p><p><b style="color:#00f">在物理机器上SP和PC是传统的物理地址寄存器中的别名，在Go汇编中名称SP和PC仍然特殊处理; 例如，SP引用要求符号，很像FP。要访问实际的硬件寄存器，请使用真实的寄存器名称。例如，在ARM体系结构上的硬件上硬件SP，PC可作为R13和R15访问。</b></p><p>分支和直接跳转总是在PC中写为的偏移量，或跳转到标签：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">MOVW $0, R1</span><br><span class="line">JMP label</span><br></pre></td></tr></table></figure><p></p><p>每个标签只能在其定义的函数中可见。因此允许文件中的多个函数定义和使用相同的标签名称。直接跳转和调用指令可以将文本符号作为目标，例如<code>name(SB)</code>,但不是符号的偏移量<code>name+4(SB)</code>。</p><p>指令，寄存器和汇编程序指令总是以大写形式提醒您，汇编编程是一项艰巨的工作。（例外：在ARM平台下，代表当前goroutine的g寄存器被重新命名。）</p><p>在Go对象文件和二进制文件中，符号的完整名字是包的路径加上一个句点：<code>fmt.Printf</code>或<code>math/rand.Int</code>。由于汇编器的解析器将句点和斜线视为标点符号，因此这些字符串不能直接用作标识符名称。相反，汇编程序允许标识符中的中点字符<code>U+00B7</code>和除法斜杠<code>U+2215</code>，并将它们重写为纯句点和斜杠。在汇编源代码文件中，上面的符号写成<code>fmt·Printf</code>和<code>math∕rand·Int</code>。通过在编译时使用-S标志看到的汇编代码列表中直接显示了句点和斜杠，而不是在汇编程序中需要的Unicode替代字符(指上面的两个特殊Unicode字符)。</p><p>大部分手写的汇编文件中，不要在符号名中包含完整的包路径，因为链接器会在任何以句点开头的名字前面插入当前对象文件的路径：包含<code>math/rand</code>包的汇编源文件中，rand包的Int函数可以当做<code>·Int</code>来引用。这种便捷性避免了需要在自身的源代码中硬编码导入路径，可以让代码从一个地方移动到另一个地方时变得更容易。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>汇编程序使用各种指令将文本和数据绑定到符号名称。例如，这里是一个简单但是完整的函数定义。<code>TEXT</code>指令声明符号<code>runtime·profileloop</code>, 指令紧接在类似于函数的主体中。<code>TEXT</code>块中的最后一条指令必须是某种跳转，通常是<code>RET</code>（伪）指令。（如果不是，链接器会追加跳转到块自身的指令;<code>TEXT</code>块中没有<code>fallthrough</code>。）在符号之后，参数是<code>标志</code>（见下面）和<code>栈帧</code>的大小，是一个常量（参见下面的代码）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·profileloop(SB),NOSPLIT,$8</span><br><span class="line">    MOVQ    $runtime·profileloop1(SB), CX</span><br><span class="line">    MOVQ    CX, 0(SP)</span><br><span class="line">    CALL    runtime·externalthreadhandler(SB)</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">这个函数的栈帧大小为8字节(MOVQ CX, 0(SP)操作栈指针)，没有参数</b></p><p>一般情况下，栈帧大小后面跟着一个由减号分隔的参数大小。（这不是一个减法，只是特殊的语法。）栈帧大小是<code>$24-8</code>描述该函数有一个24字节的栈帧，并且需要一个8个字节的参数，它位于调用者的栈帧上。如果没有为<code>TEXT</code>指定<code>NOSPLIT</code>标志，则必须提供参数大小。对于使用Go标准的汇编函数，<code>go vet</code>将检查参数大小是否正确。</p><p>请注意，符号名称使用中点分隔组件，并且被定义为从伪寄存器SB开始的一个offsets。在Go源码的runtime包中，使用简称profileloop来调用。</p><p>全局数据符号使用初始化的一系列<code>DATA</code>指令来定义，并且跟在一个<code>GLOBAL</code>指令之后。每个<code>DATA</code>指令初始化一块指定的内存区域。没有明确初始化的内存区域会被置为零。标准的<code>DATA</code>指令形式为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATAsymbol+offset(SB)/width, value</span><br></pre></td></tr></table></figure><p></p><p>这样就初始化了symbol，内存在指定的offset处，带有指定的width和给定的value。一个symbol中的DATA指令必须是逐渐增长的offsets。</p><p><code>GLOBL</code>指令声明一个符号是全局的。参数是可选的标志和需要声明为全局的数据的大小，除非<code>DATA</code>指令已初始化它，否则初始值将全部为零。<code>GLOBAL</code>指令必须跟在对应的<code>DATA</code>指令之后。</p><p>例如，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA divtab&lt;&gt;+0x00(SB)/4, $0xf4f8fcff</span><br><span class="line">DATA divtab&lt;&gt;+0x04(SB)/4, $0xe6eaedf0</span><br><span class="line">...</span><br><span class="line">DATA divtab&lt;&gt;+0x3c(SB)/4, $0x81828384</span><br><span class="line">GLOBL divtab&lt;&gt;(SB), RODATA, $64</span><br><span class="line"></span><br><span class="line">GLOBL runtime·tlsoffset(SB), NOPTR, $4</span><br></pre></td></tr></table></figure><p></p><p>声明并初始化<code>divtab&lt;&gt;</code>, 一个只读的64位<code>table</code>含有4字节的整数值。并声明<code>runtime·tlsoffset</code>一个4字节的，隐式地置零的变量，该变量不包含指针。</p><p>指令可能有一个或两个参数。如果有两个，第一个是比特掩码的标志，它可以写成数字表达式，多个掩码之间可以相加或者做逻辑或运算，或者可以写成友好可读的形式。这些值定义在头文件<code>textflag.h</code>中：</p><ul><li><code>NOPROF = 1</code> (TEXT项使用.) 不优化NOPROF标记的函数。这个标志已废弃。</li><li><code>DUPOK = 2</code> 在二进制文件中允许一个符号的多个实例。链接器会选择其中之一。</li><li><code>NOSPLIT = 4</code> (TEXT项使用.) 不插入预先检测是否将栈空间分裂的代码。程序的栈帧中，如果调用任何其他代码都会增加栈帧的大小，必须在栈顶留出可用空间。用来保护处理栈空间分裂的代码本身。</li><li><code>RODATA = 8</code> (DATA和GLOBAL项使用.) 将这个数据放在只读的块中。</li><li><code>NOPTR = 16</code> (DATA和GLOBAL项使用.)这个数据不包含指针所以就不需要垃圾收集器来扫描。</li><li><code>WRAPPER = 32</code> (TEXT项使用.) This is a wrapper function and should not count as disabling recover.</li><li><code>NEEDCTXT= 64</code> （对于TEXT项目。）这个函数是一个闭包，所以它使用它的传入上下文寄存器。</li></ul><h2 id="协调Runtime"><a href="#协调Runtime" class="headerlink" title="协调Runtime"></a>协调Runtime</h2><p>要使垃圾收集正确运行，运行时必须知道所有全局数据和大多数堆栈帧中指针的位置。Go编译器在编译Go源文件时会发出此信息，但汇编程序必须明确定义这些信息。</p><p>标有NOPTR标志的数据符号（见上面）被视为不包含指向Runtime分配数据的指针。带有<code>RODATA</code>标志的数据符号被分配在只读存储器中，因此被视为隐式标记<code>NOPTR</code>。总的大小小于指针大小的数据符号也被视为隐式标记<code>NOPTR</code>。无法在汇编语言中定义包含指针的符号; 这种符号必须在Go源文件中定义。汇编源文件仍然可以通过名称来引用符号，即使这个符号没有使用<code>DATA</code>和<code>GLOBL</code>指令也是如此。一个很好的通用规则是，在Go代码中定义非只读的数据，而不是在汇编程序中。</p><p>每个函数都需要注释，标明在其参数、返回结果和本地栈帧上给出活动指针的位置。如果汇编函数没有指针类型的结果并且没有本地栈帧，或者没有调用函数，唯一需要做的是为函数在同名的包中定义一个Go函数原型（例如，syscall包中的函数Syscall应该在其TEXT指令中使用名称·Syscall而不是等效名称syscall·Syscall）。在更复杂的情况下，需要明确的注释出。这些注释使用在头文件<code>funcdata.h</code>中定义的伪指令。</p><p>如果一个函数没有参数并且没有结果，指针信息可以省略。这可以通过在TEXT指令中使用参数大小<code>$n-0</code>指出。否则，指针信息必须由Go源文件中的Go原型函数提供，即使汇编函数不是直接被Go代码调用的。（原型还会使用<code>go vet</code>检查参数引用。）在函数的开头，参数都假设是已经被初始化的，但是函数的返回结果会假设是未初始化的。如果在执行CALL指令时，结果中HOLD住一个指针，函数应该在开头就将返回结果初始化为零值，并且接着执行伪指令<code>GO_RESULTS_INITIALIZED</code>。这个指令记录了当前返回结果已经被初始化，并且在当栈帧转移和垃圾收集的时候扫描返回结果。非常具有代表性的是会安排汇编函数不返回指针或者不包含任何CALL指令；在Go标准库中的汇编函数都没有使用<code>GO_RESULTS_INITIALIZED</code>。</p><p>如果函数没有本地堆栈帧，则可以省略指针信息。这可以通过在TEXT指令中使用栈帧大小$0-n指出。如果函数不包含<code>CALL</code>指令，指针信息也可以省略。否则，本地栈帧不能包含指针，汇编必须通过执行<code>NO_LOCAL_POINTERS</code>伪指令来确认这种情况。由于堆栈大小调整是通过移动堆栈来实现的，栈指针可能在函数调用的时候发生改变：即使指向堆栈数据的指针也不能保存在局部变量中。</p><p>汇编程序函数应该总是给出Go原型，以提供参数和结果的指针信息，并用<code>go vet</code>检查访问偏移量的偏移量是否正确。</p><h2 id="架构相关的细节"><a href="#架构相关的细节" class="headerlink" title="架构相关的细节"></a>架构相关的细节</h2><p>列出某种机器的全部指令和细节是不切实际的。如果要查看为特定机器定义了哪些指令，比如ARM，请查看该体系结构支持库的obj源代码，源码在<code>src/cmd/internal/obj/arm</code>目录中。在那个目录中是一个文件<code>a.out.go</code>; 它包含一长串以<code>A</code>开头的常量，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">AAND = obj.ABaseARM + obj.A_ARCHSPECIFIC + iota</span><br><span class="line">AEOR</span><br><span class="line">ASUB</span><br><span class="line">ARSB</span><br><span class="line">AADD</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><p>这是该架构的汇编器和链接器已知的指令及其拼写列表。该列表中的每条指令都以首字母<code>A</code>开始，因此<code>AAND</code>表示按位和指令 <code>AND</code>（不带前导A），并以<code>AND</code>写入汇编源代码。枚举主要按字母顺序排列。（<code>AXXX</code>体系结构无关，在<code>cmd/internal/obj</code>程序包中定义 ，代表无效指令）。这些A名称的顺序与机器指令的实际编码无关。<code>cmd/internal/obj</code>包负责处理这些细节。</p><p>有关386和AMD64体系结构的说明均已列入<code>cmd/internal/obj/x86/a.out.go</code>。</p><p>这些架构共享共同寻址模式的标签名，例如 <code>(R1)</code>（直接寄存器寻址）， <code>4(R1)</code>（寄存器间接偏移）和 <code>$foo(SB)</code>（绝对地址）。汇编器还支持每种体系结构特有的一些（不一定是全部）寻址模式。下面的部分列出了这些。</p><p>前面几部分示例中的一个细节是指令中的数据从左向右流动： <code>MOVQ $0, CX</code>清除<code>CX</code>。即使在某些架构上顺序是相反的，这种规则也是适用的。</p><p>这里有一些对于Go所指的架构的相关的细节的描述。</p><h3 id="32位英特尔386"><a href="#32位英特尔386" class="headerlink" title="32位英特尔386"></a>32位英特尔386</h3><p>指向g(goroutine)结构的Runtime指针通过MMU中其他未使用（就go而言）寄存器的值进行维护。如果源文件包含一个特别的头<code>go_asm.h</code>, 则为汇编程序定义一个与操作系统相关的宏<code>get_tls</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;go_asm.h&quot;</span><br></pre></td></tr></table></figure><p></p><p>runtime中，<code>get_tls</code>宏通过一个指向<code>g</code>指针的指针来加载它的参数寄存器，<code>g</code>结构包含<code>m</code>指针。加载<code>g</code>和<code>m</code>的序列使用<code>CX</code>，就像下面这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_tls(CX)</span><br><span class="line">MOVLg(CX), AX     // Move g into AX.</span><br><span class="line">MOVLg_m(AX), BX   // Move g.m into BX.</span><br></pre></td></tr></table></figure><p></p><p>寻址模式：</p><ul><li><code>(DI)(BX*2)</code>：地址<code>DI</code>加上<code>BX*2</code>的位置。</li><li><code>64(DI)(BX*2)</code>：地址<code>DI</code>加上<code>BX*2</code>加上<code>64</code> 的位置。这些模式只接受1,2,4和8作为比例因子。</li></ul><p>在使用编译器和汇编程序的<code>-dynlink</code>或<code>-shared</code>模式时，固定内存位置任何加载或存储（如全局变量）必须假定重写<code>CX</code>。因此，为了安全使用这些模式，除了在内存引用之间外，汇编源码通常应避免使用<code>CX</code>。</p><h3 id="64位Intel-386（又名amd64）"><a href="#64位Intel-386（又名amd64）" class="headerlink" title="64位Intel 386（又名amd64）"></a>64位Intel 386（又名amd64）</h3><p>这两种体系结构在汇编程序级别上表现基本相同。访问 64位版本的<code>m</code>和<code>g</code>指针的汇编代码与32位386相同，只是它使用MOVQ而不是MOVL：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_tls(CX)</span><br><span class="line">MOVQg(CX), AX     // Move g into AX.</span><br><span class="line">MOVQg_m(AX), BX   // Move g.m into BX.</span><br></pre></td></tr></table></figure><p></p><h3 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h3><p>寄存器<code>R10</code>和<code>R11</code> 由编译器和链接保留使用。</p><p><b style="color:red"><code>R10</code>指向<code>g</code>（<code>goroutine</code>）结构</b>。在汇编源代码中，这个指针必须被称为g; 名称<code>R10</code>不被识别。</p><p>为了让人们和编译器更容易地编写汇编代码，ARM链接器允许一般寻址形式和<code>DIV</code>或者<code>MOD</code>伪指令，这些伪指令使用单个硬件指令可能无法表达。它实现这些多条指令形式，通常使用<code>R11</code>寄存器来保存临时值。手写汇编可以使用<code>R11</code>，但这样做需要确保链接程序不会使用它来实现函数中的任何其他指令。</p><p>定义一个<code>TEXT</code>时，指定帧大小<code>$-4</code>告诉链接器，这是一个叶函数，不需要在Entry上保存<code>LR</code>。</p><p><code>SP</code>始终指向前面描述的虚拟堆栈指针。对于硬件寄存器，请使用<code>R13</code>。</p><p>条件码的语法是在指令中添加一个句点和一个或两个字母的代码，如下所示<code>MOVW.EQ</code>。可以附加多个代码：<code>MOVM.IA.W</code>。代码修饰符的顺序是无关紧要的。</p><p>寻址模式：</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0-&gt;16 </span><br><span class="line">R0&gt;&gt;16 </span><br><span class="line">R0&lt;&lt;16 </span><br><span class="line">R0@&gt;16：对于&lt;&lt;，左移16位的R0。其他代码是-&gt;（算术右移）， &gt;&gt;（逻辑右移）和 @&gt;（右旋）。</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R0-&gt;R1 </span><br><span class="line">R0&gt;&gt;R1 </span><br><span class="line">R0&lt;&lt;R1 </span><br><span class="line">R0@&gt;R1：因为&lt;&lt;，R0计数在左移R1。其他代码是-&gt;（算术右移）， &gt;&gt;（逻辑右移）和 @&gt;（右旋）。</span><br></pre></td></tr></table></figure></li><li><p><code>[R0,g,R12-R15]</code>：对于多寄存器指令，该组包括 <code>R0</code>，<code>g</code>，和<code>R12</code>到<code>R15</code>。</p></li><li><code>(R5, R6)</code>：目的寄存器对。</li></ul><h3 id="ARM64"><a href="#ARM64" class="headerlink" title="ARM64"></a>ARM64</h3><p>ARM64端口处于实验状态。</p><p>指令修饰符附加到指令后的句点。只有修饰符P（后置）和W（前递增）： <code>MOVW.P</code>，<code>MOVW.W</code></p><p>寻址模式：</p><ul><li><code>(R5, R6)</code>：LDP/STP的寄存器对。</li></ul><h3 id="64位PowerPC，又名ppc64"><a href="#64位PowerPC，又名ppc64" class="headerlink" title="64位PowerPC，又名ppc64"></a>64位PowerPC，又名ppc64</h3><p>64位PowerPC端口处于试验状态。</p><p>寻址模式：</p><ul><li><code>(R5)(R6*1)</code>：<code>R5</code>加<code>R6</code>的位置。它是x86上的缩放模式，但是唯一允许的扩展是1。</li><li><code>(R5+R6)</code>：<code>(R5)(R6*1)</code>的别名</li></ul><h3 id="IBM-z-Architecture，又名s390x"><a href="#IBM-z-Architecture，又名s390x" class="headerlink" title="IBM z/Architecture，又名s390x"></a>IBM z/Architecture，又名s390x</h3><p>寄存器<code>R10</code>和<code>R11</code>保留。汇编程序在汇编某些指令时使用它们来保存临时值。</p><p><code>R13</code>指向<code>g</code>（goroutine）结构。这个寄存器必须被称为g; 名称<code>R13</code>不被识别。</p><p><code>R15</code>指向堆栈帧，通常只能使用虚拟寄存器<code>SP</code>和<code>FP</code>。</p><p>加载和存储多条指令在一系列寄存器上运行。寄存器范围由开始寄存器和结束寄存器指定。例如，<code>LMG(R9)</code>, <code>R5</code>, <code>R7</code>将加载<code>R5</code>，<code>R6</code>和<code>R7</code>与在64位值<code>0(R9)</code>，<code>8(R9)</code>和<code>16(R9)</code>分别。</p><p>存储和存储指令（如<code>MVC</code>和<code>XC</code>）的长度作为第一个参数写入。例如，<code>XC $8, (R9)</code>, (R9)将在指定的地址处清除R9中八个字节。</p><p>如果一个向量指令将长度或索引作为参数，那么它将成为第一个参数。例如，<code>VLEIF $1, $16, V2</code>将16个值加载到V2索引之一中。使用向量指令时应注意确保它们在运行时可用。要使用矢量指令，机器必须同时具有矢量功能（设施列表中的位129）和内核支持。如果没有内核支持，矢量指令将不起作用（它将相当于一条<code>NOP</code>指令）。</p><p>寻址模式：</p><ul><li><code>(R5)(R6*1)</code>：R5加R6的位置。它是x86上的缩放模式，但是唯一允许的尺寸是1。</li></ul><h3 id="MIPS，MIPS64"><a href="#MIPS，MIPS64" class="headerlink" title="MIPS，MIPS64"></a>MIPS，MIPS64</h3><p>通用寄存器被命名<code>R0</code>到<code>R31</code>，浮点寄存器<code>F0</code>到<code>F31</code>。</p><p><code>R30</code>保留指向g。 <code>R23</code>被用作临时寄存器。</p><p>在<code>TEXT</code>指令中，栈大小MIPS是<code>$-4</code>，对于MIPS64是<code>$-8</code>，指示链接器不保存LR。</p><p><code>SP</code>指的是虚拟堆栈指针。对于硬件寄存器，请使用<code>R29</code>。</p><p>寻址模式：</p><ul><li>16(R1)：位置在R1加16。</li><li>(R1)：别名0(R1)。</li></ul><p>GOMIPS的环境变量的值（<code>hardfloat</code>或 <code>softfloat</code>）由预先定义<code>GOMIPS_hardfloat</code>或<code>GOMIPS_softfloat</code>提供给汇编代码。</p><h3 id="不支持的操作码"><a href="#不支持的操作码" class="headerlink" title="不支持的操作码"></a>不支持的操作码</h3><p>汇编器旨在支持编译器，因此并非所有硬件指令都针对所有体系结构定义：如果编译器不生成它，它可能不在那里。如果您需要使用缺少的指令，有两种方法可以继续。</p><ul><li>一种是直接修改汇编程序以支持该指令，这是直接的，但只有在指令可能再次使用时才值得。</li><li>相反，对于简单的一次性修改案例，可以使用<code>BYTE</code> 和<code>WORD</code>指令将明确的数据放入<code>TEXT</code>的指令流中。以下是386运行时如何定义64位原子加载函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// uint64 atomicload64(uint64 volatile* addr);</span><br><span class="line">// so actually</span><br><span class="line">// void atomicload64(uint64 *res, uint64 volatile *addr);</span><br><span class="line">TEXT runtime·atomicload64(SB), NOSPLIT, $0-12</span><br><span class="line">MOVLptr+0(FP), AX</span><br><span class="line">TESTL$7, AX</span><br><span class="line">JZ2(PC)</span><br><span class="line">MOVL0, AX // crash with nil ptr deref</span><br><span class="line">LEALret_lo+4(FP), BX</span><br><span class="line">// MOVQ (%EAX), %MM0</span><br><span class="line">BYTE $0x0f; BYTE $0x6f; BYTE $0x00</span><br><span class="line">// MOVQ %MM0, 0(%EBX)</span><br><span class="line">BYTE $0x0f; BYTE $0x7f; BYTE $0x03</span><br><span class="line">// EMMS</span><br><span class="line">BYTE $0x0F; BYTE $0x77</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想看一些具体的例子，可以查看<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmJzbWF4LmNvbS9BL2wxZHlyVzB6ZW0v" title="https://www.bbsmax.com/A/l1dyrW0zem/">Golang汇编命令解读<i class="fa fa-external-link"></i></span></p><p>我在网上也找到了一个比较有意思的<span class="exturl" data-url="aHR0cHM6Ly90YWxrcy5nb2xhbmcub3JnLzIwMTYvYXNtLnNsaWRlIzE=" title="https://talks.golang.org/2016/asm.slide#1">Go汇编设计<i class="fa fa-external-link"></i></span>的介绍。</p><p>Also, <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNnbWFuc2ZpZWxkLmNvbS8yMDE3LzA0L2EtZm9yYXktaW50by1nby1hc3NlbWJseS1wcm9ncmFtbWluZy8=" title="https://blog.sgmansfield.com/2017/04/a-foray-into-go-assembly-programming/">here<i class="fa fa-external-link"></i></span> is another blog about go assembly programming from Scott Mansfield.</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9hc20jYXJtNjQ=" title="https://golang.org/doc/asm#arm64">A Quick Guide to Go’s Assembler<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenZeppelin文档说明</title>
      <link href="//blockchain/OpenZeppelin%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E.html"/>
      <url>//blockchain/OpenZeppelin%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>本文是官方文档的翻译</p><h2 id="OpenZeppelin"><a href="#OpenZeppelin" class="headerlink" title="OpenZeppelin"></a>OpenZeppelin</h2><p>OpenZeppelin是在以太坊上安全编写<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21hcnRfY29udHJhY3Q=" title="https://en.wikipedia.org/wiki/Smart_contract">智能合约<i class="fa fa-external-link"></i></span>的库。</p><p>借助OpenZeppelin，你可以构建分布式应用程序、协议和组织：</p><ul><li>使用通用合约安全模式（请参阅<a href="/2018/03/17/blockchain/安全编写以太坊的智能合约指南/">安全编写以太坊的智能合约指南</a>）</li><li>在<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi9kZXZlbG9wLw==" title="https://solidity.readthedocs.io/en/develop/">solidity语言<i class="fa fa-external-link"></i></span>上</li></ul><p>注：如果你是入门的智能合约开发者，请查看我们的<a href="/2018/03/18/blockchain/以太坊智能合同搭建简易指南/">入门指南</a>。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>OpenZeppelin旨在提供安全、经过测试和社区审核的代码，但在处理真钱时请使用常识！我们对您的实施决定以及您可能遇到的任何安全问题不承担任何责任。</p><p>如果您发现安全问题，请发送电子邮件至<span class="exturl" data-url="bWFpbHRvOnNlY3VyaXR5QG9wZW56ZXBwZWxpbi5vcmc=" title="mailto:security@openzeppelin.org">security@openzeppelin.org<i class="fa fa-external-link"></i></span>。</p><h3 id="开发者资源"><a href="#开发者资源" class="headerlink" title="开发者资源"></a>开发者资源</h3><p>使用OpenZeppelin构建分布式应用程序，协议或组织？</p><ul><li>参阅指南：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9ndWlkZXMvaG9tZQ==" title="https://blog.zeppelin.solutions/guides/home">https://blog.zeppelin.solutions/guides/home<i class="fa fa-external-link"></i></span></li><li>寻求帮助，并关注进度：<span class="exturl" data-url="aHR0cHM6Ly9zbGFjay5vcGVuemVwcGVsaW4ub3Jn" title="https://slack.openzeppelin.org">https://slack.openzeppelin.org<i class="fa fa-external-link"></i></span></li></ul><p>有兴趣对OpenZeppelin做贡献？</p><ul><li>框架提案和路线图：<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL3plcHBlbGluLWJsb2cvemVwcGVsaW4tZnJhbWV3b3JrLXByb3Bvc2FsLWFuZC1kZXZlbG9wbWVudC1yb2FkbWFwLWZkZmE5YTNhMzJhYg==" title="https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab">https://medium.com/zeppelin-blog/zeppelin-framework-proposal-and-development-roadmap-fdfa9a3a32ab<i class="fa fa-external-link"></i></span></li><li>问题追踪：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9pc3N1ZXM=" title="https://github.com/OpenZeppelin/zeppelin-solidity/issues">https://github.com/OpenZeppelin/zeppelin-solidity/issues<i class="fa fa-external-link"></i></span></li><li>贡献指南：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9ibG9iL21hc3Rlci9DT05UUklCVVRJTkcubWQ=" title="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md">https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/CONTRIBUTING.md<i class="fa fa-external-link"></i></span></li><li>wiki：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS93aWtp" title="https://github.com/OpenZeppelin/zeppelin-solidity/wiki">https://github.com/OpenZeppelin/zeppelin-solidity/wiki<i class="fa fa-external-link"></i></span></li></ul><h3 id="OpenZeppelin合作组织和审计"><a href="#OpenZeppelin合作组织和审计" class="headerlink" title="OpenZeppelin合作组织和审计"></a>OpenZeppelin合作组织和审计</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9nb2xlbS5uZXR3b3JrLw==" title="https://golem.network/">Golem<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5tZWRpYWNoYWluLmlvLw==" title="http://www.mediachain.io/">Mediachain<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tLw==" title="http://truffleframework.com/">Truffle<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9maXJzdGJsb29kLmlvLw==" title="https://firstblood.io/">Firstblood<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnNrLmNvLw==" title="https://www.rsk.co/">Rootstock<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb25zZW5zeXMubmV0Lw==" title="https://consensys.net/">Consensys<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGd4LmlvLw==" title="https://www.dgx.io/">DigixGlobal<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb2luZnVuZC5pby8=" title="https://coinfund.io/">Coinfund<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZW1vY3JhY3kuZWFydGgv" title="https://democracy.earth/">DemocracyEarth<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zaWduYXR1cmEuY28v" title="https://signatura.co/">Signatura<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ldGhlci5jYW1wLw==" title="http://www.ether.camp/">Ether.camp<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hcmFnb24ub25lLw==" title="https://aragon.one/">Aragon<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93aW5ncy5haS8=" title="https://wings.ai/">Wings<i class="fa fa-external-link"></i></span></li></ul><p>among others…</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>根据<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9ibG9iL21hc3Rlci9MSUNFTlNF" title="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/LICENSE">MIT许可证<i class="fa fa-external-link"></i></span>发布的代码</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>OpenZeppelin与Truffle集成，Truffle是以太坊开发环境。请安装Truffle并用<code>truffle init</code>初始化您的项目。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br><span class="line">mkdir myproject &amp;&amp; <span class="built_in">cd</span> myproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure><p></p><p>要安装OpenZeppelin库，在项目根目录下运行下面的命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install -E zeppelin-solidity</span><br></pre></td></tr></table></figure><p></p><p><b>请注意，OpenZeppelin目前不遵循语义版本控制</b>。您可能会遇到轻微版本凹凸处的重大更改。我们建议不要改变您使用的OpenZeppelin版本，就像<code>-E（--save-exact）</code>选项一样。</p><p>之后，您在node_modules/zeppelin-solidity/contracts文件夹下获得的所有的库合约。你可以像这样使用库中的合约：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &apos;zeppelin-solidity/contracts/ownership/Ownable.sol&apos;;</span><br><span class="line"></span><br><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>在完成使用OpenZeppelin的智能合同开发的第一步之后，您可能需要查看涵盖几个常见使用案例和良好实践的指南：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9ndWlkZXMvaG9tZQ==" title="https://blog.zeppelin.solutions/guides/home">https://blog.zeppelin.solutions/guides/home<i class="fa fa-external-link"></i></span></p><p>例如，<a href="/2018/03/18/blockchain/以太坊智能合同搭建简易指南/">“以太坊智能合同搭便车指南”</a>将帮助您了解智能合同开发所需的各种工具，并设置您的环境。</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9hLWdlbnRsZS1pbnRyb2R1Y3Rpb24tdG8tZXRoZXJldW0tcHJvZ3JhbW1pbmctcGFydC0xLTc4M2NjNzc5NjA5NA==" title="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094">以太坊编程的基础介绍，第1部分<i class="fa fa-external-link"></i></span>提供了介绍级的非常有用的信息，包括以太坊平台的许多基本概念。</p><p>要进行更深入的探索，您可以阅读<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9kZXNpZ25pbmctdGhlLWFyY2hpdGVjdHVyZS1mb3IteW91ci1ldGhlcmV1bS1hcHBsaWNhdGlvbi05Y2VjMDg2ZjgzMTc=" title="https://blog.zeppelin.solutions/designing-the-architecture-for-your-ethereum-application-9cec086f8317">设计您的Ethereum应用程序架构指南<i class="fa fa-external-link"></i></span>，其中讨论了如何更好地构建应用程序及其与现实世界的关系。</p><p>您也可以寻求帮助或关注OpenZeppelin在<span class="exturl" data-url="aHR0cHM6Ly9zbGFjay5vcGVuemVwcGVsaW4ub3JnLw==" title="https://slack.openzeppelin.org/">Slack<i class="fa fa-external-link"></i></span>社区中的进展，或者阅读本网站上OpenZeppelin的完整API介绍。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>truffle指南</title>
      <link href="//blockchain/truffle%E6%8C%87%E5%8D%97.html"/>
      <url>//blockchain/truffle%E6%8C%87%E5%8D%97.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:#00f">本文是truffle官方文档的翻译，不确定版本，但是看到truffle官方github的版本是4.1.15.</b></p><p>Truffle是一个世界级的开发环境，用于以太坊的测试框架和资产管道，旨在使以太坊开发人员的开发更轻松。truffle有以下的一些特性：</p><ul><li>内置智能合约编译，链接，部署和二进制管理。</li><li>用于快速开发的合约自动测试。</li><li>可编写脚本的可扩展部署和迁移框架。</li><li>用于部署到任意数量的公共和专用网络的网络管理。</li><li>使用ERC190标准，使用EthPM和NPM进行包装管理。</li><li>交互式控制台，用于直接与合约交互。</li><li>可配置的构建流水线，支持紧密集成。</li><li>外部脚本运行器，用于在Truffle环境中执行脚本。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure><p>最好使用node 5.0+，另外最好有一个打开json rpc api的以太坊节点。</p><h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><p>对于那些刚刚开始使用的人，可通过<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2JveGVz" title="http://truffleframework.com/boxes">松露盒<i class="fa fa-external-link"></i></span>获取许多样板和示例应用程序。</p><p>你可以从我们的MetaCoin例子开始，在命令行上运行以下命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir MetaCoin</span><br><span class="line">cd MetaCoin</span><br><span class="line">truffle unbox metacoin</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#c7254e">注意：MetaCoin松露项目过去是通过运行<code>truffle init</code>创建的。现在它作为松露盒存在。</b></p><p>您可以使用该<code>truffle unbox &lt;box-name&gt;</code>命令下载任何其他应用程序。</p><p>如果你想从头开始构建一个项目，可以使用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir myproject</span><br><span class="line">cd myproject</span><br><span class="line">truffle init</span><br></pre></td></tr></table></figure><p></p><p>一旦完成，您现在将拥有包含以下项目的项目结构：</p><ul><li><code>contracts/</code>：<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2NvbnRyYWN0cw==" title="http://truffleframework.com/docs/getting_started/contracts">Solidity合同<i class="fa fa-external-link"></i></span>目录</li><li><code>migrations/</code>：<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL21pZ3JhdGlvbnMjbWlncmF0aW9uLWZpbGVz" title="http://truffleframework.com/docs/getting_started/migrations#migration-files">可编写脚本的部署文件的目录<i class="fa fa-external-link"></i></span></li><li><code>test/</code>：用于<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3Rlc3Rpbmc=" title="http://truffleframework.com/docs/getting_started/testing">测试您的应用程序和合约的<i class="fa fa-external-link"></i></span>测试文件目录</li><li><code>truffle.js</code>：Truffle配置文件</li></ul><h2 id="选择以太坊客户端"><a href="#选择以太坊客户端" class="headerlink" title="选择以太坊客户端"></a>选择以太坊客户端</h2><p>有许多以太坊客户端可供选择。根据您是在开发还是部署，我们推荐不同的客户端。</p><h3 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h3><h4 id="Ganache"><a href="#Ganache" class="headerlink" title="Ganache"></a>Ganache</h4><p>我们建议您在桌面上运行Ethereum开发的个人区块链<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2dhbmFjaGU=" title="http://truffleframework.com/ganache">Ganache<i class="fa fa-external-link"></i></span>。作为truffle套件的一部分，Ganache通过将合约和交易放在前面和中心处，简化了dapp的开发。使用Ganache，您可以快速看到应用程序如何影响区块链，并反馈到您的账户，余额，合约创建和gas成本等细节。您还可以对Ganache的高级采矿控制进行微调，以更好地满足您的需求。Ganache可用于Windows，Mac和Linux，您可以<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2dhbmFjaGU=" title="http://truffleframework.com/ganache">在此下载<i class="fa fa-external-link"></i></span>。</p><p>Ganache在启动时运行在<code>http://127.0.0.1:7545</code>。它将显示前10个帐户和用于创建这些帐户的助记符。（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">阅读有关帐户助记符的更多信息<i class="fa fa-external-link"></i></span>。）</p><p>默认情况下，Ganache将使用以下助记符：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure><p></p><p>该助记符可以更改为随机生成，也可以输入自己的助记符。</p><p><b style="color:#c7254e">警告：请勿在以太网主网络（mainnet）上使用此助记符。如果您将ETH发送到由此助记符生成的任何帐户，您将失去所有！</b></p><h4 id="truffle开发"><a href="#truffle开发" class="headerlink" title="truffle开发"></a>truffle开发</h4><p>我们还建议使用Truffle Develop，一种直接构建在truffle中区块链。Truffle Develop可帮助您使用单个命令设置集成区块链环境，无需安装。通过在终端中键入以下命令即可开启：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure><p></p><p>这将运行客户端<code>http://127.0.0.1:9545</code>。它将显示前10个帐户和用于创建这些帐户的助记符。Truffle Develop每次都使用相同的助记符来尽可能简化开发应用程序：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure><p></p><p>一旦启动，Truffle Develop将为您提供一个控制台，您可以使用它来运行所有可用的truffle命令。这些命令是通过省略truffle前缀来输入的。</p><p>要了解更多关于与控制台交互的信息，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2NvbnNvbGU=" title="http://truffleframework.com/docs/getting_started/console">使用控制台<i class="fa fa-external-link"></i></span>部分。</p><h4 id="GANACHE-CLI"><a href="#GANACHE-CLI" class="headerlink" title="GANACHE CLI"></a>GANACHE CLI</h4><p>Ganache还为那些在图形环境下工作的人提供了一个命令行界面。非常适合自动化测试和持续集成环境，Ganache CLI可以无人运行，可以配置为满足您的所有开发需求。Ganache CLI可以立即处理交易，而不是等待默认的区块时间，因此您可以快速测试您的代码是否可以工作。它还会在您的智能合约出现错误时立即告诉您，并直接与Truffle集成，以将测试运行时间与其他客户端相比降低90％。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS9nYW5hY2hlLWNsaS8=" title="https://github.com/trufflesuite/ganache-cli/">了解关于Ganache CLI的更多信息<i class="fa fa-external-link"></i></span>。</p><h3 id="正式环境部署"><a href="#正式环境部署" class="headerlink" title="正式环境部署"></a>正式环境部署</h3><p>有许多官方和非官方的以太坊客户可供您使用。以下是一个简短列表：</p><ul><li>geth：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVt" title="https://github.com/ethereum/go-ethereum">https://github.com/ethereum/go-ethereum<i class="fa fa-external-link"></i></span></li><li>WebThree（cpp-ethereum）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2NwcC1ldGhlcmV1bQ==" title="https://github.com/ethereum/cpp-ethereum">https://github.com/ethereum/cpp-ethereum<i class="fa fa-external-link"></i></span></li><li>Parity： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvcGFyaXR5" title="https://github.com/paritytech/parity">https://github.com/paritytech/parity<i class="fa fa-external-link"></i></span></li><li>More： <span class="exturl" data-url="aHR0cHM6Ly93d3cuZXRoZXJldW0ub3JnL2NsaQ==" title="https://www.ethereum.org/cli">https://www.ethereum.org/cli<i class="fa fa-external-link"></i></span></li></ul><h3 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h3><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yOTAxMDIzMQ==" title="https://zhuanlan.zhihu.com/p/29010231">玩转以太坊(Ethereum)的测试网络<i class="fa fa-external-link"></i></span></p><h2 id="编译合约"><a href="#编译合约" class="headerlink" title="编译合约"></a>编译合约</h2><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>所有的合同都位于您项目的contracts/目录中。<code>Migrations.sol</code>帮助部署合约。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br></pre></td></tr></table></figure><p>第一次运行时，所有合同都将被编译。后续运行时，松露只会编译自上次编译以来已更改的合同。如果您想覆盖此行为，请使用该<code>--all</code>选项运行上述命令。</p><h3 id="构建结果"><a href="#构建结果" class="headerlink" title="构建结果"></a>构建结果</h3><p>您编译的结果将被放置在<code>build/contracts/</code>目录中. 这些文件是truffle内部使用，你不需要编辑。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>您可以使用Solidity的导入命令来声明合约依赖关系。truffle将按照正确的顺序编译合约，并确保将所有依赖关系发送给编译器。依赖性可以用两种方式指定：</p><h4 id="通过文件名导入依赖关系"><a href="#通过文件名导入依赖关系" class="headerlink" title="通过文件名导入依赖关系"></a>通过文件名导入依赖关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;./AnotherContract.sol&quot;;</span><br></pre></td></tr></table></figure><p>这里<code>AnotherContract.sol</code>是相对于当前正在编写的合约的路径。</p><h4 id="从外部包导入合约"><a href="#从外部包导入合约" class="headerlink" title="从外部包导入合约"></a>从外部包导入合约</h4><p>Truffle支持通过<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3BhY2thZ2VzLWV0aHBt" title="http://truffleframework.com/docs/getting_started/packages-ethpm">EthPM<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3BhY2thZ2VzLW5wbQ==" title="http://truffleframework.com/docs/getting_started/packages-npm">NPM<i class="fa fa-external-link"></i></span>安装的依赖项。要从依赖项导入合约，请使用以下语法:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;somepackage/SomeContract.sol&quot;;</span><br></pre></td></tr></table></figure><p></p><p>这里<code>somepackage</code>表示通过EthPM或NPM安装的软件包，<code>SomeContract.sol</code>表示该软件包提供的Solidity 源文件。</p><h2 id="运行迁移"><a href="#运行迁移" class="headerlink" title="运行迁移"></a>运行迁移</h2><p>Migration是帮助您将合约部署到以太坊网络的JavaScript文件。这些文件负责暂存您的部署任务，并且这些文件是在您的部署需求随时间变化的前提下编写的。随着您的项目不断发展，您将创建新的迁移脚本以进一步推动区块链的发展。以前运行的迁移历史记录通过特定的Migrations合约记录在链上，详情如下。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle migrate</span><br></pre></td></tr></table></figure><p>这将运行位于项目<code>migrations</code>目录中的所有迁移。简而言之，迁移只是一组受管理的部署脚本。如果您的迁移先前已成功运行，<code>truffle migrate</code>则将从上次运行的迁移开始执行，仅运行新创建的迁移。如果不存在新的迁移，<code>truffle migrate</code>则根本不会执行任何操作。您可以使用该<code>--reset</code>选项从头开始运行所有迁移。对于本地测试，确保在执行<code>migrate</code>之前安装并运行测试区块链，例如<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2dhbmFjaGU=" title="http://truffleframework.com/ganache">Ganache<i class="fa fa-external-link"></i></span>.</p><h3 id="迁移文件"><a href="#迁移文件" class="headerlink" title="迁移文件"></a>迁移文件</h3><p>一个简单的迁移文件如下所示：文件名：<code>4_example_migration.js</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var MyContract = artifacts.require(&quot;MyContract&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // deployment steps</span><br><span class="line">  deployer.deploy(MyContract);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>请注意，文件名以数字为前缀，后缀为说明。需要编号的前缀才能记录迁移是否成功运行。后缀纯粹是为了人类的可读性和理解。</p><h4 id="ARTIFACTS-REQUIRE"><a href="#ARTIFACTS-REQUIRE" class="headerlink" title="ARTIFACTS.REQUIRE()"></a>ARTIFACTS.REQUIRE()</h4><p>在迁移开始时，我们告诉Truffle我们希望通过该<code>artifacts.require()</code>方法取得要进行交互的合约。此方法与Node的<code>require</code>类似，但在我们的情况，它特别返回了我们可以在我们的部署脚本的其余部分中使用的合约抽象。指定的名称应与该源文件中的合约定义的名称相匹配。不要传递源文件的名称，因为文件可以包含多个合同。</p><h4 id="MODULE-EXPORTS"><a href="#MODULE-EXPORTS" class="headerlink" title="MODULE.EXPORTS"></a>MODULE.EXPORTS</h4><p>所有的迁移必须通过<code>module.exports</code>语法导出一个函数。每个迁移导出的函数应接受一个<code>deployer</code>对象作为其第一个参数。该对象通过为部署智能合约提供清晰的语法以及执行一些部署的更普通的职责（如保存部署的工件供以后使用）来帮助部署。该<code>deployer</code>对象是用于暂存部署任务的主接口，其页面底部介绍了其API。</p><p>您的迁移函数也可以接受其他参数。看下面的例子。</p><h3 id="初始化迁移"><a href="#初始化迁移" class="headerlink" title="初始化迁移"></a>初始化迁移</h3><p>truffle需要您拥有迁移合约才能使用迁移功能。此合约必须包含特定的接口，但您可以随意编辑此合约。对于大多数项目而言，此合约最初将作为第一次迁移进行部署，不会再进行更新。在创建新项目时，您通过<code>truffle init</code>还将默认收到此合约。</p><p>文件名：<code>contracts/Migrations.sol</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.8;</span><br><span class="line"></span><br><span class="line">contract Migrations &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  // A function with the signature `last_completed_migration()`, returning a uint, is required.</span><br><span class="line">  uint public last_completed_migration;</span><br><span class="line"></span><br><span class="line">  modifier restricted() &#123;</span><br><span class="line">    if (msg.sender == owner) _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Migrations() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // A function with the signature `setCompleted(uint)` is required.</span><br><span class="line">  function setCompleted(uint completed) restricted &#123;</span><br><span class="line">    last_completed_migration = completed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function upgrade(address new_address) restricted &#123;</span><br><span class="line">    Migrations upgraded = Migrations(new_address);</span><br><span class="line">    upgraded.setCompleted(last_completed_migration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>您必须在第一次迁移中部署此合约才能利用迁移功能。为此，请创建以下迁移：<code>migrations/1_initial_migration.js</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Migrations = artifacts.require(&quot;Migrations&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Deploy the Migrations contract as our only task</span><br><span class="line">  deployer.deploy(Migrations);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>从这里，您可以使用增加的编号前缀创建新的迁移，以部署其他合约并执行进一步的部署步骤。</p><h3 id="DEPLOYER"><a href="#DEPLOYER" class="headerlink" title="DEPLOYER"></a>DEPLOYER</h3><p>您的迁移文件将使用部署者来部署部署任务。因此，您可以同步编写部署任务，并按正确的顺序执行它们：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Stage deploying A before B</span><br><span class="line">deployer.deploy(A);</span><br><span class="line">deployer.deploy(B);</span><br></pre></td></tr></table></figure><p></p><p>或者，可以将部署者上的每个功能用作Promise，以排队依赖于前一个任务执行的部署任务：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Deploy A, then deploy B, passing in A&apos;s newly deployed address</span><br><span class="line">deployer.deploy(A).then(function() &#123;</span><br><span class="line">  return deployer.deploy(B, A.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="网络考虑"><a href="#网络考虑" class="headerlink" title="网络考虑"></a>网络考虑</h3><p>可以根据部署到的网络有条件地运行部署步骤。这是一项高级功能，因此请先参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvbmV0d29ya3M=" title="http://truffleframework.com/docs/advanced/networks">网络<i class="fa fa-external-link"></i></span>部分，然后再继续。</p><p>要有条件有步骤地部署，请编写您的迁移，以便他们接受名为的第二个参数<code>network</code>。例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(deployer, network) &#123;</span><br><span class="line">  if (network == &quot;live&quot;) &#123;</span><br><span class="line">    // Do something specific to the network named &quot;live&quot;.</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Perform a different step otherwise.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="可用的账户"><a href="#可用的账户" class="headerlink" title="可用的账户"></a>可用的账户</h3><p>迁移还会通过您的以太坊客户端和web3提供商提供给您的帐户列表，供您在部署期间使用。这与<code>web3.eth.getAccounts()</code>从中返回的帐户完全相同。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(deployer, network, accounts) &#123;</span><br><span class="line">  // Use the accounts within your migrations.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="DEPLOYER-API"><a href="#DEPLOYER-API" class="headerlink" title="DEPLOYER API"></a>DEPLOYER API</h3><p>Deployer包含许多可用于简化迁移的功能。</p><h4 id="DEPLOYER-DEPLOY-CONTRACT-ARGS…-OPTIONS"><a href="#DEPLOYER-DEPLOY-CONTRACT-ARGS…-OPTIONS" class="headerlink" title="DEPLOYER.DEPLOY(CONTRACT, ARGS…, OPTIONS)"></a>DEPLOYER.DEPLOY(CONTRACT, ARGS…, OPTIONS)</h4><p>使用可选的构造函数参数部署合约对象指定的特定合约。这对于单个合约很有用，因此您的dapp只有一份此合约的实例。这将在部署之后设置合约的地址（即，<code>Contract.address</code>将等于新部署的地址），并且它将覆盖任何先前存储的地址。</p><p>您可以选择传递一组合约或一组数组，以加速部署多个合约。此外，最后一个参数是一个可选对象，可以包含指定的键<code>overwrite</code>以及其他交易参数（如<code>gas</code>和<code>from</code>）。如果<code>overwrite</code>设置为<code>false</code>，则Deployer将不会部署此合约（如果已部署）。这对于某些合约地址由外部依赖项提供的情况很有用。</p><p>请注意，在调用<code>deploy</code>之前，您需要首先部署和链接您的合约所依赖的任何库。有关link更多详细信息，请参阅以下功能.</p><p>欲了解更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxlLWNvbnRyYWN0" title="https://github.com/trufflesuite/truffle-contract">truffle-contract<i class="fa fa-external-link"></i></span>文档。</p><p>例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Deploy a single contract without constructor arguments</span><br><span class="line">deployer.deploy(A);</span><br><span class="line"></span><br><span class="line">// Deploy a single contract with constructor arguments</span><br><span class="line">deployer.deploy(A, arg1, arg2, ...);</span><br><span class="line"></span><br><span class="line">// Don&apos;t deploy this contract if it has already been deployed</span><br><span class="line">deployer.deploy(A, &#123;overwrite: false&#125;);</span><br><span class="line"></span><br><span class="line">// Set a maximum amount of gas and `from` address for the deployment</span><br><span class="line">deployer.deploy(A, &#123;gas: 4612388, from: &quot;0x....&quot;&#125;);</span><br><span class="line"></span><br><span class="line">// Deploy multiple contracts, some with arguments and some without.</span><br><span class="line">// This is quicker than writing three `deployer.deploy()` statements as the deployer</span><br><span class="line">// can perform the deployment as a single batched request.</span><br><span class="line">deployer.deploy([</span><br><span class="line">  [A, arg1, arg2, ...],</span><br><span class="line">  B,</span><br><span class="line">  [C, arg1]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// External dependency example:</span><br><span class="line">//</span><br><span class="line">// For this example, our dependency provides an address when we&apos;re deploying to the</span><br><span class="line">// live network, but not for any other networks like testing and development.</span><br><span class="line">// When we&apos;re deploying to the live network we want it to use that address, but in</span><br><span class="line">// testing and development we need to deploy a version of our own. Instead of writing</span><br><span class="line">// a bunch of conditionals, we can simply use the `overwrite` key.</span><br><span class="line">deployer.deploy(SomeDependency, &#123;overwrite: false&#125;);</span><br></pre></td></tr></table></figure><p></p><h4 id="DEPLOYER-LINK-LIBRARY-DESTINATIONS"><a href="#DEPLOYER-LINK-LIBRARY-DESTINATIONS" class="headerlink" title="DEPLOYER.LINK(LIBRARY, DESTINATIONS)"></a>DEPLOYER.LINK(LIBRARY, DESTINATIONS)</h4><p>将已部署的库链接到合约或多个合约。<code>destinations</code>可以是单个合约或多个合约的数组。如果<code>destinations</code>的任何合约不依赖于链接的库，则合约将被忽略。</p><p>例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Deploy library LibA, then link LibA to contract B, then deploy B.</span><br><span class="line">deployer.deploy(LibA);</span><br><span class="line">deployer.link(LibA, B);</span><br><span class="line">deployer.deploy(B);</span><br><span class="line"></span><br><span class="line">// Link LibA to many contracts</span><br><span class="line">deployer.link(LibA, [B, C, D]);</span><br></pre></td></tr></table></figure><p></p><h4 id="DEPLOYER-THEN-FUNCTION-…"><a href="#DEPLOYER-THEN-FUNCTION-…" class="headerlink" title="DEPLOYER.THEN(FUNCTION() {…})"></a>DEPLOYER.THEN(FUNCTION() {…})</h4><p>就像承诺一样，运行一个任意的部署步骤。在您的迁移过程中使用它来调用特定合同的函数来添加、编辑和重新组织合约数据。</p><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a, b;</span><br><span class="line">deployer.then(function() &#123;</span><br><span class="line">  // Create a new version of A</span><br><span class="line">  return A.new();</span><br><span class="line">&#125;).then(function(instance) &#123;</span><br><span class="line">  a = instance;</span><br><span class="line">  // Get the deployed instance of B</span><br><span class="line">  return B.deployed();</span><br><span class="line">&#125;).then(function(instance) &#123;</span><br><span class="line">  b = instance;</span><br><span class="line">  // Set the new instance of A&apos;s address on B via B&apos;s setA() function.</span><br><span class="line">  return b.setA(a.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="测试你的合约"><a href="#测试你的合约" class="headerlink" title="测试你的合约"></a>测试你的合约</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>truffle配置了自动化测试框架，可以轻松测试你的合约。这个框架可以让你用两种不同的方式编写简单且易于管理的测试：</p><ul><li>在<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2phdmFzY3JpcHQtdGVzdHM=" title="http://truffleframework.com/docs/getting_started/javascript-tests">JavaScript中<i class="fa fa-external-link"></i></span>，用于运行来自外部世界的合约，就像您的应用程序一样。</li><li>在<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3NvbGlkaXR5LXRlc3Rz" title="http://truffleframework.com/docs/getting_started/solidity-tests">Solidity<i class="fa fa-external-link"></i></span>中，高级特性，在公开的场景中行使您的合约。</li></ul><p>两种类型的测试都有其优点和缺点。请参阅接下来的两节来讨论。</p><h3 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h3><p>所有测试文件应位于<code>./test</code>目录中。truffle将只与下列扩展名的文件运行测试文件：<code>.js</code>，<code>.es</code>，<code>.es6</code>，<code>.jsx</code>和<code>.sol</code>。所有其他文件都被忽略。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test</span><br></pre></td></tr></table></figure><p>或者，您可以运行指定路径的文件:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test ./path/to/test/file.js</span><br></pre></td></tr></table></figure><p></p><h3 id="清空环境"><a href="#清空环境" class="headerlink" title="清空环境"></a>清空环境</h3><p>运行测试文件时，truffle提供了一个无尘室环境。在针对<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2dhbmFjaGU=" title="http://truffleframework.com/ganache">Ganache<i class="fa fa-external-link"></i></span>或Truffle Develop 运行测试时，Truffle将使用高级快照功能来确保您的测试文件不会彼此共享状态。当与其他以太坊客户一起运行时，Truffle将在每个测试文件开始时重新部署所有迁移，以确保您拥有一组新的测试合约。</p><h3 id="速度和可靠性考虑"><a href="#速度和可靠性考虑" class="headerlink" title="速度和可靠性考虑"></a>速度和可靠性考虑</h3><p>运行自动化测试时，Ganache和Truffle Develop比其他客户快得多。此外，它们还包含Truffle利用其特殊功能将测试运行时间提高近90％。作为一个通用的工作流程，我们建议您在正常开发和测试过程中使用Ganache或Truffle Develop，然后在您准备部署到现场或生产网络时，针对以太坊或其他官方Ethereum客户端运行一次测试。</p><h2 id="在JavaScript中编写测试"><a href="#在JavaScript中编写测试" class="headerlink" title="在JavaScript中编写测试"></a>在JavaScript中编写测试</h2><p>Truffle使用<span class="exturl" data-url="aHR0cHM6Ly9tb2NoYWpzLm9yZy8=" title="https://mochajs.org/">Mocha<i class="fa fa-external-link"></i></span>测试框架和<span class="exturl" data-url="aHR0cDovL2NoYWlqcy5jb20v" title="http://chaijs.com/">Chai<i class="fa fa-external-link"></i></span>进行断言，为您提供一个可编写JavaScript测试的可靠框架。让我们深入了解Truffle如何在Mocha上建立轻松您的合同的测试。</p><p><b style="color:#6ab0de">注意：如果您不熟悉在Mocha中编写单元测试，请在继续之前参阅<span class="exturl" data-url="aHR0cHM6Ly9tb2NoYWpzLm9yZy8=" title="https://mochajs.org/">Mocha的文档<i class="fa fa-external-link"></i></span>。</b></p><h3 id="使用CONTRACT-取代DESCRIBE"><a href="#使用CONTRACT-取代DESCRIBE" class="headerlink" title="使用CONTRACT()取代DESCRIBE()"></a>使用CONTRACT()取代DESCRIBE()</h3><p>在结构上，你的测试应该与Mocha的测试基本保持不变：你的测试应该存在于<code>./test</code>目录中，它们应该以<code>.js</code>扩展名结尾，并且它们应该包含Mocha将认为是自动化测试的代码。什么使truffle测试不同于Mocha的测试是<code>contract()</code>函数：该函数的工作原理与<code>describe()</code>相同，只是没有Truffle无尘室功能。它是这样工作的：</p><ul><li>在每个<code>contract()</code>函数运行之前，您的合约将重新部署到正在运行的以太坊客户端，以便其中的测试以干净的合约状态运行。</li><li>该<code>contract()</code>函数提供了您的以太坊客户端提供的账户列表，您可以使用它来编写测试。</li></ul><p><b style="color:#6ab0de">由于Truffle在发动机罩下使用了Mocha，因此<code>describe()</code>只要不需要松露清洁室功能，您仍然可以使用它来运行正常的Mocha测试。</b></p><h3 id="在测试中使用合约抽象"><a href="#在测试中使用合约抽象" class="headerlink" title="在测试中使用合约抽象"></a>在测试中使用合约抽象</h3><p>合约抽象是通过JavaScript实现合约交互的基础（它们基本上就是我们的助熔电容器）。由于truffle无法检测到在测试中需要与哪些合约进行交互，因此您需要明确要求这些合约。您可以通过使用<code>artifacts.require()</code>方法来做到这一点，该方法是由Truffle提供的一种方法，允许您为特定的Solidity合约请求可用的合约抽象。正如你在下面的例子中看到的那样，你可以使用这个抽象来确保你的合约正常工作。</p><p>有关使用合同抽象的更多信息，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2NvbnRyYWN0cw==" title="http://truffleframework.com/docs/getting_started/contracts">与您的合同交互<i class="fa fa-external-link"></i></span>一节。</p><h3 id="使用ARTIFACTS-REQUIRE"><a href="#使用ARTIFACTS-REQUIRE" class="headerlink" title="使用ARTIFACTS.REQUIRE()"></a>使用ARTIFACTS.REQUIRE()</h3><p>测试中使用<code>artifacts.require()</code>的工作方式与您在迁移中使用它是一样的; 你只需要通过合约的名称。有关详细用法，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL21pZ3JhdGlvbnMjYXJ0aWZhY3RzLXJlcXVpcmUt" title="http://truffleframework.com/docs/getting_started/migrations#artifacts-require-">artifacts.require()<i class="fa fa-external-link"></i></span>的文档。</p><h3 id="使用web3"><a href="#使用web3" class="headerlink" title="使用web3"></a>使用web3</h3><p>每个测试文件都有一个<code>web3</code>实例，配置为正确的提供者。所以调用<code>web3.eth.getBalance</code>就行了！</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="使用-THEN"><a href="#使用-THEN" class="headerlink" title="使用.THEN"></a>使用<code>.THEN</code></h4><p>这是<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2JveGVzL21ldGFjb2lu" title="http://truffleframework.com/boxes/metacoin">MetaCoin Truffle Box<i class="fa fa-external-link"></i></span>中提供的一个示例测试。请注意使用该<code>contract()</code>函数，该<code>accounts</code>数组用于指定可用的以太坊帐户，以及我们使用<code>artifacts.require()</code>直接与我们的合同进行交互。</p><p>文件：<code>./test/metacoin.js</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">var MetaCoin = artifacts.require(&quot;./MetaCoin.sol&quot;);</span><br><span class="line"></span><br><span class="line">contract(&apos;MetaCoin&apos;, function(accounts) &#123;</span><br><span class="line">  it(&quot;should put 10000 MetaCoin in the first account&quot;, function() &#123;</span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      return instance.getBalance.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      assert.equal(balance.valueOf(), 10000, &quot;10000 wasn&apos;t in the first account&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should call a function that depends on a linked library&quot;, function() &#123;</span><br><span class="line">    var meta;</span><br><span class="line">    var metaCoinBalance;</span><br><span class="line">    var metaCoinEthBalance;</span><br><span class="line"></span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      return meta.getBalance.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(outCoinBalance) &#123;</span><br><span class="line">      metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">      return meta.getBalanceInEth.call(accounts[0]);</span><br><span class="line">    &#125;).then(function(outCoinBalanceEth) &#123;</span><br><span class="line">      metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">      assert.equal(metaCoinEthBalance, 2 * metaCoinBalance, &quot;Library function returned unexpected function, linkage may be broken&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(&quot;should send coin correctly&quot;, function() &#123;</span><br><span class="line">    var meta;</span><br><span class="line"></span><br><span class="line">    // Get initial balances of first and second account.</span><br><span class="line">    var account_one = accounts[0];</span><br><span class="line">    var account_two = accounts[1];</span><br><span class="line"></span><br><span class="line">    var account_one_starting_balance;</span><br><span class="line">    var account_two_starting_balance;</span><br><span class="line">    var account_one_ending_balance;</span><br><span class="line">    var account_two_ending_balance;</span><br><span class="line"></span><br><span class="line">    var amount = 10;</span><br><span class="line"></span><br><span class="line">    return MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      return meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_one_starting_balance = balance.toNumber();</span><br><span class="line">      return meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_two_starting_balance = balance.toNumber();</span><br><span class="line">      return meta.sendCoin(account_two, amount, &#123;from: account_one&#125;);</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">      return meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_one_ending_balance = balance.toNumber();</span><br><span class="line">      return meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(function(balance) &#123;</span><br><span class="line">      account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&apos;t correctly taken from the sender&quot;);</span><br><span class="line">      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&apos;t correctly sent to the receiver&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>这个测试会输出下面的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Contract: MetaCoin</span><br><span class="line">  √ should put 10000 MetaCoin in the first account (83ms)</span><br><span class="line">  √ should call a function that depends on a linked library (43ms)</span><br><span class="line">  √ should send coin correctly (122ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3 passing (293ms)</span><br></pre></td></tr></table></figure><p></p><h3 id="使用ASYNC-AWAIT"><a href="#使用ASYNC-AWAIT" class="headerlink" title="使用ASYNC/AWAIT"></a>使用ASYNC/AWAIT</h3><p>这里是一个相似的实例，但是是使用<span class="exturl" data-url="aHR0cHM6Ly9qYXZhc2NyaXB0LmluZm8vYXN5bmMtYXdhaXQ=" title="https://javascript.info/async-await">async/await<i class="fa fa-external-link"></i></span>符号：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const MetaCoin = artifacts.require(&quot;MetaCoin&quot;);</span><br><span class="line"></span><br><span class="line">contract(&apos;2nd MetaCoin test&apos;, async (accounts) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;should put 10000 MetaCoin in the first account&quot;, async () =&gt; &#123;</span><br><span class="line">     let instance = await MetaCoin.deployed();</span><br><span class="line">     let balance = await instance.getBalance.call(accounts[0]);</span><br><span class="line">     assert.equal(balance.valueOf(), 10000);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(&quot;should call a function that depends on a linked library&quot;, async () =&gt; &#123;</span><br><span class="line">    let meta = await MetaCoin.deployed();</span><br><span class="line">    let outCoinBalance = await meta.getBalance.call(accounts[0]);</span><br><span class="line">    let metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">    let outCoinBalanceEth = await meta.getBalanceInEth.call(accounts[0]);</span><br><span class="line">    let metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    assert.equal(metaCoinEthBalance, 2 * metaCoinBalance);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;should send coin correctly&quot;, async () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // Get initial balances of first and second account.</span><br><span class="line">    let account_one = accounts[0];</span><br><span class="line">    let account_two = accounts[1];</span><br><span class="line"></span><br><span class="line">    let amount = 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let instance = await MetaCoin.deployed();</span><br><span class="line">    let meta = instance;</span><br><span class="line"></span><br><span class="line">    let balance = await meta.getBalance.call(account_one);</span><br><span class="line">    let account_one_starting_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_two);</span><br><span class="line">    let account_two_starting_balance = balance.toNumber();</span><br><span class="line">    await meta.sendCoin(account_two, amount, &#123;from: account_one&#125;);</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_one);</span><br><span class="line">    let account_one_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = await meta.getBalance.call(account_two);</span><br><span class="line">    let account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    assert.equal(account_one_ending_balance, account_one_starting_balance - amount, &quot;Amount wasn&apos;t correctly taken from the sender&quot;);</span><br><span class="line">    assert.equal(account_two_ending_balance, account_two_starting_balance + amount, &quot;Amount wasn&apos;t correctly sent to the receiver&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>这个测试将产生与前面例子相同的输出。</p><h3 id="指定测试"><a href="#指定测试" class="headerlink" title="指定测试"></a>指定测试</h3><p>您可以限制特定文件执行的测试，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle test ./test/metacoin.js</span><br></pre></td></tr></table></figure><p></p><p>有关更多信息，请参阅完整的<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29tbWFuZHMjdGVzdA==" title="http://truffleframework.com/docs/advanced/commands#test">命令<i class="fa fa-external-link"></i></span>参考。</p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>truffle可以让你访问Mocha的配置，这样你就可以改变Mocha的行为方式。请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29uZmlndXJhdGlvbiNtb2NoYQ==" title="http://truffleframework.com/docs/advanced/configuration#mocha">项目配置<i class="fa fa-external-link"></i></span>部分了解更多详情。</p><h2 id="在SOLIDITY中编写测试"><a href="#在SOLIDITY中编写测试" class="headerlink" title="在SOLIDITY中编写测试"></a>在SOLIDITY中编写测试</h2><p>solidity测试合约与Javascript测试一起作为<code>.sol</code>文件存在。当<code>truffle test</code>运行时，它们将被包括作为每个测试合约单独的测试套件。这些合约保留了Javascript测试的所有好处：即每个测试套件都有一个<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3Rlc3RpbmcjY2xlYW4tcm9vbS1lbnZpcm9ubWVudA==" title="http://truffleframework.com/docs/getting_started/testing#clean-room-environment">洁净室环境<i class="fa fa-external-link"></i></span>，可直接访问已部署的合约以及导入任何合约依赖关系的能力。除了这些特性外，Truffle的Solidity测试框架的构建还考虑到以下问题：</p><ul><li>solidity测试不应该来自任何合约（如Test合约）。这使您的测试尽可能最小化，并让您完全控制您编写的合约。</li><li>solidity测试不应受任何断言库的影响。truffle为您提供了一个默认的断言库，但您可以随时更改此库以符合您的需求。</li><li>您应该能够针对任何Ethereum客户端运行您的Solidity测试。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在深入探索之前，我们来看一个示例Solidity测试。以下是通过<code>truffle unbox metacoin</code>为您提供的示例Solidity测试：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;</span><br><span class="line">import &quot;../contracts/MetaCoin.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestMetacoin &#123;</span><br><span class="line">  function testInitialBalanceUsingDeployedContract() &#123;</span><br><span class="line">    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());</span><br><span class="line"></span><br><span class="line">    uint expected = 10000;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testInitialBalanceWithNewMetaCoin() &#123;</span><br><span class="line">    MetaCoin meta = new MetaCoin();</span><br><span class="line"></span><br><span class="line">    uint expected = 10000;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, &quot;Owner should have 10000 MetaCoin initially&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ truffle test</span><br><span class="line">Compiling ConvertLib.sol...</span><br><span class="line">Compiling MetaCoin.sol...</span><br><span class="line">Compiling truffle/Assert.sol</span><br><span class="line">Compiling truffle/DeployedAddresses.sol</span><br><span class="line">Compiling ../test/TestMetacoin.sol...</span><br><span class="line"></span><br><span class="line">  TestMetacoin</span><br><span class="line">    ✓ testInitialBalanceUsingDeployedContract (61ms)</span><br><span class="line">    ✓ testInitialBalanceWithNewMetaCoin (69ms)</span><br><span class="line"></span><br><span class="line">  2 passing (3s)</span><br></pre></td></tr></table></figure><p></p><h3 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h3><p>为了更好地理解发生了什么，让我们更详细地讨论一些事情。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>您的断言功能就像<code>Assert.equal()</code>通过<code>truffle/Assert.sol</code>库提供给你。这是默认的断言库，但是只要库通过触发正确的断言事件而松散地与Truffle的测试运行器集成，就可以包含自己的断言库。你可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvbnNlblN5cy90cnVmZmxlL2Jsb2IvYmV0YS9saWIvdGVzdGluZy9Bc3NlcnQuc29s" title="https://github.com/ConsenSys/truffle/blob/beta/lib/testing/Assert.sol">Assert.sol<i class="fa fa-external-link"></i></span>中找到所有可用的断言函数。</p><h4 id="部署的地址"><a href="#部署的地址" class="headerlink" title="部署的地址"></a>部署的地址</h4><p>您部署的合约的地址（即作为迁移一部分部署的合约）可通过<code>truffle/DeployedAddresses.sol</code>库获得。这是由Truffle提供的，并且在每个套件运行之前重新编译并重新链接，以便为您的测试提供Truffle的洁净室环境。该库为所有已部署的合约提供函数，形式如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeployedAddresses.&lt;contract name&gt;();</span><br></pre></td></tr></table></figure><p></p><p>这将返回一个地址，然后您可以使用该地址访问该合约。请参阅上面的示例测试了解使用情况。</p><p>为了使用已部署的合约，您必须将合约代码导入到测试套件中。注意示例中的<code>import &quot;../contracts/MetaCoin.sol&quot;;</code>。此导入与<code>./test</code>目录中存在的测试合约相关，并且它位于测试目录之外以便查找MetaCoin合约。然后它使用该合约将该地址转换为<code>MetaCoin</code>类型。</p><h3 id="测试合约名称"><a href="#测试合约名称" class="headerlink" title="测试合约名称"></a>测试合约名称</h3><p>所有测试合同必须<code>Test</code>开头，<code>t</code>为大写字母<code>T</code>。这与测试助手和项目合约（即被测合约）区别开来，让测试运行人员知道哪些合约代表测试套件。</p><h3 id="测试函数的名称"><a href="#测试函数的名称" class="headerlink" title="测试函数的名称"></a>测试函数的名称</h3><p>与测试合约名称一样，所有测试函数都必须以test小写字母开头。每个测试函数都按单个交易执行，按测试文件中的指定顺序（如Javascript测试）执行。由<code>truffle/Assert.sol</code>测试运行程序评估以确定测试结果的触发事件提供的断言函数。断言函数返回一个表示断言结果的布尔值，您可以使用它来尽早从测试中返回以防止执行错误（例如，<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2dhbmFjaGU=" title="http://truffleframework.com/ganache">Ganache<i class="fa fa-external-link"></i></span>或Truffle Develop将会公开的错误）。</p><h3 id="Before-After钩子"><a href="#Before-After钩子" class="headerlink" title="Before/After钩子"></a>Before/After钩子</h3><p>提供了许多测试钩子，如下例所示。这些钩子是<code>beforeAll</code>，<code>beforeEach</code>，<code>afterAll</code>和<code>afterEach</code>;你的Javascript测试中由Mocha提供的相同钩子。您可以使用这些钩子在每次测试之前和之后，或每个套件运行之前和之后执行设置和拆卸操作。像测试函数一样，每个钩子都作为单个交易执行。请注意，一些复杂的测试需要执行大量的设置，这可能会溢出单个交易的gas限制; 您可以通过创建具有不同后缀的多个钩子来解决此限制，如下例所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestHooks &#123;</span><br><span class="line">  uint someValue;</span><br><span class="line"></span><br><span class="line">  function beforeEach() &#123;</span><br><span class="line">    someValue = 5;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function beforeEachAgain() &#123;</span><br><span class="line">    someValue += 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function testSomeValueIsSix() &#123;</span><br><span class="line">    uint expected = 6;</span><br><span class="line"></span><br><span class="line">    Assert.equal(someValue, expected, &quot;someValue should have been 6&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该测试合约还显示您的测试函数和钩子函数都共享相同的合约状态。您可以在测试之前设置合约数据，在测试过程中使用该数据，然后重新设置数据以便下一个测试。请注意，就像您的Javascript测试一样，您的下一个测试函数将从之前运行的测试函数的状态继续。</p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p>Solidity测试具有一些高级功能，可以让您测试Solidity中的特定用例。</p><h4 id="测试例外情况"><a href="#测试例外情况" class="headerlink" title="测试例外情况"></a>测试例外情况</h4><p>您可以轻松测试您的合同是否应该引发异常（例如，针对<code>require()</code>/ <code>assert()</code>/ <code>revert()</code>语句; 以前版本的Solidity会<code>throw</code>）。</p><p>这个主题首先由作者Simon de la Rouviere在他的教程“<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL3R1dG9yaWFscy90ZXN0aW5nLWZvci10aHJvd3MtaW4tc29saWRpdHktdGVzdHM=" title="http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests">松露固体测试中的投掷测试<i class="fa fa-external-link"></i></span>”中撰写。N.B.的教程中大量使用通过过时的关键字<code>throw</code>,，从Solidity v0.4.13开始, 取而代之的是<code>revert()</code>，<code>require()</code>和<code>assert()</code>。</p><h4 id="测试以太网交易"><a href="#测试以太网交易" class="headerlink" title="测试以太网交易"></a>测试以太网交易</h4><p>您还可以测试您的合同如何对接收Ether做出反应，并在Solidity中编写该交互的脚本。要做到这一点，你的Solidity测试应该有一个返回一个uint叫做<code>initialBalance</code>的公共函数。这可以直接写成函数或公共变量，如下所示。当您的测试合同被部署到网络中时，truffle会向您的测试合同的测试账户中的发送这一数量的以太币。然后，您的测试合约可以使用该以太网币来与您的合约测试中的以太网交互。请注意，这<code>initialBalance</code>是可选的，不是必需的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &quot;truffle/Assert.sol&quot;;</span><br><span class="line">import &quot;truffle/DeployedAddresses.sol&quot;;</span><br><span class="line">import &quot;../contracts/MyContract.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract TestContract &#123;</span><br><span class="line">  // Truffle will send the TestContract one Ether after deploying the contract.</span><br><span class="line">  uint public initialBalance = 1 ether;</span><br><span class="line"></span><br><span class="line">  function testInitialBalanceUsingDeployedContract() &#123;</span><br><span class="line">    MyContract myContract = MyContract(DeployedAddresses.MyContract());</span><br><span class="line"></span><br><span class="line">    // perform an action which sends value to myContract, then assert.</span><br><span class="line">    myContract.send(...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function () &#123;</span><br><span class="line">    // This will NOT be executed when Ether is sent. \o/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>请注意，Truffle向你的账户发送以太币，但是不会执行fallback函数，因此您仍然可以在您的Solidity测试中使用fallback函数进行高级测试用例。</p><h2 id="与你的合约交互"><a href="#与你的合约交互" class="headerlink" title="与你的合约交互"></a>与你的合约交互</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>如果您为了与您的合约进行交互而自己向以太坊网络写入原始请求，您很快就会意识到编写这些请求非常笨重和麻烦。同样，你可能会发现管理状态的每个请求都很复杂。幸运的是，truffle为您处理这一复杂问题，轻松与您的合约进行互动。</p><h3 id="读取和写入数据"><a href="#读取和写入数据" class="headerlink" title="读取和写入数据"></a>读取和写入数据</h3><p>以太坊网络区分了将数据写入网络和从中读取数据的区别，这种区别在您编写应用程序的方式中起着重要作用。一般来说，写入数据称为交易（Transaction），而读取数据称为调用（call）。事务和调用的处理方式非常不同，并具有以下特征。</p><h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>交易从根本上改变了网络的状态。交易可以像发送以太币到其他账户一样简单，或像执行合约函数或向网络添加新合约一样复杂。交易的定义特征是它写入（或更改）数据。交易使Ether运行成为“gas”，交易需要时间来处理。当您通过交易执行合约的函数时，您不能立即处理该交易，因此无法接收该函数的返回值。一般来说，意图通过交易执行的函数不会返回值; 他们将会返回一个交易ID。所以总之，交易：</p><ul><li>成本gas（以太币）</li><li>改变网络的状态</li><li>不会立即处理</li><li>不会公开一个返回值（只有一个交易ID）。</li></ul><h4 id="调用-Call"><a href="#调用-Call" class="headerlink" title="调用 Call"></a>调用 Call</h4><p>另一方面，调用则非常不同。调用可用于在网络上执行代码，但不会永久更改数据。调用可以自由运行，其特征是他们读取数据。当您通过调用执行合约函数时，您将立即收到返回值。总之，调用：</p><ul><li>是免费的（不花费gas）</li><li>不要改变网络的状态</li><li>立即处理</li><li>将公开一个返回值（hooray！）</li></ul><p>在交易和调用之间进行选择与决定是要读取数据还是写入数据一样简单。</p><h3 id="抽象介绍"><a href="#抽象介绍" class="headerlink" title="抽象介绍"></a>抽象介绍</h3><p>合约抽象是与来自Javascript的以太坊合约进行交互的面包和黄油。简而言之，合约抽象是一种包装代码，可以让您轻松地与合约进行交互，从而让您忘记在引擎盖下执行的许多引擎和齿轮。truffle通过<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxlLWNvbnRyYWN0" title="https://github.com/trufflesuite/truffle-contract">truffle合约<i class="fa fa-external-link"></i></span>模块使用其自己的合约抽象，正是这种合约抽象如下所述。</p><p>然而，为了了解合约抽象的有用性，我们首先需要一个合约来谈论。我们将通过<code>truffle unbox metacoin</code>从Truffle Boxes获取MetaCoin合约。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">import &quot;./ConvertLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">// This is just a simple example of a coin-like contract.</span><br><span class="line">// It is not standards compatible and cannot be expected to talk to other</span><br><span class="line">// coin/token contracts. If you want to create a standards-compliant</span><br><span class="line">// token, see: https://github.com/ConsenSys/Tokens. Cheers!</span><br><span class="line"></span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">    mapping (address =&gt; uint) balances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">    function MetaCoin() &#123;</span><br><span class="line">        balances[tx.origin] = 10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sendCoin(address receiver, uint amount) returns(bool sufficient) &#123;</span><br><span class="line">        if (balances[msg.sender] &lt; amount) return false;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Transfer(msg.sender, receiver, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalanceInEth(address addr) returns(uint)&#123;</span><br><span class="line">        return ConvertLib.convert(getBalance(addr),2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance(address addr) returns(uint) &#123;</span><br><span class="line">        return balances[addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>本合约有三种方法除了构造函数（<code>sendCoin</code>，<code>getBalanceInEth</code>，和<code>getBalance</code>）。所有三种方法都可以作为交易或调用来执行。</p><p>现在让我们来看一看<code>MetaCoinTruffle</code>提供给我们的Javascript对象，就像在<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2NvbnNvbGU=" title="http://truffleframework.com/docs/getting_started/console">Truffle控制台中<i class="fa fa-external-link"></i></span>提供的那样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Print the deployed version of MetaCoin.</span><br><span class="line">// Note that getting the deployed version requires a promise, hence the .then.</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  console.log(instance);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// outputs:</span><br><span class="line">//</span><br><span class="line">// Contract</span><br><span class="line">// - address: &quot;0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92&quot;</span><br><span class="line">// - allEvents: ()</span><br><span class="line">// - getBalance: ()</span><br><span class="line">// - getBalanceInEth: ()</span><br><span class="line">// - sendCoin: ()</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p></p><p>请注意，抽象包含我们合约中存在的完全相同的函数。它还包含指向MetaCoin合约的已部署版本的地址。</p><h3 id="执行合约函数"><a href="#执行合约函数" class="headerlink" title="执行合约函数"></a>执行合约函数</h3><p>使用抽象，您可以轻松地在以太坊网络上执行合约函数。</p><h4 id="进行交易"><a href="#进行交易" class="headerlink" title="进行交易"></a>进行交易</h4><p>MetaCoin合约上有三项我们可以执行的函数。如果你分析它们中的每一个，你会发现这<code>sendCoin</code>是唯一一个旨在改变网络的函数。<code>sendCoin</code>是从一个帐户“发送”一些元币到下一个，并且这些更改是持续的。</p><p>在调用sendCoin时，我们会将其作为交易执行。在下面的例子中，我们将从一个账户向另一个账户发送10个Meta币，以保持网络变化的方式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line">var account_two = &quot;0xabcd...&quot;; // another address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  return meta.sendCoin(account_two, 10, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(result) &#123;</span><br><span class="line">  // If this callback is called, the transaction was successfully processed.</span><br><span class="line">  alert(&quot;Transaction successful!&quot;)</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>上面的代码有一些有趣的地方：</p><ul><li>我们直接调用了抽象的函数<code>sendCoin</code>。这将导致默认交易（即写入数据）而不是调用。</li><li>当交易成功时，直到交易处理完成才会触发fallback函数。这使工作变得轻松，意味着您不必亲自检查交易状态。</li><li>我们通过一个对象作为第三个参数传递给<code>sendCoin</code>。请注意，我们的Solidity合同中的<code>sendCoin</code>函数没有第三个参数。你在上面看到的是一个特殊的对象，它可以作为函数的最后一个参数传递，让你编辑有关交易的特定细节。在这里，我们设置<code>from</code>确保此交易是来自的地址<code>account_one</code>。</li></ul><h4 id="执行调用"><a href="#执行调用" class="headerlink" title="执行调用"></a>执行调用</h4><p>继续使用MetaCoin，请注意<code>getBalance</code>函数是从网络读取数据的理想选择。它不需要做任何改变，因为它只是返回传递给它的地址的MetaCoin余额。让我们试试看：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  return meta.getBalance.call(account_one, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(balance) &#123;</span><br><span class="line">  // If this callback is called, the call was successfully executed.</span><br><span class="line">  // Note that this returns immediately without any waiting.</span><br><span class="line">  // Let&apos;s print the return value.</span><br><span class="line">  console.log(balance.toNumber());</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>这里有趣的是：</p><ul><li>我们必须<code>.call()</code>明确地执行该函数，以让以太坊网络知道我们不打算坚持任何更改。</li><li>我们在成功时会收到了返回值而不是交易ID。请注意，因为以太坊网络可以处理非常大的数字，所以我们得到一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzLw==" title="https://github.com/MikeMcl/bignumber.js/">BigNumber<i class="fa fa-external-link"></i></span>对象，然后我们将其转换为数字。</li></ul><p><b style="color:#6ab0de">警告：我们将返回值转换为数字，因为在这个例子中数字很小。但是，如果您尝试转换大于Javascript支持的最大整数的BigNumber，则可能会遇到错误或意外行为。</b></p><h4 id="捕捉事件"><a href="#捕捉事件" class="headerlink" title="捕捉事件"></a>捕捉事件</h4><p>您的合同可以触发您可以捕获的事件，以更深入地了解您的合约在做什么。处理事件的最简单方法是处理触发事件的交易的结果对象，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var account_one = &quot;0x1234...&quot;; // an address</span><br><span class="line">var account_two = &quot;0xabcd...&quot;; // another address</span><br><span class="line"></span><br><span class="line">var meta;</span><br><span class="line">MetaCoin.deployed().then(function(instance) &#123;</span><br><span class="line">  meta = instance;  </span><br><span class="line">  return meta.sendCoin(account_two, 10, &#123;from: account_one&#125;);</span><br><span class="line">&#125;).then(function(result) &#123;</span><br><span class="line">  // result is an object with the following values:</span><br><span class="line">  //</span><br><span class="line">  // result.tx      =&gt; transaction hash, string</span><br><span class="line">  // result.logs    =&gt; array of decoded events that were triggered within this transaction</span><br><span class="line">  // result.receipt =&gt; transaction receipt object, which includes gas used</span><br><span class="line"></span><br><span class="line">  // We can loop through result.logs to see if we triggered the Transfer event.</span><br><span class="line">  for (var i = 0; i &lt; result.logs.length; i++) &#123;</span><br><span class="line">    var log = result.logs[i];</span><br><span class="line"></span><br><span class="line">    if (log.event == &quot;Transfer&quot;) &#123;</span><br><span class="line">      // We found the event!</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h4 id="处理交易结果"><a href="#处理交易结果" class="headerlink" title="处理交易结果"></a>处理交易结果</h4><p>当您进行交易时，您会收到一个<code>result</code>对象，可以为您提供有关交易的丰富信息。具体来说，你会得到以下结果：</p><ul><li><code>result.tx</code>（字符串） - 交易散列</li><li><code>result.logs</code>（数组） - 解码事件（日志）</li><li><code>result.receipt</code>（对象） - 交易收据</li></ul><p>欲了解更多信息，请参阅README中<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxlLWNvbnRyYWN0" title="https://github.com/trufflesuite/truffle-contract">truffle-contract<i class="fa fa-external-link"></i></span>的项目。</p><h4 id="向网络添加新的合约"><a href="#向网络添加新的合约" class="headerlink" title="向网络添加新的合约"></a>向网络添加新的合约</h4><p>在上述所有情况下，我们一直在使用已经部署的合约抽象。我们可以使用以下<code>.new()</code>函数将我们自己的版本部署到网络中：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MetaCoin.new().then(function(instance) &#123;</span><br><span class="line">  // Print the new address</span><br><span class="line">  console.log(instance.address);</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  // There was an error! Handle it.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h4 id="在特定地址使用合约"><a href="#在特定地址使用合约" class="headerlink" title="在特定地址使用合约"></a>在特定地址使用合约</h4><p>如果您已经拥有合约地址，则可以创建一个新抽象来表示该地址的合约。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var instance = MetaCoin.at(&quot;0x1234...&quot;);</span><br></pre></td></tr></table></figure><p></p><h4 id="发送以太币到合约"><a href="#发送以太币到合约" class="headerlink" title="发送以太币到合约"></a>发送以太币到合约</h4><p>您可能只想直接将Ether发送给合同，或者触发合同的<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL2RldmVsb3AvY29udHJhY3RzLmh0bWwjZmFsbGJhY2stZnVuY3Rpb24=" title="http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function">fallback函数<i class="fa fa-external-link"></i></span>。您可以使用以下两个选项之一来完成此操作。</p><p>选项1：通过<code>instance.sendTransaction()</code>直接发送交易给合约。这与所有可用的合约实例函数是一样的，并且与<code>web3.eth.sendTransaction</code>具有相同的API，但没有回调。<code>to</code>的值如果没有指定，该值将自动填入。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.sendTransaction(&#123;...&#125;).then(function(result) &#123;</span><br><span class="line">  // Same transaction result object as above.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>选项2：也可以直接发送Ether：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.send(web3.toWei(1, &quot;ether&quot;)).then(function(result) &#123;</span><br><span class="line">  // Same result object as above.</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p>truffle提供的合同抽象包含丰富的实用工具，可轻松与您的合约进行交互。查看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxlLWNvbnRyYWN0" title="https://github.com/trufflesuite/truffle-contract">松露合同<i class="fa fa-external-link"></i></span>文档以获得更多建议，技巧和见解。</p><h2 id="通过ETHPM进行包管理"><a href="#通过ETHPM进行包管理" class="headerlink" title="通过ETHPM进行包管理"></a>通过ETHPM进行包管理</h2><p>EthPM是以太坊的新<span class="exturl" data-url="aHR0cHM6Ly93d3cuZXRocG0uY29tLw==" title="https://www.ethpm.com/">包注册器<i class="fa fa-external-link"></i></span>。它遵循<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvaXNzdWVzLzE5MA==" title="https://github.com/ethereum/EIPs/issues/190">ERC190规范<i class="fa fa-external-link"></i></span>发布和使用智能合约包，并得到了许多不同以太坊开发工具的广泛支持。为了表明我们的支持，我们将以太坊包注册表直接整合到truffle中。</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><p>从EthPM安装一个包就像npm安装包一样简单。你可以直接运行下面的命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install &lt;package name&gt;</span><br></pre></td></tr></table></figure><p></p><p>你也可以安装指定版本的包：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install &lt;package name&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure><p></p><p>和NPM类型，EthPM版本遵从<span class="exturl" data-url="aHR0cHM6Ly9zZW12ZXIub3JnLw==" title="https://semver.org/">semver<i class="fa fa-external-link"></i></span>。你可在<span class="exturl" data-url="aHR0cHM6Ly93d3cuZXRocG0uY29tL3JlZ2lzdHJ5" title="https://www.ethpm.com/registry">Ethereum Package Registry<i class="fa fa-external-link"></i></span>处找到所有可用的包列表。</p><h3 id="安装依赖关系"><a href="#安装依赖关系" class="headerlink" title="安装依赖关系"></a>安装依赖关系</h3><p>您的项目可以定义一个<code>ethpm.json</code>文件，其中可以将项目固定到特定的依赖项和版本。要安装<code>ethpm.json</code>文件中列出的所有依赖项，请运行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle install</span><br></pre></td></tr></table></figure><p></p><p>有关该ethpm.json文件的更多详细信息，请参阅下面的<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3BhY2thZ2VzLWV0aHBtI3BhY2thZ2UtY29uZmlndXJhdGlvbg==" title="http://truffleframework.com/docs/getting_started/packages-ethpm#package-configuration">包配置<i class="fa fa-external-link"></i></span>。</p><h3 id="消费（CONSUMING）已安装合约"><a href="#消费（CONSUMING）已安装合约" class="headerlink" title="消费（CONSUMING）已安装合约"></a>消费（CONSUMING）已安装合约</h3><p>安装的软件包将被放置在您的项目文件夹中的<code>installed_contracts</code>目录中。如果没有<code>installed_contracts</code>目录存在，它会为你创建。你应该像对待NPM的<code>node_modules</code>文件夹那样对待这个文件夹 - 也就是说，除非你知道你在做什么，否则你不应该编辑里面的内容。:)</p><p>安装的软件包可以在您的测试，迁移和solidity合约文件中使用，通过<code>import</code>,<code>require</code>包或按名称找到的合约。例如，以下Solidity合约将从包<code>owned</code>中导入<code>owned.sol</code>文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">import &quot;owned/owned.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract is owned &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同样，以下迁移文件将使用包<code>ens</code>中的ENS.sol合约：(文件：<code>./migrations/2_deploy_contracts.js</code>)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ENS = artifacts.require(&quot;ens/ENS&quot;);</span><br><span class="line">var MyContract = artifacts.require(&quot;MyContract&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Only deploy ENS if there&apos;s not already an address already.</span><br><span class="line">  // i.e., don&apos;t deploy if we&apos;re using the canonical ENS address,</span><br><span class="line">  // but do deploy it if we&apos;re on a test network and ENS doesn&apos;t exist.</span><br><span class="line">  deployer.deploy(ENS, &#123;overwrite: false&#125;).then(function() &#123;</span><br><span class="line">    return deployer.deploy(MyContract, ENS.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>请注意，在上面的迁移中，我们会根据ENS是否已经设置地址来有条件地使用<code>ens</code>包并部署ENS合约。这是<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL21pZ3JhdGlvbnMjZGVwbG95ZXItZGVwbG95LWNvbnRyYWN0LWFyZ3Mtb3B0aW9ucy0=" title="http://truffleframework.com/docs/getting_started/migrations#deployer-deploy-contract-args-options-">deployer<i class="fa fa-external-link"></i></span>提供给你的一个奇妙的技巧，它使写入迁移依赖于网络工件的存在变得更加容易。在这种情况下，如果我们在Ropsten网络上运行我们的迁移，则此迁移不会部署该ENS合同，因为（在撰写本文时）Ropsten是规范ENS合同存在的地方 - 我们不想部署我们自己的合约。但是，如果我们正在针对不同的网络或测试网络运行我们的迁移，那么我们想要部署该ENS合约，以便我们有一个依赖合约来处理。</p><h3 id="发布你自己的软件包"><a href="#发布你自己的软件包" class="headerlink" title="发布你自己的软件包"></a>发布你自己的软件包</h3><p>发布自己的软件包与安装一样简单，但与NPM一样，需要更多配置。</p><h4 id="ROPSTEN"><a href="#ROPSTEN" class="headerlink" title="ROPSTEN"></a>ROPSTEN</h4><p>Ethereum软件包注册表目前存在于Ropsten测试网络中。要发布到注册中心，我们需要建立我们自己的Ropsten配置，因为我们将进行需要签名的交易。</p><p>在本例中，我们将使用Infura与NPM<code>truffle-hdwallet-provider</code>模块一起发布软件包以及一个代表Ropsten网络上Ethereum地址的12字钱包助记符。首先，在您的项目目录中通过NPM安装<code>truffle-hdwallet-provider</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install truffle-hdwallet-provider --save</span><br></pre></td></tr></table></figure><p></p><p>然后编辑您的配置，使用12字助记符添加<code>ropsten</code>网络：文件： <code>truffle.js</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);</span><br><span class="line"></span><br><span class="line">// 12-word mnemonic</span><br><span class="line">var mnemonic = &quot;opinion destroy betray ...&quot;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: &quot;127.0.0.1&quot;,</span><br><span class="line">      port: 8545,</span><br><span class="line">      network_id: &quot;*&quot; // Match any network id</span><br><span class="line">    &#125;,</span><br><span class="line">    ropsten: &#123;</span><br><span class="line">      provider: new HDWalletProvider(mnemonic, &quot;https://ropsten.infura.io/&quot;),</span><br><span class="line">      network_id: 3 // official id of the ropsten network</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="程序包配置"><a href="#程序包配置" class="headerlink" title="程序包配置"></a>程序包配置</h4><p>与NPM类似，EthPM的配置选项位于单独的JSON文件中ethpm.json。此文件与您的Truffle配置并列，并为Truffle发布包装所需的所有信息。您可以在<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29uZmlndXJhdGlvbg==" title="http://truffleframework.com/docs/advanced/configuration">配置<i class="fa fa-external-link"></i></span>部分看到可用选项的完整列表。</p><p>文件： <code>ethpm.json</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;package_name&quot;: &quot;adder&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.3&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Simple contract to add two numbers&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;Tim Coulter &lt;tim.coulter@consensys.net&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;ethereum&quot;,</span><br><span class="line">    &quot;addition&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;owned&quot;: &quot;^0.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><p>在确定您的配置后，发布很简单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle publish</span><br></pre></td></tr></table></figure><p></p><p>您会看到类似于下面的输出，并确认您的包已成功发布。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ truffle publish</span><br><span class="line">Gathering contracts...</span><br><span class="line">Finding publishable artifacts...</span><br><span class="line">Uploading sources and publishing to registry...</span><br><span class="line">+ adder@0.0.3</span><br></pre></td></tr></table></figure><p></p><h4 id="发布之前"><a href="#发布之前" class="headerlink" title="发布之前"></a>发布之前</h4><p>当使用<code>develop</code>配置为匹配任何Ethereum客户端的默认网络（如Ganache或Truffle Develop）时，您肯定会存在不希望发布到网络中的工件。在发布您的软件包之前，请考虑运行以下命令以删除任何无关的网络工件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle networks --clean</span><br></pre></td></tr></table></figure><p></p><p>有关更多信息，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29tbWFuZHMjbmV0d29ya3M=" title="http://truffleframework.com/docs/advanced/commands#networks">命令参考<i class="fa fa-external-link"></i></span>。</p><h2 id="通过NPM进行包管理"><a href="#通过NPM进行包管理" class="headerlink" title="通过NPM进行包管理"></a>通过NPM进行包管理</h2><p>Truffle标配npm集成，并且知道node_modules项目中的目录（如果存在）。这意味着您可以通过使用和分发合约，通过npm获取dapps和启用以太坊的库，使您的代码可被自己以及其其他人的代码使用。</p><h3 id="包布局"><a href="#包布局" class="headerlink" title="包布局"></a>包布局</h3><p>使用Truffle创建的项目默认具有特定的布局，可以将它们用作包。这种布局不是必需的，但如果用作公共约定 - 或“事实上的标准” - 则通过NPM分发合约和dapps将变得更容易。</p><p>truffle套件中最重要的目录如下：</p><ul><li><code>/contracts</code></li><li><code>/build</code>（其中包括<code>/build/contracts</code>由truffle创建的）</li></ul><p>第一个目录是您的合约目录，其中包含您的原始Solidity合同。第二个目录是构建目录，更具体地说<code>/build/contracts</code>，它以<code>.json</code>文件形式存放构建工件。在你的软件包中包括原始合约将允许其他人在他们自己的solidity代码中导入这些合约。同样，<code>.json</code>在你的包中包含你的构建工件将允许其他人无缝地与你的JavaScript合约交互，这可以在dapps，脚本和迁移中使用。</p><h3 id="使用一个包"><a href="#使用一个包" class="headerlink" title="使用一个包"></a>使用一个包</h3><p>在自己的项目中使用软件包时，需要注意的是，有两个地方可能对使用感兴趣的其他合约代码：在您的合约中以及您的Javascript代码（迁移和测试）中。以下提供了每个案例的示例，并讨论了充分利用其他合约并构建工件的技巧。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>在本例中，我们将使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvbnNlblN5cy9leGFtcGxlLXRydWZmbGUtbGlicmFyeQ==" title="https://github.com/ConsenSys/example-truffle-library">truffle示例库<i class="fa fa-external-link"></i></span>，该库提供了一个简单的名称注册，该注册表已部署到Morden测试网络。为了将其用作依赖项，我们必须首先通过npm用以下方式将其安装在我们的项目中：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd my_project</span><br><span class="line">$ npm install example-truffle-library</span><br></pre></td></tr></table></figure><p></p><p>请注意，上面的最后一个命令会下载软件包并将它放在<code>my_project/node_modules</code>目录中，这对于下面的示例很重要。请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS8=" title="https://docs.npmjs.com/">npm文档<i class="fa fa-external-link"></i></span>以获取使用npm安装软件包的帮助。</p><h4 id="嵌入你的合约"><a href="#嵌入你的合约" class="headerlink" title="嵌入你的合约"></a>嵌入你的合约</h4><p>要在合约中使用包的合约，这可以与Solidity的<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL2RldmVsb3AvbGF5b3V0LW9mLXNvdXJjZS1maWxlcy5odG1sPyNpbXBvcnRpbmctb3RoZXItc291cmNlLWZpbGVz" title="http://solidity.readthedocs.io/en/develop/layout-of-source-files.html?#importing-other-source-files">import<i class="fa fa-external-link"></i></span>声明一样简单。当您的导入路径不是明确的相对或绝对时，这表示您要从特定命名包中查找文件。考虑使用上面提到的示例truffle库的这个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;</span><br></pre></td></tr></table></figure><p></p><p>由于路径并未以<code>./</code>开始，Truffle知道要在项目的<code>node_modules</code>目录中查找该<code>example-truffle-library</code>文件夹。从那里，它解决了为您提供您所要求的合约的路径。</p><h4 id="嵌入JavaScript代码中"><a href="#嵌入JavaScript代码中" class="headerlink" title="嵌入JavaScript代码中"></a>嵌入JavaScript代码中</h4><p>要在JavaScript代码中与包的合约进行交互，您只需要<code>require</code>包的<code>.json</code>文件，然后使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxlLWNvbnRyYWN0" title="https://github.com/trufflesuite/truffle-contract">truffle-contract<i class="fa fa-external-link"></i></span>模块将这些文件转换为可用的抽象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var contract = require(&quot;truffle-contract&quot;);</span><br><span class="line">var data = require(&quot;example-truffle-library/build/contracts/SimpleNameRegistry.json&quot;);</span><br><span class="line">var SimpleNameRegistry = contract(data);</span><br></pre></td></tr></table></figure><p></p><p>要使用这些抽象概念，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2NvbnRyYWN0cw==" title="http://truffleframework.com/docs/getting_started/contracts">与您的合同交互<i class="fa fa-external-link"></i></span>一节以获取更多详细信息。</p><h4 id="包的部署地址"><a href="#包的部署地址" class="headerlink" title="包的部署地址"></a>包的部署地址</h4><p>有时候你希望你的合约与这个包的先前部署的合约进行交互。由于部署的地址存在于包的<code>.json</code>文件中，因此您必须执行额外的步骤才能将这些地址存入您的合约。为此，请使您的合约接受依存关系合约的地址，然后使用迁移。以下是项目中存在的示例合约以及示例迁移：</p><p>合约：<code>MyContract.sol</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.13;</span><br><span class="line"></span><br><span class="line">import &quot;example-truffle-library/contracts/SimpleNameRegistry.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">  SimpleNameRegistry registry;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function MyContract &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Simple example that uses the deployed registry from the package.</span><br><span class="line">  function getModule(bytes32 name) returns (address) &#123;</span><br><span class="line">    return registry.names(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set the registry if you&apos;re the owner.</span><br><span class="line">  function setRegistry(address addr) &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line"></span><br><span class="line">    registry = SimpleNameRegistry(addr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>迁移：<code>3_hook_up_example_library.js</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Note that artifacts.require takes care of creating an abstraction for us.</span><br><span class="line">var SimpleNameRegistry = artifacts.require(&quot;example-truffle-library/SimpleNameRegistry&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  // Deploy our contract, then set the address of the registry.</span><br><span class="line">  deployer.deploy(MyContract).then(function() &#123;</span><br><span class="line">    return MyContract.deployed();</span><br><span class="line">  &#125;).then(function(deployed) &#123;</span><br><span class="line">    return deployed.setRegistry(SimpleNameRegistry.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="发布之前-1"><a href="#发布之前-1" class="headerlink" title="发布之前"></a>发布之前</h4><p>当使用develop配置为匹配任何Ethereum客户端的默认网络（如Ganache或Truffle Develop）时，您肯定会在网络中存在不希望发布的工件。在发布您的软件包之前，请考虑运行以下命令以删除任何无关的网络工件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle networks --clean</span><br></pre></td></tr></table></figure><p></p><p>有关更多信息，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29tbWFuZHMjbmV0d29ya3M=" title="http://truffleframework.com/docs/advanced/commands#networks">命令参考<i class="fa fa-external-link"></i></span>。</p><h2 id="调试您的合约"><a href="#调试您的合约" class="headerlink" title="调试您的合约"></a>调试您的合约</h2><p>truffle包含一个集成的调试器，以便您可以调试对您的合约进行的交易。这个调试器看起来和现有的可用于传统开发环境的命令行调试器相似。</p><h3 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h3><p>在区块链上调试交易与调试传统应用程序（例如，用C ++或Javascript编写的应用程序）不同。在区块链上调试交易时，您不是实时运行代码; 相反，您正在逐步执行该交易的历史执行，并将该执行映射到其相关代码。这为我们调试提供了许多自由度，因为我们可以在任何时候调试任何交易，只要我们拥有交易交互的合同的代码和工件即可。将这些代码和工件看作类似于传统调试器所需的调试符号。</p><p>为了调试交易，您需要以下内容：</p><ul><li>truffle 4.0或以上。</li><li>交易在您想要的区块链上的哈希值。</li><li>交易发生的源代码和工件。</li></ul><p>请注意，如果您希望的交易导致异常情况或用完gas，那也没问题。交易仍然存在于链上，所以你仍然可以调试它！</p><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>要使用调试器，请收集您想要调试的交易，然后运行以下命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle debug &lt;transaction hash&gt;</span><br></pre></td></tr></table></figure><p></p><p>以一个交易<code>0x8e5dadfb921dd...</code>开始，该命令如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle debug 0x8e5dadfb921ddddfa8f53af1f9bd8beeac6838d52d7e0c2fe5085b42a4f3ca76</span><br></pre></td></tr></table></figure><p></p><p>这将启动下面描述的调试接口。</p><h3 id="调试界面"><a href="#调试界面" class="headerlink" title="调试界面"></a>调试界面</h3><p>启动调试器将打开一个熟悉的调试其他类型应用程序的界面。开始时，您会看到以下内容：</p><ul><li>在此交易过程中进行交易或创建的地址列表。</li><li>使用调试器的可用命令列表。</li><li>以及交易的初始入口点，包括合约源文件和代码预览。</li></ul><p><code>enter</code>键被设置为执行输入的最后一个命令。当调试器启动时，该enter键被设置为步进到在执行期间遇到的下一个逻辑源代码元素（即，由以太坊虚拟机评估的下一个表达式或语句）。此时，您可以按键enter逐步完成交易，或者输入其中一个可用命令来更详细地分析交易。命令列表详述如下。</p><h4 id="（O）跨越（Step-Over）"><a href="#（O）跨越（Step-Over）" class="headerlink" title="（O）跨越（Step Over）"></a>（O）跨越（Step Over）</h4><p>此命令遍历当前行，相对于当前在Solidity源文件中正在评估的语句或表达式的位置。如果您不想在当前行中进入函数调用或合约创建，或者想要快速跳转到源文件中的特定点，请使用此命令。</p><h4 id="（I）进入-Step-into"><a href="#（I）进入-Step-into" class="headerlink" title="（I）进入(Step into)"></a>（I）进入(Step into)</h4><p>该命令进入当前正在评估的函数调用或合同创建。使用此命令跳转到该函数并快速开始调试那里存在的代码。</p><h4 id="（U）走出去-Step-Out"><a href="#（U）走出去-Step-Out" class="headerlink" title="（U）走出去(Step Out)"></a>（U）走出去(Step Out)</h4><p>该命令退出当前正在运行的函数。如果这是交易的入口点，则使用此命令可以快速返回调用函数，或者结束交易的执行。</p><h4 id="（N）下一步（STEP-NEXT）"><a href="#（N）下一步（STEP-NEXT）" class="headerlink" title="（N）下一步（STEP NEXT）"></a>（N）下一步（STEP NEXT）</h4><p>该命令转到源代码中的下一个逻辑语句或表达式。例如，在虚拟机可以评估完整表达式之前，需要先评估子表达式。如果您想分析虚拟机评估的每个逻辑项，请使用此命令。</p><h4 id="（-）步指令"><a href="#（-）步指令" class="headerlink" title="（;）步指令"></a>（;）步指令</h4><p>该命令允许您逐步查看虚拟机评估的每条单独指令。如果您有兴趣了解由Solidity源代码创建的低级别字节码，这非常有用。当你使用这个命令时，调试器在评估指令时也会打印出栈数据。</p><h4 id="（P）打印指令"><a href="#（P）打印指令" class="headerlink" title="（P）打印指令"></a>（P）打印指令</h4><p>该命令打印当前的指令和堆栈数据，但不会进入下一条指令。如果希望在使用上述逻辑命令浏览交易后查看当前指令和堆栈数据，请使用此选项。</p><h4 id="（H）打印此帮助"><a href="#（H）打印此帮助" class="headerlink" title="（H）打印此帮助"></a>（H）打印此帮助</h4><p>打印可用命令的列表。</p><h4 id="（Q）退出"><a href="#（Q）退出" class="headerlink" title="（Q）退出"></a>（Q）退出</h4><p>退出调试器。</p><h2 id="使用Truffle开发和控制台"><a href="#使用Truffle开发和控制台" class="headerlink" title="使用Truffle开发和控制台"></a>使用Truffle开发和控制台</h2><p>有时，为了测试和调试目的，或者手工执行交易，交互式地处理您的合约是很好的。Truffle为您提供了两种通过交互式控制台执行此操作的简单方法，您的合约可供使用并随时可用。</p><ul><li>Truffle控制台：连接到任何以太坊客户端的基本交互式控制台</li><li>Truffle开发：交互式控制台，也产生一个发展区块链</li></ul><h3 id="为啥是两个不同的控制台？"><a href="#为啥是两个不同的控制台？" class="headerlink" title="为啥是两个不同的控制台？"></a>为啥是两个不同的控制台？</h3><p>拥有两个不同的控制台可让您根据自己的需求选择最佳工具。</p><p>使用Truffle控制台的理由：</p><ul><li>你有一个你已经使用的客户端，如Ganache或geth</li><li>你想迁移到测试网络（或以太坊网络）</li><li>您想要使用特定的助记符或帐户列表</li></ul><p>使用Truffle Develop的原因：</p><ul><li>您正在测试您的项目，无意立即部署</li><li>您无需使用特定帐户（并且使用默认开发帐户即可）</li><li>您不想安装和管理单独的区块链客户端</li></ul><h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><p>所有你需要的命令都在你的项目文件夹中。你不需要在根目录。</p><h4 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h4><p>启动控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle console</span><br></pre></td></tr></table></figure><p></p><p>这将查找在配置中称为<code>development</code>的网络定义，并连接到它（如果可用）。您可以使用该<code>--network &lt;name&gt;</code>选项覆盖此选项。在<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvbmV0d29ya3M=" title="http://truffleframework.com/docs/advanced/networks">“网络”<i class="fa fa-external-link"></i></span>部分以及<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29tbWFuZHM=" title="http://truffleframework.com/docs/advanced/commands">命令参考<i class="fa fa-external-link"></i></span>中查看更多详细信息。</p><p>当您加载控制台时，您会立即看到以下提示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle(development)&gt;</span><br></pre></td></tr></table></figure><p></p><p>这告诉你你正在使用d<code>evelopment</code>网络在Truffle控制台中运行。</p><h4 id="TRUFFLE-DEVELOP"><a href="#TRUFFLE-DEVELOP" class="headerlink" title="TRUFFLE DEVELOP"></a>TRUFFLE DEVELOP</h4><p>启动TRUFFLE DEVELOP：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle develop</span><br></pre></td></tr></table></figure><p></p><p>无论您的<code>truffle.js</code>配置文件需要什么，这将在端口<code>9545</code>上本地产生一个开发区块链。</p><p>当你启动了TRUFFLE DEVELOP，你会看到以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Truffle Develop started at http://localhost:9545/</span><br><span class="line"></span><br><span class="line">Accounts:</span><br><span class="line">(0) 0x627306090abab3a6e1400e9345bc60c78a8bef57</span><br><span class="line">(1) 0xf17f52151ebef6c7334fad080c5704d77216b732</span><br><span class="line">(2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef</span><br><span class="line">(3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544</span><br><span class="line">(4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2</span><br><span class="line">(5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e</span><br><span class="line">(6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5</span><br><span class="line">(7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5</span><br><span class="line">(8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc</span><br><span class="line">(9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de</span><br><span class="line"></span><br><span class="line">Private Keys:</span><br><span class="line">(0) c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3</span><br><span class="line">(1) ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f</span><br><span class="line">(2) 0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1</span><br><span class="line">(3) c88b703fb08cbea894b6aeff5a544fb92e78a18e19814cd85da83b71f772aa6c</span><br><span class="line">(4) 388c684f0ba1ef5017716adb5d21a053ea8e90277d0868337519f97bede61418</span><br><span class="line">(5) 659cbb0e2411a44db63778987b1e22153c086a95eb6b18bdf89de078917abc63</span><br><span class="line">(6) 82d052c865f5763aad42add438569276c00d3d88a2d062d36b2bae914d58b8c8</span><br><span class="line">(7) aa3680d5d48a8283413f7a108367c7299ca73f553735860a87b08f39395618b7</span><br><span class="line">(8) 0f62d96d6675f32685bbdb8ac13cda7c23436f63efbb9d07700d8669ff12b7c4</span><br><span class="line">(9) 8d5366123cb560bb606379f90a0bfd4769eecc0557f1b362dcae9012b548b1e5</span><br><span class="line"></span><br><span class="line">Mnemonic: candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</span><br></pre></td></tr></table></figure><p></p><p>这会向您显示此特定区块链的地址，私钥和助记符。</p><p><b style="color:#6ab0de">注意：助记符和地址不能更改。如果您想使用不同的助记符或一组地址，我们推荐使用Ganache。</b></p><p><b style="color:#c7254e">警告：切记不要使用这些地址或主网上的助记符。这仅用于开发。</b></p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>Truffle Develop和控制台都提供了Truffle命令行工具中的大部分功能。例如，您可以在控制台中输入内容<code>migrate --reset</code>，并将其解释为与在命令行上运行<code>truffle migrate --reset</code>时相同。</p><p>此外，Truffle Develop和控制台还具有以下特点：</p><ul><li>你所有的编译合约都可以使用。</li><li>在每个命令（例如<code>migrate --reset</code>）您的合同被重新配置后，您可以立即开始使用新分配的地址和二进制文件。</li><li>该<code>web3</code>库已经可用，并已设置为连接到您的以太坊客户端。</li><li>所有返回承诺的命令都会自动解析，并打印结果，不需要为简单的命令使用<code>.then()</code>。例如，以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyContract.at(&quot;0xabcd...&quot;).getValue.call();</span><br></pre></td></tr></table></figure></li></ul><p>会返回类似如下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p></p><h3 id="可用的命令"><a href="#可用的命令" class="headerlink" title="可用的命令"></a>可用的命令</h3><ul><li><code>build</code></li><li><code>compile</code></li><li><code>create</code></li><li><code>debug</code></li><li><code>exec</code></li><li><code>install</code></li><li><code>migrate</code></li><li><code>networks</code></li><li><code>opcode</code></li><li><code>publish</code></li><li><code>test</code></li><li><code>version</code></li></ul><p>如果truffle命令不可用，那是因为它与现有项目无关（例如<code>init</code>）或者没有意义（例如<code>develop</code>或<code>console</code>）。</p><p>查看完整的<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29tbWFuZHM=" title="http://truffleframework.com/docs/advanced/commands">命令参考<i class="fa fa-external-link"></i></span>了解更多信息。</p><h2 id="编写外部脚本"><a href="#编写外部脚本" class="headerlink" title="编写外部脚本"></a>编写外部脚本</h2><p>通常您可能想要运行与您的合同交互的外部脚本。truffle提供了一种简单的方法来实现这一点，根据您所需的网络引导您的合同，并根据您的<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvY29uZmlndXJhdGlvbg==" title="http://truffleframework.com/docs/advanced/configuration">项目配置<i class="fa fa-external-link"></i></span>自动连接到您的以太坊客户端。</p><h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><p>要运行外部脚本，请执行以下操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle exec &lt;path/to/file.js&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>为了使外部脚本正确运行，<code>Truffle</code>期望它们导出一个函数，该函数唯一的参数作为回调函数：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(callback) &#123;</span><br><span class="line">  // perform actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>只要在脚本结束时调用回调函数，就可以在该脚本中执行任何您想要的操作。回调接受一个错误作为它的第一个也是唯一的参数。如果提供了错误，执行将暂停并且该进程将返回非零退出代码。</p><h2 id="使用构建管道"><a href="#使用构建管道" class="headerlink" title="使用构建管道"></a>使用构建管道</h2><p>Truffle 1.0和2.0标准的默认构建系统主要面向Web应用程序（这里，术语“构建”意味着将代码工件转换为HTML，Javascript和CSS）。该构建系统已被引入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxlLWRlZmF1bHQtYnVpbGRlci90cmVlL21hc3Rlcg==" title="https://github.com/trufflesuite/truffle-default-builder/tree/master">自己的模块<i class="fa fa-external-link"></i></span>，使Truffle可用于各种应用并可扩展。</p><p>Truffle可以配置为与任何构建系统紧密集成。要配置自定义生成系统，请参阅<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvYWR2YW5jZWQvYnVpbGRfcHJvY2Vzc2Vz" title="http://truffleframework.com/docs/advanced/build_processes">高级生成过程<i class="fa fa-external-link"></i></span>部分以获取更多详细信息。</p><h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><p>要在构建系统时编译应用程序，请运行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle build</span><br></pre></td></tr></table></figure><p></p><p>请注意，如果您尝试在未首先配置自定义构建过程的情况下运行<code>build</code>命令，则会收到错误。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity内联装配通用语言</title>
      <link href="//blockchain/solidity%E5%86%85%E8%81%94%E8%A3%85%E9%85%8D%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80.html"/>
      <url>//blockchain/solidity%E5%86%85%E8%81%94%E8%A3%85%E9%85%8D%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:red">JULIA是一种可以编译到各种不同后端的中间语言（EVM1.0，EVM 1.5和eWASM正在计划中）。正因为如此，它被设计为所有三个平台均可用。它已经可以用于Solidity内部的“内联汇编”，并且未来版本的Solidity编译器甚至将JULIA用作中间语言。为JULIA构建高级优化器阶段也应该很容易。</b></p><p><b style="color:#6ab0de">注意:请注意，用于“内联汇编”的风格不具有类型（所有内容均是<code>u256</code>类型），并且内置函数与EVM操作码相同。有关详细信息，请参阅内联汇编文档。</b></p><p>JULIA的核心组件是函数，语句块，变量，文本（literals），for循环，if语句，switch语句，表达式和变量赋值。</p><p>JULIA是类型化的，变量和文字（Literals）都必须用后缀表示法指定类型。支持的类型有<code>bool</code>，<code>u8</code>，<code>s8</code>，<code>u32</code>，<code>s32</code>， <code>u64</code>，<code>s64</code>，<code>u128</code>，<code>s128</code>，<code>u256</code>和<code>s256</code>。</p><p>JULIA本身甚至不提供操作符。如果EVM是运行目标，则操作码将以内置函数提供，但如果后端更改，则可以重新实现它们。有关强制性内置函数的列表，请参阅下面的部分。</p><p>下面的示例程序假定EVM操作码<code>mul</code>，<code>div</code>和<code>mod</code>可以本地或者作为函数可用并计算求幂。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base:u256, exponent:u256) -&gt; result:u256</span><br><span class="line">    &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0:u256 &#123; result := 1:u256 &#125;</span><br><span class="line">        case 1:u256 &#123; result := base &#125;</span><br><span class="line">        default:</span><br><span class="line">        &#123;</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2:u256))</span><br><span class="line">            switch mod(exponent, 2:u256)</span><br><span class="line">                case 1:u256 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>也可以使用for循环而不是递归来实现相同的函数。在这里，我们需要EVM操作码<code>lt</code>（小于）和<code>add</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base:u256, exponent:u256) -&gt; result:u256</span><br><span class="line">    &#123;</span><br><span class="line">        result := 1:u256</span><br><span class="line">        for &#123; let i := 0:u256 &#125; lt(i, exponent) &#123; i := add(i, 1:u256) &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            result := mul(result, base)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="JULIA规格"><a href="#JULIA规格" class="headerlink" title="JULIA规格"></a>JULIA规格</h2><p>本章介绍JULIA代码。JULIA代码通常放置在JULIA对象中，将在下一章中介绍。</p><p>语法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement =</span><br><span class="line">    Block |</span><br><span class="line">    FunctionDefinition |</span><br><span class="line">    VariableDeclaration |</span><br><span class="line">    Assignment |</span><br><span class="line">    Expression |</span><br><span class="line">    Switch |</span><br><span class="line">    ForLoop |</span><br><span class="line">    BreakContinue</span><br><span class="line">FunctionDefinition =</span><br><span class="line">    &apos;function&apos; Identifier &apos;(&apos; TypedIdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; TypedIdentifierList )? Block</span><br><span class="line">VariableDeclaration =</span><br><span class="line">    &apos;let&apos; TypedIdentifierList ( &apos;:=&apos; Expression )?</span><br><span class="line">Assignment =</span><br><span class="line">    IdentifierList &apos;:=&apos; Expression</span><br><span class="line">Expression =</span><br><span class="line">    FunctionCall | Identifier | Literal</span><br><span class="line">If =</span><br><span class="line">    &apos;if&apos; Expression Block</span><br><span class="line">Switch =</span><br><span class="line">    &apos;switch&apos; Expression Case* ( &apos;default&apos; Block )?</span><br><span class="line">Case =</span><br><span class="line">    &apos;case&apos; Literal Block</span><br><span class="line">ForLoop =</span><br><span class="line">    &apos;for&apos; Block Expression Block Block</span><br><span class="line">BreakContinue =</span><br><span class="line">    &apos;break&apos; | &apos;continue&apos;</span><br><span class="line">FunctionCall =</span><br><span class="line">    Identifier &apos;(&apos; ( Expression ( &apos;,&apos; Expression )* )? &apos;)&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">TypeName = Identifier | BuiltinTypeName</span><br><span class="line">BuiltinTypeName = &apos;bool&apos; | [us] ( &apos;8&apos; | &apos;32&apos; | &apos;64&apos; | &apos;128&apos; | &apos;256&apos; )</span><br><span class="line">TypedIdentifierList = Identifier &apos;:&apos; TypeName ( &apos;,&apos; Identifier &apos;:&apos; TypeName )*</span><br><span class="line">Literal =</span><br><span class="line">    (NumberLiteral | StringLiteral | HexLiteral | TrueLiteral | FalseLiteral) &apos;:&apos; TypeName</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">TrueLiteral = &apos;true&apos;</span><br><span class="line">FalseLiteral = &apos;false&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure><p></p><h3 id="对语法的限制"><a href="#对语法的限制" class="headerlink" title="对语法的限制"></a>对语法的限制</h3><p>Switches必须至少有一个case（包括默认case）。如果表达式的所有可能值都被覆盖了，那么就不应该允许使用默认情况（例如，一个带有bool表达式的开关，同时具有true和false的情况下不应允许默认情况）。</p><p>每个表达式都计算为零个或多个值。标识符和文字只计算一个值，函数调用计算的值等于所调用函数的返回值。</p><p>在变量声明和赋值中，右侧表达式（如果存在）必须计算出与左侧变量数量相等的许多值。这是唯一允许评估多个值的表达式。</p><p>也是语句的表达式（例如语句块级别的）必须评估为零值。</p><p>在所有其他情况下，表达式必须评估为恰好一个值。</p><p><code>continue</code>和<code>break</code>语句只能在循环体内部使用和必须在相同的函数的循环（或两者都必须在顶层）。<code>for-loop</code>的条件部分必须评估到一个值。</p><p>文字(Literals)不能大于他们的类型。定义的最大类型是256位宽。</p><h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>JULIA中的作用域与语句块相关（例外是函数和for循环，如下所述），所有声明（<code>FunctionDefinition</code>，<code>VariableDeclaration</code>）都将新标识符引入到这些作用域中。</p><p>标识符在其定义的语句块中（包括所有子节点和子语句块）中都可见。作为例外，for循环（第一个块）的“init”部分中定义的标识符在for循环的所有其他部分（但不在循环之外）中都是可见的。在for循环的其他部分声明的标识符遵守常规的作用域范围规则。函数的参数和返回参数在函数体中可见，并且它们的名称不能重叠。</p><p>变量只能在声明后引用。特别是变量不能在自己的变量声明的右边引用。函数可以在声明之前被引用（如果它们是可见的）。</p><p>阴影是不允许的，也就是说，即使不可访问，也不能在另一个具有相同名称的标识符可见的位置声明标识符。（也就是同名变量不能存在）</p><p>在函数内部，不可能访问在该函数之外声明的变量。</p><h3 id="形式规范"><a href="#形式规范" class="headerlink" title="形式规范"></a>形式规范</h3><p>我们通过在AST的各个节点上提供评估重载函数E来正式指定JULIA。任何函数都可能有副作用，所以E需要两个状态对象和AST节点，并返回两个新的状态对象和可变数量的其他值。这两个状态对象是全局状态对象（在EVM的上下文中是区块链的内存，存储和状态）和本地状态对象（局部变量的状态，即EVM中堆栈的一部分） 。如果AST节点是一个语句，E将返回两个状态对象和一个用于<code>break</code>和<code>continue</code>语句的“模式” 。如果AST节点是表达式，则E返回两个状态对象，并返回与表达式计算结果相同的值。</p><p>对于这个高层次的描述，全局状态的确切性质并没有说明。本地状态<code>L</code>是标识符<code>i</code>到值<code>v</code>的映射，表示为<code>L[i] = v</code>。</p><p>对于标识符<code>v</code>，让<code>$v</code>成为标识符的名称。</p><p>我们将使用AST节点的解构符号。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">E(G, L, &lt;&#123;St1, ..., Stn&#125;&gt;: Block) =</span><br><span class="line">    let G1, L1, mode = E(G, L, St1, ..., Stn)</span><br><span class="line">    let L2 be a restriction of L1 to the identifiers of L</span><br><span class="line">    G1, L2, mode</span><br><span class="line">E(G, L, St1, ..., Stn: Statement) =</span><br><span class="line">    if n is zero:</span><br><span class="line">        G, L, regular</span><br><span class="line">    else:</span><br><span class="line">        let G1, L1, mode = E(G, L, St1)</span><br><span class="line">        if mode is regular then</span><br><span class="line">            E(G1, L1, St2, ..., Stn)</span><br><span class="line">        otherwise</span><br><span class="line">            G1, L1, mode</span><br><span class="line">E(G, L, FunctionDefinition) =</span><br><span class="line">    G, L, regular</span><br><span class="line">E(G, L, &lt;let var1, ..., varn := rhs&gt;: VariableDeclaration) =</span><br><span class="line">    E(G, L, &lt;var1, ..., varn := rhs&gt;: Assignment)</span><br><span class="line">E(G, L, &lt;let var1, ..., varn&gt;: VariableDeclaration) =</span><br><span class="line">    let L1 be a copy of L where L1[$vari] = 0 for i = 1, ..., n</span><br><span class="line">    G, L1, regular</span><br><span class="line">E(G, L, &lt;var1, ..., varn := rhs&gt;: Assignment) =</span><br><span class="line">    let G1, L1, v1, ..., vn = E(G, L, rhs)</span><br><span class="line">    let L2 be a copy of L1 where L2[$vari] = vi for i = 1, ..., n</span><br><span class="line">    G, L2, regular</span><br><span class="line">E(G, L, &lt;for &#123; i1, ..., in &#125; condition post body&gt;: ForLoop) =</span><br><span class="line">    if n &gt;= 1:</span><br><span class="line">        let G1, L1, mode = E(G, L, i1, ..., in)</span><br><span class="line">        // mode has to be regular due to the syntactic restrictions</span><br><span class="line">        let G2, L2, mode = E(G1, L1, for &#123;&#125; condition post body)</span><br><span class="line">        // mode has to be regular due to the syntactic restrictions</span><br><span class="line">        let L3 be the restriction of L2 to only variables of L</span><br><span class="line">        G2, L3, regular</span><br><span class="line">    else:</span><br><span class="line">        let G1, L1, v = E(G, L, condition)</span><br><span class="line">        if v is false:</span><br><span class="line">            G1, L1, regular</span><br><span class="line">        else:</span><br><span class="line">            let G2, L2, mode = E(G1, L, body)</span><br><span class="line">            if mode is break:</span><br><span class="line">                G2, L2, regular</span><br><span class="line">            else:</span><br><span class="line">                G3, L3, mode = E(G2, L2, post)</span><br><span class="line">                E(G3, L3, for &#123;&#125; condition post body)</span><br><span class="line">E(G, L, break: BreakContinue) =</span><br><span class="line">    G, L, break</span><br><span class="line">E(G, L, continue: BreakContinue) =</span><br><span class="line">    G, L, continue</span><br><span class="line">E(G, L, &lt;if condition body&gt;: If) =</span><br><span class="line">    let G0, L0, v = E(G, L, condition)</span><br><span class="line">    if v is true:</span><br><span class="line">        E(G0, L0, body)</span><br><span class="line">    else:</span><br><span class="line">        G0, L0, regular</span><br><span class="line">E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn&gt;: Switch) =</span><br><span class="line">    E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default &#123;&#125;)</span><br><span class="line">E(G, L, &lt;switch condition case l1:t1 st1 ... case ln:tn stn default st&apos;&gt;: Switch) =</span><br><span class="line">    let G0, L0, v = E(G, L, condition)</span><br><span class="line">    // i = 1 .. n</span><br><span class="line">    // Evaluate literals, context doesn&apos;t matter</span><br><span class="line">    let _, _, v1 = E(G0, L0, l1)</span><br><span class="line">    ...</span><br><span class="line">    let _, _, vn = E(G0, L0, ln)</span><br><span class="line">    if there exists smallest i such that vi = v:</span><br><span class="line">        E(G0, L0, sti)</span><br><span class="line">    else:</span><br><span class="line">        E(G0, L0, st&apos;)</span><br><span class="line"></span><br><span class="line">E(G, L, &lt;name&gt;: Identifier) =</span><br><span class="line">    G, L, L[$name]</span><br><span class="line">E(G, L, &lt;fname(arg1, ..., argn)&gt;: FunctionCall) =</span><br><span class="line">    G1, L1, vn = E(G, L, argn)</span><br><span class="line">    ...</span><br><span class="line">    G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)</span><br><span class="line">    Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)</span><br><span class="line">    Let &lt;function fname (param1, ..., paramn) -&gt; ret1, ..., retm block&gt;</span><br><span class="line">    be the function of name $fname visible at the point of the call.</span><br><span class="line">    Let L&apos; be a new local state such that</span><br><span class="line">    L&apos;[$parami] = vi and L&apos;[$reti] = 0 for all i.</span><br><span class="line">    Let G&apos;&apos;, L&apos;&apos;, mode = E(Gn, L&apos;, block)</span><br><span class="line">    G&apos;&apos;, Ln, L&apos;&apos;[$ret1], ..., L&apos;&apos;[$retm]</span><br><span class="line">E(G, L, l: HexLiteral) = G, L, hexString(l),</span><br><span class="line">    where hexString decodes l from hex and left-aligns it into 32 bytes</span><br><span class="line">E(G, L, l: StringLiteral) = G, L, utf8EncodeLeftAligned(l),</span><br><span class="line">    where utf8EncodeLeftAligned performs a utf8 encoding of l</span><br><span class="line">    and aligns it left into 32 bytes</span><br><span class="line">E(G, L, n: HexNumber) = G, L, hex(n)</span><br><span class="line">    where hex is the hexadecimal decoding function</span><br><span class="line">E(G, L, n: DecimalNumber) = G, L, dec(n),</span><br><span class="line">    where dec is the decimal decoding function</span><br></pre></td></tr></table></figure><p></p><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>JULIA不支持隐式类型转换，因此存在提供显式转换的函数。在将较大类型转换为较短类型时，如果发生溢出，则可能会发生运行时异常。</p><p>以下类型转换功能必须可用： -<code>u32tobool(x:u32) -&gt; y:bool</code> -<code>booltou32(x:bool) -&gt; y:u32</code> -<code>u32tou64(x:u32) -&gt; y:u64</code> -<code>u64tou32(x:u64) -&gt; y:u32</code> - 等（TBD）.</p><h3 id="低级函数"><a href="#低级函数" class="headerlink" title="低级函数"></a>低级函数</h3><p>以下函数必须可用：</p><table><thead><tr><th>算术</th><th></th></tr></thead><tbody><tr><td>addu256(x:u256, y:u256) -&gt; z:u256</td><td>x + y</td></tr><tr><td>subu256(x:u256, y:u256) -&gt; z:u256</td><td>x - y</td></tr><tr><td>mulu256(x:u256, y:u256) -&gt; z:u256</td><td>x * y</td></tr><tr><td>divu256(x:u256, y:u256) -&gt; z:u256</td><td>x / y</td></tr><tr><td>divs256(x:s256, y:s256) -&gt; z:s256</td><td>x / y，用于补码中的有符号数</td></tr><tr><td>modu256(x:u256, y:u256) -&gt; z:u256</td><td>x % y</td></tr><tr><td>mods256(x:s256, y:s256) -&gt; z:s256</td><td>x % y，用于补码中的有符号数</td></tr><tr><td>signextendu256(i:u256, x:u256) -&gt; z:u256</td><td>符号从最低有效位（i * 8 + 7）位开始计数</td></tr><tr><td>expu256(x:u256, y:u256) -&gt; z:u256</td><td>x对y的幂</td></tr><tr><td>addmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td><td>(x + y)％m，任意精确算术</td></tr><tr><td>mulmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td><td>（x * y）％m,任意精确算术</td></tr><tr><td>ltu256(x:u256, y:u256) -&gt; z:bool</td><td>如果x &lt;y,1，否则为0</td></tr><tr><td>gtu256(x:u256, y:u256) -&gt; z:bool</td><td>如果x&gt;y，1,否则为0</td></tr><tr><td>sltu256(x:s256, y:s256) -&gt; z:bool</td><td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td></tr><tr><td>sgtu256(x:s256, y:s256) -&gt; z:bool</td><td>如果x&gt;y,1，否则为0，否则为2的补码中的有符号数</td></tr><tr><td>equ256(x:u256, y:u256) -&gt; z:bool</td><td>如果x == y,1，否则为0</td></tr><tr><td>notu256(x:u256) -&gt; z:u256</td><td>〜x，x的每一位取反</td></tr><tr><td>andu256(x:u256, y:u256) -&gt; z:u256</td><td>x和y按位与</td></tr><tr><td>oru256(x:u256, y:u256) -&gt; z:u256</td><td>x和y按位或</td></tr><tr><td>xoru256(x:u256, y:u256) -&gt; z:u256</td><td>x和y的按位异或</td></tr><tr><td>shlu256(x:u256, y:u256) -&gt; z:u256</td><td>x以y的逻辑左移</td></tr><tr><td>shru256(x:u256, y:u256) -&gt; z:u256</td><td>x，y的逻辑右移</td></tr><tr><td>saru256(x:u256, y:u256) -&gt; z:u256</td><td>x以y的算术右移</td></tr><tr><td>byte(n:u256, x:u256) -&gt; v:u256</td><td>x的第n个字节，其中最重要的字节是第0个字节不能用and256（shr256（n，x），0xff替换它）并让它由EVM后端进行优化？</td></tr><tr><td>内存和存储</td><td></td></tr><tr><td>mload(p:u256) -&gt; v:u256</td><td>mem[p..(p+32))</td></tr><tr><td>mstore(p:u256, v:u256)</td><td>mem[p..(p+32)) := v</td></tr><tr><td>mstore8(p:u256, v:u256)</td><td>mem[p] := v &amp; 0xff - 仅修改单个字节</td></tr><tr><td>sload(p:u256) -&gt; v:u256</td><td>storage[p]</td></tr><tr><td>sstore(p:u256, v:u256)</td><td>storage[p] := v</td></tr><tr><td>msize() -&gt; size:u256</td><td>内存大小，即最大访问内存索引，虽然是由于内存扩展功能（由字扩展）造成的，但它总是32个字节的倍数</td></tr><tr><td>执行控制</td><td></td></tr><tr><td>create(v:u256, p:u256, s:u256)</td><td>用代码mem [p ..（p + s））创建新的合同并发送v wei并返回新的地址</td></tr><tr><td>call(g:u256, a:u256, v:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td><td>在输入mem [in ..（in + insize））时提供g gas和v wei以及输出区mem [out ..（out + oversize）），在地址a处调用合同，并在错误时返回0（例如， 1成功</td></tr><tr><td>callcode(g:u256, a:u256, v:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td><td>相同call但只能使用a的代码，否则保留在当前合同的上下文中</td></tr><tr><td>delegatecall(g:u256, a:u256, in:u256, insize:u256, out:u256, outsize:u256) -&gt; r:u256</td><td>相同callcode，但也保持caller 和callvalue</td></tr><tr><td>atop()</td><td>停止执行，与返回相同（0,0）也许它会有意义的退休，因为它等于return（0,0）。它可以是EVM后端的优化。</td></tr><tr><td>abort()</td><td>中止（相当于EVM上的无效指令）</td></tr><tr><td>return(p:u256, s:u256)</td><td>结束执行，返回数据mem [p ..（p + s））</td></tr><tr><td>revert(p:u256, s:u256)</td><td>结束执行，恢复状态更改，返回数据mem [p ..（p + s））</td></tr><tr><td>selfdestruct(a:u256)</td><td>终止执行，摧毁当前合同并将资金发送给</td></tr><tr><td>log0(p:u256, s:u256)</td><td>没有主题和数据记录[p ..（p + s））</td></tr><tr><td>log1(p:u256, s:u256, t1:u256)</td><td>记录主题t1和数据mem [p ..（p + s））</td></tr><tr><td>log2(p:u256, s:u256, t1:u256, t2:u256)</td><td>记录主题t1，t2和数据mem [p ..（p + s））</td></tr><tr><td>log3(p:u256, s:u256, t1:u256, t2:u256, t3:u256)</td><td>记录主题t，t2，t3和数据mem [p ..（p + s））</td></tr><tr><td>log4(p:u256, s:u256, t1:u256, t2:u256, t3:u256, t4:u256)</td><td>记录主题t1，t2，t3，t4和数据mem [p ..（p + s））</td></tr><tr><td>状态查询</td><td></td></tr><tr><td>blockcoinbase() -&gt; address:u256</td><td>目前的采矿受益者</td></tr><tr><td>blockdifficulty() -&gt; difficulty:u256</td><td>当前块的难度</td></tr><tr><td>blockgaslimit() -&gt; limit:u256</td><td>阻止当前块的气体限制</td></tr><tr><td>blockhash(b:u256) -&gt; hash:u256</td><td>块nr b的散列值 - 仅适用于不包括当前值的最后256个块</td></tr><tr><td>blocknumber() -&gt; block:u256</td><td>当前程序段号</td></tr><tr><td>blocktimestamp() -&gt; timestamp:u256</td><td>当前块的时间戳，以秒为单位</td></tr><tr><td>txorigin() -&gt; address:u256</td><td>交易发件人</td></tr><tr><td>txgasprice() -&gt; price:u256</td><td>交易的天然气价格</td></tr><tr><td>gasleft() -&gt; gas:u256</td><td>仍然可以用于执行的gas</td></tr><tr><td>balance(a:u256) -&gt; v:u256</td><td>地址a的余额（wei）</td></tr><tr><td>this() -&gt; address:u256</td><td>当前合同/执行上下文的地址</td></tr><tr><td>caller() -&gt; address:u256</td><td>呼叫发送者（不包括委托呼叫）</td></tr><tr><td>callvalue() -&gt; v:u256</td><td>目前的调用一起发送的以太币</td></tr><tr><td>calldataload(p:u256) -&gt; v:u256</td><td>从位置p开始的调用数据（32字节）</td></tr><tr><td>calldatasize() -&gt; v:u256</td><td>通话数据的大小以字节为单位</td></tr><tr><td>calldatacopy(t:u256, f:u256, s:u256)</td><td>从位置f的calldata复制s个字节到位置t的mem</td></tr><tr><td>codesize() -&gt; size:u256</td><td>当前合同/执行上下文的代码大小</td></tr><tr><td>codecopy(t:u256, f:u256, s:u256)</td><td>从位置f的代码复制s字节到位置t的mem</td></tr><tr><td>extcodesize(a:u256) -&gt; size:u256</td><td>地址a处代码的大小</td></tr><tr><td>extcodecopy(a:u256, t:u256, f:u256, s:u256)</td><td>像代码复制（t，f，s），但需要在地址a处进行编码</td></tr><tr><td>其他</td><td></td></tr><tr><td>discardu256(unused:u256)</td><td>丢弃价值</td></tr><tr><td>splitu256tou64(x:u256) -&gt; (x1:u64, x2:u64,x3:u64, x4:u64)</td><td>将u256分成四个u64</td></tr><tr><td>combineu64tou256(x1:u64, x2:u64, x3:u64,x4:u64) -&gt; (x:u256)</td><td>将四个U64组合成一个U256</td></tr><tr><td>sha3(p:u256, s:u256) -&gt; v:u256</td><td>keccak（MEM [P …（P + S）））</td></tr></tbody></table><p>以上的表格内容都是机翻，由于之前在solidity的内联汇编中都有类似的指令，大概进行翻译，这里有时间的话会进行相应的处理。</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>后端或目标是JULIA到特定字节码的翻译。每个后端都可以暴露以后端名称为前缀的函数。我们为两个建议的后端预留<code>evm_</code>并加上<code>ewasm_</code>前缀。</p><h3 id="后端：EVM"><a href="#后端：EVM" class="headerlink" title="后端：EVM"></a>后端：EVM</h3><p>EVM目标将具有以<code>evm_</code>前缀暴露的所有底层EVM操作码。</p><h3 id="后端：“EVM-1-5”"><a href="#后端：“EVM-1-5”" class="headerlink" title="后端：“EVM 1.5”"></a>后端：“EVM 1.5”</h3><p>TBD</p><h3 id="后端：eWASM"><a href="#后端：eWASM" class="headerlink" title="后端：eWASM"></a>后端：eWASM</h3><p>TBD</p><h2 id="JULIA对象的规范"><a href="#JULIA对象的规范" class="headerlink" title="JULIA对象的规范"></a>JULIA对象的规范</h2><p>语法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TopLevelObject = &apos;object&apos; &apos;&#123;&apos; Code? ( Object | Data )* &apos;&#125;&apos;</span><br><span class="line">Object = &apos;object&apos; StringLiteral &apos;&#123;&apos; Code? ( Object | Data )* &apos;&#125;&apos;</span><br><span class="line">Code = &apos;code&apos; Block</span><br><span class="line">Data = &apos;data&apos; StringLiteral HexLiteral</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br></pre></td></tr></table></figure><p></p><p>以上<code>Block</code>是指<code>Block</code>前一章中介绍的JULIA代码语法。</p><p>JULIA对象示例如下所示：</p><p>..代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Code consists of a single object. A single &quot;code&quot; node is the code of the object.</span><br><span class="line">// Every (other) named object or data section is serialized and</span><br><span class="line">// made accessible to the special built-in functions datacopy / dataoffset / datasize</span><br><span class="line">object &#123;</span><br><span class="line">    code &#123;</span><br><span class="line">        let size = datasize(&quot;runtime&quot;)</span><br><span class="line">        let offset = allocate(size)</span><br><span class="line">        // This will turn into a memory-&gt;memory copy for eWASM and</span><br><span class="line">        // a codecopy for EVM</span><br><span class="line">        datacopy(dataoffset(&quot;runtime&quot;), offset, size)</span><br><span class="line">        // this is a constructor and the runtime code is returned</span><br><span class="line">        return(offset, size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data &quot;Table2&quot; hex&quot;4123&quot;</span><br><span class="line"></span><br><span class="line">    object &quot;runtime&quot; &#123;</span><br><span class="line">        code &#123;</span><br><span class="line">            // runtime code</span><br><span class="line"></span><br><span class="line">            let size = datasize(&quot;Contract2&quot;)</span><br><span class="line">            let offset = allocate(size)</span><br><span class="line">            // This will turn into a memory-&gt;memory copy for eWASM and</span><br><span class="line">            // a codecopy for EVM</span><br><span class="line">            datacopy(dataoffset(&quot;Contract2&quot;), offset, size)</span><br><span class="line">            // constructor parameter is a single number 0x1234</span><br><span class="line">            mstore(add(offset, size), 0x1234)</span><br><span class="line">            create(offset, add(size, 32))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Embedded object. Use case is that the outside is a factory contract,</span><br><span class="line">        // and Contract2 is the code to be created by the factory</span><br><span class="line">        object &quot;Contract2&quot; &#123;</span><br><span class="line">            code &#123;</span><br><span class="line">                // code here ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            object &quot;runtime&quot; &#123;</span><br><span class="line">                code &#123;</span><br><span class="line">                    // code here ...</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             data &quot;Table1&quot; hex&quot;4123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity编码风格</title>
      <link href="//blockchain/solidity%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC.html"/>
      <url>//blockchain/solidity%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本指南旨在为编写可靠性代码提供编码约定。本指南应该被认为是一个不断变化的规范，随着时间的推移会发生变化，因为找到有用的约定而旧的惯例已经过时。</p><p>许多项目将实施他们自己的风格指南。在发生冲突时，项目特定的风格指南优先。</p><p>该风格指南中的结构和许多建议均取自python的<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDAwOC8=" title="https://www.python.org/dev/peps/pep-0008/">pep8风格指南<i class="fa fa-external-link"></i></span>。</p><p>本指南的目标不是编写可靠代码的正确方式或最佳方式。本指南的目标是一致性。来自python的<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDAwOC8jYS1mb29saXNoLWNvbnNpc3RlbmN5LWlzLXRoZS1ob2Jnb2JsaW4tb2YtbGl0dGxlLW1pbmRz" title="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds">pep8<i class="fa fa-external-link"></i></span>的引用很好地捕捉了这个概念。</p><p>风格指南是关于一致性的。与此风格指南的一致性非常重要。项目中的一致性更重要。一个模块或功能内的一致性是最重要的。但最重要的是：知道什么时候不一致 - 有时风格指南不适用。如有疑问，请使用您的最佳判断。看看其他例子，并决定什么看起来最好。不要犹豫，问！</p><h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>每个缩进级别使用4个空格。</p><h3 id="Tabs或空格"><a href="#Tabs或空格" class="headerlink" title="Tabs或空格"></a>Tabs或空格</h3><p>空格是首选的缩进方法。</p><p>应该避免混合tabs和空格。</p><h3 id="空白行"><a href="#空白行" class="headerlink" title="空白行"></a>空白行</h3><p>顶层声明用两个空白行分隔。</p><p>正确做法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示范<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">contract B &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在一个合同环绕函数声明中有一个空白行。在相关单行的组之间可以省略空行（例如抽象合约的存根函数）</p><p>正确做法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    function spam() public;</span><br><span class="line">    function ham() public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    function spam() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ham() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示范<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    function spam() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    function ham() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="最大行的长度"><a href="#最大行的长度" class="headerlink" title="最大行的长度"></a>最大行的长度</h3><p>PEP 8建议的行保持在79（或99）字符，可帮助读者轻松解析代码。</p><p>行包裹（看示例你就明白了）应符合以下准则：</p><ol><li>第一个参数不应该附在开头括号上。</li><li>应该使用一个，并且只有一个缩进。</li><li>每个参数都应该落在自己的位置上。</li><li>终止元素<code>);</code>应该放在最后一行上。</li></ol><p>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">                              longArgument2,</span><br><span class="line">                              longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1, longArgument2,</span><br><span class="line">    longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">longArgument1,</span><br><span class="line">longArgument2,</span><br><span class="line">longArgument3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">thisFunctionCallIsReallyLong(</span><br><span class="line">    longArgument1,</span><br><span class="line">    longArgument2,</span><br><span class="line">    longArgument3);</span><br></pre></td></tr></table></figure><p></p><p>赋值语句：<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(</span><br><span class="line">    argument1,</span><br><span class="line">    argument2,</span><br><span class="line">    argument3,</span><br><span class="line">    argument4</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thisIsALongNestedMapping[being][set][to_some_value] = someFunction(argument1,</span><br><span class="line">                                                                   argument2,</span><br><span class="line">                                                                   argument3,</span><br><span class="line">                                                                   argument4);</span><br></pre></td></tr></table></figure><p></p><p>事件定义和事件触发器：<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(</span><br><span class="line">    adress sender,</span><br><span class="line">    adress recipient,</span><br><span class="line">    uint256 publicKey,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes32[] options</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(</span><br><span class="line">    sender,</span><br><span class="line">    recipient,</span><br><span class="line">    publicKey,</span><br><span class="line">    amount,</span><br><span class="line">    options</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event LongAndLotsOfArgs(adress sender,</span><br><span class="line">                        adress recipient,</span><br><span class="line">                        uint256 publicKey,</span><br><span class="line">                        uint256 amount,</span><br><span class="line">                        bytes32[] options);</span><br><span class="line"></span><br><span class="line">LongAndLotsOfArgs(sender,</span><br><span class="line">                  recipient,</span><br><span class="line">                  publicKey,</span><br><span class="line">                  amount,</span><br><span class="line">                  options);</span><br></pre></td></tr></table></figure><p></p><h3 id="源文件编码"><a href="#源文件编码" class="headerlink" title="源文件编码"></a>源文件编码</h3><p>UTF-8 或者 ASCII编码是首选。</p><h3 id="Imports语句"><a href="#Imports语句" class="headerlink" title="Imports语句"></a>Imports语句</h3><p>导入语句必须是文件的开头。</p><p>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &quot;owned&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示范：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import &quot;owned&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract B is owned &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="函数的排序"><a href="#函数的排序" class="headerlink" title="函数的排序"></a>函数的排序</h3><p>排序有助于读者识别他们可以调用哪些函数，并更容易地找到构造函数和回退定义。</p><p>函数应根据其可见性分组，并按照如下顺序排列：</p><ul><li>constructor</li><li>fallback function (if exists)</li><li>external</li><li>public</li><li>internal</li><li>private</li></ul><p>在分组中，将<code>constant</code>函数放在最后。</p><p>正确示范：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line">    function A() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // External functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // External functions that are constant</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Public functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Internal functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Private functions</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示范：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract A &#123;</span><br><span class="line"></span><br><span class="line">    // External functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Private functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // Public functions</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    function A() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Internal functions</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="表达式中的空白符"><a href="#表达式中的空白符" class="headerlink" title="表达式中的空白符"></a>表达式中的空白符</h3><p>在以下情况下避免无关的空白：</p><p>立即在括号，括号或大括号内，除单行函数声明外。</p><p>正确的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam(ham[1], Coin(&#123;name: &quot;ham&quot;&#125;));</span><br></pre></td></tr></table></figure><p></p><p>错误的示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spam( ham[ 1 ], Coin( &#123; name: &quot;ham&quot; &#125; ) );</span><br></pre></td></tr></table></figure><p></p><p>例外情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function singleLine() public &#123; spam(); &#125;</span><br></pre></td></tr></table></figure><p></p><p>紧接在逗号,分号前面的空白符：<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function spam(uint i, Coin coin) public;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function spam(uint i , Coin coin) public ;</span><br></pre></td></tr></table></figure><p></p><p>在任务或其他操作符周围的多个空间与另一个空间对齐：<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 1;</span><br><span class="line">y = 2;</span><br><span class="line">long_variable = 3;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x             = 1;</span><br><span class="line">y             = 2;</span><br><span class="line">long_variable = 3;</span><br></pre></td></tr></table></figure><p></p><p>不要在fallback函数中包含空格：<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function() public &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function () public &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>表示合同，库，函数和结构主体的大括号应该：</p><ol><li>与声明在同一行</li><li>在声明开始的同一缩进级别自行关闭。</li><li>开口支架应该由一个空间进行。</li></ol><p>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract Coin &#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Coin</span><br><span class="line">&#123;</span><br><span class="line">    struct Bank &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于if, else, while， for这些语句也是一样的。</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>对于简短的函数声明，建议将函数体的左大括号与函数声明保持在同一行。</p><p>右大括号应该与函数声明的缩进级别相同。</p><p>前面的大括号应该在前面有一个空格。</p><p>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function increment(uint x) public pure returns (uint) &#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure onlyowner returns (uint) &#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function increment(uint x) public pure returns (uint)</span><br><span class="line">&#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure returns (uint)&#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure returns (uint) &#123;</span><br><span class="line">    return x + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function increment(uint x) public pure returns (uint) &#123;</span><br><span class="line">    return x + 1;&#125;</span><br></pre></td></tr></table></figure><p></p><p>你应该明确标注所有函数的可见性，包括构造函数。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function explicitlyPublic(uint val) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function implicitlyPublic(uint val) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>函数的可见性修饰符应位于任何自定义修饰符之前。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function kill() public onlyowner &#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function kill() onlyowner public &#123;</span><br><span class="line">    selfdestruct(owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于长函数声明，建议将每个参数放在与函数体相同的缩进级别的自己的行上。 右括号和左括号应该放在它们自己的行上，以及与函数声明相同的缩进级别。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionHasLotsOfArguments(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c,</span><br><span class="line">    address d,</span><br><span class="line">    address e,</span><br><span class="line">    address f</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionHasLotsOfArguments(address a, address b, address c,</span><br><span class="line">    address d, address e, address f) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionHasLotsOfArguments(address a,</span><br><span class="line">                                        address b,</span><br><span class="line">                                        address c,</span><br><span class="line">                                        address d,</span><br><span class="line">                                        address e,</span><br><span class="line">                                        address f) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionHasLotsOfArguments(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c,</span><br><span class="line">    address d,</span><br><span class="line">    address e,</span><br><span class="line">    address f) public &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果一个长函数声明有修饰符，那么每个修饰符应该放在它自己的行中。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">    public</span><br><span class="line">    onlyowner</span><br><span class="line">    priced</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionNameIsReallyLong(</span><br><span class="line">    address x,</span><br><span class="line">    address y,</span><br><span class="line">    address z,</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    onlyowner</span><br><span class="line">    priced</span><br><span class="line">    returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">                                      public</span><br><span class="line">                                      onlyowner</span><br><span class="line">                                      priced</span><br><span class="line">                                      returns (address) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">    public onlyowner priced returns (address)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function thisFunctionNameIsReallyLong(address x, address y, address z)</span><br><span class="line">    public</span><br><span class="line">    onlyowner</span><br><span class="line">    priced</span><br><span class="line">    returns (address) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>多行输出参数和返回语句应遵循建议用于包装“最大行长度”部分中找到的长行的相同样式。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    returns (</span><br><span class="line">        address someAddressName,</span><br><span class="line">        uint256 LongArgument,</span><br><span class="line">        uint256 Argument</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    doSomething()</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        veryLongReturnArg1,</span><br><span class="line">        veryLongReturnArg2,</span><br><span class="line">        veryLongReturnArg3</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function thisFunctionNameIsReallyLong(</span><br><span class="line">    address a,</span><br><span class="line">    address b,</span><br><span class="line">    address c</span><br><span class="line">)</span><br><span class="line">    public</span><br><span class="line">    returns (address someAddressName,</span><br><span class="line">             uint256 LongArgument,</span><br><span class="line">             uint256 Argument)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething()</span><br><span class="line"></span><br><span class="line">    return (veryLongReturnArg1,</span><br><span class="line">            veryLongReturnArg1,</span><br><span class="line">            veryLongReturnArg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于基础需要参数的继承合约的构造函数，如果函数声明很长或难以阅读，建议将基础构造函数以与修饰符相同的方式放到新行上。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A is B, C, D &#123;</span><br><span class="line">    function A(uint param1, uint param2, uint param3, uint param4, uint param5)</span><br><span class="line">        B(param1)</span><br><span class="line">        C(param2, param3)</span><br><span class="line">        D(param4)</span><br><span class="line">        public</span><br><span class="line">    &#123;</span><br><span class="line">        // do something with param5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract A is B, C, D &#123;</span><br><span class="line">    function A(uint param1, uint param2, uint param3, uint param4, uint param5)</span><br><span class="line">    B(param1)</span><br><span class="line">    C(param2, param3)</span><br><span class="line">    D(param4)</span><br><span class="line">    public</span><br><span class="line">    &#123;</span><br><span class="line">        // do something with param5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract A is B, C, D &#123;</span><br><span class="line">    function A(uint param1, uint param2, uint param3, uint param4, uint param5)</span><br><span class="line">        B(param1)</span><br><span class="line">        C(param2, param3)</span><br><span class="line">        D(param4)</span><br><span class="line">        public &#123;</span><br><span class="line">        // do something with param5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当用单个语句声明简短函数时，允许在一行中完成。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function shortFunction() public &#123; doSomething(); &#125;</span><br></pre></td></tr></table></figure><p></p><p>这些函数声明的准则旨在提高可读性。 作者应该使用他们的最佳判断，因为本指南并不试图涵盖函数声明的所有可能的排列。</p><h3 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h3><p>待讨论</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>数组变量的声明在类型和括号之间不应该有空格。<br>正确示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint[] x;</span><br></pre></td></tr></table></figure><p></p><p>错误示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint [] x;</span><br></pre></td></tr></table></figure><p></p><h3 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h3><ul><li>字符串应该用双引号而不是单引号引用。</li><li>操作符左右都应该有空格，例如<code>x += 3 + 4;</code></li><li>比其他优先级高的运算符可以排除周围的空白，以表示优先级。 这是为了提高复杂语句的可读性。 您应该始终在运算符的任一侧使用相同数量的空白：</li></ul><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>命名约定在被广泛采用和使用时功能强大。 使用不同的约定可以传达重要的元信息，否则这些信息将不会立即可用。</p><p>这里给出的命名建议旨在提高可读性，因此它们不是规则，而是试图帮助通过事物名称传达最多信息的指导原则。</p><p>最后，代码库中的一致性应始终取代本文档中概述的任何约定。</p><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><p>防止混淆，以下名称将用于指代不同的命名风格。</p><ul><li><code>b</code> (single lowercase letter)</li><li><code>B</code> (single uppercase letter)</li><li><code>lowercase</code></li><li><code>lower_case_with_underscores</code></li><li><code>UPPERCASE</code></li><li><code>UPPER_CASE_WITH_UNDERSCORES</code></li><li><code>CapitalizedWords</code> (or CapWords)</li><li><code>mixedCase</code> (differs from CapitalizedWords by initial lowercase character!)</li><li><code>Capitalized_Words_With_Underscores</code></li></ul><h3 id="规避的命名"><a href="#规避的命名" class="headerlink" title="规避的命名"></a>规避的命名</h3><ul><li><code>l</code> - Lowercase letter el</li><li><code>O</code> - Uppercase letter oh</li><li><code>I</code> - Uppercase letter eye</li></ul><p>切勿将任何这些用于单个字母的变量名称。 它们通常与数字1和零不可区分。</p><h3 id="合约和库命名"><a href="#合约和库命名" class="headerlink" title="合约和库命名"></a>合约和库命名</h3><p>大写风格：<code>SimpleToken</code>, <code>SmartBank</code>, <code>CertificateHashRepository</code>, <code>Player</code></p><h3 id="结构命名"><a href="#结构命名" class="headerlink" title="结构命名"></a>结构命名</h3><p>大写风格：<code>MyCoin</code>, <code>Position</code>, <code>PositionXY</code></p><h3 id="事件命名"><a href="#事件命名" class="headerlink" title="事件命名"></a>事件命名</h3><p>大写风格：<code>Deposit</code>, <code>Transfer</code>, <code>Approval</code>, <code>BeforeTransfer</code>, <code>AfterTransfer</code></p><h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>mixedCase：<code>getBalance</code>, <code>transfer</code>, <code>verifyOwner</code>, <code>addMember</code>, <code>changeOwner</code></p><h3 id="函数参数命名"><a href="#函数参数命名" class="headerlink" title="函数参数命名"></a>函数参数命名</h3><p>mixedCase：<code>initialSupply</code>, <code>account</code>, <code>recipientAddress</code>, <code>senderAddress</code>, <code>newOwner</code></p><h3 id="本地变量与状态变量"><a href="#本地变量与状态变量" class="headerlink" title="本地变量与状态变量"></a>本地变量与状态变量</h3><p>mixedCase：</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><code>MAX_BLOCKS</code></p><h3 id="函数修饰符命名"><a href="#函数修饰符命名" class="headerlink" title="函数修饰符命名"></a>函数修饰符命名</h3><p>mixedCase：<code>onlyBy</code>, <code>onlyAfter</code>, <code>onlyDuringThePreSale</code>.</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>CapWords：<code>TokenGroup</code>, <code>Frame</code>, <code>HashStyle</code>, <code>CharacterLocation</code>.</p><h3 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a>避免命名冲突</h3><p><code>single_trailing_underscore_</code></p><p>当所需名称与内置名称或其他名称相冲突时，会提示此惯例。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity应用程序二进制接口规范（ABI）</title>
      <link href="//blockchain/solidity%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%EF%BC%88ABI%EF%BC%89.html"/>
      <url>//blockchain/solidity%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83%EF%BC%88ABI%EF%BC%89.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>应用程序二进制接口（ABI）是与区块链以外的以太坊生态系统中的合约进行交互的标准方式，也是合约到合约交互的标准方式。数据根据其类型进行编码，如本规范中所述。编码不是自描述的，因此需要一个模式才能解码。</p><p>我们假设合约的接口函数是强类型的，在编译时和静态时都是已知的。不会提供自检机制。我们假设所有合约都将具有编译时可用的任何合约的接口定义。</p><p>本规范不涉及其接口是动态的或仅在运行时才知道的合约。如果这些情况变得重要，那么它们可以作为以太坊生态系统内的设施进行充分处理。</p><h2 id="函数选择器"><a href="#函数选择器" class="headerlink" title="函数选择器"></a>函数选择器</h2><p>函数调用的调用数据的前四个字节指定要调用的函数。它是函数签名的Keccak（SHA-3）哈希中的前面（左边，高位在大端）四个字节。签名被定义为基本原型的规范表达式，即带有括号括起来的参数类型列表的函数名称。参数类型由一个逗号分隔 - 不使用空格。</p><p><b style="color:#6ab0de">注意：函数的返回类型不是此签名的一部分。在Solidity的函数中，不考虑<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI292ZXJsb2FkLWZ1bmN0aW9u" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#overload-function">重载<i class="fa fa-external-link"></i></span>类型。原因是保持函数调用的解析与上下文无关。然而，ABI的JSON描述包含输入和输出。请参阅（<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2FiaS1zcGVjLmh0bWwjYWJpLWpzb24=" title="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-json">JSON ABI<i class="fa fa-external-link"></i></span>）</b></p><h2 id="参数编码"><a href="#参数编码" class="headerlink" title="参数编码"></a>参数编码</h2><p>从第五个字节开始，是编码的参数。这种编码也用于其他地方，例如返回值和事件参数都以相同的方式编码，而不用四个字节指定函数。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>存在以下基本类型：</p><ul><li><code>uint&lt;M&gt;</code>：<code>M</code>位的无符号整数类型，<code>0 &lt; M &lt;= 256</code>, <code>M % 8 == 0</code>。例如<code>uint32</code>，<code>uint8</code>，<code>uint256</code>。</li><li><code>int&lt;M&gt;</code>：<code>M</code>位的二进制补码有符号整数类型，<code>0 &lt; M &lt;= 256</code>, <code>M % 8 == 0</code>。</li><li><code>address</code>：相当于<code>uint160</code>，除了假设的解释和语言类型。为了计算函数选择器，使用<code>address</code>。</li><li><code>uint</code>，<code>int</code>：同义词<code>uint256</code>，<code>int256</code>分别。为了计算函数选择器，<code>uint256</code>和<code>int256</code>必须使用。</li><li><code>bool</code>：等同于<code>uint8</code>限制为0和1的值。为了计算函数选择器，bool被使用。</li><li><code>fixed&lt;M&gt;x&lt;N&gt;</code>：<code>M</code>位有符号的定点小数，<code>8 &lt;= M &lt;= 256</code>，<code>M % 8 ==0</code>和<code>0 &lt; N &lt;= 80</code>，其表示的值<code>v</code>作为<code>v / (10 ** N)</code>。</li><li><code>fixed</code>，<code>ufixed</code>：同义词<code>fixed128x19</code>，<code>ufixed128x19</code>分别。用于计算函数选择器，<code>fixed128x19</code>和<code>ufixed128x19</code>必须使用。</li><li><code>bytes&lt;M&gt;</code>：M位字节类型，<code>0 &lt; M &lt;= 32</code>。</li><li><code>function</code>：由函数选择器（4字节）填充的地址（20字节）。编码与<code>bytes24</code>完全相同。</li></ul><p>存在以下（固定大小）数组类型：</p><ul><li><code>&lt;type&gt;[M]</code>：给定类型的固定长度为<code>M</code>个元素的数组。<code>M &gt; 0</code>.</li></ul><p>存在以下非固定大小类型：</p><ul><li><code>bytes</code>：动态大小的字节序列。</li><li><code>string</code>：动态大小的unicode字符串，假定UTF-8编码。</li><li><code>&lt;type&gt;[]</code>：给定类型的元素的可变长度数组。</li></ul><p>类型可以通过在圆括号内包含一个有限的非负数的数字来组合成一个元组，用逗号分隔：</p><ul><li><code>(T1,T2,...,Tn)</code>：由类型<code>T1，... Tn</code>，<code>n &gt;= 0</code>组成的元组</li></ul><p>可以形成元组的元组，元组数组等等。</p><p><b style="color:#6ab0de">注意: 除了元组之外，Solidity支持上面提到的所有同名的类型。ABI元组类型用于编码Solidity<code>structs</code>。</b></p><h2 id="编码的形式规范"><a href="#编码的形式规范" class="headerlink" title="编码的形式规范"></a>编码的形式规范</h2><p>我们现在将正式指定编码，以便它具有以下属性，如果某些参数是嵌套数组，则这些属性特别有用：</p><p>属性：</p><ol><li>访问一个值所需的读取次数至多是参数数组结构中值的深度，即需要四次读取才能检索<code>a_i[k][l][r]</code>。在以前版本的ABI中，读数的数量与最坏情况下动态参数的总数成线性关系。</li><li>变量或数组元素的数据不与其他数据交织，并且可重定位，即它只使用相对“地址”</li></ol><p>我们区分静态和动态类型。静态类型就地编码，动态类型在当前语句块之后的位置，单独分配的位置进行编码。</p><p>定义：以下类型称为“动态类型”：</p><ul><li><code>bytes</code></li><li><code>string</code></li><li><code>T[]</code> 为任何类型 <code>T</code></li><li><code>T[k]</code>任何动态<code>T</code>和任何<code>k &gt; 0</code></li><li><code>(T1,...,Tk)</code>如果有的话<code>Ti</code>是动态的<code>1 &lt;= i &lt;= k</code>。</li></ul><p>所有其他类型被称为“静态的”。</p><p>定义：len(a)是二进制字符串<code>a</code>中的字节数。len(a)假定的类型是uint256。</p><p>我们将<code>enc</code>实际编码定义为ABI类型值与二进制字符串的映射关系，当且仅当<code>X</code>的类型是动态的，len(enc(X))取决于<code>X</code>的值。</p><p>定义：对于任何ABI值<code>X</code>，我们递归定义<code>enc(X)</code>，根据<code>X</code>类型是</p><ul><li><b style="color:red"><code>(T1,...,Tk)</code></b>对于<code>k&gt;=0</code>并且任何类型，<code>T1</code>, …,<code>Tk</code><br><code>enc(X) = head(X(1)) ... head(X(k-1)) tail(X(0)) ... tail(X(k-1))</code><br><code>X(i)</code>是<code>ith</code>值的组成部分， <code>head</code>和<code>tail</code>是为<code>Ti</code>静态类型定义的，<code>head(X(i)) = enc(X(i))</code>和<code>tail(X(i)) = &quot;&quot;</code>（空字符串）。<br>并作为<code>head(X(i)) = enc(len(head(X(0)) ... head(X(k-1)) tail(X(0)) ... tail(X(i-1))))</code>和<code>tail(X(i)) = enc(X(i))</code><br>否则，即如果<code>Ti</code>是动态类型。<br>请注意，在动态情况下，<code>head(X(i))</code>由于头部长度仅取决于类型而非值，因此定义良好(well-defined)。它的值是<code>tail(X(i))</code>开始相对于<code>enc(X)</code>开始的偏移量。</li><li><code>T[k]</code>对于任何<code>T</code>和<code>k</code>：<br><code>enc(X) = enc((X[0], ..., X[k-1]))</code><br>即它被编码为它是具有<code>k</code>相同类型元素的元组。</li><li><code>T[]</code>其中<code>X</code>有<code>k</code>个元素（<code>k</code>假定是类型<code>uint256</code>）：<br><code>enc(X) = enc(k) enc([X[1], ..., X[k]])</code><br>即它被编码，就好像它是一个静态大小的数组k，以元素的数量为前缀。</li><li><code>bytes</code>，长度<code>k</code>（假定为类型<code>uint256</code>）：<br><code>enc(X) = enc(k) pad_right(X)</code>，即bytes的数字被编码为<code>uint256</code>接着是<code>X</code>作为字节序列的实际值，接着是零字节的最小数目，例如<code>len(enc(X))</code>是32的倍数。</li><li><code>string</code>：<code>enc(X) = enc(enc_utf8(X))</code>即<code>X</code>是utf-8编码，并且该值被解释为bytes类型并被进一步编码。请注意，此后续编码中使用的长度是utf-8编码字符串的字节数，而不是其字符数。</li><li><code>uint&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>的大端编码，用零字节填充在高阶（左侧），长度为32字节。</li><li><code>address</code>：这和<code>uint160</code>一样</li><li><code>int&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>的大端的二进制补码编码，对于负数<code>X</code>在较高阶（左侧）填充<code>0xff</code>，对于正数<code>X</code>为使用零字节，<code>X</code>长度为32字节。</li><li><code>bool</code>：如同在这种<code>uint8</code>下的情况，<code>1</code>用于<code>true</code>和<code>0</code>用于<code>false</code></li><li><code>fixed&lt;M&gt;x&lt;N&gt;</code>：当<code>X * 10**N</code>被解读为<code>uint256</code>,<code>enc(X)</code>是<code>enc(X * 10**N)</code>。</li><li><code>fixed</code>：就像<code>fixed128x19</code>这样</li><li><code>ufixed&lt;M&gt;x&lt;N&gt;</code>：当<code>X * 10**N</code>被解读为<code>uint256</code>,<code>enc(X)</code>是<code>enc(X * 10**N)</code>。</li><li><code>ufixed</code>：就像<code>ufixed128x19</code>这样</li><li><code>bytes&lt;M&gt;</code>：<code>enc(X)</code>是<code>X</code>填充后的零字节长度为32个字节的字节序列。</li></ul><p>请注意，对于任何<code>X</code>，<code>len(enc(X))</code>是32的倍数。</p><h2 id="函数选择器和参数编码"><a href="#函数选择器和参数编码" class="headerlink" title="函数选择器和参数编码"></a>函数选择器和参数编码</h2><p>总而言之，通过参数<code>a_1, ..., a_n</code>调用函数<code>f</code>被编码为<code>function_selector(f) enc((a_1, ..., a_n))</code>; <code>f</code>的返回值<code>v_1, ..., v_k</code>被编码为：<code>enc((v_1, ..., v_k))</code>；即这些值被组合成一个元组并被编码。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>给出下面的合同：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">  function bar(bytes3[2]) public pure &#123;&#125;</span><br><span class="line">  function baz(uint32 x, bool y) public pure returns (bool r) &#123; r = x &gt; 32 || y; &#125;</span><br><span class="line">  function sam(bytes, bool, uint[]) public pure &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因此，对于我们的<code>Foo</code>例子，如果我们想调用<code>baz</code>,参数为<code>69</code>和<code>true</code>，我们将传递总计68个字节消息，可细分为：</p><ul><li><code>0xcdcd77c0</code>：函数ID。这是作为签名<code>baz(uint32,bool)</code>的ASCII形式的Keccak散列的前4个字节而得出的。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000045</code>：第一个参数，一个uint32值<code>69</code>填充的32个字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数 - 布尔值true，填充为32个字节</li></ul><p>总计：<code>0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</code><br>它返回一个单一的<code>bool</code>。例如，如果它要返回<code>false</code>，它的输出将是单个字节数组<code>0x0000000000000000000000000000000000000000000000000000000000000000</code>，单个布尔值。</p><p>如果我们用参数<code>[&quot;abc&quot;, &quot;def&quot;]</code>来调用<code>bar</code>方法，我们将总共传递68个字节，分解为：</p><ul><li><code>0xfce353f6</code>：方法ID。这是从<code>bar(bytes3[2])</code>的签名派生。</li><li><code>0x6162630000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第一部分，一个bytes3值”abc”（左对齐）。</li><li><code>0x6465660000000000000000000000000000000000000000000000000000000000</code>：第一个参数的第二部分，一个bytes3值”def”（左对齐）。</li></ul><p>总共：<code>0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000</code></p><p>如果我们想用参数<code>&quot;dave&quot;</code>, <code>true</code>和<code>[1, 2, 3]</code>调用<code>sam</code>，我们将总共传递292个字节，分解为：</p><ul><li><code>0xa5643bf2</code>：方法ID。这是从<code>sam(bytes,bool,uint256[])</code>签名派生的。请注意，它将<code>uint</code>被其规范<code>uint256</code>表示所取代。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000060</code>：第一个参数（动态类型）的数据部分的位置，从参数块的开始字节开始测量。在这种情况下，<code>0x60</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第二个参数：boolean true。</li><li><code>0x00000000000000000000000000000000000000000000000000000000000000a0</code>：第三个参数（动态类型）的数据部分的位置，以字节为单位。在这种情况下，<code>0xa0</code>。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000004</code>：<b style="color:red">第一个参数的数据部分，它以元素中字节数组的长度开始，在本例中为4</b>。</li><li><code>0x6461766500000000000000000000000000000000000000000000000000000000</code>：第一个参数的内容：UTF-8（在这种情况下等于ASCII）的编码”dave”，在右边填充到32个字节。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：<b style="color:red">第三个参数的数据部分，它以元素中数组的长度开始，在本例中为3。</b></li><li><code>0x0000000000000000000000000000000000000000000000000000000000000001</code>：第三个参数的第一个条目。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code>：第三个参数的第二个条目。</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000003</code>：第三个参数的第三个条目。</li></ul><p>总共：<br><code>0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</code></p><h2 id="动态类型的使用"><a href="#动态类型的使用" class="headerlink" title="动态类型的使用"></a>动态类型的使用</h2><p>通过签名<code>f(uint,uint32[],bytes10,bytes)</code>连同参数<code>(0x123, [0x456, 0x789], &quot;1234567890&quot;, &quot;Hello, world!&quot;)</code>来调用一个函数，按以下方式进行编码：</p><p>我们采取<code>sha3(&quot;f(uint256,uint32[],bytes10,bytes)&quot;)</code>前四个字节，即<code>0x8be65246</code>。然后我们对所有四个参数的头部分进行编码。对于静态类型<code>uint256</code>和<code>bytes10</code>，这些是直接我们想要传递的值，而对于动态类型<code>uint32[]</code>和<code>bytes</code>，我们使用在字节偏移到它们的数据区的开始，从值编码开始测量（即，不计数前四个字节包含函数签名的散列）。这些是：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000123</code>（<code>0x123</code>填充到32个字节）</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000080</code> （偏移到第二个参数的数据部分的开始，4 * 32个字节，正好是头部的大小）</li><li><code>0x3132333435363738393000000000000000000000000000000000000000000000</code>（”1234567890”填充到右侧的32个字节）</li><li><code>0x00000000000000000000000000000000000000000000000000000000000000e0</code>（第四个参数的数据部分的起始偏移量=第一个动态参数的数据部分的起始偏移量+第一个动态参数的数据部分的大小= 4 <em>32 + 3 </em>32（见下文））</li></ul><p>在此之后，第一个动态参数的数据部分<code>[0x456, 0x789]</code>,如下所示：</p><ul><li><code>0x0000000000000000000000000000000000000000000000000000000000000002</code> （阵列元素的数量，2）</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000456</code> （第一元素）</li><li><code>0x0000000000000000000000000000000000000000000000000000000000000789</code> （第二元素）</li></ul><p>最后，我们编码第二个动态参数的数据部分：<code>&quot;Hello, world!&quot;</code></p><ul><li><code>0x000000000000000000000000000000000000000000000000000000000000000d</code> （元素数量（在这种情况下是字节数）：13）</li><li><code>0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</code>（填充到右侧的32个字节）”Hello, world!”</li></ul><p>总的来说，编码是（为了清晰起见,每32字节换行显示）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x8be65246</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000123</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000080</span><br><span class="line">  3132333435363738393000000000000000000000000000000000000000000000</span><br><span class="line">  00000000000000000000000000000000000000000000000000000000000000e0</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000002</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000456</span><br><span class="line">  0000000000000000000000000000000000000000000000000000000000000789</span><br><span class="line">  000000000000000000000000000000000000000000000000000000000000000d</span><br><span class="line">  48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><p></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是以太坊日志/事件监听协议的抽象。日志条目提供合约的地址，一系列最多四个主题（其实就是索引）和一些任意长度的二进制数据。事件利用现有的ABI函数来解释这个（与一个接口规范一起）为一个正确类型的结构。</p><p>给定一个事件名称和一系列事件参数，我们将它们分成两个子系列：索引的和不是索引的。<b style="color:red">那些被编入索引的，最多可达3个，与事件签名的Keccak散列一起使用，以形成日志条目的主题</b>。那些没有索引的事件形成事件的字节数组。</p><p>实际上，使用这个ABI的日志条目被描述为：</p><ul><li><code>address</code>：合同地址（本质上由以太坊提供）;</li><li><code>topics[0]</code>：<code>keccak(EVENT_NAME+&quot;(&quot;+EVENT_ARGS.map(canonical_type_of).join(&quot;,&quot;)+&quot;)&quot;)</code>（<code>canonical_type_of</code>就是简单地返回所述规范类型给定的参数的函数，例如对于<code>uint indexed foo</code>，它会返回<code>uint256</code>）。如果该事件被声明为<code>anonymous</code>，<code>topics[0]</code>不会生成;</li><li><code>topics[n]</code>：<code>EVENT_INDEXED_ARGS[n - 1]</code>（<code>EVENT_INDEXED_ARGS</code>是<code>EVENT_ARGS</code>被索引的序列;</li><li><code>data</code>：<code>abi_serialise(EVENT_NON_INDEXED_ARGS)</code>（<code>EVENT_NON_INDEXED_ARGS</code>是该系列的<code>EVENT_ARGS</code>未索引的部分，<code>abi_serialise</code>用于从函数返回的一系列类型的值的ABI序列化的功能，如上文所述）。</li></ul><p>对于所有固定长度的Solidity类型，<code>EVENT_INDEXED_ARGS</code>数组直接包含32字节的编码值。然而，对于动态长度的类型，包括<code>string</code>，<code>bytes</code>和数组，<code>EVENT_INDEXED_ARGS</code>将包含Keccak散列的编码值，而不是直接对值进行编码。这允许应用程序高效地查询动态长度类型的值（通过将编码值的散列设置为主题），但是应用程序无法解码他们没有查询的索引值。对于动态长度类型，应用程序开发人员需要在快速搜索预定值（如果参数为索引）和任意值的易读性（这要求参数不被索引）之间进行权衡。开发人员可以通过定义具有两个参数的事件（一个索引，一个不打算保持相同的值）来克服这种折衷并实现有效搜索和任意易读性。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>合约接口的JSON格式由一组函数和/或事件描述给出。函数描述是一个带有如下字段的JSON对象：</p><ul><li><code>type</code>：<code>&quot;function&quot;</code>，<code>&quot;constructor&quot;</code>或<code>&quot;fallback&quot;</code>（未命名的“默认”函数）;</li><li><code>name</code>：函数的名称;</li><li><code>inputs</code>：一个对象数组，每个对象都包含：<ul><li><code>name</code>：参数的名称;</li><li><code>type</code>：参数的规范类型（下面更多）。</li><li><code>components</code>：用于元组类型（下面会介绍）。</li></ul></li><li><code>outputs</code>：类似于<code>inputs</code>对象的数组，如果函数不返回任何东西，则可以省略它;</li><li><code>payable</code>：如果函数接受ether为<code>true</code>，则默认为false;</li><li><code>stateMutability</code>：具有以下值之一的字符串：<code>pure</code>（指定为不读blockchain状态）， <code>view</code>（指定为不修改blockchain状态），<code>nonpayable</code>和<code>payable</code>（同上述<code>payable</code>）。</li><li><code>constant</code>：如果函数是<code>pure</code>或者<code>view</code>, 则为true。</li></ul><p><code>type</code>可以省略，默认为<code>&quot;function&quot;</code>。</p><p>构造函数和fallback函数从来没有<code>name</code>或<code>outputs</code>。fallback函数也没有<code>inputs</code>。</p><p>发送非零以太币到没有<code>payable</code>的函数将抛出异常。不要这样做。</p><p>事件描述是一个具有如下相似字段的JSON对象：</p><ul><li><code>type</code>：总是<code>&quot;event&quot;</code></li><li><code>name</code>：事件的名称;</li><li><code>inputs</code>：一个对象数组，每个对象都包含：<ul><li><code>name</code>：参数的名称;</li><li><code>type</code>：参数的规范类型（下面更多）。</li><li><code>components</code>：用于元组类型（下面更多）。</li></ul></li><li><code>indexed</code>：如果该字段是日志主题的一部分为true，false的话，那么它是日志数据段中的一个。</li><li><code>anonymous</code>：如果事件被声明为<code>anonymous</code>为true。</li></ul><p>例如，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  function Test() public &#123; b = 0x12345678901234567890123456789012; &#125;</span><br><span class="line">  event Event(uint indexed a, bytes32 b);</span><br><span class="line">  event Event2(uint indexed a, bytes32 b);</span><br><span class="line">  function foo(uint a) public &#123; Event(a, b); &#125;</span><br><span class="line">  bytes32 b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会生成如下json结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">&quot;type&quot;:&quot;event&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes32&quot;,&quot;indexed&quot;:false&#125;],</span><br><span class="line">&quot;name&quot;:&quot;Event&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;type&quot;:&quot;event&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;,&quot;indexed&quot;:true&#125;,&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes32&quot;,&quot;indexed&quot;:false&#125;],</span><br><span class="line">&quot;name&quot;:&quot;Event2&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;type&quot;:&quot;function&quot;,</span><br><span class="line">&quot;inputs&quot;: [&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],</span><br><span class="line">&quot;name&quot;:&quot;foo&quot;,</span><br><span class="line">&quot;outputs&quot;: []</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p></p><h3 id="处理元组类型"><a href="#处理元组类型" class="headerlink" title="处理元组类型"></a>处理元组类型</h3><p>尽管这些名称不是ABI编码的一部分，但它们确实在JSON中包含很多意义，以便将其显示给最终用户。该结构以如下方式嵌套：</p><p>包含<code>name</code>,<code>type</code>和可能的<code>components</code>成员的对象描述类型化变量。规范类型被确定，直到达到一个元组类型和字符串描述到这一点被存储在<code>type</code>,以<code>tuple</code>为前缀，即，其将在<code>tuple</code>随后的序列<code>[]</code>和<code>[k]</code>连同整数<code>k</code>。然后将元组的元素存储在成员<code>components</code>中，该成员是数组类型的，并且具有与顶级对象相同的结构，除非在那里<code>indexed</code>不允许。</p><p>示例代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">  struct S &#123; uint a; uint[] b; T[] c; &#125;</span><br><span class="line">  struct T &#123; uint x; uint y; &#125;</span><br><span class="line">  function f(S s, T t, uint a) public &#123; &#125;</span><br><span class="line">  function g() public returns (S s, T t, uint a) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会生成如下的JSON：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;f&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;function&quot;,</span><br><span class="line">    &quot;inputs&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;s&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;b&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256[]&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;c&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;tuple[]&quot;,</span><br><span class="line">            &quot;components&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;t&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;tuple&quot;,</span><br><span class="line">        &quot;components&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;x&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;name&quot;: &quot;y&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;uint256&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outputs&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h2 id="非标准打包模式"><a href="#非标准打包模式" class="headerlink" title="非标准打包模式"></a>非标准打包模式</h2><p>Solidity支持非标准打包模式，其中：</p><ul><li>没有<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2FiaS1zcGVjLmh0bWwjYWJpLWZ1bmN0aW9uLXNlbGVjdG9y" title="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-function-selector">函数选择器<i class="fa fa-external-link"></i></span>被编码，</li><li>短于32字节的类型既不填零也不签名扩展</li><li>动态类型就地编码并且没有长度。</li></ul><p>使用值<code>-1, 0x42, 0x2424, &quot;Hello, world!&quot;</code>进行编码<code>int1, bytes1, uint16, string</code>的示例结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0xff42242448656c6c6f2c20776f726c6421</span><br><span class="line">  ^^                                 int1(-1)</span><br><span class="line">    ^^                               bytes1(0x42)</span><br><span class="line">      ^^^^                           uint16(0x2424)</span><br><span class="line">          ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(&quot;Hello, world!&quot;) without a length field</span><br></pre></td></tr></table></figure><p></p><p>更具体地说，每个静态大小的类型占用其范围所具有的字节数量，以及动态大小的类型<code>string</code>，<code>bytes</code>或者<code>uint[]</code>在不使用其长度字段的情况下进行编码。这意味着只要有两个动态大小的元素，编码就不明确。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity合约元数据</title>
      <link href="//blockchain/solidity%E5%90%88%E7%BA%A6%E5%85%83%E6%95%B0%E6%8D%AE.html"/>
      <url>//blockchain/solidity%E5%90%88%E7%BA%A6%E5%85%83%E6%95%B0%E6%8D%AE.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>Solidity编译器自动生成JSON文件，即合约元数据，其中包含有关当前合约的信息。它可以用于查询编译器版本，使用的源代码，ABI和NatSpec文档，以便更安全地与合约进行交互并验证其源代码。</p><p>编译器会将元数据文件的Swarm哈希值附加到每个合约的字节码末尾（详情请参阅下文），以便您可以以认证的方式检索文件，而不必求助于集中式数据提供者。（swarm是和ipfs一样的服务吗？还是文件去中心化的一种规范？）</p><p>当然，您必须将元数据文件发布到Swarm（或其他服务），以便其他人可以访问它。该文件可以通过使用<code>solc --metadata</code>输出，文件<code>solc --metadataContractName_meta.json</code>将被调用。它将包含Swarm对源代码的引用，因此您必须上传所有源文件和元数据文件。</p><p><b style="color:#00f">元数据文件具有以下格式。下面的例子以可读的方式呈现。正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的关键字进行排序以得到唯一的格式。注释当然也是不允许的，这里仅用于解释目的。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Required: The version of the metadata format</span><br><span class="line">  version: &quot;1&quot;,</span><br><span class="line">  // Required: Source code language, basically selects a &quot;sub-version&quot;</span><br><span class="line">  // of the specification</span><br><span class="line">  language: &quot;Solidity&quot;,</span><br><span class="line">  // Required: Details about the compiler, contents are specific</span><br><span class="line">  // to the language.</span><br><span class="line">  compiler: &#123;</span><br><span class="line">    // Required for Solidity: Version of the compiler</span><br><span class="line">    version: &quot;0.4.6+commit.2dabbdf0.Emscripten.clang&quot;,</span><br><span class="line">    // Optional: Hash of the compiler binary which produced this output</span><br><span class="line">    keccak256: &quot;0x123...&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Compilation source files/source units, keys are file names</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;myFile.sol&quot;: &#123;</span><br><span class="line">      // Required: keccak256 hash of the source file</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x123...&quot;,</span><br><span class="line">      // Required (unless &quot;content&quot; is used, see below): Sorted URL(s)</span><br><span class="line">      // to the source file, protocol is more or less arbitrary, but a</span><br><span class="line">      // Swarm URL is recommended</span><br><span class="line">      &quot;urls&quot;: [ &quot;bzzr://56ab...&quot; ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mortal&quot;: &#123;</span><br><span class="line">      // Required: keccak256 hash of the source file</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x234...&quot;,</span><br><span class="line">      // Required (unless &quot;url&quot; is used): literal contents of the source file</span><br><span class="line">      &quot;content&quot;: &quot;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Compiler settings</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // Required for Solidity: Sorted list of remappings</span><br><span class="line">    remappings: [ &quot;:g/dir&quot; ],</span><br><span class="line">    // Optional: Optimizer settings (enabled defaults to false)</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: File and name of the contract or library this</span><br><span class="line">    // metadata is created for.</span><br><span class="line">    compilationTarget: &#123;</span><br><span class="line">      &quot;myFile.sol&quot;: &quot;MyContract&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // Required for Solidity: Addresses for libraries used</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      &quot;MyLib&quot;: &quot;0x123123...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Required: Generated information about the contract.</span><br><span class="line">  output:</span><br><span class="line">  &#123;</span><br><span class="line">    // Required: ABI definition of the contract</span><br><span class="line">    abi: [ ... ],</span><br><span class="line">    // Required: NatSpec user documentation of the contract</span><br><span class="line">    userdoc: [ ... ],</span><br><span class="line">    // Required: NatSpec developer documentation of the contract</span><br><span class="line">    devdoc: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b style="color:#6ab0de">注意:注意上面的ABI定义没有固定的顺序。它可以随编译器版本改变。</b></p><p><b style="color:#6ab0de">注意:由于生成的合约的字节码包含元数据散列，因此对元数据的任何更改都会导致字节码的更改。此外，由于元数据包含所有使用的源的散列，所以任何源代码中的单个空白变化将导致不同的元数据，并随后产生不同的字节代码。</b></p><h2 id="编码字节码中的元数据散列"><a href="#编码字节码中的元数据散列" class="headerlink" title="编码字节码中的元数据散列"></a>编码字节码中的元数据散列</h2><p>由于我们可能会支持其他方式来检索未来的元数据文件，因此映射<code>{&quot;bzzr0&quot;: &lt;Swarm hash&gt;}</code>将存储为<span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcwNDk=" title="https://tools.ietf.org/html/rfc7049">CBOR<i class="fa fa-external-link"></i></span>编码。由于该编码的开始不容易找到，因此其长度以两字节大端编码添加。Solidity编译器的当前版本因此将以下内容添加到部署的字节码的末尾：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xa1 0x65 &apos;b&apos; &apos;z&apos; &apos;z&apos; &apos;r&apos; &apos;0&apos; 0x58 0x20 &lt;32 bytes swarm hash&gt; 0x00 0x29</span><br></pre></td></tr></table></figure><p></p><p>因此，为了恢复数据，可以检查部署的字节码的末尾以匹配该模式，并使用Swarm哈希来取回文件。</p><h2 id="自动接口生成和NatSpec的用法"><a href="#自动接口生成和NatSpec的用法" class="headerlink" title="自动接口生成和NatSpec的用法"></a>自动接口生成和NatSpec的用法</h2><p>元数据以下列方式使用：想要与合约交互的组件（例如Mist）从合并代码中检索合约代码，然后从该文件的Swarm散列中检索合约代码。该文件被JSON解码成上述结构。</p><p>然后该组件可以使用ABI自动生成合同的基本用户界面。</p><p>此外，Mist可以使用userdoc在用户与合约交互时向用户显示确认消息。</p><p>关于以太坊自然规范（NatSpec）的更多信息可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9FdGhlcmV1bS1OYXR1cmFsLVNwZWNpZmljYXRpb24tRm9ybWF0" title="https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format">这里<i class="fa fa-external-link"></i></span>找到。(这里面其实讲得是以太坊solidity文档注释的规范。)</p><h2 id="源代码验证的用法"><a href="#源代码验证的用法" class="headerlink" title="源代码验证的用法"></a>源代码验证的用法</h2><p>为了验证编译，可以通过元数据文件中的链接从Swarm中检索源代码。使用指定的设置在该输入上调用正确版本的编译器（将其选中为“官方”编译器的一部分）。得到的字节码与创建交易或CREATE操作码数据的数据进行比较。这会自动验证元数据，因为它的散列是字节码的一部分。过多的数据对应于构造函数的输入数据，应该根据接口将其解码并呈现给用户。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity编译器使用</title>
      <link href="//blockchain/solidity%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8.html"/>
      <url>//blockchain/solidity%E7%BC%96%E8%AF%91%E5%99%A8%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><h2 id="使用命令行编译器"><a href="#使用命令行编译器" class="headerlink" title="使用命令行编译器"></a>使用命令行编译器</h2><p><b style="color:#6ab0de">注意：本篇不适用于<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2luc3RhbGxpbmctc29saWRpdHkuaHRtbCNzb2xjanM=" title="https://solidity.readthedocs.io/en/v0.4.21/installing-solidity.html#solcjs">solcjs<i class="fa fa-external-link"></i></span>。</b></p><p>Solidity库的构建目标之一是solidity<code>solc</code>命令行编译器。使用<code>solc --help</code>为您提供了所有选项的解释。编译器可以生成各种输出，范围从简单的二进制文件和汇编到抽象语法树（解析树），以估计gas的使用情况。如果你只想编译一个文件，你可以运行<code>solc --bin sourceFile.sol</code>，它会打印出二进制信息。在部署合约之前，在使用<code>solc --optimize --bin sourceFile.sol</code>编译时激活优化器。如果您想获得一些更高级的<code>solc</code>输出变体，最好告诉它使用<code>solc -o outputDirectory --bin --ast --asm sourceFile.sol</code>将所有内容输出到单独使用的文件中。</p><p>命令行编译器将读取自动从文件系统中导入的文件，但也可以使用以下<code>prefix=path</code>的方式提供路径重定向：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solc github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol</span><br></pre></td></tr></table></figure><p></p><p>这实质上指示编译器来搜索任何以<code>github.com/ethereum/dapp-bin/</code>开始的东西，可以在<code>/usr/local/lib/dapp-bin</code>目录下找，如果没有找到该文件，它会在<code>/usr/local/lib/fallback</code>（空格前缀始终匹配）下继续搜索。<code>solc</code>将不会从位于重映射目标之外和显式指定的源文件所在目录之外的文件系统读取文件，因此<code>import &quot;/etc/passwd&quot;;</code>只有在添加为重映射<code>=/</code>时才会起作用。</p><p>如果由于重映射而存在多个匹配，则选择具有最长公共前缀的那个匹配。(这个类似于java的双亲委派模型了)</p><p>出于安全原因，编译器限制了它可以访问的目录。在命令行中指定的源文件的路径（及其子目录）和通过重映射定义的路径可用于导入语句，但其他所有内容都被拒绝。额外的路径（及其子目录）可以通过<code>--allow-paths /sample/path,/another/sample/path</code>切换。</p><p>如果您的合约使用<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI2xpYnJhcmllcw==" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#libraries">库<i class="fa fa-external-link"></i></span>，您会注意到该字节码包含表单<code>__LibraryName______</code>的子字符串。您可以将<code>solc</code>用作链接器，这意味着它将在这些位置为您插入库地址.</p><p>无论是添加<code>--libraries &quot;Math:0x12345678901234567890 Heap:0xabcdef0123456&quot;</code>到您的命令提供的每个库地址或是储存在一个文件中的字符串（每行一个库），并运行<code>--libraries fileName</code>。</p><p>如果<code>solc</code>使用该选项<code>--link</code>调用，所有在上面提到的<code>__LibraryName____</code>-格式输入文件将被解释为未链接的二进制文件（十六进制编码），并就地链接（如果输入从stdin读取，写入stdout）。在这种情况下，所有的选项除了<code>--libraries</code>将被忽略（包括<code>-o</code>）。</p><p>如果<code>solc</code>使用该选项调用<code>--standard-json</code>，则会在标准输入上使用JSON输入（如下所述），并在标准输出上返回JSON输出。</p><h2 id="编译器输入和输出JSON描述"><a href="#编译器输入和输出JSON描述" class="headerlink" title="编译器输入和输出JSON描述"></a>编译器输入和输出JSON描述</h2><p>这些JSON格式由编译器API使用，也可以通过<code>solc</code>。这些可能会发生变化，有些字段是可选的（如上所述），但其目的仅在于进行向后兼容的更改。</p><p>编译器API需要JSON格式的输入，并以JSON格式的输出编译结果。</p><p><b style="color:#00f">注释当然是不允许的，这里仅用于解释目的。</b></p><h3 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Required: 源码的语言, 比如&quot;Solidity&quot;, &quot;serpent&quot;, &quot;lll&quot;, &quot;assembly&quot;, etc.</span><br><span class="line">  language: &quot;Solidity&quot;,</span><br><span class="line">  // Required</span><br><span class="line">  sources:</span><br><span class="line">  &#123;</span><br><span class="line">    // 这里的keys是源文件的“global”名称，</span><br><span class="line">    // 导入可以通过重新映射使用其他文件（参见下文）。</span><br><span class="line">    &quot;myFile.sol&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: 源文件的keccak256散列值，它用于验证通过URL导入的检索内容。</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x123...&quot;,</span><br><span class="line">      // Required（除非使用“content”，见下文）：源文件的URL。</span><br><span class="line">      // URL应该以下面的顺序被导入，并且需要使用keccak256散列检查结果（如果可用）。如果哈希值不匹配或者没有任何一个URL导致成功，则应该引发错误。</span><br><span class="line">      &quot;urls&quot;:</span><br><span class="line">      [</span><br><span class="line">        &quot;bzzr://56ab...&quot;,</span><br><span class="line">        &quot;ipfs://Qma...&quot;,</span><br><span class="line">        &quot;file:///tmp/path/to/file.sol&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mortal&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: 源文件的keccak256 hash</span><br><span class="line">      &quot;keccak256&quot;: &quot;0x234...&quot;,</span><br><span class="line">      // Required(除非urls被使用)：源文件的文字内容</span><br><span class="line">      &quot;content&quot;: &quot;contract mortal is owned &#123; function kill() &#123; if (msg.sender == owner) selfdestruct(owner); &#125; &#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Optional</span><br><span class="line">  settings:</span><br><span class="line">  &#123;</span><br><span class="line">    // Optional: Sorted list of remappings</span><br><span class="line">    remappings: [ &quot;:g/dir&quot; ],</span><br><span class="line">    // Optional: 优化器设置 (enabled的默认值是false)</span><br><span class="line">    optimizer: &#123;</span><br><span class="line">      enabled: true,</span><br><span class="line">      runs: 500</span><br><span class="line">    &#125;,</span><br><span class="line">    evmVersion: &quot;byzantium&quot;, // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople</span><br><span class="line">    // Metadata settings (optional)</span><br><span class="line">    metadata: &#123;</span><br><span class="line">      // Use only literal content and not URLs (false by default)</span><br><span class="line">      useLiteralContent: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.</span><br><span class="line">    libraries: &#123;</span><br><span class="line">      // The top level key is the the name of the source file where the library is used.</span><br><span class="line">      // If remappings are used, this source file should match the global path after remappings were applied.</span><br><span class="line">      // If this key is an empty string, that refers to a global level.</span><br><span class="line">      &quot;myFile.sol&quot;: &#123;</span><br><span class="line">        &quot;MyLib&quot;: &quot;0x123123...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // The following can be used to select desired outputs.</span><br><span class="line">    // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.</span><br><span class="line">    // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,</span><br><span class="line">    // while the star refers to all of the contracts.</span><br><span class="line">    //</span><br><span class="line">    // The available output types are as follows:</span><br><span class="line">    //   abi - ABI</span><br><span class="line">    //   ast - AST of all source files</span><br><span class="line">    //   legacyAST - legacy AST of all source files</span><br><span class="line">    //   devdoc - Developer documentation (natspec)</span><br><span class="line">    //   userdoc - User documentation (natspec)</span><br><span class="line">    //   metadata - Metadata</span><br><span class="line">    //   ir - New assembly format before desugaring</span><br><span class="line">    //   evm.assembly - New assembly format after desugaring</span><br><span class="line">    //   evm.legacyAssembly - Old-style assembly format in JSON</span><br><span class="line">    //   evm.bytecode.object - Bytecode object</span><br><span class="line">    //   evm.bytecode.opcodes - Opcodes list</span><br><span class="line">    //   evm.bytecode.sourceMap - Source mapping (useful for debugging)</span><br><span class="line">    //   evm.bytecode.linkReferences - Link references (if unlinked object)</span><br><span class="line">    //   evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode)</span><br><span class="line">    //   evm.methodIdentifiers - The list of function hashes</span><br><span class="line">    //   evm.gasEstimates - Function gas estimates</span><br><span class="line">    //   ewasm.wast - eWASM S-expressions format (not supported atm)</span><br><span class="line">    //   ewasm.wasm - eWASM binary format (not supported atm)</span><br><span class="line">    //</span><br><span class="line">    // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every</span><br><span class="line">    // target part of that output. Additionally, `*` can be used as a wildcard to request everything.</span><br><span class="line">    //</span><br><span class="line">    outputSelection: &#123;</span><br><span class="line">      // Enable the metadata and bytecode outputs of every single contract.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;*&quot;: [ &quot;metadata&quot;, &quot;evm.bytecode&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the abi and opcodes output of MyContract defined in file def.</span><br><span class="line">      &quot;def&quot;: &#123;</span><br><span class="line">        &quot;MyContract&quot;: [ &quot;abi&quot;, &quot;evm.bytecode.opcodes&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the source map output of every single contract.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;*&quot;: [ &quot;evm.bytecode.sourceMap&quot; ]</span><br><span class="line">      &#125;,</span><br><span class="line">      // Enable the legacy AST output of every single file.</span><br><span class="line">      &quot;*&quot;: &#123;</span><br><span class="line">        &quot;&quot;: [ &quot;legacyAST&quot; ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // Optional: not present if no errors/warnings were encountered</span><br><span class="line">  errors: [</span><br><span class="line">    &#123;</span><br><span class="line">      // Optional: Location within the source file.</span><br><span class="line">      sourceLocation: &#123;</span><br><span class="line">        file: &quot;sourceFile.sol&quot;,</span><br><span class="line">        start: 0,</span><br><span class="line">        end: 100</span><br><span class="line">      ],</span><br><span class="line">      // Mandatory: Error type, such as &quot;TypeError&quot;, &quot;InternalCompilerError&quot;, &quot;Exception&quot;, etc.</span><br><span class="line">      // See below for complete list of types.</span><br><span class="line">      type: &quot;TypeError&quot;,</span><br><span class="line">      // Mandatory: Component where the error originated, such as &quot;general&quot;, &quot;ewasm&quot;, etc.</span><br><span class="line">      component: &quot;general&quot;,</span><br><span class="line">      // Mandatory (&quot;error&quot; or &quot;warning&quot;)</span><br><span class="line">      severity: &quot;error&quot;,</span><br><span class="line">      // Mandatory</span><br><span class="line">      message: &quot;Invalid keyword&quot;</span><br><span class="line">      // Optional: the message formatted with source location</span><br><span class="line">      formattedMessage: &quot;sourceFile.sol:100: Invalid keyword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.</span><br><span class="line">  sources: &#123;</span><br><span class="line">    &quot;sourceFile.sol&quot;: &#123;</span><br><span class="line">      // Identifier (used in source maps)</span><br><span class="line">      id: 1,</span><br><span class="line">      // The AST object</span><br><span class="line">      ast: &#123;&#125;,</span><br><span class="line">      // The legacy AST object</span><br><span class="line">      legacyAST: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.</span><br><span class="line">  contracts: &#123;</span><br><span class="line">    &quot;sourceFile.sol&quot;: &#123;</span><br><span class="line">      // If the language used has no contract names, this field should equal to an empty string.</span><br><span class="line">      &quot;ContractName&quot;: &#123;</span><br><span class="line">        // The Ethereum Contract ABI. If empty, it is represented as an empty array.</span><br><span class="line">        // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI</span><br><span class="line">        abi: [],</span><br><span class="line">        // See the Metadata Output documentation (serialised JSON string)</span><br><span class="line">        metadata: &quot;&#123;...&#125;&quot;,</span><br><span class="line">        // User documentation (natspec)</span><br><span class="line">        userdoc: &#123;&#125;,</span><br><span class="line">        // Developer documentation (natspec)</span><br><span class="line">        devdoc: &#123;&#125;,</span><br><span class="line">        // Intermediate representation (string)</span><br><span class="line">        ir: &quot;&quot;,</span><br><span class="line">        // EVM-related outputs</span><br><span class="line">        evm: &#123;</span><br><span class="line">          // Assembly (string)</span><br><span class="line">          assembly: &quot;&quot;,</span><br><span class="line">          // Old-style assembly (object)</span><br><span class="line">          legacyAssembly: &#123;&#125;,</span><br><span class="line">          // Bytecode and related details.</span><br><span class="line">          bytecode: &#123;</span><br><span class="line">            // The bytecode as a hex string.</span><br><span class="line">            object: &quot;00fe&quot;,</span><br><span class="line">            // Opcodes list (string)</span><br><span class="line">            opcodes: &quot;&quot;,</span><br><span class="line">            // The source mapping as a string. See the source mapping definition.</span><br><span class="line">            sourceMap: &quot;&quot;,</span><br><span class="line">            // If given, this is an unlinked object.</span><br><span class="line">            linkReferences: &#123;</span><br><span class="line">              &quot;libraryFile.sol&quot;: &#123;</span><br><span class="line">                // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.</span><br><span class="line">                &quot;Library1&quot;: [</span><br><span class="line">                  &#123; start: 0, length: 20 &#125;,</span><br><span class="line">                  &#123; start: 200, length: 20 &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          // The same layout as above.</span><br><span class="line">          deployedBytecode: &#123; &#125;,</span><br><span class="line">          // The list of function hashes</span><br><span class="line">          methodIdentifiers: &#123;</span><br><span class="line">            &quot;delegate(address)&quot;: &quot;5c19a95c&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          // Function gas estimates</span><br><span class="line">          gasEstimates: &#123;</span><br><span class="line">            creation: &#123;</span><br><span class="line">              codeDepositCost: &quot;420000&quot;,</span><br><span class="line">              executionCost: &quot;infinite&quot;,</span><br><span class="line">              totalCost: &quot;infinite&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            external: &#123;</span><br><span class="line">              &quot;delegate(address)&quot;: &quot;25000&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            internal: &#123;</span><br><span class="line">              &quot;heavyLifting()&quot;: &quot;infinite&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // eWASM related outputs</span><br><span class="line">        ewasm: &#123;</span><br><span class="line">          // S-expressions format</span><br><span class="line">          wast: &quot;&quot;,</span><br><span class="line">          // Binary format (hex string)</span><br><span class="line">          wasm: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ol><li>JSONError：JSON输入不符合所需格式，例如，输入不是JSON对象，不支持该语言等。</li><li>IOError：IO和导入处理错误，例如在提供的源中无法解析的URL或散列不匹配。</li><li>ParserError：源代码不符合语言规则。</li><li>DocstringParsingError：注释块中的NatSpec标签无法解析。</li><li>SyntaxError：语法错误，例如continue在for循环外部使用。</li><li>DeclarationError：无效的，无法解析的或冲突的标识符名称。例如Identifier not found</li><li>TypeError：类型系统内出错，例如无效类型转换，无效分配等。</li><li>UnimplementedFeatureError：编译器不支持该功能，但预计将在未来的版本中受支持。</li><li>InternalCompilerError：在编译器中触发的内部错误 - 这应该被报告为一个问题。</li><li>Exception：编译期间未知失败 - 应将此报告为问题。</li><li>CompilerError：编译器堆栈的使用无效 - 这应该被报告为一个问题。</li><li>FatalError：致命错误未正确处理 - 应将此报告为问题。</li><li>Warning：警告，并没有停止编译，但应尽可能处理。</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity安全考虑</title>
      <link href="//blockchain/solidity%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91.html"/>
      <url>//blockchain/solidity%E5%AE%89%E5%85%A8%E8%80%83%E8%99%91.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>虽然构建可按预期工作的软件通常非常容易，但要检查没有人能够以没有预料到的方式使用它，要困难得多。</p><p>在Solidity中，这更加重要，因为您可以使用智能合约来处理代币或可能更有价值的东西。此外，智能合约的每一次执行都在公开场合进行，除此之外，源代码通常是公开的。</p><p>当然，你总是需要考虑有多大的风险：你可以将智能合约与对公众开放的Web服务（以及对恶意行为者）以及甚至开放源代码进行比较。如果您只将该购物清单存储在该Web服务上，则可能不必太在意，但如果您使用该Web服务管理您的银行账户，则应该更加小心。</p><p>本节将列出一些陷阱和一般安全建议，但当然可能永远不会完整。另外，请记住，即使您的智能合约代码没有缺陷，编译器或平台本身也可能有错误。可以在已知错误列表中找到编译器的一些公开<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2J1Z3MuaHRtbCNrbm93bi1idWdz" title="https://solidity.readthedocs.io/en/v0.4.21/bugs.html#known-bugs">已知安全相关bug列表<i class="fa fa-external-link"></i></span>，这些bug也是机器可读的。请注意，有一个错误赏金程序涵盖了Solidity编译器的代码生成器。</p><p>与往常一样，使用文档开源，请帮助我们扩展本节（特别是，一些不会产生伤害的示例）！</p><h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><h3 id="私人信息和随机性"><a href="#私人信息和随机性" class="headerlink" title="私人信息和随机性"></a>私人信息和随机性</h3><p>您在智能合同使用的一切是公开可见的，甚至是局部变量和标记<code>private</code>的状态变量。</p><p>如果你不希望矿工能够作弊，在智能合同中使用随机数字是相当棘手的。</p><h3 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h3><p>合同（A）与另一合同（B）的任何互动以及以太币的任何转让均将控制移交给该合同（B）。这使得在这个交互完成之前B可以回调A. 举一个例子，下面的代码包含一个错误（它只是一个片段而不是一个完整的合约）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.send(shares[msg.sender]))</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的问题不是太严重，因为有限的gas是<code>send</code>其中的一部分，但它仍然暴露出一个弱点：以太币转移总是可以包含代码执行，因此<code>withdraw</code>接收方可以是一个重新回调的合约。这将让它得到多个退款，并基本上检索合同中的所有以太币。特别是，下面的合约将允许攻击者在使用<code>call</code>默认情况下多次退还所有剩余gas：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.call.value(shares[msg.sender])())</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为了避免重新入侵，您可以使用Checks-Effects-Interactions模式，详情如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        var share = shares[msg.sender];</span><br><span class="line">        shares[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>请注意，重入不仅是以太币转移的影响，而且是任何其他合约的函数调用的影响。此外，您还必须考虑多合约情况。被调用合约可以修改您依赖的另一份合约的状态。</p><h3 id="gas限制和循环"><a href="#gas限制和循环" class="headerlink" title="gas限制和循环"></a>gas限制和循环</h3><p>没有固定迭代次数的循环（例如取决于存储值的循环）必须小心使用：由于区块gas限制，交易只能消耗一定量的gas。无论是明确的还是仅仅由于正常的操作，循环中的迭代次数可能会超出区块gas限制，这会导致整个合约在某个点停滞。这可能不适用于<code>constant</code>仅用于从区块链中读取数据的函数。尽管如此，这些函数可能会被其他合约作为链上操作的一部分进行调用，并将其拖延。请在合约文件中明确说明这些情况。</p><h3 id="发送和接收以太币"><a href="#发送和接收以太币" class="headerlink" title="发送和接收以太币"></a>发送和接收以太币</h3><ul><li>合约和“外部账户”都不能阻止有人送他们以太币。合约可以作出反应并拒绝定期的转移，但有些方法可以在不创建消息调用的情况下移动以太币。一种方法是简单地“mine to”合约地址和第二种方式是使用<code>selfdestruct(x)</code>。</li><li>如果合约收到Ether（没有调用函数），则执行fallback函数。如果它没有fallback函数，Ether将被拒绝（通过抛出异常）。在执行fallback函数时，合约只能依靠当时可用的“gas津贴”（2300 gas）。这笔津贴不足以以任何方式访问存储。为确保您的合约能够以此方式接收Ether，请检查fallback函数的gas要求（例如，在Remix的“详细信息”部分中）。</li><li>有一种方法可以使用<code>addr.call.value(x)()</code>给予接收的合约更多的gas。这基本上与<code>addr.transfer(x)</code>相同，只是它转发所有剩余的gas并打开接收方执行更昂贵的操作的能力（并且它仅仅返回失败代码并且不会自动传播错误,即抛异常）。这可能包括回调发起者合约或您可能没有想到的其他状态更改。因此它为诚实用户提供了极大的灵活性，同时也为恶意行为者提供了很大的灵活性</li><li>如果你想通过<code>address.transfer</code>发送以太币，有一些细节需要注意：<ol><li>如果接收者是合约，它将导致其执行fallback函数，从而可以回调发起者合约。</li><li>发送以太币可能会因调用深度超过1024而失败。由于调用者完全控制调用深度，因此可能让转币强制失败; 考虑这种可能性或使用<code>send</code>并确保始终检查其返回值。更好的是，用接受者可以对以太币提现的模式编写你的合约。</li><li>发送以太币也可能会失败，因为接收者合约的执行需要比gas的分配金额（显式地使用<code>require</code>， <code>assert</code>，<code>revert</code>，<code>throw</code>或因为操作太昂贵） -它“runs out of gas”（OOG）。如果您使用<code>transfer</code>或<code>send</code>带有返回值检查，这可能为接收者提供阻止发送合约进度的手段。同样，这里的最佳做法是<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbW1vbi1wYXR0ZXJucy5odG1sI3dpdGhkcmF3YWwtcGF0dGVybg==" title="https://solidity.readthedocs.io/en/v0.4.21/common-patterns.html#withdrawal-pattern">使用<code>”withdraw“</code>模式而不是<code>“send”</code>模式<i class="fa fa-external-link"></i></span>。</li></ol></li></ul><h3 id="栈调用深度"><a href="#栈调用深度" class="headerlink" title="栈调用深度"></a>栈调用深度</h3><p>外部函数调用可能会随时失败，因为它们超出了1024的最大调用堆栈。在这种情况下，Solidity会引发异常。恶意行为者在与你的合约进行交互之前可能会强制调用堆栈的价值很高。</p><p>请注意，如果调用堆栈已耗尽，但这种情况<code>.send()</code>返回<code>false</code>，不会抛出异常false。低层次的函数<code>.call()</code>，<code>.callcode()</code>和<code>.delegatecall()</code>以相同的方式表现。</p><h3 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a><b style="color:red">tx.origin</b></h3><p>切勿使用tx.origin进行授权。假设你有这样的钱包合约：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在有人欺骗你将以太币发送到这个攻击钱包的地址：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">如果你的钱包已经检查<code>msg.sender</code>的授权，它将得到攻击钱包的地址，而不是所有者地址。但通过检查<code>tx.origin</code>，它会得到启动交易的原始地址，该交易仍是所有者地址。攻击钱包立即消耗您的所有资金。</b></p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li>在<code>for (var i = 0; i &lt; arrayName.length; i++) { ... }</code>中，<code>i</code>的类型将是<code>uint8</code>，因为这是保存该值所需的最小类型。如果数组有超过255个元素，则循环不会终止。</li><li>函数的<code>constant</code>关键字编译器目前不强制执行。此外，它不是由EVM强制执行的，所以声明为<code>constant</code>的函数可能还是会导致状态的变更。</li><li><b style="color:red">不占用完整32字节的类型可能包含“脏高位”。如果您访问<code>msg.data</code>，这一点尤其重要 - 它带来了可扩展性风险：您可以创建调用函数<code>f(uint8 x)</code>的交易，函数有带有<code>0xff000001</code>和<code>0x00000001</code>的raw字节参数。两者都被纳入合同，考虑<code>x</code>的值，两者看起来都像数字<code>1</code>一样，但会有所不同，所以如果您使用<code>keccak256(msg.data)</code>，您将得到不同的结果。</b></li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="限制以太币的数量"><a href="#限制以太币的数量" class="headerlink" title="限制以太币的数量"></a>限制以太币的数量</h3><p>限制可以存储在智能合约中的以太币（或其他令牌）数量。如果您的源代码，编译器或平台有错误，这些资金可能会丢失。如果你想限制你的损失，限制以太币的数量。</p><h3 id="保持小型化和模块化"><a href="#保持小型化和模块化" class="headerlink" title="保持小型化和模块化"></a>保持小型化和模块化</h3><p>保持合同规模小，易于理解。在其他合约或库中找出无关的功能。关于源代码质量的一般建议：限制局部变量的数量，函数的长度等等。函数需要写文档注释，以便其他人可以理解你的意图是什么，以及它是否与代码不同。</p><h3 id="使用检查-效果-互动（Checks-Effects-Interactions）模式"><a href="#使用检查-效果-互动（Checks-Effects-Interactions）模式" class="headerlink" title="使用检查-效果-互动（Checks-Effects-Interactions）模式"></a>使用检查-效果-互动（Checks-Effects-Interactions）模式</h3><p>大多数函数将首先执行一些检查（谁调用函数，参数是否在范围内，他们是否发送了足够多的Ether，人员是否有令牌等）。这些检查应该先完成。</p><p>作为第二步，如果所有检查都通过了，则应该对当前合约的状态变量产生影响。与其他合约的交互应该是任何函数的最后一步。</p><p>早期合约延迟了一些效果，并等待外部函数调用以非错误状态返回。由于上面提到的重入问题，这通常是一个严重的错误。</p><p>请注意，对已知合约的调用也可能导致对未知合约的调用，所以最好始终应用此模式。</p><h3 id="包含安全失败（Fail-Safe）模式"><a href="#包含安全失败（Fail-Safe）模式" class="headerlink" title="包含安全失败（Fail-Safe）模式"></a>包含安全失败（Fail-Safe）模式</h3><p>在使系统完全去中心化的同时将删除任何中介，这可能是一个好主意，特别是对于新代码，可能包含某种故障安全机制：</p><p>您可以在智能合约中添加一个函数，该函数执行一些自我检查，例如“有任何以太坊泄露？”，“代币的总和等于合约余额吗？”或类似的事情。请记住，你不能使用太多的gas，所以可能需要脱链计算的帮助。</p><p>如果自检失败，合同会自动切换到某种“Fail-Safe”模式，例如，禁用大部分函数，将控制权移交给固定和受信任的第三方，或者仅将合同转换为简单的“把我的钱还给我“的合约。</p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><p>使用形式验证，可以执行自动化的数学证明，证明源代码符合特定的正式规范。规范仍然是正式的（就像源代码一样），但通常要简单得多。</p><p>请注意，形式验证本身只能帮助你理解你所做的事情（规范）和你如何做（实际实现）之间的差异。您仍然需要检查规格是否是您想要的，并且您没有错过任何意想不到的效果。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity杂项</title>
      <link href="//blockchain/solidity%E6%9D%82%E9%A1%B9.html"/>
      <url>//blockchain/solidity%E6%9D%82%E9%A1%B9.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p><h2 id="Storage中状态变量的布局"><a href="#Storage中状态变量的布局" class="headerlink" title="Storage中状态变量的布局"></a>Storage中状态变量的布局</h2><p>静态大小的变量（除映射和动态大小的数组类型之外的所有变量）都是从位置<code>0</code>开始连续地放置在存储中。如果可能的话，需要少于32个字节的多个项目按照以下规则打包到一个存储槽中：</p><ul><li>存储槽中的第一项存储在低阶对齐中。</li><li>基本类型只使用存储它们所需的那么多字节。</li><li>如果基本类型不适合存储槽的其余部分，则将其移动到下一个存储槽。</li><li>结构和数组数据总是会启动一个新的槽并占据整个槽（但是根据这些规则，结构或数组内的项会紧紧地压缩）。</li></ul><p><b style="color:#6ab0de">警告：使用小于32字节的元素时，您合约的gas使用量可能会更高。这是因为EVM一次运行32个字节。因此，如果元素小于此值，则EVM必须使用更多操作才能将元素的大小从32个字节减小到所需的大小。</b></p><p><b style="color:red">如果您正在处理存储值，那么只使用减小尺寸的参数是有益的，因为编译器会将多个元素打包到一个存储槽中，从而将多个读取或写入组合到一个操作中。处理函数参数或内存值时，没有固有的好处，因为编译器不会打包这些值。</b></p><p><b style="color:red">最后，为了让EVM为此进行优化，请确保您尝试对存储变量和<code>struct</code>成员进行排序，以便它们可以紧密打包。例如，声明你的<code>uint128, uint128, uint256</code>存储变量的顺序，而不是<code>uint128, uint256, uint128</code> ，因为前者将只占用存储的两个槽，而后者将占用三个。</b></p><p>结构和数组的元素会相互存储，就像明确地给出的顺序一样。</p><p>由于其大小不可预知，映射和动态大小的数组类型使用Keccak-256散列计算来查找值或数组数据的起始位置。这些起始位置总是全堆栈槽。</p><p>映射或动态数组本身根据上述规则（或通过将此规则映射到映射或数组阵列）递归地占用存储在某个位置<code>p</code>的（未填充）槽。对于动态数组，此槽存储数组中元素的数量（字节数组和字符串在这里是一个例外，见下文）。对于映射，该槽未被使用（但是这是需要的，使得两个相同的映射在彼此之后将使用不同的散列分布）。数组数据位于<code>keccak256(p)</code>, 对应于映射键<code>k</code>的值位<code>keccak256(k . p)</code>于其中<code>.</code>是级联。如果该值又是非基本类型，则通过添加<code>keccak256(k . p)</code>的偏移量来找到位置。keccak256(k . p).keccak256(k . p)</p><p><code>bytes</code>和<code>string</code>存储在相同的槽中，槽中也存储长度。特别地：如果数据长度至多为<code>31</code>字节，则它存储在高位字节（左对齐）中，而最低位字节存储<code>length * 2</code>。如果更长，主要的槽存储<code>length * 2 + 1</code>和数据按常规存储在<code>keccak256(slot)</code>。</p><p>因此，对于以下合同片段：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  struct s &#123; uint a; uint b; &#125;</span><br><span class="line">  uint x;</span><br><span class="line">  mapping(uint =&gt; mapping(uint =&gt; s)) data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>data[4][9].b</code>的位置是在<code>keccak256(uint256(9) . keccak256(uint256(4) . uint256(1))) + 1</code>。</p><h2 id="内存中的布局"><a href="#内存中的布局" class="headerlink" title="内存中的布局"></a>内存中的布局</h2><p>Solidity保留三个256位槽：</p><ul><li>0 - 64：散列方法的暂存空间</li><li>64 - 96：当前分配的内存大小（即可用内存指针）</li></ul><p>语句之间可以使用临时空间（包括在内联程序在内）。</p><p>Solidity始终将新对象放置在空闲内存指针上，内存永远不会释放（这可能会在未来发生变化）。</p><p><b style="color:#6ab0de">警告：Solidity中有一些操作需要大于64字节的临时内存区域，因此临时内存空间不会不匹配。它们将被放置在空闲内存指针指向的位置，但给予其较短的生命周期，指针不会更新。内存可能会或可能不会被清零。正因为如此，人们不应该期望自由内存被清零。</b></p><h2 id="调用方法数据的布局"><a href="#调用方法数据的布局" class="headerlink" title="调用方法数据的布局"></a>调用方法数据的布局</h2><p>当部署Solidity合同并从账户调用时，假定输入数据采用<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2FiaS1zcGVjLmh0bWwjYWJp" title="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi">ABI规范<i class="fa fa-external-link"></i></span>中的格式。ABI规范要求将参数填充为32个字节的倍数。内部函数调用使用不同的约定。</p><h2 id="内部-清理变量"><a href="#内部-清理变量" class="headerlink" title="内部 - 清理变量"></a>内部 - 清理变量</h2><p>当某个值小于256位时，在某些情况下必须清除其余的位。Solidity编译器的设计就是在任何可能受其余位中潜在垃圾影响的操作之前清除这些剩余位。例如，在将值写入内存之前，需要清除其余位，因为内存内容可用于计算散列值或作为消息调用的数据发送。类似地，在将值存储在storage中之前，需要清除其余位，否则就会观察到乱码值。</p><p>另一方面，如果紧接着的操作不受影响，我们不清除这些位。例如，由于任何非零值被<code>JUMPI</code>指令认为是<code>true</code>，在值作为<code>JUMPI</code>指令条件之前，我们不会清除布尔值。</p><p>除了上面的设计原理外，Solidity编译器还会在输入数据加载到堆栈时清除输入数据。<b style="color:#ff0">难道是使用懒清除方式？</b></p><p>不同类型的清理无效值的规则有所不同：</p><table><thead><tr><th>类型</th><th>有效值</th><th>无效值的意思</th></tr></thead><tbody><tr><td>n个成员的枚举</td><td>0直到n-1</td><td>exception</td></tr><tr><td>bool</td><td>0或1</td><td>1</td></tr><tr><td>有符号整数</td><td>符号扩展的字</td><td>目前默默地包裹; 将来会有异常情况发生</td></tr><tr><td>无符号整数</td><td>更高位清零</td><td>目前默默地包裹; 将来会有异常情况发生</td></tr></tbody></table><h2 id="内部-优化器"><a href="#内部-优化器" class="headerlink" title="内部 - 优化器"></a>内部 - 优化器</h2><p>Solidity优化器在汇编上操作，所以它可以或者已经被其他语言使用。它在<code>JUMPs</code>和<code>JUMPDESTs</code>指令处分裂指令的序列使成为基本语句块。在这些语句块内部，分析指令，对堆栈、对内存、对storage的每个修改，都被记录为表达式，该表达式包括指令和基本上指向其他表达式的参数列表。现在主要想法是找到始终相等的表达式（在每个输入上）并将它们组合到一个表达式类中。优化器首先尝试在已知表达式的列表中查找每个新表达式。如果这不起作用，则表达式按照规则进行简化，规则像<code>constant + constant = sum_of_constants</code>或者<code>X * 1 = X</code>。由于这是递归完成的，所以如果第二个因子是一个更复杂的表达式，我们知道它总是会评估为1，那么我们也可以应用后一个规则。对存储和内存位置的修改必须删除有关存储和内存位置的认知（knowledge，我怎么翻译），这些认知并不是已知的不同：如果我们先写入位置x，然后写入位置y; 并且<code>x</code>和<code>y</code>都是输入变量，则第二个可能会覆盖第一个，所以我们实际上在我们写y值之后不知道在x处存储了什么。另一方面，如果表达式<code>x - y</code>的简化计算为非零常数，那么我们知道我们可以保存关于x中存储的内容的认知。</p><p>在这个过程结束时，我们知道最后哪些表达式必须在堆栈上，并且有一个内存和存储的修改的列表。这些信息与基本语句块一起存储并用于链接（link）它们。此外，关于堆栈，存储和内存配置的知识被转发到下一个语句块。如果我们知道所有<code>JUMP</code>和<code>JUMPI</code>指令的目标，我们可以构建一个完整的程序流程图。如果只有一个我们不知道的目标（原则上这可能发生，跳跃目标可以从输入中计算），我们必须消除关于语句块输入状态的所有认知，因为它可能是未知<code>JUMP</code>指令的目标。如果任何<code>JUMPI</code>指令被发现评估为常数的条件，则将其转换为无条件跳转。</p><p>作为最后一步，每个语句块中的代码都会完全重新生成。从语句块的结尾处的表达式创建依赖关系图，并且不是该图的一部分的每个操作都基本上被丢弃。现在生成的代码会按照原始代码中的顺序将修改应用于内存和存储（删除已发现不需要的修改），最后在堆栈中正确的位置生成需要的所有值。</p><p>这些步骤适用于每个基本语句块，如果较小，则新生成的代码将用作替换。如果分析过程中在<code>JUMPI</code>指令处分割了一个基本语句块并且条件评估为常量，根据常量的值替换<code>JUMPI</code>指令，因此代码类似于<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 7;</span><br><span class="line">data[7] = 9;</span><br><span class="line">if (data[x] != x + 2)</span><br><span class="line">  return 2;</span><br><span class="line">else</span><br><span class="line">  return 1;</span><br></pre></td></tr></table></figure><p></p><p>被简化为也可以编译的代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[7] = 9;</span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure><p></p><p>即使指令在开始时包含<code>jump</code>指令。</p><h2 id="源映射（就是源码hash）"><a href="#源映射（就是源码hash）" class="headerlink" title="源映射（就是源码hash）"></a>源映射（就是源码hash）</h2><p>作为AST输出的一部分，编译器提供AST中相应节点所代表的源代码范围。这可以用于各种用途，包括基于AST报告错误的静态分析工具和突出显示局部变量及其用途的调试工具。</p><p>此外，编译器还可以生成从字节码到生成该指令的源代码范围的映射。对于在字节码级别上运行的静态分析工具以及对于在调试器中显示源代码当前位置或者对于断点处理，这一点同样重要。</p><p>这两种源映射都使用整数标识符（其实就是句柄）来引用源文件。这些是通常称为<code>&quot;sourceList&quot;</code>的源文件列表中的常规数组索引，它是组合json(combined-json)和json / npm编译器输出的一部分。</p><p><b style="color:#6ab0de">注意: 对于与任何特定源文件没有关联的指令的情况，源映射分配一个整数标识符-1。这可能发生在编译器生成的内联汇编语句的字节代码段中。</b></p><p>AST内的源映射使用以下表示法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:l:f</span><br></pre></td></tr></table></figure><p></p><p>其中s是对于源文件的开始位置的字节偏移， l是在字节源范围的长度和f为上述的源索引。</p><p>字节码的源映射中的编码更复杂：它是一个由<code>s:l:f:j</code>组成以<code>;</code>分隔的列表。每个元素都对应一条指令，即不能使用字节偏移量，但必须使用指令偏移量（推送指令长于单个字节）。的字段<code>s</code>，<code>l</code>和<code>f</code>如上文，<code>j</code>可以是<code>i</code>，<code>o</code>或<code>-</code>标志着一个跳转指令是否进入函数，从函数返回或是一个例如一个循环一部分的常规跳转。</p><p>为了压缩这些源映射，尤其是字节码，使用以下规则：</p><ul><li>如果一个字段为空，则使用前一个元素的值。</li><li>如果缺少<code>:</code>，则以下所有字段均视为空。</li></ul><p>这意味着以下源映射表示相同的信息：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span><br><span class="line">1:2:1;:9;2:1:2;;</span><br></pre></td></tr></table></figure><p></p><h2 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h2><ul><li>在数组上用<code>delete</code>以删除其所有元素。</li><li>对结构元素使用较短的类型并对它们进行排序，以便将短类型组合在一起。这可以降低gas成本，因为多种<code>SSTORE</code>操作可能合并为一种（<code>SSTORE</code>成本5000或20000，因此这是您想要优化的）。使用天gas价格估算器（启用优化器）来检查！</li><li>让你的状态变量公开 - 编译器会自动为你创建<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI3Zpc2liaWxpdHktYW5kLWdldHRlcnM=" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#visibility-and-getters">getters<i class="fa fa-external-link"></i></span>。</li><li>如果总是在函数开始的地方检查输入条件或状态，请尝试使用<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI21vZGlmaWVycw==" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#modifiers">函数修饰符<i class="fa fa-external-link"></i></span>。</li><li>如果你的合约有一个调用<code>send</code>的函数，但你想使用内置的send函数，请使用<code>address(contractVariable).send(amount)</code>。</li><li>用一个赋值语句初始化storage结构： <code>x = MyStruct({a: 1, b: 2});</code></li></ul><p>注意：如果存储结构具有压缩打包的属性，请使用单独的赋值对其进行初始化：<code>x.a = 1; x.b = 2;</code>。通过这种方式，优化器可以一次更新存储，从而使赋值更便宜。</p><h2 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h2><h3 id="操作符的优先顺序"><a href="#操作符的优先顺序" class="headerlink" title="操作符的优先顺序"></a>操作符的优先顺序</h3><p>以下是按评估顺序列出的操作符的优先顺序。</p><table><thead><tr><th>优先权</th><th>描述</th><th>操作者</th></tr></thead><tbody><tr><td>1</td><td>后缀增量和减量</td><td><code>++</code>，<code>--</code></td></tr><tr><td></td><td>new的表达</td><td><code>new &lt;typename&gt;</code></td></tr><tr><td></td><td>数组下标</td><td><code>&lt;array&gt;[&lt;index&gt;]</code></td></tr><tr><td></td><td>成员访问</td><td><code>&lt;object&gt;.&lt;member&gt;</code></td></tr><tr><td></td><td>函数样式的调用</td><td><code>&lt;func&gt;(&lt;args...&gt;)</code></td></tr><tr><td></td><td>括号</td><td><code>(&lt;statement&gt;)</code></td></tr><tr><td>2</td><td>前缀增量和减量</td><td><code>++</code>，<code>--</code></td></tr><tr><td></td><td>一元正负号</td><td><code>+</code>，<code>-</code></td></tr><tr><td></td><td>一元操作</td><td><code>delete</code></td></tr><tr><td></td><td>逻辑NOT</td><td><code>!</code></td></tr><tr><td></td><td>按位取反</td><td><code>~</code></td></tr><tr><td>3</td><td>幂</td><td><code>**</code></td></tr><tr><td>4</td><td>乘法，除法和模</td><td><code>*</code>，<code>/</code>，<code>%</code></td></tr><tr><td>5</td><td>加减</td><td><code>+</code>，<code>-</code></td></tr><tr><td>6</td><td>按位移位运算符</td><td><code>&lt;&lt;</code>，<code>&gt;&gt;</code></td></tr><tr><td>7</td><td>按位与</td><td><code>&amp;</code></td></tr><tr><td>8</td><td>按位XOR</td><td><code>^</code></td></tr><tr><td>9</td><td>按位或</td><td>&#124;</td></tr><tr><td>10</td><td>不等式操作符</td><td><code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code></td></tr><tr><td>11</td><td>等于操作符</td><td><code>==</code>，<code>!=</code></td></tr><tr><td>12</td><td>逻辑AND</td><td><code>&amp;&amp;</code></td></tr><tr><td>13</td><td>逻辑或</td><td>&#124;&#124;</td></tr><tr><td>14</td><td>三元操作符</td><td><code>&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;</code></td></tr><tr><td>15</td><td>赋值运算符</td><td><code>=</code>，&#124;=，<code>^=</code>，<code>&amp;=</code>，<code>&lt;&lt;=</code>， <code>&gt;&gt;=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>， <code>%=</code></td></tr><tr><td>16</td><td>逗号运算符</td><td><code>,</code></td></tr></tbody></table><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的散列 - 仅适用于256个最新块</li><li><code>block.coinbase(address)</code>：当前块矿工的地址</li><li><code>block.difficulty(uint)</code>：当前区块的困难度</li><li><code>block.gaslimit(uint)</code>：当前区块的gaslimit</li><li><code>block.number(uint)</code>：当前区块的块高</li><li><code>block.timestamp(uint)</code>：当前区块的时间戳</li><li><code>gasleft() returns (uint256)</code>：剩余的gas</li><li><code>msg.data(bytes)</code>：完成calldata</li><li><code>msg.gas(uint)</code>：剩余gas - 在版本0.4.21中弃用并将被替换为<code>gasleft()</code></li><li><code>msg.sender(address)</code>：消息的发起者（当前调用者）</li><li><code>msg.value(uint)</code>：与消息一起发送的以太币数量（单位：wei）</li><li><code>now(uint)</code>：当前块时间戳（别名为<code>block.timestamp</code>）</li><li><code>tx.gasprice(uint)</code>：交易的gas价格</li><li><code>tx.origin(address)</code>：交易的发起者（完整的调用链）</li><li><code>assert(bool condition)</code>：如果条件是<code>false</code>,中止执行并恢复状态更改（用于内部错误）</li><li><code>require(bool condition)</code>：如果条件是<code>false</code>中止执行并恢复状态更改（用于格式错误的输入或外部组件中的错误）</li><li><code>revert()</code>：中止执行并恢复状态更改</li><li><code>keccak256(...) returns (bytes32)</code>：计算（紧密排列）参数的Ethereum-SHA-3（Keccak-256）散列</li><li><code>sha3(...) returns (bytes32)</code>：<code>keccak256</code>的别名</li><li><code>sha256(...) returns (bytes32)</code>：计算（紧密排列）参数的SHA-256哈希值</li><li><code>ripemd160(...) returns (bytes20)</code>：计算（紧密排列）参数的RIPEMD-160哈希值</li><li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：从椭圆曲线签名中恢复与公钥相关的地址，错误时返回零</li><li><code>addmod(uint x, uint y, uint k) returns (uint)</code>：计算<code>(x + y) % k</code>以任意精度执行加法的位置，并且不会在<code>2**256</code>环绕。断言<code>k != 0</code>从0.5.0版开始。</li><li><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：计算<code>(x * y) % k</code>以任意精度执行乘法的位置，并且不会在<code>2**256</code>绕回。断言<code>k != 0</code>从0.5.0版开始。</li><li><code>this</code>(当前合同的类型)：当前合约，明确转换为address</li><li><code>super</code>：继承层次结构高一级的合约</li><li><code>selfdestruct(address recipient)</code>：销毁当前的合约，将资金发送到给定的地址</li><li><code>suicide(address recipient)</code>：<code>selfdestruct</code>的别名</li><li><code>&lt;address&gt;.balance(uint256)</code>：地址的余额（单位：wei）</li><li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：发送指定地址相应数量的以太币，失败时返回false</li><li><code>&lt;address&gt;.transfer(uint256 amount)</code>：发送给地址指定数量的以太币，失败抛出异常</li></ul><h3 id="函数可见性说明符"><a href="#函数可见性说明符" class="headerlink" title="函数可见性说明符"></a>函数可见性说明符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myFunction() &lt;visibility specifier&gt; returns (bool) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public</code>：在外部和内部可见（为存储/状态变量创建一个<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI2dldHRlci1mdW5jdGlvbnM=" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#getter-functions">getter函数<i class="fa fa-external-link"></i></span>）</li><li><code>private</code>：只在当前合约中可见</li><li><code>external</code>：仅在外部可见（仅用于函数） - 即只能通过消息调用（通过<code>this.func</code>）</li><li><code>internal</code>：只在内部可见</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>pure</code> 对于函数：禁止修改或访问状态 - 这还没有强制执行。</li><li><code>view</code> 函数：不允许修改状态 - 这还没有强制执行。</li><li><code>payable</code> 函数：允许他们在收到调用的同时接收Ether。</li><li><code>constant</code> 对于状态变量：禁止分配（初始化除外），不占用存储槽。</li><li><code>constant</code> 用于函数：与<code>view</code>相同。</li><li><code>anonymous</code> 事件：不将事件签名存储为主题。</li><li><code>indexed</code> 用于事件参数：将参数存储为主题。</li></ul><h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><p>这些关键字保留在Solidity中。它们可能成为未来语法的一部分：</p><p><code>abstract</code>，<code>after</code>，<code>case</code>，<code>catch</code>，<code>default</code>，<code>final</code>，<code>in</code>，<code>inline</code>，<code>let</code>，<code>match</code>，<code>null</code>， <code>of</code>，<code>relocatable</code>，<code>static</code>，<code>switch</code>，<code>try</code>，<code>type</code>，<code>typeof</code>。</p><h3 id="语言语法"><a href="#语言语法" class="headerlink" title="语言语法"></a>语言语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*</span><br><span class="line"></span><br><span class="line">// Pragma actually parses anything up to the trailing &apos;;&apos; to be fully forward-compatible.</span><br><span class="line">PragmaDirective = &apos;pragma&apos; Identifier ([^;]+) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ImportDirective = &apos;import&apos; StringLiteral (&apos;as&apos; Identifier)? &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; (&apos;*&apos; | Identifier) (&apos;as&apos; Identifier)? &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line">        | &apos;import&apos; &apos;&#123;&apos; Identifier (&apos;as&apos; Identifier)? ( &apos;,&apos; Identifier (&apos;as&apos; Identifier)? )* &apos;&#125;&apos; &apos;from&apos; StringLiteral &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ContractDefinition = ( &apos;contract&apos; | &apos;library&apos; | &apos;interface&apos; ) Identifier</span><br><span class="line">                     ( &apos;is&apos; InheritanceSpecifier (&apos;,&apos; InheritanceSpecifier )* )?</span><br><span class="line">                     &apos;&#123;&apos; ContractPart* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ContractPart = StateVariableDeclaration | UsingForDeclaration</span><br><span class="line">             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition</span><br><span class="line"></span><br><span class="line">InheritanceSpecifier = UserDefinedTypeName ( &apos;(&apos; Expression ( &apos;,&apos; Expression )* &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">StateVariableDeclaration = TypeName ( &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; | &apos;constant&apos; )? Identifier (&apos;=&apos; Expression)? &apos;;&apos;</span><br><span class="line">UsingForDeclaration = &apos;using&apos; Identifier &apos;for&apos; (&apos;*&apos; | TypeName) &apos;;&apos;</span><br><span class="line">StructDefinition = &apos;struct&apos; Identifier &apos;&#123;&apos;</span><br><span class="line">                     ( VariableDeclaration &apos;;&apos; (VariableDeclaration &apos;;&apos;)* )? &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ModifierDefinition = &apos;modifier&apos; Identifier ParameterList? Block</span><br><span class="line">ModifierInvocation = Identifier ( &apos;(&apos; ExpressionList? &apos;)&apos; )?</span><br><span class="line"></span><br><span class="line">FunctionDefinition = &apos;function&apos; Identifier? ParameterList</span><br><span class="line">                     ( ModifierInvocation | StateMutability | &apos;external&apos; | &apos;public&apos; | &apos;internal&apos; | &apos;private&apos; )*</span><br><span class="line">                     ( &apos;returns&apos; ParameterList )? ( &apos;;&apos; | Block )</span><br><span class="line">EventDefinition = &apos;event&apos; Identifier EventParameterList &apos;anonymous&apos;? &apos;;&apos;</span><br><span class="line"></span><br><span class="line">EnumValue = Identifier</span><br><span class="line">EnumDefinition = &apos;enum&apos; Identifier &apos;&#123;&apos; EnumValue? (&apos;,&apos; EnumValue)* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">ParameterList = &apos;(&apos; ( Parameter (&apos;,&apos; Parameter)* )? &apos;)&apos;</span><br><span class="line">Parameter = TypeName StorageLocation? Identifier?</span><br><span class="line"></span><br><span class="line">EventParameterList = &apos;(&apos; ( EventParameter (&apos;,&apos; EventParameter )* )? &apos;)&apos;</span><br><span class="line">EventParameter = TypeName &apos;indexed&apos;? Identifier?</span><br><span class="line"></span><br><span class="line">FunctionTypeParameterList = &apos;(&apos; ( FunctionTypeParameter (&apos;,&apos; FunctionTypeParameter )* )? &apos;)&apos;</span><br><span class="line">FunctionTypeParameter = TypeName StorageLocation?</span><br><span class="line"></span><br><span class="line">// semantic restriction: mappings and structs (recursively) containing mappings</span><br><span class="line">// are not allowed in argument lists</span><br><span class="line">VariableDeclaration = TypeName StorageLocation? Identifier</span><br><span class="line"></span><br><span class="line">TypeName = ElementaryTypeName</span><br><span class="line">         | UserDefinedTypeName</span><br><span class="line">         | Mapping</span><br><span class="line">         | ArrayTypeName</span><br><span class="line">         | FunctionTypeName</span><br><span class="line"></span><br><span class="line">UserDefinedTypeName = Identifier ( &apos;.&apos; Identifier )*</span><br><span class="line"></span><br><span class="line">Mapping = &apos;mapping&apos; &apos;(&apos; ElementaryTypeName &apos;=&gt;&apos; TypeName &apos;)&apos;</span><br><span class="line">ArrayTypeName = TypeName &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line">FunctionTypeName = &apos;function&apos; FunctionTypeParameterList ( &apos;internal&apos; | &apos;external&apos; | StateMutability )*</span><br><span class="line">                   ( &apos;returns&apos; FunctionTypeParameterList )?</span><br><span class="line">StorageLocation = &apos;memory&apos; | &apos;storage&apos;</span><br><span class="line">StateMutability = &apos;pure&apos; | &apos;constant&apos; | &apos;view&apos; | &apos;payable&apos;</span><br><span class="line"></span><br><span class="line">Block = &apos;&#123;&apos; Statement* &apos;&#125;&apos;</span><br><span class="line">Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |</span><br><span class="line">            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |</span><br><span class="line">              Throw | EmitStatement | SimpleStatement ) &apos;;&apos;</span><br><span class="line"></span><br><span class="line">ExpressionStatement = Expression</span><br><span class="line">IfStatement = &apos;if&apos; &apos;(&apos; Expression &apos;)&apos; Statement ( &apos;else&apos; Statement )?</span><br><span class="line">WhileStatement = &apos;while&apos; &apos;(&apos; Expression &apos;)&apos; Statement</span><br><span class="line">PlaceholderStatement = &apos;_&apos;</span><br><span class="line">SimpleStatement = VariableDefinition | ExpressionStatement</span><br><span class="line">ForStatement = &apos;for&apos; &apos;(&apos; (SimpleStatement)? &apos;;&apos; (Expression)? &apos;;&apos; (ExpressionStatement)? &apos;)&apos; Statement</span><br><span class="line">InlineAssemblyStatement = &apos;assembly&apos; StringLiteral? InlineAssemblyBlock</span><br><span class="line">DoWhileStatement = &apos;do&apos; Statement &apos;while&apos; &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">Continue = &apos;continue&apos;</span><br><span class="line">Break = &apos;break&apos;</span><br><span class="line">Return = &apos;return&apos; Expression?</span><br><span class="line">Throw = &apos;throw&apos;</span><br><span class="line">EmitStatement = &apos;emit&apos; FunctionCall</span><br><span class="line">VariableDefinition = (&apos;var&apos; IdentifierList | VariableDeclaration) ( &apos;=&apos; Expression )?</span><br><span class="line">IdentifierList = &apos;(&apos; ( Identifier? &apos;,&apos; )* Identifier? &apos;)&apos;</span><br><span class="line"></span><br><span class="line">// Precedence by order (see github.com/ethereum/solidity/pull/732)</span><br><span class="line">Expression</span><br><span class="line">  = Expression (&apos;++&apos; | &apos;--&apos;)</span><br><span class="line">  | NewExpression</span><br><span class="line">  | IndexAccess</span><br><span class="line">  | MemberAccess</span><br><span class="line">  | FunctionCall</span><br><span class="line">  | &apos;(&apos; Expression &apos;)&apos;</span><br><span class="line">  | (&apos;!&apos; | &apos;~&apos; | &apos;delete&apos; | &apos;++&apos; | &apos;--&apos; | &apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression &apos;**&apos; Expression</span><br><span class="line">  | Expression (&apos;*&apos; | &apos;/&apos; | &apos;%&apos;) Expression</span><br><span class="line">  | Expression (&apos;+&apos; | &apos;-&apos;) Expression</span><br><span class="line">  | Expression (&apos;&lt;&lt;&apos; | &apos;&gt;&gt;&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;^&apos; Expression</span><br><span class="line">  | Expression &apos;|&apos; Expression</span><br><span class="line">  | Expression (&apos;&lt;&apos; | &apos;&gt;&apos; | &apos;&lt;=&apos; | &apos;&gt;=&apos;) Expression</span><br><span class="line">  | Expression (&apos;==&apos; | &apos;!=&apos;) Expression</span><br><span class="line">  | Expression &apos;&amp;&amp;&apos; Expression</span><br><span class="line">  | Expression &apos;||&apos; Expression</span><br><span class="line">  | Expression &apos;?&apos; Expression &apos;:&apos; Expression</span><br><span class="line">  | Expression (&apos;=&apos; | &apos;|=&apos; | &apos;^=&apos; | &apos;&amp;=&apos; | &apos;&lt;&lt;=&apos; | &apos;&gt;&gt;=&apos; | &apos;+=&apos; | &apos;-=&apos; | &apos;*=&apos; | &apos;/=&apos; | &apos;%=&apos;) Expression</span><br><span class="line">  | PrimaryExpression</span><br><span class="line"></span><br><span class="line">PrimaryExpression = BooleanLiteral</span><br><span class="line">                  | NumberLiteral</span><br><span class="line">                  | HexLiteral</span><br><span class="line">                  | StringLiteral</span><br><span class="line">                  | TupleExpression</span><br><span class="line">                  | Identifier</span><br><span class="line">                  | ElementaryTypeNameExpression</span><br><span class="line"></span><br><span class="line">ExpressionList = Expression ( &apos;,&apos; Expression )*</span><br><span class="line">NameValueList = Identifier &apos;:&apos; Expression ( &apos;,&apos; Identifier &apos;:&apos; Expression )*</span><br><span class="line"></span><br><span class="line">FunctionCall = Expression &apos;(&apos; FunctionCallArguments &apos;)&apos;</span><br><span class="line">FunctionCallArguments = &apos;&#123;&apos; NameValueList? &apos;&#125;&apos;</span><br><span class="line">                      | ExpressionList?</span><br><span class="line"></span><br><span class="line">NewExpression = &apos;new&apos; TypeName</span><br><span class="line">MemberAccess = Expression &apos;.&apos; Identifier</span><br><span class="line">IndexAccess = Expression &apos;[&apos; Expression? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">BooleanLiteral = &apos;true&apos; | &apos;false&apos;</span><br><span class="line">NumberLiteral = ( HexNumber | DecimalNumber ) (&apos; &apos; NumberUnit)?</span><br><span class="line">NumberUnit = &apos;wei&apos; | &apos;szabo&apos; | &apos;finney&apos; | &apos;ether&apos;</span><br><span class="line">           | &apos;seconds&apos; | &apos;minutes&apos; | &apos;hours&apos; | &apos;days&apos; | &apos;weeks&apos; | &apos;years&apos;</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*</span><br><span class="line"></span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+ ( &apos;.&apos; [0-9]* )? ( [eE] [0-9]+ )?</span><br><span class="line"></span><br><span class="line">TupleExpression = &apos;(&apos; ( Expression? ( &apos;,&apos; Expression? )*  )? &apos;)&apos;</span><br><span class="line">                | &apos;[&apos; ( Expression  ( &apos;,&apos; Expression  )*  )? &apos;]&apos;</span><br><span class="line"></span><br><span class="line">ElementaryTypeNameExpression = ElementaryTypeName</span><br><span class="line"></span><br><span class="line">ElementaryTypeName = &apos;address&apos; | &apos;bool&apos; | &apos;string&apos; | &apos;var&apos;</span><br><span class="line">                   | Int | Uint | Byte | Fixed | Ufixed</span><br><span class="line"></span><br><span class="line">Int = &apos;int&apos; | &apos;int8&apos; | &apos;int16&apos; | &apos;int24&apos; | &apos;int32&apos; | &apos;int40&apos; | &apos;int48&apos; | &apos;int56&apos; | &apos;int64&apos; | &apos;int72&apos; | &apos;int80&apos; | &apos;int88&apos; | &apos;int96&apos; | &apos;int104&apos; | &apos;int112&apos; | &apos;int120&apos; | &apos;int128&apos; | &apos;int136&apos; | &apos;int144&apos; | &apos;int152&apos; | &apos;int160&apos; | &apos;int168&apos; | &apos;int176&apos; | &apos;int184&apos; | &apos;int192&apos; | &apos;int200&apos; | &apos;int208&apos; | &apos;int216&apos; | &apos;int224&apos; | &apos;int232&apos; | &apos;int240&apos; | &apos;int248&apos; | &apos;int256&apos;</span><br><span class="line"></span><br><span class="line">Uint = &apos;uint&apos; | &apos;uint8&apos; | &apos;uint16&apos; | &apos;uint24&apos; | &apos;uint32&apos; | &apos;uint40&apos; | &apos;uint48&apos; | &apos;uint56&apos; | &apos;uint64&apos; | &apos;uint72&apos; | &apos;uint80&apos; | &apos;uint88&apos; | &apos;uint96&apos; | &apos;uint104&apos; | &apos;uint112&apos; | &apos;uint120&apos; | &apos;uint128&apos; | &apos;uint136&apos; | &apos;uint144&apos; | &apos;uint152&apos; | &apos;uint160&apos; | &apos;uint168&apos; | &apos;uint176&apos; | &apos;uint184&apos; | &apos;uint192&apos; | &apos;uint200&apos; | &apos;uint208&apos; | &apos;uint216&apos; | &apos;uint224&apos; | &apos;uint232&apos; | &apos;uint240&apos; | &apos;uint248&apos; | &apos;uint256&apos;</span><br><span class="line"></span><br><span class="line">Byte = &apos;byte&apos; | &apos;bytes&apos; | &apos;bytes1&apos; | &apos;bytes2&apos; | &apos;bytes3&apos; | &apos;bytes4&apos; | &apos;bytes5&apos; | &apos;bytes6&apos; | &apos;bytes7&apos; | &apos;bytes8&apos; | &apos;bytes9&apos; | &apos;bytes10&apos; | &apos;bytes11&apos; | &apos;bytes12&apos; | &apos;bytes13&apos; | &apos;bytes14&apos; | &apos;bytes15&apos; | &apos;bytes16&apos; | &apos;bytes17&apos; | &apos;bytes18&apos; | &apos;bytes19&apos; | &apos;bytes20&apos; | &apos;bytes21&apos; | &apos;bytes22&apos; | &apos;bytes23&apos; | &apos;bytes24&apos; | &apos;bytes25&apos; | &apos;bytes26&apos; | &apos;bytes27&apos; | &apos;bytes28&apos; | &apos;bytes29&apos; | &apos;bytes30&apos; | &apos;bytes31&apos; | &apos;bytes32&apos;</span><br><span class="line"></span><br><span class="line">Fixed = &apos;fixed&apos; | ( &apos;fixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">Ufixed = &apos;ufixed&apos; | ( &apos;ufixed&apos; [0-9]+ &apos;x&apos; [0-9]+ )</span><br><span class="line"></span><br><span class="line">InlineAssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line"></span><br><span class="line">AssemblyItem = Identifier | FunctionalAssemblyExpression | InlineAssemblyBlock | AssemblyLocalBinding | AssemblyAssignment | AssemblyLabel | NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">AssemblyLocalBinding = &apos;let&apos; Identifier &apos;:=&apos; FunctionalAssemblyExpression</span><br><span class="line">AssemblyAssignment = ( Identifier &apos;:=&apos; FunctionalAssemblyExpression ) | ( &apos;=:&apos; Identifier )</span><br><span class="line">AssemblyLabel = Identifier &apos;:&apos;</span><br><span class="line">FunctionalAssemblyExpression = Identifier &apos;(&apos; AssemblyItem? ( &apos;,&apos; AssemblyItem )* &apos;)&apos;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity汇编</title>
      <link href="//blockchain/solidity%E6%B1%87%E7%BC%96.html"/>
      <url>//blockchain/solidity%E6%B1%87%E7%BC%96.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p><p>Solidity定义了一种汇编语言，也可以在没有Solidity的情况下使用。此汇编语言也可以用作Solidity源代码中的“内联汇编”。我们从描述如何使用内联汇编开始，以及它如何与独立汇编不同，然后指定汇编本身。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>为了更细粒度的控制，尤其是为了通过编写库来增强语言，可以使用接近虚拟机的语言将内联汇编与的Solidity语句交织在一起。由于EVM是堆栈机，因此通常很难解决正确的堆栈插槽问题，并为堆栈上正确的操作码提供参数。Solidity的内联汇编试图通过以下功能来促进编写手动汇编时出现的问题和其他问题：</p><ul><li>方法样式的操作码：<code>mul(1, add(2, 3))</code>替换<code>push1 3 push1 2 add push1 1 mul</code>.</li><li>装配局部变量：<code>let x := add(2, 3) let y := mload(0x40) x := add(x, y)</code></li><li>访问外部变量： <code>function f(uint x) public { assembly { x := sub(x, 1) } }</code></li><li>标签： <code>let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li><li>循环： <code>for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }</code></li><li>if语句： <code>if slt(x, 0) { x := sub(0, x) }</code></li><li>switch语句： <code>switch x case 0 { y := mul(x, 2) } default { y := 0 }</code></li><li>函数调用： <code>function f(x) -&gt; y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) } }</code></li></ul><p>我们现在要详细描述内联汇编语言。</p><p><b style="color:#6ab0de">警告: 内联汇编是一种在低级别访问以太坊虚拟机的方法。这丢弃了Solidity的几个重要的安全特征。</b></p><p><b style="color:#6ab0de">注意: TODO：写下内联汇编的作用域规则如何有点不同并且例如使用库的内部函数时出现的复杂情况。此外，编写有关编译器定义的符号。</b></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下示例提供了库代码以访问另一个合同的代码并将其加载到bytes变量中。这对于“普通的solidity”来说根本不可能，并且这个想法是用组装库的方式来增强语言。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">library GetCode &#123;</span><br><span class="line">    function at(address _addr) public view returns (bytes o_code) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            // retrieve the size of the code, this needs assembly</span><br><span class="line">            let size := extcodesize(_addr)</span><br><span class="line">            // allocate output byte array - this could also be done without assembly</span><br><span class="line">            // by using o_code = new bytes(size)</span><br><span class="line">            o_code := mload(0x40)</span><br><span class="line">            // new &quot;memory end&quot; including padding</span><br><span class="line">            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))</span><br><span class="line">            // store length in memory</span><br><span class="line">            mstore(o_code, size)</span><br><span class="line">            // actually retrieve the code, this needs assembly</span><br><span class="line">            extcodecopy(_addr, add(o_code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在优化器无法生成高效代码的情况下，内联汇编也可能有所帮助。请注意，由于编译器不执行检查，所以汇编更难以编写，因此只有在您确实知道自己在做什么时才应该将它用于复杂的事情。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library VectorSum &#123;</span><br><span class="line">    // This function is less efficient because the optimizer currently fails to</span><br><span class="line">    // remove the bounds checks in array access.</span><br><span class="line">    function sumSolidity(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i)</span><br><span class="line">            o_sum += _data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We know that we only access the array in bounds, so we can avoid the check.</span><br><span class="line">    // 0x20 needs to be added to an array because the first slot contains the</span><br><span class="line">    // array length.</span><br><span class="line">    function sumAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Same as above, but accomplish the entire code within inline assembly.</span><br><span class="line">    function sumPureAsm(uint[] _data) public view returns (uint o_sum) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">           // Load the length (first 32 bytes)</span><br><span class="line">           let len := mload(_data)</span><br><span class="line"></span><br><span class="line">           // Skip over the length field.</span><br><span class="line">           //</span><br><span class="line">           // Keep temporary variable so it can be incremented in place.</span><br><span class="line">           //</span><br><span class="line">           // NOTE: incrementing _data would result in an unusable</span><br><span class="line">           //       _data variable after this assembly block</span><br><span class="line">           let data := add(_data, 0x20)</span><br><span class="line"></span><br><span class="line">           // Iterate until the bound is not met.</span><br><span class="line">           for</span><br><span class="line">               &#123; let end := add(data, len) &#125;</span><br><span class="line">               lt(data, end)</span><br><span class="line">               &#123; data := add(data, 0x20) &#125;</span><br><span class="line">           &#123;</span><br><span class="line">               o_sum := add(o_sum, mload(data))</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h3><p>Assembly会像Solidity一样解析注释，文字和标识符，因此您可以使用常规的<code>//</code>和<code>/* */</code>进行注释。内联汇编集<code>assembly { ... }</code>在这些花括号内标记，并且可以使用以下内容（请参阅后面的章节以获取更多详细信息）。</p><ul><li>文字，例如<code>0x123</code>，<code>42</code>或<code>&quot;abc&quot;</code>（最多32个字符的字符串）</li><li>操作码（在“指令样式”中），例如<code>mload sload dup1 sstore</code>，列表见下文.</li><li>方法风格的操作码，例如 <code>add(1, mlod(0))</code></li><li>标签，例如 <code>name:</code></li><li>变量声明，例如<code>let x := 7</code>，<code>let x := add(y, 3)</code>或<code>let x</code>（被分配初始值空（0））</li><li>标识符（如果用作内联汇编，则为标签、汇编局部变量和外部），例如<code>jump(name)</code>，<code>3 x add</code></li><li>赋值（以“指令风格”），例如 <code>3 =: x</code></li><li>函数风格的赋值，例如 <code>x := add(y, 3)</code></li><li>局部变量作用域范围的块，例如 <code>{ let x := 3 { let y := add(x, 1) } }</code></li></ul><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>本文档不希望成为以太坊虚拟机的完整描述，但下面的列表可用作其操作码的指南。</p><p>如果一个操作码需要参数（总是从栈顶开始），它们会在括号中给出。请注意，参数的顺序可以被看作是在不是函数风格中被颠倒（下面会解释）。<code>-</code>标记的操作码不会向堆上压项目，标记<code>*</code>的操作码是特殊的，所有其他操作符都只能将一个项目压入到堆栈中。标有<code>F</code>，<code>H</code>，<code>B</code>或<code>C</code>的操作码表明自从Frontier，Homestead, Byzantium or Constantinople开始就有了。Constantinople仍处于规划之中，所有标记如此的指令都将导致无效的指令异常。</p><p>在下文中，<code>mem[a...b)</code>表示从位置<code>a</code>直到（不包括）位置<code>b</code>的内存字节，<code>storage[p]</code>表示<code>storage</code>在p处的内容。</p><p>该操作码<code>pushi</code>和<code>jumpdest</code>不能直接使用。</p><p>在语法中，操作码被表示为预定义的标识符。</p><table><thead><tr><th>指令</th><th></th><th></th><th>说明</th></tr></thead><tbody><tr><td>stop</td><td>-</td><td>F</td><td>停止执行，与<code>return(0,0)</code>相同</td></tr><tr><td>add(x, y)</td><td></td><td>F</td><td>x + y</td></tr><tr><td>sub(x, y)</td><td></td><td>F</td><td>x - y</td></tr><tr><td>mul(x, y)</td><td></td><td>F</td><td>x * y</td></tr><tr><td>div(x, y)</td><td></td><td>F</td><td>x / y</td></tr><tr><td>sdiv(x，y)</td><td></td><td>F</td><td>x / y，用于补码中的有符号数</td></tr><tr><td>mod(x，y)</td><td></td><td>F</td><td>x％y</td></tr><tr><td>smod(x，y)</td><td></td><td>F</td><td>x％y，用于补码中的有符号数</td></tr><tr><td>exp(x，y)</td><td></td><td>F</td><td>x对y的幂</td></tr><tr><td>not(x)</td><td></td><td>F</td><td>〜x，x的每一位都是取反的</td></tr><tr><td>lt(x, y)</td><td></td><td>F</td><td>如果x&lt;y,值为1，否则为0</td></tr><tr><td>gt(x, y)</td><td></td><td>F</td><td>如果x&gt;y,值为1，否则为0</td></tr><tr><td>slt(x, y)</td><td></td><td>F</td><td>如果x&lt;y，则为1，否则为0，用于补码中的有符号数</td></tr><tr><td>sgt(x, y)</td><td></td><td>F</td><td>如果x&gt;y，值为1，否则为0，用于补码中的有符号数</td></tr><tr><td>eq(x, y)</td><td></td><td>F</td><td>如果x == y, 为1，否则为0</td></tr><tr><td>iszero(x)</td><td></td><td>F</td><td>如果x == 0，为1，否则为0</td></tr><tr><td>and(x, y)</td><td></td><td>F</td><td>x和y按位与</td></tr><tr><td>or(x, y)</td><td></td><td>F</td><td>x和y按位或</td></tr><tr><td>xor(x, y)</td><td></td><td>F</td><td>x和y的按位异或</td></tr><tr><td>byte(n, x)</td><td></td><td>F</td><td>x的第n个字节，其中最高有效字节是第0字节</td></tr><tr><td>shl(x, y)</td><td></td><td>C</td><td>y逻辑左移x位</td></tr><tr><td>shr(x, y)</td><td></td><td>C</td><td>y逻辑右移x位</td></tr><tr><td>sar(x, y)</td><td></td><td>C</td><td>y算术右移x位</td></tr><tr><td>addmod(x, y, m)</td><td></td><td>F</td><td>（x + y）％ m以任意精确算术</td></tr><tr><td>mulmod(x, y, m)</td><td></td><td>F</td><td>（x * y）％m以任意精确算术</td></tr><tr><td>signextend(i, x)</td><td></td><td>F</td><td>符号从最低有效位（i*8 + 7）位开始计数</td></tr><tr><td>keccak256(p, n)</td><td></td><td>F</td><td><code>keccak(mem[p…(p+n)))</code></td></tr><tr><td>sha3(p, n)</td><td></td><td>F</td><td><code>keccak(mem[p…(p+n)))</code></td></tr><tr><td>jump(label)</td><td>-</td><td>F</td><td>跳转到标签/代码位置</td></tr><tr><td>jumpi(label, cond)</td><td>-</td><td>F</td><td>如果cond不为零，则跳转到标签</td></tr><tr><td>pc</td><td></td><td>F</td><td>代码中的当前位置</td></tr><tr><td>pop(x)</td><td>-</td><td>F</td><td>弹出x个栈顶元素</td></tr><tr><td>dup1…dup16</td><td></td><td>F</td><td>将第i个堆栈槽复制到顶部（从顶部开始计数）</td></tr><tr><td>swap1…swap16</td><td>*</td><td>F</td><td>交换栈顶和在其下面的第i个栈槽</td></tr><tr><td>mload(p)</td><td></td><td>F</td><td><code>mem[p..(p+32))</code></td></tr><tr><td>mstore(p, v)</td><td>-</td><td>F</td><td><code>mem[p..(p+32)) := v</code></td></tr><tr><td>mstore8(p, v)</td><td>-</td><td>F</td><td><code>mem[p] := v &amp; 0xff</code>（仅修改单个字节）</td></tr><tr><td>sload(p)</td><td></td><td>F</td><td>storage[p]</td></tr><tr><td>sstore(p, v)</td><td>-</td><td>F</td><td>storage[p] := v</td></tr><tr><td>msize</td><td></td><td>F</td><td>内存大小，即最大的访问内存索引</td></tr><tr><td>gas</td><td></td><td>F</td><td>仍然可以用于执行的gas</td></tr><tr><td>address</td><td></td><td>F</td><td>当前合同/执行上下文的地址</td></tr><tr><td>balance(a)</td><td></td><td>F</td><td>地址a的账户余额（wei）</td></tr><tr><td>caller</td><td></td><td>F</td><td>调用者（不含delegatecall）</td></tr><tr><td>callvalue</td><td></td><td>F</td><td>目前的调用一起发送的以太币（wei）</td></tr><tr><td>calldataload(p)</td><td></td><td>F</td><td>从位置p开始的调用数据（32字节）</td></tr><tr><td>calldatasize</td><td></td><td>F</td><td>调用数据的大小，以字节为单位</td></tr><tr><td>calldatacopy(t, f, s)</td><td>-</td><td>F</td><td>从calldata数据位置f复制s个字节到mem的位置t开始的位置</td></tr><tr><td>codesize</td><td></td><td>F</td><td>当前合同/执行上下文的代码大小</td></tr><tr><td>codecopy(t, f, s)</td><td>-</td><td>F</td><td>从位置f的代码复制s字节到mem的位置t</td></tr><tr><td>extcodesize(a)</td><td></td><td>F</td><td>地址a处代码的大小</td></tr><tr><td>extcodecopy(a, t, f, s)</td><td>-</td><td>F</td><td>像<code>codecopy(t, f, s)</code>，但是从地址a处获取代码</td></tr><tr><td>returndatasize</td><td></td><td>B</td><td>最近一次返回数据的大小</td></tr><tr><td>returndatacopy(t, f, s)</td><td>-</td><td>B</td><td>将返回数据f位置的字节复制到t位置的mem</td></tr><tr><td>create(v, p, s)</td><td></td><td>F</td><td>用代码mem[p..(p + s))创建新的合约并发送v wei以太币并返回新的地址</td></tr><tr><td>create2(v, n, p, s)</td><td></td><td>C</td><td>在地址<code>keccak256(&lt;address&gt; . n . keccak256(mem[p..(p+s)))</code> 创建与代码mem[p..(p + s))的新合约并发送v wei并返回新地址</td></tr><tr><td>call(g, a, v, in, insize, out, outsize)</td><td></td><td>F</td><td>在输入mem[in..(in + insize))时提供g gas和v wei以及输出区mem[out..(out + oversize))，在地址a处调用合约，并在错误时返回0,1代表成功</td></tr><tr><td>callcode(g, a, v, in, insize, out, outsize)</td><td></td><td>F</td><td>与<code>call</code>相同，但只能使用地址a的代码，否则保留在当前合约的上下文中</td></tr><tr><td>delegatecall(g, a, in, insize, out, outsize)</td><td></td><td>H</td><td>与<code>callcode</code>相同，但也保持<code>caller</code> 和<code>callvalue</code></td></tr><tr><td>staticcall(g, a, in, insize, out, outsize)</td><td></td><td>B</td><td>与<code>call(g, a, 0, in, insize, out, outsize)</code>相同, 但不允许状态修改</td></tr><tr><td>return(p, s)</td><td>-</td><td>F</td><td>结束执行，返回数据mem[p..(p + s))</td></tr><tr><td>revert(p, s)</td><td>-</td><td>B</td><td>结束执行，恢复状态更改，返回数据mem[p..(p + s))</td></tr><tr><td>selfdestruct(a)</td><td>-</td><td>F</td><td>终止执行，摧毁当前合同并将资金发送给地址a</td></tr><tr><td>invalid</td><td>-</td><td>F</td><td>用无效指令结束执行</td></tr><tr><td>log0(p, s)</td><td>-</td><td>F</td><td>没有主题和mem[p..(p + s))的数据的日志</td></tr><tr><td>log1(p, s, t1)</td><td>-</td><td>F</td><td>记录主题t1和mem[p..(p + s))的数据</td></tr><tr><td>log2(p, s, t1, t2)</td><td>-</td><td>F</td><td>记录主题t1，t2和数据mem[p..(p + s))</td></tr><tr><td>log3(p, s, t1, t2, t3)</td><td>-</td><td>F</td><td>记录主题t1，t2，t3和数据mem[p..(p + s))</td></tr><tr><td>log4(p, s, t1, t2, t3, t4)</td><td>-</td><td>F</td><td>记录主题t1，t2，t3，t4和数据mem[p..(p + s))</td></tr><tr><td>origin</td><td></td><td>F</td><td>交易发送者</td></tr><tr><td>gasprice</td><td></td><td>F</td><td>交易的gas价格</td></tr><tr><td>blockhash(b)</td><td></td><td>F</td><td>块b的散列值 - 仅适用于不包括当前值的最后256个块</td></tr><tr><td>coinbase</td><td></td><td>F</td><td>目前的采矿受益者</td></tr><tr><td>timestamp</td><td></td><td>F</td><td>当前块的时间戳，以秒为单位</td></tr><tr><td>number</td><td></td><td>F</td><td>当前区块高度</td></tr><tr><td>difficulty</td><td></td><td>F</td><td>当前块的难度</td></tr><tr><td>gaslimit</td><td></td><td>F</td><td>当前块的区块gas限制</td></tr></tbody></table><h3 id="字面Literals"><a href="#字面Literals" class="headerlink" title="字面Literals"></a>字面Literals</h3><p>您可以使用十进制或十六进制符号键入整数常量，这会自动生成相应的<code>PUSHi</code>指令。下面创建代码，将2和3加起来得到5，然后与字符串“abc”进行按位与计算。字符串存储为左对齐，不能超过32个字节。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; 2 3 add &quot;abc&quot; and &#125;</span><br></pre></td></tr></table></figure><p></p><p>译者注：这个看起来像比特币的脚本语言有木有。（基于堆栈的脚本语言，也就是说solidity的底层实现有点像比特币脚本，只是支持跳转语句而已）。</p><h3 id="函数风格"><a href="#函数风格" class="headerlink" title="函数风格"></a>函数风格</h3><p>您可以在操作码之后键入操作码，它们将以字节码结尾。例如将内存中在位置0x80处的数据加3，将是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0x80 mload add 0x80 mstore</span><br></pre></td></tr></table></figure><p></p><p>由于通常很难看到某些操作码的实际参数是什么，所以Solidity内联汇编还提供了一种“函数风格”表示法，其中相同的代码可如下编写<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstore(0x80, add(mload(0x80), 3))</span><br></pre></td></tr></table></figure><p></p><p>函数风格表达式不能在内部使用函数风格，例如<code>1 2 mstore(0x80, add)</code>不是有效的程序，它必须写成<code>mstore(0x80, add(2, 1))</code>。对于不带参数的操作码，括号可以省略。</p><p><b style="color:red">请注意，参数的顺序在函数风格中与指令风格完全相反</b>。如果使用函数风格，第一个参数将会在堆栈顶部结束。</p><h3 id="访问外部变量和函数"><a href="#访问外部变量和函数" class="headerlink" title="访问外部变量和函数"></a>访问外部变量和函数</h3><p><b style="color:red">通过简单地使用它们的名称就可以访问solidity变量和其他标识符。对于内存变量，这会将地址而不是值推入堆栈</b>。<b style="color:red">存储变量不同：存储中的值可能不占用完整的存储槽，因此它们的“地址”由该槽中的槽和字节偏移量组成</b>。要检索变量<code>x</code>指向的槽，你需要使用<code>x_slot</code>并检索您使用的字节偏移量<code>x_offset</code>。</p><p>在赋值中（见下文），我们甚至可以使用本地Solidity变量来赋值。</p><p>也可以访问内联汇编外部的函数：汇编将推入它们的入口标签（应用虚函数解析）。solidity中可靠的调用语义是：</p><ul><li>调用者将<code>return label, arg1, arg2, …, argn</code>压入栈中</li><li>调用连同<code>ret1, ret2, …, retm</code>返回。</li></ul><p>这个特性使用起来还是有点麻烦，因为在调用期间堆栈偏移量实际上会发生变化，因此对局部变量的引用将会出错。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint b;</span><br><span class="line">    function f(uint x) public returns (uint r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r := mul(x, sload(b_slot)) // ignore the offset, we know it is zero</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>EVM组装中的另一个问题是，jump和jumpi使用可以轻易改变的绝对地址。Solidity内联汇编提供了标签，以便更容易地使用跳转。请注意，标签是低级特征，只需使用汇编函数，loops，if和switch指令（参见下文），就可以编写无标签的高效汇编。以下代码计算斐波那契数列中的一个元素。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let n := calldataload(4)</span><br><span class="line">    let a := 1</span><br><span class="line">    let b := a</span><br><span class="line">loop:</span><br><span class="line">    jumpi(loopend, eq(n, 0))</span><br><span class="line">    a add swap1</span><br><span class="line">    n := sub(n, 1)</span><br><span class="line">    jump(loop)</span><br><span class="line">loopend:</span><br><span class="line">    mstore(0, a)</span><br><span class="line">    return(0, 0x20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>请注意，只有汇编器知道当前堆栈高度时，才能自动访问堆栈变量。如果跳转源和目标具有不同的堆栈高度，这将失效。使用这种跳转仍然ok，但在这种情况下，您应该不会访问任何堆栈变量（即使是汇编中的变量）。</p><p>此外，堆栈高度分析器通过操作码（而不是根据控制流）执行代码操作码，因此在下列情况下，汇编器对在标签<code>two</code>处的堆栈高度会产生错误印象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 8</span><br><span class="line">    jump(two)</span><br><span class="line">    one:</span><br><span class="line">        // Here the stack height is 2 (because we pushed x and 7),</span><br><span class="line">        // but the assembler thinks it is 1 because it reads</span><br><span class="line">        // from top to bottom.</span><br><span class="line">        // Accessing the stack variable x here will lead to errors.</span><br><span class="line">        x := 9</span><br><span class="line">        jump(three)</span><br><span class="line">    two:</span><br><span class="line">        7 // push something onto the stack</span><br><span class="line">        jump(one)</span><br><span class="line">    three:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>译者注：看来这是堆栈式语言引入jump之后带来的一个大问题，不知道如何解决这个问题，这个问题既有编译器编译逻辑也有机器代码逻辑的表示。</p><h3 id="声明汇编本地变量"><a href="#声明汇编本地变量" class="headerlink" title="声明汇编本地变量"></a>声明汇编本地变量</h3><p>您可以使用let关键字来声明仅在内联程序中可见的变量，实际上仅在当前的<code>{...}</code>块中可见。<b style="color:red">该let指令将创建一个为变量保留的新堆栈槽，并在达到语句块末尾时再次自动删除</b>。您需要为变量提供一个初始值0，但它也可以是一个复杂的函数风格表达式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint x) public view returns (uint b) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            let v := add(x, 1)</span><br><span class="line">            mstore(0x80, v)</span><br><span class="line">            &#123;</span><br><span class="line">                let y := add(sload(v), 1)</span><br><span class="line">                b := y</span><br><span class="line">            &#125; // y is &quot;deallocated&quot; here</span><br><span class="line">            b := add(b, v)</span><br><span class="line">        &#125; // v is &quot;deallocated&quot; here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以将汇编局部变量和局部变量赋值给函数。请注意，当您给指向内存或存储的变量赋值时，只会更改指针而不是数据。</p><p>有两种赋值方式：函数风格和指令风格。对于函数风格赋值（<code>variable := value</code>），您需要在函数风格表达式中提供一个值，该值可以导致恰好一个堆栈值，对于指令风格赋值（<code>=: variable</code>），该值仅从堆栈顶部获取。对于这两种方式，冒号<code>:</code>指向变量的名称。通过用新值替换堆栈上的变量值来执行赋值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v := 0 // functional-style assignment as part of variable declaration</span><br><span class="line">    let g := add(v, 2)</span><br><span class="line">    sload(10)</span><br><span class="line">    =: v // instruction style assignment, puts the result of sload(10) into v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句可以用于有条件地执行代码。没有“else”部分，如果您需要多种选择，请考虑使用“switch”（请参阅​​下文）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if eq(value, 0) &#123; revert(0, 0) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>主体的花括号是必需的。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>你可以使用switch语句作为“if/else”的一个非常基本的版本（由于汇编中if没有else，我们可以使用switch的default代替）。它采用表达式的值并将其与几个常量进行比较，采用与匹配常数对应的分支。与某些编程语言的容易出错的行为相反，控制流不会从一种情况继续下去。可以有一个回退或默认情况称为<code>default</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    switch calldataload(4)</span><br><span class="line">    case 0 &#123;</span><br><span class="line">        x := calldataload(0x24)</span><br><span class="line">    &#125;</span><br><span class="line">    default &#123;</span><br><span class="line">        x := calldataload(0x44)</span><br><span class="line">    &#125;</span><br><span class="line">    sstore(0, div(x, 2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>case可以不用大括号，但case的主体确实需要它们。</p><h3 id="循环Loops"><a href="#循环Loops" class="headerlink" title="循环Loops"></a>循环Loops</h3><p>汇编支持一个简单的for-style循环。For-style循环有一个包含初始化部分，条件和后迭代部分的头文件。条件必须是功能式的表达，而另外两个是语句块。如果初始化部分声明了任何变量，则这些变量的作用域被扩展到正文中（包括条件和后迭代部分）。</p><p>以下示例计算内存中区域的总和。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, 0x100) &#123; i := add(i, 0x20) &#125; &#123;</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>For循环也可以写成像while循环一样：只需将初始化和后迭代部分留空。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x := 0</span><br><span class="line">    let i := 0</span><br><span class="line">    for &#123; &#125; lt(i, 0x100) &#123; &#125; &#123;     // while(i &lt; 0x100)</span><br><span class="line">        x := add(x, mload(i))</span><br><span class="line">        i := add(i, 0x20)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>内联汇编允许定义低级函数。这些从堆栈中取出它们的参数（并返回PC），并将结果放入堆栈。调用函数的方式与执行函数风格的操作码相同。</p><p>函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在该函数之外定义的局部变量。没有明确的<code>return</code>语句。</p><p>如果您调用返回多个值的函数，则必须使用<code>a, b := f(x)</code>或者<code>let a, b := f(x)</code> 将它们分配给元组。</p><p>以下示例通过平方和乘法实现幂函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function power(base, exponent) -&gt; result &#123;</span><br><span class="line">        switch exponent</span><br><span class="line">        case 0 &#123; result := 1 &#125;</span><br><span class="line">        case 1 &#123; result := base &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">            // 通过递归进行幂值计算。</span><br><span class="line">            result := power(mul(base, base), div(exponent, 2))</span><br><span class="line">            switch mod(exponent, 2)</span><br><span class="line">                case 1 &#123; result := mul(base, result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="要避免的事情"><a href="#要避免的事情" class="headerlink" title="要避免的事情"></a>要避免的事情</h3><p>内联汇编可能具有相当高级的表象，但实际上它是非常低级的。函数调用，loops，ifs和switch通过简单的重写规则进行转换，之后，汇编程序为您做的唯一事情就是重新安排函数风格的操作码，管理跳转标签，计算变量访问的堆栈高度并在到达语句块的末尾时删除堆栈槽中分配的本地变量。特别是对于最后两种情况，<b style="color:red">重要的是要知道，汇编程序仅从上到下计数堆栈高度，而不一定遵循控制流程。而且，swap等操作只会交换堆栈的内容，而不会交换变量的位置。</b></p><h3 id="solidity约定"><a href="#solidity约定" class="headerlink" title="solidity约定"></a>solidity约定</h3><p><b style="color:#00f">与EVM组装相反，Solidity知道窄于256位的类型，例如uint24。为了使它们更高效，大多数算术运算只将它们视为256位数字，而高位仅在必要时清除，即在它们被写入内存之前或执行比较之前。这意味着如果您从内联汇编中访问这样的变量，则可能必须首先手动清除更高位。</b>这个有助于我们理解solidity的工作机制。</p><p>Solidity以一种非常简单的方式管理内存：内存位置<code>0x40</code>处有一个“空闲内存指针”。如果你想分配内存，只需在那个位置使用内存，并相应地更新指针。</p><p>在solidity的内存数组元素始终占据32个字节（是的，对于<code>byte[]</code>，这是真实的，而对于<code>bytes</code>和<code>string</code>不是这样）。多维内存数组是指向内存数组的指针。动态数组的长度存储在数组的第一个插槽中，然后跟随数组元素。</p><p><b style="color:#6ab0de">警告:静态大小的内存数组没有长度字段，但它很快就会添加，以便在静态和动态大小的数组之间实现更好的可转换性，所以请不要依赖它。</b></p><h2 id="独立汇编"><a href="#独立汇编" class="headerlink" title="独立汇编"></a>独立汇编</h2><p>以上内联汇编语言描述的汇编语言也可以单独使用，实际上，计划是将其用作Solidity编译器的中间语言。在这种形式下，它试图实现几个目标：</p><ol><li>写在其中的程序应该是可读的，即使代码是由Solidity的编译器生成的。</li><li>从汇编到字节码的翻译应该包含尽可能少的“surprises”。</li><li>控制流应该易于检测，以帮助进行格式验证和优化。</li></ol><p>为了实现第一个和最后一个目标，汇编提供了高层次的结构，如<code>for</code>循环，<code>if</code>和<code>switch</code>语句和函数调用。它应该能够编写汇编程序不使用明确的<code>SWAP</code>，<code>DUP</code>， <code>JUMP</code>和<code>JUMPI</code>语句，因为前两个模糊的数据流和最后两个模糊处理的控制流。此外，函数语句<code>mul(add(x, y), 7)</code>优于纯操作码语句<code>7 y x add mul</code>， 因为在第一种形式中，更容易看出哪个操作数用于哪个操作码。</p><p>第二个目标是通过引入一个desugaring阶段来实现的，该阶段只能以非常规的方式移除较高级别的构造，并且仍然允许检查生成的低级汇编代码。汇编程序执行的唯一非本地操作是用户定义的标识符（函数，变量，…）的名称查找，它遵循非常简单和常规的范围规则以及从堆栈中清除局部变量。</p><p>作用域：声明的标识符（标签，变量，函数，汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。跨函数边界访问局部变量是不合法的，即使它们在范围内。阴影是不允许的。局部变量在声明之前不能被访问，但标签，函数和内联汇编可以。assembly是特殊的语句块，用于例如返回运行时代码或创建合约。子assembly中没有可见的外部assembly标识符。</p><p>如果控制流经过语句块的末尾，则会插入与该语句块中声明的局部变量数匹配的流行指令。无论何时引用局部变量，代码生成器都需要知道其当前在堆栈中的相对位置，因此需要跟踪当前所谓的堆栈高度。<b style="color:red">由于所有局部变量都在块的末尾被删除，块前后的堆栈高度应该相同。如果情况并非如此，则会发出警告。</b></p><p>为什么要使用更高级别的结构类似<code>switch</code>，<code>for</code>和函数：</p><p>使用switch，for和函数，它应该有可能编写复杂的代码，而无需手工使用jump或jumpi。这使得分析控制流程变得更加容易，从而可以改进格式验证和优化。</p><p>此外，如果允许手动跳转，计算堆栈高度相当复杂。需要知道堆栈中所有局部变量的位置，否则在块结束时既不会自动引用局部变量也不会从堆栈中自动删除局部变量。脱钩机构正确地将操作插入无法访问的语句块，以便在没有持续控制流的跳转情况下正确调整堆栈高度。</p><p>例：我们将按照Solidity的示例汇编去装配。我们考虑以下Solidity程序的运行时字节码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">  function f(uint x) public pure returns (uint y) &#123;</span><br><span class="line">    y = 1;</span><br><span class="line">    for (uint i = 0; i &lt; x; i++)</span><br><span class="line">      y = 2 * y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>将生成以下汇编：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60) // store the &quot;free memory pointer&quot;</span><br><span class="line">  // function dispatcher</span><br><span class="line">  switch div(calldataload(0), exp(2, 226))</span><br><span class="line">  case 0xb3de648b &#123;</span><br><span class="line">    let r := f(calldataload(4))</span><br><span class="line">    let ret := $allocate(0x20)</span><br><span class="line">    mstore(ret, r)</span><br><span class="line">    return(ret, 0x20)</span><br><span class="line">  &#125;</span><br><span class="line">  default &#123; revert(0, 0) &#125;</span><br><span class="line">  // memory allocator</span><br><span class="line">  function $allocate(size) -&gt; pos &#123;</span><br><span class="line">    pos := mload(0x40)</span><br><span class="line">    mstore(0x40, add(pos, size))</span><br><span class="line">  &#125;</span><br><span class="line">  // the contract function</span><br><span class="line">  function f(x) -&gt; y &#123;</span><br><span class="line">    y := 1</span><br><span class="line">    for &#123; let i := 0 &#125; lt(i, x) &#123; i := add(i, 1) &#125; &#123;</span><br><span class="line">      y := mul(2, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>解除阶段后，它看起来如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mstore(0x40, 0x60)</span><br><span class="line">  &#123;</span><br><span class="line">    let $0 := div(calldataload(0), exp(2, 226))</span><br><span class="line">    jumpi($case1, eq($0, 0xb3de648b))</span><br><span class="line">    jump($caseDefault)</span><br><span class="line">    $case1:</span><br><span class="line">    &#123;</span><br><span class="line">      // the function call - we put return label and arguments on the stack</span><br><span class="line">      $ret1 calldataload(4) jump(f)</span><br><span class="line">      // This is unreachable code. Opcodes are added that mirror the</span><br><span class="line">      // effect of the function on the stack height: Arguments are</span><br><span class="line">      // removed and return values are introduced.</span><br><span class="line">      pop pop</span><br><span class="line">      let r := 0</span><br><span class="line">      $ret1: // the actual return point</span><br><span class="line">      $ret2 0x20 jump($allocate)</span><br><span class="line">      pop pop let ret := 0</span><br><span class="line">      $ret2:</span><br><span class="line">      mstore(ret, r)</span><br><span class="line">      return(ret, 0x20)</span><br><span class="line">      // although it is useless, the jump is automatically inserted,</span><br><span class="line">      // since the desugaring process is a purely syntactic operation that</span><br><span class="line">      // does not analyze control-flow</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $caseDefault:</span><br><span class="line">    &#123;</span><br><span class="line">      revert(0, 0)</span><br><span class="line">      jump($endswitch)</span><br><span class="line">    &#125;</span><br><span class="line">    $endswitch:</span><br><span class="line">  &#125;</span><br><span class="line">  jump($afterFunction)</span><br><span class="line">  allocate:</span><br><span class="line">  &#123;</span><br><span class="line">    // we jump over the unreachable code that introduces the function arguments</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let size := 0</span><br><span class="line">    $start:</span><br><span class="line">    // output variables live in the same scope as the arguments and is</span><br><span class="line">    // actually allocated.</span><br><span class="line">    let pos := 0</span><br><span class="line">    &#123;</span><br><span class="line">      pos := mload(0x40)</span><br><span class="line">      mstore(0x40, add(pos, size))</span><br><span class="line">    &#125;</span><br><span class="line">    // This code replaces the arguments by the return values and jumps back.</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    // Again unreachable code that corrects stack height.</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  f:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($start)</span><br><span class="line">    let $retpos := 0 let x := 0</span><br><span class="line">    $start:</span><br><span class="line">    let y := 0</span><br><span class="line">    &#123;</span><br><span class="line">      let i := 0</span><br><span class="line">      $for_begin:</span><br><span class="line">      jumpi($for_end, iszero(lt(i, x)))</span><br><span class="line">      &#123;</span><br><span class="line">        y := mul(2, y)</span><br><span class="line">      &#125;</span><br><span class="line">      $for_continue:</span><br><span class="line">      &#123; i := add(i, 1) &#125;</span><br><span class="line">      jump($for_begin)</span><br><span class="line">      $for_end:</span><br><span class="line">    &#125; // Here, a pop instruction will be inserted for i</span><br><span class="line">    swap1 pop swap1 jump</span><br><span class="line">    0 0</span><br><span class="line">  &#125;</span><br><span class="line">  $afterFunction:</span><br><span class="line">  stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>汇编发生在以下四个阶段：</p><ol><li>解析</li><li>Desugaring（移除switch，for和函数）</li><li>操作码流生成</li><li>字节码生成</li></ol><p>我们将以伪正式的方式指定第一步到第三步。更正式的规格将随之而来。</p><h3 id="解析-语法"><a href="#解析-语法" class="headerlink" title="解析/语法"></a>解析/语法</h3><p>解析器的任务如下：</p><ul><li>将字节流转换为标识符（就是每一个单词）流，丢弃C++风格的注释（对源引用存在特殊注释，但我们不在这里解释）。</li><li>根据下面的语法将标识符流转换为AST</li><li>使用它们在其定义的语句块中注册标识符（注释到AST节点）并注意从哪个点开始，可以访问变量。</li></ul><p>汇编词法分析器遵循由Solidity自己定义的那个。</p><p>空格用于分隔标识符，它由空格，制表符和换行符组成。评论是常规的JavaScript/C++评论，并且以与Whitespace相同的方式进行解释。</p><p>语法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AssemblyBlock = &apos;&#123;&apos; AssemblyItem* &apos;&#125;&apos;</span><br><span class="line">AssemblyItem =</span><br><span class="line">    Identifier |</span><br><span class="line">    AssemblyBlock |</span><br><span class="line">    AssemblyExpression |</span><br><span class="line">    AssemblyLocalDefinition |</span><br><span class="line">    AssemblyAssignment |</span><br><span class="line">    AssemblyStackAssignment |</span><br><span class="line">    LabelDefinition |</span><br><span class="line">    AssemblyIf |</span><br><span class="line">    AssemblySwitch |</span><br><span class="line">    AssemblyFunctionDefinition |</span><br><span class="line">    AssemblyFor |</span><br><span class="line">    &apos;break&apos; |</span><br><span class="line">    &apos;continue&apos; |</span><br><span class="line">    SubAssembly</span><br><span class="line">AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral</span><br><span class="line">AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral</span><br><span class="line">Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*</span><br><span class="line">AssemblyCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;</span><br><span class="line">AssemblyLocalDefinition = &apos;let&apos; IdentifierOrList ( &apos;:=&apos; AssemblyExpression )?</span><br><span class="line">AssemblyAssignment = IdentifierOrList &apos;:=&apos; AssemblyExpression</span><br><span class="line">IdentifierOrList = Identifier | &apos;(&apos; IdentifierList &apos;)&apos;</span><br><span class="line">IdentifierList = Identifier ( &apos;,&apos; Identifier)*</span><br><span class="line">AssemblyStackAssignment = &apos;=:&apos; Identifier</span><br><span class="line">LabelDefinition = Identifier &apos;:&apos;</span><br><span class="line">AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblySwitch = &apos;switch&apos; AssemblyExpression AssemblyCase*</span><br><span class="line">    ( &apos;default&apos; AssemblyBlock )?</span><br><span class="line">AssemblyCase = &apos;case&apos; AssemblyExpression AssemblyBlock</span><br><span class="line">AssemblyFunctionDefinition = &apos;function&apos; Identifier &apos;(&apos; IdentifierList? &apos;)&apos;</span><br><span class="line">    ( &apos;-&gt;&apos; &apos;(&apos; IdentifierList &apos;)&apos; )? AssemblyBlock</span><br><span class="line">AssemblyFor = &apos;for&apos; ( AssemblyBlock | AssemblyExpression )</span><br><span class="line">    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock</span><br><span class="line">SubAssembly = &apos;assembly&apos; Identifier AssemblyBlock</span><br><span class="line">NumberLiteral = HexNumber | DecimalNumber</span><br><span class="line">HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]&#123;2&#125;)* &apos;\&apos;&apos;)</span><br><span class="line">StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;</span><br><span class="line">HexNumber = &apos;0x&apos; [0-9a-fA-F]+</span><br><span class="line">DecimalNumber = [0-9]+</span><br></pre></td></tr></table></figure><p></p><h3 id="Desugaring-去除语法糖"><a href="#Desugaring-去除语法糖" class="headerlink" title="Desugaring(去除语法糖)"></a>Desugaring(去除语法糖)</h3><p>AST转换删除<code>for</code>,<code>switch</code>和函数结构。结果仍然可以由同一个解析器解析，但它不会使用某些结构。如果jumpdests被添加，只跳转到不继续，将添加有关堆栈内容的信息，除非未访问外部作用域的局部变量或堆栈高度与前一条指令相同。</p><p>伪代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">desugar item: AST -&gt; AST =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyFunctionDefinition(&apos;function&apos; name &apos;(&apos; arg1, ..., argn &apos;)&apos; &apos;-&gt;&apos; ( &apos;(&apos; ret1, ..., retm &apos;)&apos; body) -&gt;</span><br><span class="line">  &lt;name&gt;:</span><br><span class="line">  &#123;</span><br><span class="line">    jump($&lt;name&gt;_start)</span><br><span class="line">    let $retPC := 0 let argn := 0 ... let arg1 := 0</span><br><span class="line">    $&lt;name&gt;_start:</span><br><span class="line">    let ret1 := 0 ... let retm := 0</span><br><span class="line">    &#123; desugar(body) &#125;</span><br><span class="line">    swap and pop items so that only ret1, ... retm, $retPC are left on the stack</span><br><span class="line">    jump</span><br><span class="line">    0 (1 + n times) to compensate removal of arg1, ..., argn and $retPC</span><br><span class="line">  &#125;</span><br><span class="line">AssemblyFor(&apos;for&apos; &#123; init &#125; condition post body) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    init // cannot be its own block because we want variable scope to extend into the body</span><br><span class="line">    // find I such that there are no labels $forI_*</span><br><span class="line">    $forI_begin:</span><br><span class="line">    jumpi($forI_end, iszero(condition))</span><br><span class="line">    &#123; body &#125;</span><br><span class="line">    $forI_continue:</span><br><span class="line">    &#123; post &#125;</span><br><span class="line">    jump($forI_begin)</span><br><span class="line">    $forI_end:</span><br><span class="line">  &#125;</span><br><span class="line">&apos;break&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_end</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_end</span><br><span class="line">    jump($forI_end)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">&apos;continue&apos; -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find nearest enclosing scope with label $forI_continue</span><br><span class="line">    pop all local variables that are defined at the current point</span><br><span class="line">    but not at $forI_continue</span><br><span class="line">    jump($forI_continue)</span><br><span class="line">    0 (as many as variables were removed above)</span><br><span class="line">  &#125;</span><br><span class="line">AssemblySwitch(switch condition cases ( default: defaultBlock )? ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    // find I such that there is no $switchI* label or variable</span><br><span class="line">    let $switchI_value := condition</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: -&gt; jumpi($switchI_caseJ, eq($switchI_value, val))</span><br><span class="line">    &#125;</span><br><span class="line">    if default block present: -&gt;</span><br><span class="line">      &#123; defaultBlock jump($switchI_end) &#125;</span><br><span class="line">    for each of cases match &#123;</span><br><span class="line">      case val: &#123; body &#125; -&gt; $switchI_caseJ: &#123; body jump($switchI_end) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $switchI_end:</span><br><span class="line">  &#125;</span><br><span class="line">FunctionalAssemblyExpression( identifier(arg1, arg2, ..., argn) ) -&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    if identifier is function &lt;name&gt; with n args and m ret values -&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        // find I such that $funcallI_* does not exist</span><br><span class="line">        $funcallI_return argn  ... arg2 arg1 jump(&lt;name&gt;)</span><br><span class="line">        pop (n + 1 times)</span><br><span class="line">        if the current context is `let (id1, ..., idm) := f(...)` -&gt;</span><br><span class="line">          let id1 := 0 ... let idm := 0</span><br><span class="line">          $funcallI_return:</span><br><span class="line">        else -&gt;</span><br><span class="line">          0 (m times)</span><br><span class="line">          $funcallI_return:</span><br><span class="line">          turn the functional expression that leads to the function call</span><br><span class="line">          into a statement stream</span><br><span class="line">      &#125;</span><br><span class="line">    else -&gt; desugar(children of node)</span><br><span class="line">  &#125;</span><br><span class="line">default node -&gt;</span><br><span class="line">  desugar(children of node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="生成操作码流"><a href="#生成操作码流" class="headerlink" title="生成操作码流"></a>生成操作码流</h3><p>在操作码流生成期间，我们会跟踪计数器中的当前堆栈高度，以便可以通过名称访问堆栈变量。每个修改堆栈的操作码以及每个用堆栈调整注释的标签都会修改堆栈高度。每次引入一个新的局部变量时，它都会与当前堆栈高度一起注册。如果访问变量（复制其值或赋值），则根据引入变量时当前堆栈高度和堆栈高度之间的差异选择适当的<code>DUP</code>或<code>SWAP</code>指令。</p><p>伪代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">codegen item: AST -&gt; opcode_stream =</span><br><span class="line">match item &#123;</span><br><span class="line">AssemblyBlock(&#123; items &#125;) -&gt;</span><br><span class="line">  join(codegen(item) for item in items)</span><br><span class="line">  if last generated opcode has continuing control flow:</span><br><span class="line">    POP for all local variables registered at the block (including variables</span><br><span class="line">    introduced by labels)</span><br><span class="line">    warn if the stack height at this point is not the same as at the start of the block</span><br><span class="line">Identifier(id) -&gt;</span><br><span class="line">  lookup id in the syntactic stack of blocks</span><br><span class="line">  match type of id</span><br><span class="line">    Local Variable -&gt;</span><br><span class="line">      DUPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">    Label -&gt;</span><br><span class="line">      // reference to be resolved during bytecode generation</span><br><span class="line">      PUSH&lt;bytecode position of label&gt;</span><br><span class="line">    SubAssembly -&gt;</span><br><span class="line">      PUSH&lt;bytecode position of subassembly data&gt;</span><br><span class="line">FunctionalAssemblyExpression(id ( arguments ) ) -&gt;</span><br><span class="line">  join(codegen(arg) for arg in arguments.reversed())</span><br><span class="line">  id (which has to be an opcode, might be a function name later)</span><br><span class="line">AssemblyLocalDefinition(let (id1, ..., idn) := expr) -&gt;</span><br><span class="line">  register identifiers id1, ..., idn as locals in current block at current stack height</span><br><span class="line">  codegen(expr) - assert that expr returns n items to the stack</span><br><span class="line">FunctionalAssemblyAssignment((id1, ..., idn) := expr) -&gt;</span><br><span class="line">  lookup id1, ..., idn in the syntactic stack of blocks, assert that they are variables</span><br><span class="line">  codegen(expr)</span><br><span class="line">  for j = n, ..., i:</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(idj)</span><br><span class="line">  POP</span><br><span class="line">AssemblyAssignment(=: id) -&gt;</span><br><span class="line">  look up id in the syntactic stack of blocks, assert that it is a variable</span><br><span class="line">  SWAPi where i = 1 + stack_height - stack_height_of_identifier(id)</span><br><span class="line">  POP</span><br><span class="line">LabelDefinition(name:) -&gt;</span><br><span class="line">  JUMPDEST</span><br><span class="line">NumberLiteral(num) -&gt;</span><br><span class="line">  PUSH&lt;num interpreted as decimal and right-aligned&gt;</span><br><span class="line">HexLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit interpreted as hex and left-aligned&gt;</span><br><span class="line">StringLiteral(lit) -&gt;</span><br><span class="line">  PUSH32&lt;lit utf-8 encoded and left-aligned&gt;</span><br><span class="line">SubAssembly(assembly &lt;name&gt; block) -&gt;</span><br><span class="line">  append codegen(block) at the end of the code</span><br><span class="line">dataSize(&lt;name&gt;) -&gt;</span><br><span class="line">  assert that &lt;name&gt; is a subassembly -&gt;</span><br><span class="line">  PUSH32&lt;size of code generated from subassembly &lt;name&gt;&gt;</span><br><span class="line">linkerSymbol(&lt;lit&gt;) -&gt;</span><br><span class="line">  PUSH32&lt;zeros&gt; and append position to linker table</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity合约</title>
      <link href="//blockchain/solidity%E5%90%88%E7%BA%A6.html"/>
      <url>//blockchain/solidity%E5%90%88%E7%BA%A6.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p><p>Solidity合约与面向对象语言中的类相似。它们包含可以修改这些变量的状态变量和函数中的持久数据。在不同的合约（实例）上调用函数将执行EVM函数调用，从而切换上下文以使状态变量不可访问。</p><h2 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约</h2><p>合约可以通过以太坊交易或从Solidity合约中“从外部”创建。</p><p>诸如<span class="exturl" data-url="aHR0cHM6Ly9yZW1peC5ldGhlcmV1bS5vcmcv" title="https://remix.ethereum.org/">Remix<i class="fa fa-external-link"></i></span>之类的 IDE 使用UI元素使创建过程透明。</p><p>在Ethereum上以编程方式创建合约最好通过使用JavaScript API <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dlYjMuanM=" title="https://github.com/ethereum/web3.js">web3.js<i class="fa fa-external-link"></i></span>完成。截至今天，它有一个名为<span class="exturl" data-url="aHR0cHM6Ly93ZWIzanMucmVhZHRoZWRvY3MuaW8vZW4vMS4wL3dlYjMtZXRoLWNvbnRyYWN0Lmh0bWwjbmV3LWNvbnRyYWN0" title="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract<i class="fa fa-external-link"></i></span>的方法 来促进合约创建。</p><p><b style="color:red">创建合约时，其构造函数（与合约名称相同的函数）将执行一次。构造函数是可选的。只允许一个构造函数，这意味着不支持重载。</b></p><p><b style="color:#00f">在内部，构造函数参数在合约本身的代码之后通过<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2FiaS1zcGVjLmh0bWwjYWJp" title="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi">ABI编码<i class="fa fa-external-link"></i></span>传递，但如果使用<code>web3.js</code>，则不必关心这一点。</b></p><p><b style="color:#00f">如果合约要创建另一个合约，则创建者必须知道所创建合约的源代码（和二进制文件）。这意味着循环创建依赖是不可能的。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    // TokenCreator is a contract type that is defined below.</span><br><span class="line">    // It is fine to reference it as long as it is not used</span><br><span class="line">    // to create a new contract.</span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    // This is the constructor which registers the</span><br><span class="line">    // creator and the assigned name.</span><br><span class="line">    function OwnedToken(bytes32 _name) public &#123;</span><br><span class="line">        // State variables are accessed via their name</span><br><span class="line">        // and not via e.g. this.owner. This also applies</span><br><span class="line">        // to functions and especially in the constructors,</span><br><span class="line">        // you can only call them like that (&quot;internally&quot;),</span><br><span class="line">        // because the contract itself does not exist yet.</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        // We do an explicit type conversion from `address`</span><br><span class="line">        // to `TokenCreator` and assume that the type of</span><br><span class="line">        // the calling contract is TokenCreator, there is</span><br><span class="line">        // no real way to check that.</span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(bytes32 newName) public &#123;</span><br><span class="line">        // Only the creator can alter the name --</span><br><span class="line">        // the comparison is possible since contracts</span><br><span class="line">        // are implicitly convertible to addresses.</span><br><span class="line">        if (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address newOwner) public &#123;</span><br><span class="line">        // Only the current owner can transfer the token.</span><br><span class="line">        if (msg.sender != owner) return;</span><br><span class="line">        // We also want to ask the creator if the transfer</span><br><span class="line">        // is fine. Note that this calls a function of the</span><br><span class="line">        // contract defined below. If the call fails (e.g.</span><br><span class="line">        // due to out-of-gas), the execution here stops</span><br><span class="line">        // immediately.</span><br><span class="line">        if (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    function createToken(bytes32 name)</span><br><span class="line">       public</span><br><span class="line">       returns (OwnedToken tokenAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        // Create a new Token contract and return its address.</span><br><span class="line">        // From the JavaScript side, the return type is simply</span><br><span class="line">        // `address`, as this is the closest type available in</span><br><span class="line">        // the ABI.</span><br><span class="line">        return new OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(OwnedToken tokenAddress, bytes32 name)  public &#123;</span><br><span class="line">        // Again, the external type of `tokenAddress` is</span><br><span class="line">        // simply `address`.</span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isTokenTransferOK(address currentOwner, address newOwner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bool ok)</span><br><span class="line">    &#123;</span><br><span class="line">        // Check some arbitrary condition.</span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可见性和Getters"><a href="#可见性和Getters" class="headerlink" title="可见性和Getters"></a>可见性和Getters</h2><p>由于Solidity知道两种函数调用（不产生实际EVM调用的内部函数（也称为“消息调用”）和外部函数调用），<b style="color:red">函数和状态变量有四种类型的可见性。</b></p><p><b style="color:#00f">如存在函数可以指定external， public，internal或者private，其中默认为 public。对于状态变量，这external是不可能的，而且默认是internal。</b></p><ul><li>external：外部功能是合约界面的一部分，这意味着可以从其他合约和交易中调用它们。外部函数f不能在内部调用（即f()不起作用，但this.f()可以）。<b style="color:red">外部函数在接收大量数据时有时更高效。</b></li><li>public：<b style="color:#00f">公共方法是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量，会生成一个自动获取器函数（见下文）。</b></li><li>internal：<b style="color:#00f">这些方法和状态变量只能在内部进行访问（即从当前合约或从中衍生出的合约内），而不能使用this。</b></li><li>private：<b style="color:#00f">私有函数和状态变量仅对它们定义的合约而不是衍生合约中可见。</b></li></ul><p><b style="color:#6ab0de">注意: 所有外部观察者都可以看到合约内的所有内容。设置成员为private只会阻止其他合约访问和修改信息，但在区块链之外，整个世界仍然可以看到它。</b></p><p>可见性说明符在状态变量的类型之后以及函数的参数列表和返回参数列表之间给出。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a) private pure returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在以下示例中，<code>D</code>，可以调用c.getData()以检索data状态存储的值 ，但无法调用f。合约E来源于 C，因此可以调用compute方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//这将不会编译</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint private data;</span><br><span class="line"></span><br><span class="line">    function f(uint a) private returns(uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) public &#123; data = a; &#125;</span><br><span class="line">    function getData() public returns(uint) &#123; return data; &#125;</span><br><span class="line">    function compute(uint a, uint b) internal returns (uint) &#123; return a+b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    function readData() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint local = c.f(7); // error: member `f` is not visible</span><br><span class="line">        c.setData(3);</span><br><span class="line">        local = c.getData();</span><br><span class="line">        local = c.compute(3, 5); // error: member `compute` is not visible</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract E is C &#123;</span><br><span class="line">    function g() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint val = compute(3, 5); // access to internal member (from derived to parent contract)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Getter函数"><a href="#Getter函数" class="headerlink" title="Getter函数"></a>Getter函数</h3><p>编译器自动为所有公共状态变量创建getter函数。对于下面给出的合约，编译器将生成一个函数data，它不会接受任何参数并返回uint状态变量的值data。状态变量的初始化可以在声明中完成。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">getter方法具有外部可见性。如果符号在内部被访问（即没有<code>this.</code>），它被认为是一个状态变量。如果它是外部访问的（即with <code>this.</code>），它将作为函数进行访问。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data;</span><br><span class="line">    function x() public &#123;</span><br><span class="line">        data = 3; // internal access</span><br><span class="line">        uint val = this.data(); // external access</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个例子有点复杂：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>它将生成以下形式的函数：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>请注意，结构中的映射被省略，因为没有提供映射键的好方法。</p><h2 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h2><p><b style="color:red">修饰符可以用来轻松改变函数的行为。例如，他们可以在执行该方法之前自动检查一个条件。修饰符是合约的可继承属性，可能会被衍生合约覆盖。</b></p><p><b style="color:red">可修饰符，注意看代码的15行和52行，这个就是我们如何自定义自己的函数修饰符的例子，总的来说就是实现了钩子方法，超赞。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // This contract only defines a modifier but does not use</span><br><span class="line">    // it: it will be used in derived contracts.</span><br><span class="line">    // The function body is inserted where the special symbol</span><br><span class="line">    // `_;` in the definition of a modifier appears.</span><br><span class="line">    // This means that if the owner calls this function, the</span><br><span class="line">    // function is executed and otherwise, an exception is</span><br><span class="line">    // thrown.</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // This contract inherits the `onlyOwner` modifier from</span><br><span class="line">    // `owned` and applies it to the `close` function, which</span><br><span class="line">    // causes that calls to `close` only have an effect if</span><br><span class="line">    // they are made by the stored owner.</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // Modifiers can receive arguments:</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // It is important to also provide the</span><br><span class="line">    // `payable` keyword here, otherwise the function will</span><br><span class="line">    // automatically reject all Ether sent to it.</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// This function is protected by a mutex, which means that</span><br><span class="line">    /// reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br><span class="line">    /// The `return 7` statement assigns 7 to the return value but still</span><br><span class="line">    /// executes the statement `locked = false` in the modifier.</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b style="color:red">通过在一个空白分隔的列表中指定多个修饰符并按照所呈现的顺序对多个修饰符进行评估。</b></p><p><b style="color:#6ab0de">警告: 在早期版本的Solidity中，return具有修饰符的函数中的语句表现不同。</b></p><p><b style="color:red">来自修饰符或函数体的显式返回仅保留当前修饰符或函数体。返回变量被赋值并且控制流程在前一个修改器中的“_”之后继续。</b></p><p><b style="color:red">修饰符参数可使用允许任意表达式，在此上下文中，从该函数可见的所有符号在修饰符中都是可见的。在修饰符中引入的符号在函数中是不可见的（因为它们可能通过覆盖而改变）。(注意这里的修饰符是指修饰符函数)</b></p><h2 id="常量状态变量"><a href="#常量状态变量" class="headerlink" title="常量状态变量"></a>常量状态变量</h2><p><b style="color:red">状态变量可以声明为constant。在这种情况下，它们必须在编译时的常量表达式中分配。访问存储的任何表达式，blockchain数据（例如<code>now</code>，<code>this.balance</code>或 <code>block.number</code>），或者执行数据（<code>msg.value</code>或<code>gasleft()</code>）或调用外部合约是不允许的。对内存分配可能有副作用的表达式是允许的，但对其他内存对象可能有副作用的表达式则不允许。内置的功能<code>keccak256</code>，<code>sha256</code>，<code>ripemd160</code>，<code>ecrecover</code>，<code>addmod</code>和<code>mulmod</code>是允许的（即使他们这样做调用外部合约）。</b></p><p>在内存分配器上允许副作用的原因是应该可以构造复杂的对象，例如查找表。此功能尚未完全可用。</p><p>编译器不会为这些变量保留一个存储槽，并且每个出现都被各自的常量表达式替换（可能由优化器为单个值计算）。</p><p>并非所有类型的常量都在此时执行。唯一支持的类型是值类型和字符串。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h3 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h3><p>可以用<code>view</code>声明函数，在这种情况下，它们保证不修改状态。</p><p>以下声明被视为修改状态：</p><ul><li>写入状态变量。</li><li><span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI2V2ZW50cw==" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#events">发射(触发)事件。<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sI2NyZWF0aW5nLWNvbnRyYWN0cw==" title="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#creating-contracts">创建其他合约<i class="fa fa-external-link"></i></span>。</li><li>使用<code>selfdestruct</code>。</li><li>通过调用方法发送以太币。</li><li>调用任何未标记<code>view</code>或<code>pure</code>的方法。</li><li>使用低级别的调用。</li><li>使用包含某些操作码的内联汇编。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public view returns (uint) &#123;</span><br><span class="line">        return a * (b + 42) + now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b style="color:#6ab0de">注意: 方法上的<code>constant</code>是<code>view</code>的别名，但这已被弃用，并计划在0.5.0版中删除。</b></p><p><b style="color:#6ab0de">注意: Getter方法被标记为<code>view</code>。</b></p><p><b style="color:#6ab0de">注意: 如果使用无效的显式类型转换，那么即使view调用了一个函数，状态修改也是可能的。您可以切换编译器在调用此类函数时使用<code>STATICCALL</code>，那么通过添加<code>pragma experimental &quot;v0.5.0&quot;;</code>来防止修改EVM级别的状态.</b></p><p><b style="color:#6ab0de">警告:编译器不强制<code>view</code>方法不去修改状态。但它会提出了一个警告。</b></p><h3 id="纯函数-pure-functions"><a href="#纯函数-pure-functions" class="headerlink" title="纯函数(pure functions)"></a>纯函数(<code>pure functions</code>)</h3><p>可以声明函数为<code>pure</code>，在这种情况下，它们承诺不读取或修改状态。</p><p>除了上面解释的状态修改语句列表之外，以下内容被认为是从状态中读取的：</p><ul><li>从状态变量读取。</li><li>访问<code>this.balance</code>或<code>&lt;address&gt;.balance</code>。</li><li>访问任何成员<code>block</code>，<code>tx</code>，<code>msg</code>（<code>msg.sig</code>和<code>msg.data</code>除外）。</li><li>调用任何未标记为<code>pure</code>的方法。</li><li>使用包含某些操作码的内联汇编。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public pure returns (uint) &#123;</span><br><span class="line">        return a * (b + 42);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b style="color:#6ab0de">注意: 如果使用无效的显式类型转换，那么即使pure调用了一个函数，状态修改也是可能被访问的。您可以切换编译器在调用此类函数时使用<code>STATICCALL</code>，从而通过添加<code>pragma experimental &quot;v0.5.0&quot;;</code>来防止修改EVM级别的状态。</b></p><p><b style="color:#6ab0de">警告: 不可能阻止函数读取EVM级别的状态，只能防止它们写入状态（只有<code>view</code>能在EVM级别执行，<code>pure</code>不能）。</b></p><p><b style="color:#6ab0de">警告: 在版本0.4.17之前，编译器没有强制要求<code>pure</code>不读状态。</b></p><h3 id="fallback方法"><a href="#fallback方法" class="headerlink" title="fallback方法"></a>fallback方法</h3><p>我觉得应该在这里插入一个真实项目的示例，这样才能理解这篇的知识：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @dev fallback function ***DO NOT OVERRIDE***</span><br><span class="line">*/</span><br><span class="line">function () external payable &#123;</span><br><span class="line">    deposit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">合约可以有一个未命名的方法。这个方法不能有参数，也不能返回任何东西。如果没有其他函数与给定的函数标识符匹配（或者根本没有提供数据），它将在对合约的调用中执行。</b></p><p><b style="color:red">此外，只要合约收到普通以太网币（无数据），就会执行此方法。另外，为了接收以太币，必须标记回退功能payable。如果不存在此类功能，则合约无法通过正常交易接收以太币。</b></p><p>在最坏的情况下，fallback方法只能依靠2300gas（例如使用发送或传输以太币时使用），除了基本日志记录以外，没有太多空间来执行其他操作。以下操作将消耗比2300gas津贴更多的gas：</p><ul><li>写入存储（<code>storage</code>）</li><li>创建合约</li><li>调用消耗大量gas的外部方法</li><li>发送以太币</li></ul><p>像任何方法一样，只要给足够的gas，fallback方法就可以执行复杂的操作。</p><p><b style="color:#6ab0de">注意：即使fallback函数不能有参数，它仍然可以使用<code>msg.data</code>来检索随该调用提供的任何有效内容。</b></p><p><b style="color:#6ab0de">警告: 直接接收Ether的合约（没有函数调用，即使用send或transfer）但没有定义fallback函数会抛出异常，发回Ether（这在Solidity v0.4.0之前是不同的）。所以如果你想让你的合约接收Ether，你必须实现一个fallback方法。</b></p><p><b style="color:#6ab0de">警告：没有<code>payable</code>,<code>fallback</code>方法的合约可以作为coinbase交易（矿工挖矿奖励）的接收者或作为<code>selfdestruct</code>的目的地接收以太币。</b><br><b style="color:red">合约不能对这种以太币传输作出反应，因此也不能拒绝它们。这是EVM的设计选择，而且Solidity无法解决这个问题。</b><br><b style="color:#6ab0de">这也意味着<code>this.balance</code>可以高于合约中实施的一些账务计算的总和（即，具有在fallback函数中更新的计数器）。（这个就是在某些条件下转入的以太币，fallback函数不被执行，导致账户实际的值与你在合约中计算的值不一致的问题。）</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // This function is called for all messages sent to</span><br><span class="line">    // this contract (there is no other function).</span><br><span class="line">    // Sending Ether to this contract will cause an exception,</span><br><span class="line">    // because the fallback function does not have the `payable`</span><br><span class="line">    // modifier.</span><br><span class="line">    function() public &#123; x = 1; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// This contract keeps all Ether sent to it with no way</span><br><span class="line">// to get it back.</span><br><span class="line">contract Sink &#123;</span><br><span class="line">    function() public payable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    function callTest(Test test) public &#123;</span><br><span class="line">        test.call(0xabcdef01); // hash does not exist</span><br><span class="line">        // results in test.x becoming == 1.</span><br><span class="line"></span><br><span class="line">        // The following will not compile, but even</span><br><span class="line">        // if someone sends ether to that contract,</span><br><span class="line">        // the transaction will fail and reject the</span><br><span class="line">        // Ether.</span><br><span class="line">        //test.send(2 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>合约可以具有多个具有相同名称但具有不同参数的函数。这也适用于继承功能。以下示例显示了合约<code>A</code>范围内的函数重载<code>f</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint _in) public pure returns (uint out) &#123;</span><br><span class="line">        out = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint _in, bytes32 _key) public pure returns (uint out) &#123;</span><br><span class="line">        out = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>函数重载也存在于外部接口中。如果两个外部可见函数的Solidity类型不同而不是它们的外部类型不同，这是错误的(返回的类型一定要相同)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码不会被编译</span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(B _in) public pure returns (B out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(address _in) public pure returns (address out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述两个重载函数<code>f</code>最终都会接受ABI的地址类型，尽管它们在Solidity中被认为是不同的。</p><h4 id="重载解析和参数匹配"><a href="#重载解析和参数匹配" class="headerlink" title="重载解析和参数匹配"></a>重载解析和参数匹配</h4><p><b style="color:#00f">通过将当前作用域中的函数声明与函数调用中提供的参数进行匹配来选择重载函数。如果所有参数都可以隐式转换为预期类型，则函数被选为超载候选。如果没有确切的一个候选人，则解决失败。</b></p><p>注意: 重载解析不考虑返回参数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">调用<code>f(50)</code>会创建一个类型错误，因为250可以隐式转换为<code>uint8</code> 和<code>uint256</code>类型。另一方面<code>f(256)</code>将解决<code>f(uint256)</code>重载，因为256不能隐式转换为uint8。</b></p><h2 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h2><p>事件允许方便地使用EVM日志记录工具，而后者又可用于在用于监听这些事件的dapp的用户界面中“调用”JavaScript回调。</p><p><b style="color:#00f">Event是可继承的合约成员。当它们被调用时，它们会在交易日志中(区块链中的特殊数据结构)存储参数</b>。这些日志与合约的地址相关联，日志将被并入区块链并停留在区块链的可访问区块中（Frontier和Homestead这个永远是这样的，但这可能随着Serenity发布而改变）。<b style="color:red">日志和事件数据不能从合约内访问（甚至不能从创建它们的合约中访问）</b>。</p><p><b style="color:red">可以使用日志的SPV证明，因此如果外部实体提供有这种证明的合约，它可以检查日志是否确实存在于区块链中。但请注意，必须提供区块头，因为合约只能看到最后的256个区块的hash。</b></p><p><b style="color:#00f">最多三个参数可以接收<code>indexed</code>属性，将导致搜索各个参数找到<code>indexed</code>：可以用户界面中筛选索引参数的特定值。</b> <b style="color:red">（其实就是说，参数是排序的，根据索引可以取得参数，然后指定该参数的过滤条件以达到筛选的功能,可以看一下下面我从别的地方拷贝来的代码，你就能明白一些，当然你如果能查看web3的源码，理解会更深入，其实以我的理解就是日志加查询索引而已！）。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);</span><br></pre></td></tr></table></figure><p>如果数组（包括string和bytes）用作索引参数，则其Keccak-256散列值将作为主题存储。</p><p><b style="color:red">除了用<code>anonymous</code>说明符声明事件之外，事件签名的散列是其中一个主题。这意味着无法通过名称筛选特定的匿名事件。</b></p><p><b style="color:red">所有非索引参数都将存储在日志的数据部分中。</b></p><p>注意: 索引参数不会自行存储。您只能搜索这些值，但不可能自行检索这些值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // Events are emitted using `emit`, followed by</span><br><span class="line">        // the name of the event and the arguments</span><br><span class="line">        // (if any) in parentheses. Any such invocation</span><br><span class="line">        // (even deeply nested) can be detected from</span><br><span class="line">        // the JavaScript API by filtering for `Deposit`.</span><br><span class="line">        emit Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>JavaScript API中的用法如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// watch for changes</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // result will contain various information</span><br><span class="line">    // including the argumets given to the `Deposit`</span><br><span class="line">    // call.</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Or pass a callback to start watching immediately</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h3 id="日志的低级接口"><a href="#日志的低级接口" class="headerlink" title="日志的低级接口"></a>日志的低级接口</h3><p>另外，也可以通过函数来访问低层接口的日志机制<code>log0</code>，<code>log1</code>，<code>log2</code>，<code>log3</code>和<code>log4</code>。<code>logi</code>接受<code>i+1</code>的bytes32类型参数，其中第一个参数将用于日志的数据部分，其他参数用作主题。上面的事件调用可以按照与上述相同的方式执行，如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public payable &#123;</span><br><span class="line">        bytes32 _id = 0x420042;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>长十六进制数等于<code>keccak256(&quot;Deposit(address,hash256,uint256)&quot;)</code>, 事件的签名。</p><h3 id="了解事件的其他资源"><a href="#了解事件的其他资源" class="headerlink" title="了解事件的其他资源"></a>了解事件的其他资源</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KYXZhU2NyaXB0LUFQSSNjb250cmFjdC1ldmVudHM=" title="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events">Javascript文档<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlYnJpcy9zbWFydC1leGNoYW5nZS9ibG9iL21hc3Rlci9saWIvY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2Uuc29s" title="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">事件的示例用法<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RlYnJpcy9zbWFydC1leGNoYW5nZS9ibG9iL21hc3Rlci9saWIvZXhjaGFuZ2VfdHJhbnNhY3Rpb25zLmpz" title="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js">如何在js中访问它们<i class="fa fa-external-link"></i></span></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><b style="color:red">通过复制包括多态性的代码，Solidity支持多重继承。</b></p><p>所有的函数调用都是虚拟的，这意味着调用了大多数派生函数，除非明确给出了合约名称。</p><p>当合约从多个合约中继承时，只会在区块链上创建单个合约，并将所有基础合约中的代码复制到创建的合约中。</p><p>一般继承系统与Python非常相似 ，特别是多继承。</p><p>以下示例中给出了详细信息。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use `is` to derive from another contract. Derived</span><br><span class="line">// contracts can access all non-private members including</span><br><span class="line">// internal functions and state variables. These cannot be</span><br><span class="line">// accessed externally via `this`, though.</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// These abstract contracts are only provided to make the</span><br><span class="line">// interface known to the compiler. Note the function</span><br><span class="line">// without body. If a contract does not implement all</span><br><span class="line">// functions it can only be used as an interface.</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="line">// also a base class of `mortal`, yet there is only a single</span><br><span class="line">// instance of `owned` (as for virtual inheritance in C++).</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Functions can be overridden by another function with the same name and</span><br><span class="line">    // the same number/types of inputs.  If the overriding function has different</span><br><span class="line">    // types of output parameters, that causes an error.</span><br><span class="line">    // Both local and message-based function calls take these overrides</span><br><span class="line">    // into account.</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // It is still possible to call a specific</span><br><span class="line">            // overridden function.</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If a constructor takes an argument, it needs to be</span><br><span class="line">// provided in the header (or modifier-invocation-style at</span><br><span class="line">// the constructor of the derived contract (see below)).</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">请注意，上面我们调用<code>mortal.kill()</code>“转发”销毁请求。这样做的方式是有问题的，如以下示例所示</b>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>Final.kill()</code>的调用将会调用<code>Base2.kill</code>称为最派生的覆盖，但这个函数将绕过<code>Base1.kill</code>，主要是因为它甚至不知道 <code>Base1</code>。解决这个问题的方法是使用super：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">如果<code>Base2</code>调用<code>super</code>的函数，它不会简单地在其一个基础合约上调用该函数。相反，它在最终的继承图中的下一个基础合约上调用该函数，因此它会调用<code>Base1.kill()</code>（请注意，最终的继承序列是 - 从派生最多的合约开始：<code>Final</code>，<code>Base2</code>，<code>Base1</code>，<code>mortal</code>，<code>owned</code>）。使用<code>super</code>时调用的实际函数在使用它的类的上下文中是未知的，尽管其类型是已知的。这对于普通的虚拟方法查找是相似的。</b></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一个可选函数，其名称与创建合约时执行的合约名称相同。<b style="color:red">构造函数可以是public或者internal</b>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint public a;</span><br><span class="line"></span><br><span class="line">    function A(uint _a) internal &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A(1) &#123;</span><br><span class="line">    function B() public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>设置构造函数为internal会导致合约被标记为<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI2Fic3RyYWN0LWNvbnRyYWN0" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#abstract-contract">抽象<i class="fa fa-external-link"></i></span>。</p><h3 id="基础构造函数的参数"><a href="#基础构造函数的参数" class="headerlink" title="基础构造函数的参数"></a>基础构造函数的参数</h3><p>派生合约需要提供基础构造函数所需的所有参数。这可以通过两种方式完成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一种方法直接在继承列表（<code>is Base(7)</code>）中。另一种方式是调用一个修饰符作为派生构造函数（<code>Base(_y * _y)</code>）的头部分的一部分。如果构造函数参数是一个常量来定义合约的行为或描述它，第一种实现方法更为方便。如果基础的构造函数参数取决于衍生合约的构造函数参数，则必须使用第二种方法。<b style="color:red">如果像在这个简单的例子中一样，这两处都用到了，那么修饰语风格的参数优先。</b></p><h3 id="多重继承和线性化"><a href="#多重继承和线性化" class="headerlink" title="多重继承和线性化"></a>多重继承和线性化</h3><p><b style="color:#00f">允许多重继承的语言必须处理几个问题。一个是<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXVsdGlwbGVfaW5oZXJpdGFuY2UjVGhlX2RpYW1vbmRfcHJvYmxlbQ==" title="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">钻石问题<i class="fa fa-external-link"></i></span>。Solidity遵循Python的方式，并使用<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQzNfbGluZWFyaXphdGlvbg==" title="https://en.wikipedia.org/wiki/C3_linearization">“C3线性化”<i class="fa fa-external-link"></i></span>来强制基类的DAG中的特定顺序。这导致单调性的理想特性，但不允许某些继承图。特别是，在指令<code>is</code>中给出基类的顺序很重要。在下面的代码中，Solidity会给出错误<code>Linearization of inheritance graph impossible</code>。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 这将不会编译</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure><p>其原因是<code>C</code>请求<code>X</code>覆盖<code>A</code> （通过<code>A,X</code>按此顺序），但<code>A</code>本身请求覆盖，这是无法解决的矛盾。</p><p><b style="color:red">要记住的一个简单规则是按照“most base-like”到“most derived”的顺序​​指定基类。</b></p><h3 id="继承不同类型的同名成员"><a href="#继承不同类型的同名成员" class="headerlink" title="继承不同类型的同名成员"></a>继承不同类型的同名成员</h3><p><b style="color:red">当继承导致具有相同名称的函数和修饰符的合约时，它被视为错误。这个错误也是由同名的事件和修饰符以及同名的函数和事件产生的。作为一个例外，状态变量getter可以覆盖公共函数。</b></p><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p><b style="color:red">如果至少其中一个方法缺少如下例所示的实现（注意函数声明标头以<code>;</code>终止），则合约被标记为抽象</b>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这些合约不能被编译（即使它们包含已实现的功能以及未实现的功能），但它们可以用作基本合约：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32) &#123; return &quot;miaow&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果合约继承自抽象合约，并且没有通过覆盖来实现所有未实现的功能，它本身就是抽象的。</p><p>请注意，没有实现的函数与<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL3R5cGVzLmh0bWwjZnVuY3Rpb24tdHlwZXM=" title="https://solidity.readthedocs.io/en/v0.4.21/types.html#function-types">函数类型<i class="fa fa-external-link"></i></span>不同，即使它们的语法看起来非常相似。</p><p>没有实现的函数示​​例（函数声明）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(address) external returns (address);</span><br></pre></td></tr></table></figure><p></p><p>函数类型的示例（变量声明，其中变量是<code>function</code>类型的）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(address) external returns (address) foo;</span><br></pre></td></tr></table></figure><p></p><p>抽象合约将合约的定义与其实现分离开来，从而提供更好的可扩展性和自我文档，并促进像Template方法和消除代码重复这样的模式。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><b style="color:red">接口类似于抽象合约，但它们不能实现任何方法。还有其他限制</b>：</p><ol><li>无法继承其他合约或接口。</li><li>无法定义构造函数。</li><li>无法定义变量。</li><li>无法定义struct。</li><li>无法定义枚举。</li></ol><p>这些限制中的一些可能会在未来取消。</p><p><b style="color:red">接口基本上仅限于合约ABI可以表示的内容，并且ABI和接口之间的转换应该是可能的，而不会丢失任何信息</b>。</p><p>接口由关键字<code>interface</code>表示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    function transfer(address recipient, uint amount) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>合约可以继承接口，因为它们会继承其他合约。</p><h2 id="库-Libraries"><a href="#库-Libraries" class="headerlink" title="库 Libraries"></a>库 Libraries</h2><p>库与合约类似，但其用途是它们只在特定地址部署一次，并使用EVM 的<code>DELEGATECALL</code> （<code>CALLCODE</code>直到Homestead）方法重用其代码。这意味着如果调用库函数，它们的代码将在调用合约的上下文中执行，即this指向调用合约，特别是可以访问来自调用合约的存储（storage）。由于库是一段独立的源代码，因此它只能访问调用协定的状态变量（如果它们被明确提供，否则无法命名它们）。如果库函数<code>DELEGATECALL</code>不修改状态（即，如果它们是<code>view</code>或<code>pure</code>方法），则只能直接调用库函数（即不使用<code>DELEGATECALL</code>），因为库被认为是无状态的。特别是，除非Solidity的类型系统被规避，否则不可能破坏库。</p><p>库可以被视为使用它们的合约的隐含基础合约。它们不会在继承层次结构中显式可见，但对库函数的调用看起来就像调用显式基础合约的函数（<code>L.f()</code>如果<code>L</code>是库的名称）。此外，<code>internal</code>库函数在所有合约中都是可见的，就像库是基础合约一样。当然，对内部函数的调用使用内部调用合约，这意味着可以传递所有内部类型，并且内存类型将通过引用传递并且不会被复制。为了在EVM中实现这一点，内部库函数和其中调用的所有函数的代码将在编译时拉入到调用合约中，并且JUMP将使用常规调用而不是<code>DELEGATECALL</code>。</p><p>以下示例说明了如何使用库（但请务必查看<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyYWN0cy5odG1sI3VzaW5nLWZvcg==" title="https://solidity.readthedocs.io/en/v0.4.21/contracts.html#using-for">使用for<i class="fa fa-external-link"></i></span>获取更高级的示例来实现Set）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // We define a new struct datatype that will be used to</span><br><span class="line">  // hold its data in the calling contract.</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // Note that the first parameter is of type &quot;storage</span><br><span class="line">  // reference&quot; and thus only its storage address and not</span><br><span class="line">  // its contents is passed as part of the call.  This is a</span><br><span class="line">  // special feature of library functions.  It is idiomatic</span><br><span class="line">  // to call the first parameter `self`, if the function can</span><br><span class="line">  // be seen as a method of that object.</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // The library functions can be called without a</span><br><span class="line">        // specific instance of the library, since the</span><br><span class="line">        // &quot;instance&quot; will be the current contract.</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // In this contract, we can also directly access knownValues.flags, if we want.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当然，您不必遵循这种方式来使用库：它们也可以在不定义结构数据类型的情况下使用。函数也可以在没有任何storage引用参数的情况下工作，并且它们可以具有多个storage引用参数并且在任何位置。</p><p><b style="color:#00f">所有对<code>Set.contains</code>，<code>Set.insert</code>和<code>Set.remove</code>的调用都被编译为调用（<code>DELEGATECALL</code>）到外部合约/库</b>。<b style="color:#00f">如果使用库，请注意执行实际的外部函数调用</b>。 <code>msg.sender</code>，<code>msg.value</code>和<code>this</code>在此调用中将保留它们的值，虽然（Homestead之前，因为使用的<code>CALLCODE</code>，<code>msg.sender</code>和<code>msg.value</code>改变了）。</p><p>下面的例子显示了如何在库中使用内存类型和内部函数，以实现自定义类型，而无需外部函数调用的开销：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // too bad, we have to add a limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于编译器无法知道库的部署位置，因此必须通过链接器将这些地址填充到最终的字节码中（请参阅<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL3VzaW5nLXRoZS1jb21waWxlci5odG1sI2NvbW1hbmRsaW5lLWNvbXBpbGVy" title="https://solidity.readthedocs.io/en/v0.4.21/using-the-compiler.html#commandline-compiler">使用命令行编译器<i class="fa fa-external-link"></i></span>了解如何使用命令行编译器进行链接）。如果地址不作为编译器的参数给出，编译的十六进制代码将包含表单的占位符<code>__Set______</code>（其中 Set是库的名称）。地址可以通过用库合约地址的十六进制编码来手动填充替换所有这40个符号。</p><p>与合约相比，库的限制：</p><ul><li>没有状态变量</li><li>不能继承，也不能被继承</li><li>无法接收以太币</li></ul><p>（这些可能会在之后的版本解除。）</p><h3 id="库的调用保护"><a href="#库的调用保护" class="headerlink" title="库的调用保护"></a>库的调用保护</h3><p>正如介绍中提到，如果某个库的代码被执行应使用<code>CALL</code>，而不是一个<code>DELEGATECALL</code>或<code>CALLCODE</code>，它会恢复，除非<code>view</code>或<code>pure</code>函数被调用。</p><p><b style="color:red">EVM不提供直接的方式来检测合约是否被<code>CALL</code>调用，但合约可以使用<code>ADDRESS</code>操作码来找出当前正在运行的“哪里”。生成的代码将此地址与创建时使用的地址进行比较，以确定调用模式。</b></p><p><b style="color:red">更具体地说，库的运行时代码始终以一个推送指令开始，该指令在编译时为20个字节的零。部署代码运行时，该常量在内存中被当前地址替换，并且此修改的代码存储在合约中。在运行时，这会导致部署时间地址成为第一个被压入堆栈的常量，并且调度程序代码会将当前地址与此常量进行比较，以查看任何非<code>view</code>和非<code>pure</code>函数。</b></p><h2 id="using-for语句"><a href="#using-for语句" class="headerlink" title="using for语句"></a>using for语句</h2><p>该指令<code>using A for B;</code>可用于将库函数（从库<code>A</code>中）附加到任何类型（<code>B</code>）。<b style="color:red">这些函数将接收它们被调用的对象作为它们的第一个参数（如Python中的变量）</b>。</p><p><code>using A for *;</code>其效果是库<code>A</code>中的函数被附加到任何类型。</p><p>在这两种情况下，都会附加所有函数，即使是第一个参数的类型与对象类型不匹配的函数。在函数被调用的地方检查类型，并执行函数重载解析。</p><p><code>using A for B;</code>该指令对于当前作用域是有效的，现在仅限于一个合约，但稍后将被提升到全局作用域，这样通过包含一个模块，其数据类型（包括库函数）可用，而无需添加进一步的代码。</p><p>让我们以这种方式重写库中的设置示例 ：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// This is the same code as before, just without comments</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // this is the crucial change</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以这种方式扩展基本类型也是可能的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return uint(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint _old, uint _new) public &#123;</span><br><span class="line">        // This performs the library function call</span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        if (index == uint(-1))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        else</span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">请注意，所有库调用都是实际的EVM函数调用。这意味着如果您传递内存或值类型，将执行副本，甚至是<code>self</code>变量。唯一不执行复制的情况是使用storage引用变量。</b></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity表达式和控制结构</title>
      <link href="//blockchain/solidity%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.html"/>
      <url>//blockchain/solidity%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p><h2 id="输入参数和输出参数"><a href="#输入参数和输出参数" class="headerlink" title="输入参数和输出参数"></a>输入参数和输出参数</h2><p>与Javascript一样，方法可能会将参数作为输入; 不像Javascript和C中，它们也可以返回任意数量的参数作为输出。</p><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><p>输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名称。例如，假设我们希望我们的合约接受一种具有两个整数的外部调用，我们会写如下所示的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function taker(uint _a, uint _b) public pure &#123;</span><br><span class="line">        // do something with _a and _b.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>输出参数可以在returns关键字后用相同的语法声明 。例如，假设我们希望返回两个结果：两个给定整数的和以及乘积，那么我们会写：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function arithmetics(uint _a, uint _b)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint o_sum, uint o_product)</span><br><span class="line">    &#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出参数的名称可以省略。输出值也可以使用return语句指定。该return语句还能够返回多个值，请参阅<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sI211bHRpLXJldHVybg==" title="https://solidity.readthedocs.io/en/v0.4.21/control-structures.html#multi-return">返回多个值<i class="fa fa-external-link"></i></span>。返回参数被初始化为零; 如果他们没有明确设定，他们将保持为零。</p><p><b style="color:#00f">输入参数和输出参数可以用作函数体中的表达式。在那里，它们也可以在赋值语句的左侧使用。</b></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>除了<code>switch</code>和<code>goto</code>之外，来自JavaScript的大部分控制结构都可以使用。所以有：<code>if</code>，<code>else</code>，<code>while</code>，<code>do</code>，<code>for</code>，<code>break</code>，<code>continue</code>，<code>return</code>，<code>?:</code>，这些与C或JavaScript已知的常规语义一样。</p><p>条件语句不能省略括号，但可以在单个语句的主体周围省略花括号。</p><p>请注意，solidity没有有从非布尔类型转换为Boolean类型的方式，因为<code>if (1) { ... }</code>在C和JavaScript中是可以转化，但是不是有效的solidity语句。</p><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>当函数有多个输出参数时，<code>return (v0, v1, ..., vn)</code>可以返回多个值。组件的数量必须与输出参数的数量相同。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>可以直接（“internally”）调用当前合约的方法，也可以递归地调用，如在这个无意义的示例中所见：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g(uint a) public pure returns (uint ret) &#123; return f(); &#125;</span><br><span class="line">    function f() internal pure returns (uint ret) &#123; return g(7) + f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">这些函数调用被转换为EVM内部的简单跳转。这样做的效果是当前内存不会被清除，即将内存引用传递给内部调用的函数非常有效。只有同一合约的方法可以在内部调用。</b></p><h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>表达式<code>this.g(8);</code>和<code>c.g(2);</code>（其中<code>c</code>是合约实例）也是有效的函数调用，但是这次函数将通过消息调用而不是直接通过跳转被称为“externally”。<b style="color:red">请注意函数调用this不能在构造函数中使用，因为实际合约尚未创建。</b></p><p><b style="color:red">其他合约的方法必须从外部调用。对于外部调用，所有方法参数都必须复制到内存中。</b></p><p>当调用其他合约的方法，调用发送wei的数量和gas可以用特殊的选项来指定<code>.value()</code>和<code>.gas()</code>分别：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>修饰符<code>payable</code>必须用于<code>info</code>，否则，<code>.value()</code> 选项将不可用。</p><p>请注意，该表达式<code>InfoFeed(addr)</code>执行显式类型转换，指出“我们知道给定地址处的合约类型是InfoFeed”，并且这不会执行构造函数。<b style="color:red">显式类型转换必须谨慎处理。不要在不确定其类型的合同上调用函数。</b></p><p>我们也可以直接使用<code>function setFeed(InfoFeed _feed) { feed = _feed; }</code>。要小心这样一个事实，即 <code>feed.info.value(10).gas(800)</code>只有（本地）设置函数调用发送的ether值和gas的数量，并且只有最后的括号才能执行实际的调用。</p><p>如果被调用合约不存在（在账户不包含代码的意义上），或者被调用合约本身抛出异常或缺少gas，函数调用会导致异常。</p><p><b style="color:#6ab0de">警告：与其他合约的任何交互都会产生潜在的危险，特别是如果合约的源代码未提前知晓。目前的合约将控制权移交给被调用合约，这可能会做任何事情。即使被调用合约继承自已知的父合约，继承合约也只需要具有正确的接口。然而，合约的执行可能是完全随意的，因此构成危险。另外，要做好准备，以防其在您的系统的在其他合约中调用，甚至在第一次调用返回之前回到被调用合约中。这意味着被调用合约可以通过其方法改变主动调用合约的状态变量。例如，以一种方式编写你的方法。</b></p><h3 id="命名调用和匿名方法参数"><a href="#命名调用和匿名方法参数" class="headerlink" title="命名调用和匿名方法参数"></a>命名调用和匿名方法参数</h3><p><b style="color:#00f">函数调用参数也可以按名称的顺序给出，如果它们被包含在<code>{}</code>内，就可以在下面的例子中看到。参数列表必须按名称与函数声明中的参数列表重合，但可以按任意顺序排列。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint key, uint value) public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // named arguments</span><br><span class="line">        f(&#123;value: 2, key: 3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="省略方法参数名称"><a href="#省略方法参数名称" class="headerlink" title="省略方法参数名称"></a>省略方法参数名称</h3><p><b style="color:#00f">未使用的参数名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问。</b><b style="color:red">注意：具名返回参数是可以通过名称直接访问的。这个也是solidity语言和其它语言的一个很大不同之处。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // omitted name for parameter</span><br><span class="line">    function func(uint k, uint) public pure returns(uint) &#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="通过new创建合约"><a href="#通过new创建合约" class="headerlink" title="通过new创建合约"></a>通过new创建合约</h2><p>合约可以使用new关键字创建新合约。创建合约的完整代码必须事先知道，因此递归创建依赖关系是不可能的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = new D(4); // will be executed as part of C&apos;s constructor</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">        // Send ether along with the creation</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">如示例中所示，可以在创建<code>D</code>使用该<code>.value()</code>选项的实例时转发Ether ，但不可能限制gas的数量</b>。如果创建失败（由于堆栈外，没有足够的余额或其他问题），会引发异常。</p><h2 id="表达式评估顺序"><a href="#表达式评估顺序" class="headerlink" title="表达式评估顺序"></a>表达式评估顺序</h2><p><b style="color:#00f">表达式的评估顺序没有被指定（更正式地说，表达式树中一个节点的子节点的评估顺序没有被指定，但是它们当然是在节点本身之前被评估的）。只能保证语句按顺序执行，布尔表达式的短路完成。有关更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL21pc2NlbGxhbmVvdXMuaHRtbCNvcmRlcg==" title="https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html#order">操作符的优先顺序<i class="fa fa-external-link"></i></span>。</b></p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><h3 id="解构赋值和返回多值"><a href="#解构赋值和返回多值" class="headerlink" title="解构赋值和返回多值"></a>解构赋值和返回多值</h3><p><b style="color:red">Solidity内部允许元组类型，即在编译时大小为常量的可能不同类型的对象列表。这些元组可以同时返回多个值，并同时将它们分配给多个变量（或一般的LValues）</b>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br><span class="line">        var (x, b, y) = f();</span><br><span class="line">        // Assigns to a pre-existing variable.</span><br><span class="line">        (x, y) = (2, 7);</span><br><span class="line">        // Common trick to swap values -- does not work for non-value storage types.</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        // Components can be left out (also for variable declarations).</span><br><span class="line">        // If the tuple ends in an empty component,</span><br><span class="line">        // the rest of the values are discarded.</span><br><span class="line">        (data.length,) = f(); // Sets the length to 7</span><br><span class="line">        // The same can be done on the left side.</span><br><span class="line">        // If the tuple begins in an empty component, the beginning values are discarded.</span><br><span class="line">        (,data[3]) = f(); // Sets data[3] to 2</span><br><span class="line">        // Components can only be left out at the left-hand-side of assignments, with</span><br><span class="line">        // one exception:</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        // (1,) is the only way to specify a 1-component tuple, because (1) is</span><br><span class="line">        // equivalent to 1.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Arrays和Structs的复杂度"><a href="#Arrays和Structs的复杂度" class="headerlink" title="Arrays和Structs的复杂度"></a>Arrays和Structs的复杂度</h3><p>赋值语义对于像数组和结构体这样的非值类型来说更复杂一些。<b style="color:red">赋值给状态变量总是创建一个独立的副本。另一方面，赋值给局部变量只为基本类型创建独立副本，即适合32个字节的静态类型。</b><b style="color:#00f">如果结构或数组（包括bytes和string）从状态变量分配给局部变量，则局部变量保存对原始状态变量的引用。对局部变量的二次赋值不会修改状态，只会改变引用。</b><b style="color:red">赋值给局部变量的成员（或元素）会改变状态。(这个意思应该是指改变arrays和struct局部变量中的某一个属相，这个肯定是改变值的)</b></p><h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h2><p>被声明的变量将具有初始缺省值，其字节表示全部为零。变量的“默认值”是任何类型的典型“零状态”。例如，bool is 的默认值false。uint或int类型的默认值是0。对于静态大小的数组和bytes1对bytes32，每个单独的元件将被初始化为对应于其类型的默认值。最后，对于动态大小的数组，bytes和string，默认值是一个空数组或字符串。</p><p><b style="color:red">在方法中的任何位置声明的变量将在整个方法的范围内，而不管它在哪里声明（这将很快发生变化，请参见下文）</b>。发生这种情况是因为Solidity从JavaScript继承了它的范围规则。这与许多语言形成对比，在这些语言中变量只在声明块结束时才声明变量。因此，下面的代码是非法的并且会导致编译器抛出一个错误：<code>Identifier already declared</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 这个不会编译的</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract ScopingErrors &#123;</span><br><span class="line">    function scoping() public &#123;</span><br><span class="line">        uint i = 0;</span><br><span class="line"></span><br><span class="line">        while (i++ &lt; 1) &#123;</span><br><span class="line">            uint same1 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i++ &lt; 2) &#123;</span><br><span class="line">            uint same1 = 0;// Illegal, second declaration of same1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function minimalScoping() public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;// Illegal, second declaration of same2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function forLoopScoping() public &#123;</span><br><span class="line">        for (uint same3 = 0; same3 &lt; 1; same3++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (uint same3 = 0; same3 &lt; 1; same3++) &#123;// Illegal, second declaration of same3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">除此之外，如果声明了一个变量，它将在函数的开头初始化为其默认值。因此，尽管写得不好，但下面的代码是合法的：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function foo() public pure returns (uint) &#123;</span><br><span class="line">        // baz is implicitly initialized as 0</span><br><span class="line">        uint bar = 5;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">            bar += baz;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint baz = 10;// never executes</span><br><span class="line">        &#125;</span><br><span class="line">        return bar;// returns 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="0-5-0版开始的作用域"><a href="#0-5-0版开始的作用域" class="headerlink" title="0.5.0版开始的作用域"></a><b style="color:red">0.5.0版开始的作用域</b></h3><p>从版本0.5.0开始，Solidity将更改为更广泛的C99（以及许多其他语言）的范围规则：变量从声明后的正确位置直到块的结尾才可见。<b style="color:#00f">作为这条规则的一个例外，在for循环的初始化部分声明的变量只有在for循环结束之前才可见。</b></p><p><b style="color:#00f">在代码块之外声明的变量和其他项目，例如函数，合约，用户定义的类型等，不会更改其作用域行为。这意味着您可以在声明它们之前使用状态变量并递归调用函数。</b></p><p>这些规则现在已经作为实验性特性引入。</p><p>因此，下面的示例将在没有警告的情况下编译，因为这两个变量具有相同的名称，但是不相交的范围。<b style="color:red">在非0.5.0模式下，它们具有相同的作用域（函数minimalScoping），因此它不会在那里编译。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function minimalScoping() pure public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>作为C99范围规则的一个特殊示例，请注意，在下面的第一个赋值中，<code>x</code>实际上将分配外部变量而不是内部变量。在任何情况下，您都会收到有关外部变量被覆盖的警告。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() pure public returns (uint) &#123;</span><br><span class="line">        uint x = 1;</span><br><span class="line">        &#123;</span><br><span class="line">            x = 2; // this will assign to the outer variable</span><br><span class="line">            uint x;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; // x has value 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="错误处理：Assert-Require-Revert和Exceptions"><a href="#错误处理：Assert-Require-Revert和Exceptions" class="headerlink" title="错误处理：Assert, Require, Revert和Exceptions"></a>错误处理：Assert, Require, Revert和Exceptions</h2><p>Solidity使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。如果条件不满足，便利函数<code>assert</code>和<code>require</code>可以用来检查条件并抛出一个异常。<b style="color:red">该<code>assert</code>函数只能用于测试内部错误并检查不变量</b>。<b style="color:red">该require函数应用于确保有效条件（如输入或合同状态变量），或者验证从外部合约调用返回值</b>。如果使用得当，分析工具可以评估您的合约，以确定将失败的条件和方法调用，这个方法调用通过assert方法快速失败。正确运行的代码不应该达到失败的断言语句; 如果发生这种情况，您应该修复合同中的错误。</p><p>还有两种其他方式可以触发异常：<b style="color:red">该<code>revert</code>方法可用于标记错误并恢复当前的调用。将来还可能在revert调用中包含有关错误的详细信息。该throw关键字也可以用<code>revert()</code>替代。</b></p><p><b style="color:red">注意:从版本0.4.13开始，该throw关键字将被弃用，并将在未来逐步淘汰。</b></p><p><b style="color:#00f">当子调用中发生异常时，它们会自动“冒泡”（即重新排除异常）。这个规则的例外是send和低级函数call，delegatecall以及callcode - false在发生异常而不是“冒泡”的情况下返回。</b></p><p><b style="color:#6ab0de">警告：作为EVM设计的一部分，如果被调用帐户不存在，低级别call，delegatecall和callcode调用将会返回成功。如果需要，必须在调用之前检查是否存在。</b></p><p><b style="color:red">捕捉异常尚不可能。</b></p><p>在以下示例中，您可以看到如何require轻松检查输入条件以及如何使用assert进行内部错误检查：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0); // Only allow even numbers</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);</span><br><span class="line">        // Since transfer throws an exception on failure and</span><br><span class="line">        // cannot call back here, there should be no way for us to</span><br><span class="line">        // still have half of the money.</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一种<code>assert</code>风格的异常在下列情况下产生的：</p><ol><li>如果您访问数组的索引太大或是负数（即x[i] 当<code>i &gt;= x.length</code> 或<code>i &lt; 0</code>）。</li><li>如果您访问固定长度的bytesN索引太大或负数。</li><li>如果除以0或者对0取模。<code>5 / 0</code> 和<code>23 % 0</code></li><li>如果你数字移位的位数是负值。</li><li>如果你将一个太大或负值的值转换为一个枚举类型。</li><li>如果您调用内部函数类型的零初始化变量。</li><li>如果您assert使用评估为false的参数进行调用。</li></ol><p>require风格在以下情况下会生成异常：</p><ol><li>调用throw方法。</li><li>require使用评估为的参数进行调用false。</li><li>如果你调用通过消息调用方法，但它不能正常完成（即用完gas，没有匹配的方法，或抛出一个异常本身），当低层次的操作，除了call，send，delegatecall或callcode使用。低级操作不会抛出异常，但会通过返回false来指示失败。</li><li>如果您使用new关键字创建合约，但合约创建没有正确完成（请参阅上面有关“未正确完成”的定义）。（比如Contract构造方法中使用this）</li><li>如果您针对不包含代码的合约执行外部函数调用。</li><li><b style="color:red">如果您的合约通过一个没有payable修饰符的公共函数（包括构造函数和后备函数）接收Ether 。</b></li><li><b style="color:red">如果你的合同通过公共的getter函数接收Ether。</b></li><li>如果<code>.transfer()</code>调用失败。</li></ol><p><b style="color:#00f">在内部，Solidity对一个require-style异常执行恢复操作（指令<code>0xfd</code>），并执行一个无效操作（指令<code>0xfe</code>）来抛出一个assert-style异常。在这两种情况下，这都会导致EVM恢复对该状态所做的所有更改。恢复的原因是没有安全的方法来继续执行，因为预期的效果没有发生。因为我们想保留交易的原子性，所以最安全的做法是恢复所有更改并使整个交易（或至少是调用）无效</b>。<b style="color:red">请注意，assert样式异常会消耗所有可用于调用的gas，而require风格异常不会消耗Metropolis版本中的任何气体。</b></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity单位和全局可用变量</title>
      <link href="//blockchain/Solidity%E5%8D%95%E4%BD%8D%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E5%8F%98%E9%87%8F.html"/>
      <url>//blockchain/Solidity%E5%8D%95%E4%BD%8D%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E5%8F%98%E9%87%8F.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><h2 id="Ether单位"><a href="#Ether单位" class="headerlink" title="Ether单位"></a>Ether单位</h2><p>字面上的Ether数量可以采取的后缀<code>wei</code>，<code>finney</code>，<code>szabo</code>或<code>ether</code>，没有Ether后缀，货币数字subdenominations之间的转换单位假定是<code>wei</code>，如<code>2 ether == 2000 finney</code>, 这个值为true</p><h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><p>像后缀<code>seconds</code>，<code>minutes</code>，<code>hours</code>，<code>days</code>，<code>weeks</code>和 <code>years</code>文字数字后可以用于时间单位，其中秒是基本单元和单位之间的转换如下：</p><ul><li>1 == 1 seconds</li><li>1 minutes == 60 seconds</li><li>1 hours == 60 minutes</li><li>1 days == 24 hours</li><li>1 weeks == 7 days</li><li><code>1 years == 365 days</code></li></ul><p><b style="color:#00f">请注意，如果您使用这些单位执行日历计算，因为不是每年都等于365天，甚至因为闰秒而不是每天都有24小时。由于闰秒无法预测，因此必须通过外部oracle更新确切的日历库。</b></p><p>这些后缀不能应用于变量(<b style="color:red">因为这些是字面量，solidity引入的新的概念很重要</b>)。如果你想在例如几天内解释一些输入变量，你可以通过以下方式来完成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) &#123;</span><br><span class="line">    if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="特殊变量和函数"><a href="#特殊变量和函数" class="headerlink" title="特殊变量和函数"></a>特殊变量和函数</h2><p><b style="color:red">全局命名空间中总是存在特殊的变量和方法，主要用于提供有关区块链的信息。</b></p><h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性</h3><ul><li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>：给定区块的散列 - 仅适用于256个最新块，不包括当前块</li><li><code>block.coinbase(address)</code>：当前区块矿工的地址</li><li><code>block.difficulty(uint)</code>：当前区块困难</li><li><code>block.gaslimit(uint)</code>：当前区块的gaslimit</li><li><code>block.number(uint)</code>：当前区块的块高</li><li><code>block.timestamp(uint)</code>：当前区块时间戳记，因为unix时期以来的秒数</li><li><code>msg.data(bytes)</code>：完整的calldata</li><li><code>msg.gas(uint)</code>：剩余gas</li><li><code>msg.sender(address)</code>：消息的发送者（当前调用者）</li><li><code>msg.sig(bytes4)</code>：calldata的前四个字节（即函数标识符）</li><li><code>msg.value(uint)</code>：与消息一起发送的wei的数量</li><li><code>now(uint)</code>：当前区块时间戳（别名为block.timestamp）</li><li><code>tx.gasprice(uint)</code>：交易的gas价格</li><li><code>tx.origin(address)</code>：交易的发送者（完整的调用链）</li></ul><p><b style="color:#6ab0de">每个外部函数调用都可以修改msg所有成员的值，包括msg.sender和 msg.value也都可以更改。这包括调用库函数。</b></p><p><b style="color:#6ab0de">不要依赖<code>block.timestamp</code>，<code>now</code>和<code>block.blockhash</code>作为随机的来源，除非你知道自己在做什么。<br>在一定程度上，时间戳和区块哈希都会受到矿工的影响。例如，矿工社区中的不良者可以对选定的散列运行赌场支付功能，如果他们没有收到任何钱，只需重试一次不同的散列。<br>当前块时间戳必须严格大于最后一个块的时间戳，但唯一的保证是它将位于规范链中两个连续块的时间戳之间的某处。</b></p><p><b style="color:#6ab0de">如果要使用库函数实现访问限制 msg.sender，则必须手动提供值 msg.sender作为参数。</b></p><p><b style="color:#6ab0de">出于可伸缩性原因，块哈希不可用于所有块。您只能访问最近256个块的哈希，其他所有值都将为零。</b></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="assert-bool-condition-："><a href="#assert-bool-condition-：" class="headerlink" title="assert(bool condition)："></a><code>assert(bool condition)</code>：</h3><p>如果条件不满足则抛出 - 用于内部错误。</p><h3 id="require-bool-condition-："><a href="#require-bool-condition-：" class="headerlink" title="require(bool condition)："></a><code>require(bool condition)</code>：</h3><p>如果条件未满足则抛出 - 用于输入或外部组件中的错误。</p><h3 id="revert-："><a href="#revert-：" class="headerlink" title="revert()："></a><code>revert()</code>：</h3><p>中止执行并恢复状态更改</p><h2 id="数学和加密函数"><a href="#数学和加密函数" class="headerlink" title="数学和加密函数"></a>数学和加密函数</h2><h3 id="addmod-uint-x-uint-y-uint-k-returns-uint-："><a href="#addmod-uint-x-uint-y-uint-k-returns-uint-：" class="headerlink" title="addmod(uint x, uint y, uint k) returns (uint)："></a><code>addmod(uint x, uint y, uint k) returns (uint)</code>：</h3><p>添加以任意精度执行的时候，计算<code>(x + y) % k</code>，并且不会环绕在<code>2**256</code>。断言<code>k!=0</code>从0.5.0版开始。</p><h3 id="mulmod-uint-x-uint-y-uint-k-returns-uint-："><a href="#mulmod-uint-x-uint-y-uint-k-returns-uint-：" class="headerlink" title="mulmod(uint x, uint y, uint k) returns (uint)："></a><code>mulmod(uint x, uint y, uint k) returns (uint)</code>：</h3><p>在以任意精度执行乘法的时候，计算<code>(x * y) % k</code>，并且不会绕回<code>2**256</code>。断言<code>k!=0</code>从0.5.0版开始。</p><h3 id="keccak256-returns-bytes32-："><a href="#keccak256-returns-bytes32-：" class="headerlink" title="keccak256(...) returns (bytes32)："></a><code>keccak256(...) returns (bytes32)</code>：</h3><p>计算（<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2FiaS1zcGVjLmh0bWwjYWJpLXBhY2tlZC1tb2Rl" title="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-packed-mode">紧密排列的<i class="fa fa-external-link"></i></span>）参数的Ethereum-SHA-3（Keccak-256）散列</p><h3 id="sha256-returns-bytes32-："><a href="#sha256-returns-bytes32-：" class="headerlink" title="sha256(...) returns (bytes32)："></a><code>sha256(...) returns (bytes32)</code>：</h3><p>计算（<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL2FiaS1zcGVjLmh0bWwjYWJpLXBhY2tlZC1tb2Rl" title="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html#abi-packed-mode">紧密排列<i class="fa fa-external-link"></i></span>）参数的SHA-256哈希值</p><h3 id="sha3-…-returns-bytes32-："><a href="#sha3-…-returns-bytes32-：" class="headerlink" title="sha3(…) returns (bytes32)："></a>sha3(…) returns (bytes32)：</h3><p>别名 keccak256</p><h3 id="ripemd160-returns-bytes20-："><a href="#ripemd160-returns-bytes20-：" class="headerlink" title="ripemd160(...) returns (bytes20)："></a><code>ripemd160(...) returns (bytes20)</code>：</h3><p>计算（紧密排列）参数的 RIPEMD-160哈希值</p><h3 id="ecrecover-bytes32-hash-uint8-v-bytes32-r-bytes32-s-returns-address-："><a href="#ecrecover-bytes32-hash-uint8-v-bytes32-r-bytes32-s-returns-address-：" class="headerlink" title="ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)："></a><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code>：</h3><p>从椭圆曲线签名中恢复与公钥相关的地址，或在错误时返回零（<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTc3Ny93b3JrZmxvdy1vbi1zaWduaW5nLWEtc3RyaW5nLXdpdGgtcHJpdmF0ZS1rZXktZm9sbG93ZWQtYnktc2lnbmF0dXJlLXZlcmlmaWNhdGlv" title="https://ethereum.stackexchange.com/questions/1777/workflow-on-signing-a-string-with-private-key-followed-by-signature-verificatio">示例用法<i class="fa fa-external-link"></i></span>）</p><p><b style="color:red">在上面，“紧密排列”意味着这些参数是连续的而没有填充。这意味着以下几点完全相同：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line">keccak256(0x616263)</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)</span><br></pre></td></tr></table></figure><p></p><p>如果需要填充，可以使用显式类型转换：<code>keccak256(&quot;\x00\x12&quot;)</code>与<code>keccak256(uint16(0x12))</code>相同。</p><p>请注意，常量将使用存储它们所需的最小字节数打包。这意味着，例如<code>keccak256(0x12345678) == keccak256(uint32(0x12345678))</code>和<code>keccak256(0) == keccak256(uint8(0))</code>。</p><p><b style="color:red">这可能是因为您在私人区块链上调用sha256，ripemd160或者ecrecover时遇到了Out-of-Gas这种情况。这样做的原因是，这些被作为所谓的预编译的合约执行，这些合约他们收到的第一条消息后（尽管他们的合约代码是硬编码）才真正存在。发送给不存在的合约的消息更加昂贵，因此执行会出现Out-of-Gas错误。解决这个问题的一个解决方法是，先在您的实际合同中使用它们，然后将例如1Wei发送给每个合同。这不是官方或测试网上的问题。</b></p><h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><h3 id="lt-address-gt-balance（uint256）："><a href="#lt-address-gt-balance（uint256）：" class="headerlink" title="&lt;address&gt;.balance（uint256）："></a><code>&lt;address&gt;.balance（uint256）</code>：</h3><p>以wei为单位的地址的余额</p><h3 id="lt-address-gt-transfer-uint256-amount-："><a href="#lt-address-gt-transfer-uint256-amount-：" class="headerlink" title="&lt;address&gt;.transfer(uint256 amount)："></a><code>&lt;address&gt;.transfer(uint256 amount)</code>：</h3><p>给相应地址发送一定数量的以太币（单位wei），<b style="color:red">失败时抛异常，转发2300gas的量，不可调整</b></p><h3 id="lt-address-gt-send-uint256-amount-returns-bool-："><a href="#lt-address-gt-send-uint256-amount-returns-bool-：" class="headerlink" title="&lt;address&gt;.send(uint256 amount) returns (bool)："></a><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>：</h3><p>给相应地址发送一定数量的以太币（单位wei），<b style="color:red">失败返回false，转发2300gas的量，不可调整</b></p><h3 id="lt-address-gt-call-returns-bool-："><a href="#lt-address-gt-call-returns-bool-：" class="headerlink" title="&lt;address&gt;.call(...) returns (bool)："></a><code>&lt;address&gt;.call(...) returns (bool)</code>：</h3><p>发出低级别的CALL，<b style="color:red">失败返回false，转发所有可用的gas，可调节</b></p><h3 id="lt-address-gt-callcode-returns-bool-："><a href="#lt-address-gt-callcode-returns-bool-：" class="headerlink" title="&lt;address&gt;.callcode(...) returns (bool)："></a><code>&lt;address&gt;.callcode(...) returns (bool)</code>：</h3><p>发出低级别的CALLCODE，失败返回false，转发所有可用的gas，可调节</p><h3 id="lt-address-gt-delegatecall-returns-bool-："><a href="#lt-address-gt-delegatecall-returns-bool-：" class="headerlink" title="&lt;address&gt;.delegatecall(...) returns (bool)："></a><code>&lt;address&gt;.delegatecall(...) returns (bool)</code>：</h3><p>发出低级别的DELEGATECALL，失败返回false，转发所有可用的gas，可调节</p><p>欲了解更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi92MC40LjIxL3R5cGVzLmh0bWwjYWRkcmVzcw==" title="https://solidity.readthedocs.io/en/v0.4.21/types.html#address">地址<i class="fa fa-external-link"></i></span>部分。</p><p><b style="color:#6ab0de">使用中存在一些危险<code>send</code>：如果调用堆栈深度为1024（调用程序始终强制执行此操作），则传输将失败，如果发起人耗尽gas，则传输也会失败。因此，为了进行安全的ether传输，请务必检查<code>send</code>的返回值，使用<code>transfer</code>甚至更好：使用接收方提取资金的模式。</b></p><p><b style="color:#6ab0de">callcode不鼓励使用，将来会被删除。</b></p><h2 id="合同相关"><a href="#合同相关" class="headerlink" title="合同相关"></a>合同相关</h2><h3 id="this-（当前合同的类型）："><a href="#this-（当前合同的类型）：" class="headerlink" title="this （当前合同的类型）："></a>this （当前合同的类型）：</h3><p>目前的合同，明确转换为地址</p><h3 id="selfdestruct-address-recipient-："><a href="#selfdestruct-address-recipient-：" class="headerlink" title="selfdestruct(address recipient)："></a>selfdestruct(address recipient)：</h3><p>销毁当前的合同，将资金发送到给定的地址</p><h3 id="suicide-address-recipient-："><a href="#suicide-address-recipient-：" class="headerlink" title="suicide(address recipient)："></a>suicide(address recipient)：</h3><p>别名 selfdestruct</p><p>此外，当前合约的所有功能都可以直接包含当前方法。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidity数据类型说明</title>
      <link href="//blockchain/solidity%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E.html"/>
      <url>//blockchain/solidity%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>最近一直在看区块链的英文文档，看起来很吃力，重点是特别容易遗忘，只能记一个大概比较痛苦，也许写文章是一个比较好的思路，可以强迫自己进行总结思考。但是最近发现写文章吧，很费时，一天也就只能看一篇（面试+项目上的事情很心烦），再加上区块链这样的技术比较新，有很大的概率会出现一些新的概念，导致一些单词不太好翻译（不像java的学习，现在资料满天飞），这给阅读带来极大的障碍。不管怎样还是坚持吧！</p><p>今天来聊聊solidity的类型，网上看过很多资料不是翻译不好就是版本太旧，根本没法看。今天就针对官方的文档总结一下。</p><p><b style="color:red">本文是基于solidity官方文档v0.4.21.</b></p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>solidity是一种静态类型的语言，这意味着每个变量的类型（State和local）在编译时需要被指定。Solidity提供几个基本类型，这些类型可以组合为复杂的类型。</p><p>另外，类型可以在包含运算符的表达式中相互交互。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>下面的都是值类型，这些类型的变量永远是采用值传递。在复制和传给方法时，他们都是采用拷贝的方式。</p><h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><p>bool：只有值true和false</p><h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><p><code>int</code>/<code>uint</code>: 可变长度的有符号和无符号整数。关键字<code>uint8</code>到<code>uint256</code>，步长为8。相对的<code>int8</code>到<code>int256</code>。<code>uint</code>和<code>int</code>是<code>uint256</code>和<code>int256</code>的别名。</p><p>除法总是截断（它只是编译为EVM的DIV操作码），但如果两个操作符都是Literals（或Literals表达式），它就不会截断。</p><p>移位操作的结果是左操作数的类型(意思是y一直在右边，x一直在左边)。表达式<code>x &lt;&lt; y</code>相当于<code>x * 2 ** y</code>，<code>x &gt;&gt; y</code>相当于<code>x / 2 ** y</code>。 这意味着将负数符号转移。按负数移动会引发运行时异常。</p><p><b style="color:red">由有符号整数类型负值的右移产生的结果与其他编程语言产生的结果不同。 在Solidity中，将右侧的地图向右移动，以便移位后的负值将舍入为零（截断）。 在其他编程语言中，负值的右移就像四舍五入的分割（朝向负无穷大）。</b></p><h3 id="固定小数的数字"><a href="#固定小数的数字" class="headerlink" title="固定小数的数字"></a>固定小数的数字</h3><p><b style="color:#00f">固定点数字尚未完全支持。 它们可以被声明，但不能被赋值或被分配。</b></p><p><code>fixed / ufixed</code>：有符号和无符号的各种大小的定点数。 关键词<code>ufixedMxN</code>和<code>fixedMxN</code>，其中M表示类型所占的位数，N表示可用的小数点数。 M必须能被8整除，并从8到256位。 N必须介于0和80之间，包括0和80。 <code>ufixed</code>和<code>fixed</code>分别为<code>ufixed128x19</code>和<code>fixed128x19</code>的别名。</p><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>保存20个字节的值（以太坊地址的大小）。 地址类型也有成员，并作为所有合同的基础。</p><p>操作： <code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code> and <code>&gt;</code></p><p>地址的成员：</p><h4 id="balance-和-transfer"><a href="#balance-和-transfer" class="headerlink" title="balance 和 transfer"></a>balance 和 transfer</h4><p>可以使用balance属性来获取账户余额。通过transfer方法发送以太币。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = 0x123;</span><br><span class="line">address myAddress = this;</span><br><span class="line">if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#6ab0de">如果x是合同地址，则其代码（更具体而言：其fallback方法，如果存在）将与transfer调用一起执行（这是EVM的限制，无法阻止）。 如果执行耗尽gas或以任何方式失败，则以太网币转移将被还原，并且当前合同将以异常停止。</b></p><h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>send是transfer低级别的副本。如果执行失败，当前合同的执行不会以异常的方式停止，但是会返回false；注意send调用深度是1024.</p><h4 id="call-callcode-delegatecall"><a href="#call-callcode-delegatecall" class="headerlink" title="call, callcode, delegatecall"></a>call, callcode, delegatecall</h4><p>此外，对于不符合ABI的合约接口，提供了函数call，它可以接受任意类型、任意数量的参数。 这些参数被填充到32个字节并连接。一个例外是第一个参数被编码为正好四个字节的情况。在这种情况下，它没有被填充以允许在这里使用方法签名。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;</span><br><span class="line">nameReg.call(&quot;register&quot;, &quot;MyName&quot;);</span><br><span class="line">nameReg.call(bytes4(keccak256(&quot;fun(uint256)&quot;)), a);</span><br></pre></td></tr></table></figure><p></p><p>call返回一个布尔值，指示调用的函数是否终止（true）或导致EVM异常（false）。 无法访问返回的实际数据（为此，我们需要事先知道编码和大小）。</p><p>我们可以通过<code>.gas()</code>来调整消耗的gas：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p></p><p>相似的，提供的以太币数量也可以被控制：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p></p><p>最后，这些修饰可以组合使用，循序无所谓的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure><p></p><p>delegatecall可以以相同的方式使用，不同点在于只是使用了给定地址的代码，其他方面（storage、balance，……）都是从当前合约获取。delegatecall的目的是使用其他合约存储的library代码。用户必须确认storage的布局是适合双方合约delegatecall的。从Prior到homestead，只有名为<code>callcode</code>的有限变体可用，它不提供对原始合约<code>msg.sender</code>和<code>msg.value</code>值的访问。</p><p><b style="color:#6ab0de">这三个函数调用，delegatecall和callcode都是非常低级的函数，只能作为最后的手段，因为它们会破坏Solidity的类型安全性。</b></p><p><b style="color:#6ab0de"><code>.gas()</code>操作在这3个方法上都是可用的，<code>.value()方法不能在delegatecall上使用。</code></b></p><p><b style="color:red">所有的合约都继承了address的成员，所以我们可以通过<code>this.balance</code>来获取当前合约的账户余额。</b></p><p>callcode操作已被放弃，将来可能会被移除。</p><p>所有这些功能都是低级功能，应小心使用。具体来说，任何未知的合约都可能是恶意的，如果你要调用它，你将控制权移交给那个可以反过来又回到你的合约中的合约，所以当你的合约call调用返回时，做好改变你的状态变量的准备。</p><h3 id="固定大小的字节数组"><a href="#固定大小的字节数组" class="headerlink" title="固定大小的字节数组"></a>固定大小的字节数组</h3><p><code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, …, <code>bytes32</code>. <code>byte</code> 是 <code>bytes1</code>的别名.</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>比较： &lt;=, &lt;, ==, !=, &gt;=, &gt; (evaluate to bool)</li><li>位操作： &amp;, |, ^ (bitwise exclusive or), ~ (bitwise negation), &lt;&lt; (left shift), &gt;&gt; (right shift)</li><li>索引访问</li></ul><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><ul><li>length：(只读）</li></ul><p><b style="color:#6ab0de"><code>byte[]</code>可能会浪费大量空间，31个字节；当向调用传递参数时，最好使用<code>bytes</code>.</b></p><h3 id="动态大小的byte数组"><a href="#动态大小的byte数组" class="headerlink" title="动态大小的byte数组"></a>动态大小的byte数组</h3><ul><li>bytes: 动态大小字节数据，查看<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL3poL2xhdGVzdC90eXBlcy5odG1sI2FycmF5cw==" title="http://solidity.readthedocs.io/zh/latest/types.html#arrays">Arrays<i class="fa fa-external-link"></i></span>。不是值类型。</li><li>string: 动态大小的UTF-8编码字符串，查看<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL3poL2xhdGVzdC90eXBlcy5odG1sI2FycmF5cw==" title="http://solidity.readthedocs.io/zh/latest/types.html#arrays">Arrays<i class="fa fa-external-link"></i></span>。不是值类型。</li></ul><p>根据经验，对任意长度的原始字节数据使用字节，对任意长度的字符串（UTF-8）数据使用字符串。如果您可以将长度限制为特定数量的字节，则始终使用<code>bytes1</code>到<code>bytes32</code>中的一个，因为它们便宜得多。</p><h3 id="地址文字"><a href="#地址文字" class="headerlink" title="地址文字"></a>地址文字</h3><p>通过地址校验测试的十六进制文字是地址类型，例如<code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>。 长度在39到41位之间且未通过校验和测试的十六进制文字会产生警告，并被视为常规有理数字文字。</p><h3 id="有理数和整数文字"><a href="#有理数和整数文字" class="headerlink" title="有理数和整数文字"></a>有理数和整数文字</h3><p>整数的是0-9的序列组成的，这被解读为数字。例如69. 八进制在solidity中是不存在的，所以前导的0是无效的。</p><p>分数是通过<code>.</code>表示的，左或右至少有一个数字。例如<code>1.</code>,<code>.1</code>,<code>1.3</code>。</p><p>科学记数法也支持，其中基数可以有分数，而指数则不可以。 例子包括<code>2e10</code>，<code>-2e10</code>，<code>2e-10</code>，<code>2.5e1</code>。</p><p>数字文字表达式保持任意精度，直到它们被转换为非文字类型（即通过将它们与非文字表达式一起使用）。 这意味着计算不会溢出，并且不会在数字文字表达式中截断。例如<code>(2**800 + 1) - 2**800</code>导致常量1（类型uint8），尽管中间结果甚至不适合机器字大小。 此外，<code>.5 * 8</code>会导致整数<code>4</code>（<b style="color:red">尽管在它们之间使用了非整数</b>）。</p><p>只要操作数是整数，任何可以应用于整数的运算符也可以应用于数字文字表达式。 如果两者中的任何一个都是小数，则位操作是不允许的，并且如果指数是分数（因为这可能导致非有理数），指数是不允许的。</p><p><b style="color:red">对于每个有理数，Solidity都有一个数字字面类型。</b>整数文字和有理数字文字属于数字文字类型。 此外，所有数字文字表达式（即仅包含数字文字和运算符的表达式）属于数字文字类型。 所以数字文字表达式1 + 2和2 + 1对于有理数3都属于相同的数字文字类型。</p><p><b style="color:#6ab0de">整数除法表达式在早前的版本中是截断的，但是现在将转化为一个有理数，比如<code>5/2</code>不再等于2，二是等于2.5.</b></p><p><b style="color:#00f">数字文字表达式只要与非文字表达式一起使用，就会转换为非文字类型。 尽管我们知道在以下示例中赋值给b的表达式的值计算为整数，但部分表达式2.5 + a没有类型检查，因此代码不会编译.</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint128 a = 1;</span><br><span class="line">uint128 b = 2.5 + a + 0.5;</span><br></pre></td></tr></table></figure><p></p><h3 id="字符串文字"><a href="#字符串文字" class="headerlink" title="字符串文字"></a>字符串文字</h3><p>单引号或者双引号（”foo”或者’bar’）。它不需要像C中尾部放一个0.与整数文字一样，它们的类型可以变化，但如果它们适合字节和字符串，它们可以隐式转换为<code>bytes1</code>，…，<code>bytes32</code>。</p><p>字符串文字也支持转义字符，例如<code>\n</code>, <code>\xNN</code>和<code>\uNNNN</code>。<code>\xNN</code>使用十六进制并插入适当类型。<code>\uNNNN</code>使用Unicode编码，插入以UTF-8序列。</p><h3 id="十六进制文字"><a href="#十六进制文字" class="headerlink" title="十六进制文字"></a>十六进制文字</h3><p>以<code>hex</code>开头并且用单引号或者双引号包裹。它们的内容必须是十六进制字符串，它们的值将是这些值的二进制表示。</p><p>十六进制文字的行为与字符串文字相似，并具有相同的可转换性限制。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是在Solidity中创建用户定义类型的一种方法。 它们可以显式转换为所有整数类型，但是不允许隐式转换。 显式转换检查运行时的值范围，失败会导致异常。 枚举需要至少一个成员。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="方法类型（函数类型）"><a href="#方法类型（函数类型）" class="headerlink" title="方法类型（函数类型）"></a>方法类型（函数类型）</h2><p>函数类型是函数的类型。 函数类型的变量可以从函数中分配，而函数类型的函数参数可以用于将函数传递给函数调用并从函数调用返回函数。 函数类型有两种 - 内部和外部方法：</p><p><b style="color:red">内部函数</b>只能在当前合约内（更具体地说，在当前代码单元内部，它还包含内部库函数和继承函数）内部调用，因为它们不能在当前合约的上下文之外执行。 调用内部函数是通过跳转到其入口标签来实现的，就像在内部调用当前合同的函数一样。</p><p><b style="color:red">外部函数</b>由一个地址和一个函数签名组成，它们可以通过外部函数调用传递并返回。</p><p>函数类型的标注如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure><p></p><p>与参数类型不同，返回类型不能为空 - 如果函数类型不应返回任何内容，则必须省略整个<code>returns (&lt;return types&gt;)</code>部分。</p><p>默认情况下，函数类型是内部的，所以内部关键字可以省略。相比之下，合约函数本身在默认情况下是公共的，只有当用作类型的名称时，默认是内部的。</p><p><b style="color:red">有两种方法可以访问当前合约中的函数：直接使用其名称f或使用this.f.前者将产生内部功能，后者则具有外部功能。</b></p><p>如果函数类型变量未初始化，调用它将导致异常。如果您在使用delete之后调用某个函数，则会发生同样的情况。</p><p>如果外部函数类型在Solidity上下文之外使用，则它们被视为函数类型，它将函数标识符后跟的地址一起编码为单个字节24类型。</p><p>请注意，当前合约的公共方法既可以用作内部函数，也可以用作外部函数。要将f用作内部函数，只需使用f，如果要使用其外部窗体，请使用this.f.</p><p>显示如何使用内部函数类型的示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.5;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另一个使用外部方法类型的示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Lambda和内联函数计划加入，但是现在还不支持。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>复杂类型（即不总是适合256位的类型）必须比我们已经看到的值类型更仔细地处理。 由于复制它们可能相当昂贵，我们必须考虑是否要将它们存储在内存中（不是持久的）或存储器（存储状态变量的地方）。</p><h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h3><p>每种复杂类型（即数组和结构）都有一个额外的注释，即“数据位置”，关于它是存储在内存还是storage中。根据上下文，总是有一个默认值，但可以通过将<code>storage</code>或<code>memory</code>添加到该类型来覆盖它。函数参数（包括返回参数）的默认值是<code>memory</code>，局部变量的默认值是<code>storage</code>，并且对该状态变量（显然）被强制为<code>storage</code>。</p><p>还有第三个数据位置<code>calldata</code>，它是存储函数参数的不可修改的非持久性区域。外部函数的函数参数（不返回参数）被强制为calldata并且行为主要与内存相似。</p><p>数据位置很重要，因为它们会改变分配的行为方式：<code>storage</code>和<code>memory</code>之间的分配以及状态变量（甚至来自其他状态变量）的分配始终会创建独立副本。虽然本地存储变量的赋值只能指定一个引用，并且该引用始终指向状态变量，即使后者在此期间发生更改。另一方面，从内存存储引用类型到另一个内存存储引用类型的分配不会创建副本。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; // the data location of x is storage</span><br><span class="line"></span><br><span class="line">    // the data location of memoryArray is memory</span><br><span class="line">    function f(uint[] memoryArray) &#123;</span><br><span class="line">        x = memoryArray; // works, copies the whole array to storage</span><br><span class="line">        var y = x; // works, assigns a pointer, data location of y is storage</span><br><span class="line">        y[7]; // fine, returns the 8th element</span><br><span class="line">        y.length = 2; // fine, modifies x through y</span><br><span class="line">        delete x; // fine, clears the array, also modifies y</span><br><span class="line">        // The following does not work; it would need to create a new temporary /</span><br><span class="line">        // unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br><span class="line">        // y = memoryArray;</span><br><span class="line">        // This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br><span class="line">        // is no sensible location it could point to.</span><br><span class="line">        // delete y;</span><br><span class="line">        g(x); // calls g, handing over a reference to x</span><br><span class="line">        h(x); // calls h and creates an independent, temporary copy in memory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>强制的数据位置：</p><ul><li>外部函数的参数（不返回）：calldata</li><li>状态变量： storage</li></ul><p>默认的数据位置：</p><ul><li>函数的参数（也返回）：memory</li><li>其他的本地变量： storage</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组可以有编译时固定的大小，也可以是动态的。对于<code>storage</code>数组，元素类型可以是任意的（即其他数组，映射或结构）。对于<code>memory</code>数组，它不能是一个<code>mapping</code>，如果它是一个公共可见函数的参数，则它必须是ABI类型。</p><p>一个固定大小的数组k和元素类型T被写为<code>T[k]</code>，一个动态大小为<code>T[]</code>的数组。举例来说，uint的5个动态数组的数组是<code>uint[][5]</code>（请注意，与其他一些语言相比，符号是反转的）。要访问第三个动态数组中的第二个uint，可以使用<code>x[2][1]</code>（索引是基于零的，<b style="color:red">并且访问以与声明相反的方式工作</b>，即<code>x[2]</code>从类型中删除一个级别正确的）。</p><p>bytes和string的变量是特殊数组。一个bytes与byte[]类似，但是它紧密地包含在<code>calldata</code>中。string等于bytes, 但不允许使用长度或索引访问（现在）。</p><p>所以bytes总是比byte[]更受欢迎，因为它比较便宜。</p><p><b style="color:#6ab0de">如果你想访问字符串<code>s</code>的字节表示，使用<code>bytes(s).length / bytes(s)[7] = &#39;x&#39;;</code>. 请记住，您正在访问UTF-8表示的低级字节，而不是单个字符！</b></p><p>有可能将公开的数组标记并让Solidity创建一个getter。 数字索引将成为getter的必需参数。</p><h4 id="分配内存数组"><a href="#分配内存数组" class="headerlink" title="分配内存数组"></a>分配内存数组</h4><p>在内存中创建具有可变长度的数组可以使用new关键字来完成。与<code>storage</code>数组相反，通过分配给<code>.length</code>成员来调整存储器阵列的大小是不可能的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="数组文字-行内数组"><a href="#数组文字-行内数组" class="headerlink" title="数组文字/行内数组"></a>数组文字/行内数组</h4><p>数组文字是作为表达式写入的数组，并且不会立即分配给变量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] _data) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>数组文本的类型是固定大小的<code>memory</code>数组，其基数类型是给定元素的常见类型。<code>[1,2,3]</code>的类型是<code>uint8[3] memory</code>，因为这些常量中的每一个的类型都是<code>uint8</code>。 因此，有必要将上例中的第一个元素转换为uint。请注意，目前固定大小的<code>memory</code>数组不能分配给动态大小的<code>memory</code>，即以下情况是不可能的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile.</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() &#123;</span><br><span class="line">        // The next line creates a type error because uint[3] memory</span><br><span class="line">        // cannot be converted to uint[] memory.</span><br><span class="line">        uint[] x = [uint(1), 3, 4];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>计划在将来删除此限制，但由于数组在ABI中的传递方式，目前会产生一些复杂性。</p><h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><h5 id="length"><a href="#length" class="headerlink" title="length"></a>length</h5><p>数组有一个<code>length</code>成员来保存元素的数量。 通过更改<code>.length</code>成员，动态数组可以在<code>storage</code>中（不在内存中）调整大小。 尝试访问当前长度以外的元素时，不会自动发生。<code>memory</code>数组的大小一旦被创建就是固定的（但是动态的，即它可以依赖于运行时参数）。</p><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>动态<code>storage</code>数组和bytes（不是字符串）具有一个名为push的成员函数，可用于在数组末尾追加一个元素。 该函数返回新的长度。</p><p><b style="color:#6ab0de">尚不可能在外部函数中使用数组的数组。</b></p><p><b style="color:#6ab0de">由于EVM的限制，无法从外部函数调用返回动态内容。 <code>contract C { function f() returns (uint[]) { ... } }</code>中的函数f将返回从web3.js调用的内容，但不会从Solidity调用。<br>现在唯一的解决方法是使用大型静态大小的数组。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[2**20] m_aLotOfIntegers;</span><br><span class="line">    // Note that the following is not a pair of dynamic arrays but a</span><br><span class="line">    // dynamic array of pairs (i.e. of fixed size arrays of length two).</span><br><span class="line">    bool[2][] m_pairsOfFlags;</span><br><span class="line">    // newPairs is stored in memory - the default for function arguments</span><br><span class="line"></span><br><span class="line">    function setAllFlagPairs(bool[2][] newPairs) &#123;</span><br><span class="line">        // assignment to a storage array replaces the complete array</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFlagPair(uint index, bool flagA, bool flagB) &#123;</span><br><span class="line">        // access to a non-existing index will throw an exception</span><br><span class="line">        m_pairsOfFlags[index][0] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][1] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeFlagArraySize(uint newSize) &#123;</span><br><span class="line">        // if the new size is smaller, removed array elements will be cleared</span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() &#123;</span><br><span class="line">        // these clear the arrays completely</span><br><span class="line">        delete m_pairsOfFlags;</span><br><span class="line">        delete m_aLotOfIntegers;</span><br><span class="line">        // identical effect here</span><br><span class="line">        m_pairsOfFlags.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    function byteArrays(bytes data) &#123;</span><br><span class="line">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class="line">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += 7;</span><br><span class="line">        m_byteData[3] = 8;</span><br><span class="line">        delete m_byteData[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addFlag(bool[2] flag) returns (uint) &#123;</span><br><span class="line">        return m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createMemoryArray(uint size) returns (bytes) &#123;</span><br><span class="line">        // Dynamic memory arrays are created using `new`:</span><br><span class="line">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class="line">        // Create a dynamic byte array:</span><br><span class="line">        bytes memory b = new bytes(200);</span><br><span class="line">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Solidity提供了一种以结构形式定义新类型的方法，如以下示例所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    // Defines a new type with two fields.</span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (uint =&gt; Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    function newCampaign(address beneficiary, uint goal) returns (uint campaignID) &#123;</span><br><span class="line">        campaignID = numCampaigns++; // campaignID is return variable</span><br><span class="line">        // Creates new struct and saves in storage. We leave out the mapping type.</span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute(uint campaignID) payable &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        // Creates a new temporary memory struct, initialised with the given values</span><br><span class="line">        // and copies it over to storage.</span><br><span class="line">        // Note that you can also use Funder(msg.sender, msg.value) to initialise.</span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkGoalReached(uint campaignID) returns (bool reached) &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        if (c.amount &lt; c.fundingGoal)</span><br><span class="line">            return false;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = 0;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>合约没有提供众筹合约的全部功能，但它包含了理解结构所必需的基本概念。 结构类型可以用在映射和数组中，它们本身可以包含映射和数组。</p><p>尽管结构本身可以是映射成员的值类型，但结构不可能包含它自己类型的成员。 这个限制是必要的，因为结构的大小必须是有限的。</p><p>请注意，在所有函数中，结构类型被分配给（缺省存储数据位置的）局部变量。 这不会复制该结构，而只会存储一个引用，以便分配给本地变量的成员实际写入该状态。</p><p>当然，您也可以直接访问结构体的成员，而无需将其分配给本地变量，比如<code>campaigns[campaignID].amount=0</code>。</p><h3 id="映射Mappings"><a href="#映射Mappings" class="headerlink" title="映射Mappings"></a>映射Mappings</h3><p>映射类型被声明为<code>mapping(_KeyType =&gt; _ValueType)</code>。这里<code>_KeyType</code>几乎可以是任何类型，除了映射，动态大小的数组，合约，枚举和结构。 <code>_ValueType</code>实际上可以是任何类型，包括映射。</p><p>映射可以看作散列表，它被虚拟初始化，这样每个可能的键都存在并映射到一个字节表示全为零的值：一个类型的<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL3poL2xhdGVzdC9jb250cm9sLXN0cnVjdHVyZXMuaHRtbCNkZWZhdWx0LXZhbHVl" title="http://solidity.readthedocs.io/zh/latest/control-structures.html#default-value">默认值<i class="fa fa-external-link"></i></span>。但是，相似性在此处结束：关键数据实际上并不存储在映射中，只有其<code>keccak256</code>哈希用于查找值。</p><p>因此，映射没有长度或“设置”键或值的概念。</p><p>映射只能用于状态变量（或作为内部函数中的存储引用类型）。</p><p>有可能将<code>public</code>标记映射并让Solidity创建一个getter。<code>_KeyType</code>将成为getter的必需参数，它将返回<code>_ValueType</code>。</p><p><code>_ValueType</code>也可以是一个映射。 getter将递归地为每个<code>_KeyType</code>使用一个参数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint newBalance) &#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    function f() returns (uint) &#123;</span><br><span class="line">        MappingExample m = new MappingExample();</span><br><span class="line">        m.update(100);</span><br><span class="line">        return m.balances(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>映射不可迭代，但可以在其上实现数据结构。 有关示例，请参阅<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2RhcHAtYmluL2Jsb2IvbWFzdGVyL2xpYnJhcnkvaXRlcmFibGVfbWFwcGluZy5zb2w=" title="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">可迭代映射<i class="fa fa-external-link"></i></span>。</p><h2 id="涉及LValues的操作符"><a href="#涉及LValues的操作符" class="headerlink" title="涉及LValues的操作符"></a>涉及LValues的操作符</h2><p>如果a是一个LValue（即一个变量或可以分配的东西），则以下运算符可用作简写：</p><p><code>a += e</code>相当于<code>a = a + e</code>。 相应地定义运算符 -=，*=，/=，％=，a |=，＆=和^=。 a++和a–相当于 a+= 1 / a -= 1，但表达式本身仍然具有a的前一个值。 相反，–a和++a对a有相同的效果，但在更改后返回值。</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><b style="color:red"><code>delete a</code>将类型的初始值赋给a</b>。即 对于整数而言，它相当于<code>a = 0</code>，但它也可以用于数组，它指定一个长度为零的动态数组或一个长度相同且所有元素都重置的静态数组。 对于结构体，它分配一个所有成员重置的结构体。</p><p>删除对整个映射没有影响（因为映射的键可能是任意的并且通常是未知的）。 所以，如果你删除一个结构体，它将重置所有不是映射的成员，并且还会映射到成员中，除非它们是映射关系。 但是，可以删除个人密钥及其映射的内容。</p><p><b style="color:red">需要注意的是<code>delete a</code>的行为类似于对a的赋值，即它将一个新对象存储在a中。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() &#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        delete x; // sets x to 0, does not affect data</span><br><span class="line">        delete data; // sets data to 0, does not affect x which still holds a copy</span><br><span class="line">        uint[] y = dataArray;</span><br><span class="line">        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also</span><br><span class="line">        // y is affected which is an alias to the storage object</span><br><span class="line">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span><br><span class="line">        // referencing storage objects can only be made from existing storage objects.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h2><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>如果编译器不允许隐式转换，但您知道自己在做什么，则有时可以使用显式类型转换。请注意，这可能会给你一些意想不到的行为，所以一定要测试以确保结果是你想要的！以下面的例子为例，你将一个负数int8转换为uint：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int8 y = -3;</span><br><span class="line">uint x = uint(y);</span><br></pre></td></tr></table></figure><p></p><p>在此代码片段的末尾，x将具有值<code>0xfffff..fd</code>（64个十六进制字符），在256位的二进制补码表示中为<code>-3</code>。</p><p>如果某种类型明确转换为较小类型，则会切断较高位：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = 0x12345678;</span><br><span class="line">uint16 b = uint16(a); // b will be 0x5678 now</span><br></pre></td></tr></table></figure><p></p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>为了方便起见，并不总是需要明确指定变量的类型，编译器会根据分配给变量的第一个表达式的类型自动推断它：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint24 x = 0x123;</span><br><span class="line">var y = x;</span><br></pre></td></tr></table></figure><p></p><p>在这里，类型y将是uint24。var函数参数或返回参数不可用。</p><p><b style="color:#6ab0de">该类型仅从第一个赋值中推导出来，因此以下片段中的循环是无限的，因为i将具有该类型uint8并且该类型的 任何值都小于2000.</b><code>for (var i = 0; i &lt; 2000; i++) { ... }</code>.</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
          <category> solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保护你的智能合约：6个Solidity漏洞以及如何避开它们</title>
      <link href="//blockchain/%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%BD%A0%E7%9A%84%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%9A6%E4%B8%AASolidity%E6%BC%8F%E6%B4%9E%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%BC%80%E5%AE%83%E4%BB%AC.html"/>
      <url>//blockchain/%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%BD%A0%E7%9A%84%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%9A6%E4%B8%AASolidity%E6%BC%8F%E6%B4%9E%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%BC%80%E5%AE%83%E4%BB%AC.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>智能合约是“不可变的”。一旦部署，它们的代码是不能更改的，导致无法修复任何发现的bug。</p><p>在潜在的未来里，整个组织都由智能合约代码管控，对于适当的安全性需求巨大。过去的黑客如TheDAO或去年的Parity黑客（7月、11月）提高了开发者们的警惕，可我们还有很长的路要走。</p><h2 id="范围溢出的问题"><a href="#范围溢出的问题" class="headerlink" title="范围溢出的问题"></a>范围溢出的问题</h2><ol><li>代币中记录用户的代币数量，一旦上溢，就会出现用户代币数归零的现象。</li><li>同样，减号会出现下溢的问题。</li><li>如果溢出出现在循环语句中，那么可能就会出现不进入循环、过早结束循环和无限循环的问题。</li></ol><p>缓解措施：现在使用OpenZeppelin的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9ibG9iL21hc3Rlci9jb250cmFjdHMvbWF0aC9TYWZlTWF0aC5zb2w=" title="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol">SafeMath<i class="fa fa-external-link"></i></span>库已经成为了一个标准。</p><h2 id="可视性-Visibility-和Delegatecall"><a href="#可视性-Visibility-和Delegatecall" class="headerlink" title="可视性(Visibility)和Delegatecall"></a>可视性(Visibility)和Delegatecall</h2><p>对去年7月发生的事有印象的人来说，这个bug就很眼熟，毕竟Parity钱包被黑导致用户损失了3千万美金。</p><p><b style="color:red">Solidity的可视性修改功能和它们的区别:</b></p><ul><li>公共(Public)函数可以被任何人调用（被合约里的函数、继承合约里的函数、或者外面的用户）。</li><li>外部(External)函数只能从外部访问，<b style="color:#00f">意味着它们不能被合约里的其他函数调用</b>。下面的要点不能编译，cannotBeCalled的外部可视性不允许它被合约里的函数调用（但它可以被别的合约调用）。</li></ul><p><b style="color:red">外部函数用起来更便宜因为它使用calldata操作码，而公共函数需要把所有参数复制到内存中</b>，详情请看<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkzODAvZXh0ZXJuYWwtdnMtcHVibGljLWJlc3QtcHJhY3RpY2VzP2Fuc3dlcnRhYj1hY3RpdmUjdGFiLXRvcA==" title="https://ethereum.stackexchange.com/questions/19380/external-vs-public-best-practices?answertab=active#tab-top">这里<i class="fa fa-external-link"></i></span>。</p><p><b style="color:#00f">私有(Private)和内部(Internal)函数更简单：private是只能在该合约里使用，而internal提供了一个更宽松的限制，它允许从母合约处继承的子合约使用那个函数。那就是说，除了需要外部交互的时候，设置你的函数为private或者internal。</b></p><h3 id="Delegatecall"><a href="#Delegatecall" class="headerlink" title="Delegatecall"></a>Delegatecall</h3><p>引述<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL2RldmVsb3AvaW50cm9kdWN0aW9uLXRvLXNtYXJ0LWNvbnRyYWN0cy5odG1sP2hpZ2hsaWdodD1kZWxlZ2F0ZWNhbGwjZGVsZWdhdGVjYWxsLWNhbGxjb2RlLWFuZC1saWJyYXJpZXM=" title="http://solidity.readthedocs.io/en/develop/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries">solidity文件<i class="fa fa-external-link"></i></span>：</p><p><quota>“Delegatecall和信息调用，除了目标地址的代码要在请求调用的合约的上下文中执行之外，是完全一样的。msg.sender和msg.value不改变他们的值。 这意味着合约可以在运行是动态加载来自不同地址的代码。存储、当前地址和余额仍都取决于请求调用的合约，只有代码来自被调用合约。”</quota><b style="color:red">意思就是说将别的合约加入到自己的代码空间执行，但是不会改变别人合约的状态。</b></p><p><b style="color:red">这个低级函数非常有用，因为它是实现库和模块化代码的中坚力量。 然而，它打开了漏洞的大门，因为你的合同基本上允许任何人以他们的状态做任何他们想做的。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">// Credits to OpenZeppelin for this contract taken from the Ethernaut CTF</span><br><span class="line">// https://ethernaut.zeppelin.solutions/level/0x68756ad5e1039e4f3b895cfaa16a3a79a5a73c59</span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function Delegate(address _owner) &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  function Delegation(address _delegateAddress) &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // an attacker can call Delegate.pwn() in the context of Delegation</span><br><span class="line">  // this means that pwn() will modify the state of **Delegation** and not Delegate</span><br><span class="line">  // the result is that the attacker takes unauthorized ownership of the contract</span><br><span class="line">  function() &#123;</span><br><span class="line">    if(delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parity黑客涉及两个不安全的可见性修改功能组合，以及用任意数据滥用delegate调用。易受攻击的合约的函数实现了delegatecall，并且一个来自其他合约，能修改主权的函数被设成公共的。这使得攻击者可以设计msg.data字段来调用易受攻击的函数。</p><p>至于msg.data字段里会包含什么，那会是你想要调用函数的签名。这里的签名指的是函数原型的sha3（keccak256的别名）散列的前8个字节。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In this case:</span><br><span class="line">web3.sha3(&quot;pwn()&quot;).slice(0,10) --&gt; 0xdd365b8b</span><br><span class="line">// If the function takes an argument, pwn(uint256 x):</span><br><span class="line">web3.sha3(&quot;pwn(uint256)&quot;).slice(0,10) --&gt; 0x35f4581b</span><br></pre></td></tr></table></figure><p></p><h2 id="可重入性（The-DAO黑客事件）"><a href="#可重入性（The-DAO黑客事件）" class="headerlink" title="可重入性（The DAO黑客事件）"></a>可重入性（The DAO黑客事件）</h2><p>Solidity的call函数当被带着value调用时，会发送所有它收到的gas。在下面的代码片段中，调用是在实际减少发件人的余额之前完成的。一个在TheDAO黑客事件发生时reddit上的评论很好地解释了这个漏洞：</p><p><b style="color:#00f">简单来说，就好像银行出纳员在她把你所要求的钱全部给你之前，不会更改你的余额。“我能取出500美金吗？等一下，在那之前，我能取出500美金吗？” 等等等等。按照设计的智能合约只会在最开始检查你有500美金，一次，而且允许它们自己被打断。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) public &#123;</span><br><span class="line">  if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">    if(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">      _amount;</span><br><span class="line">    &#125;</span><br><span class="line">    balances[msg.sender] -= _amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如这里所详细描述的，修复方案就是先减少发送人的余额再进行价值转移。对于使用并行编程的人来说，另外一个解决方法就是用互斥锁，从而一起缓解各种竞争条件。</p><p>目前来说，使用require(msg.sender.transfer(_value))是处理这些情况的最好的方法。</p><p>详细的信息也可以查看<span class="exturl" data-url="aHR0cDovL3Zlc3NlbmVzLmNvbS9tb3JlLWV0aGVyZXVtLWF0dGFja3MtcmFjZS10by1lbXB0eS1pcy10aGUtcmVhbC1kZWFsLw==" title="http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/">More Ethereum Attacks: Race-To-Empty is the Real Deal<i class="fa fa-external-link"></i></span></p><p>也可以查看：<span class="exturl" data-url="aHR0cDovL3d3dy5iaWtlamkuY29tL2Rpc2N1c3Npb25zLzQwMjc=" title="http://www.bikeji.com/discussions/4027">DAO攻击简单解释<i class="fa fa-external-link"></i></span></p><h2 id="强行将以太币置入合约"><a href="#强行将以太币置入合约" class="headerlink" title="强行将以太币置入合约"></a>强行将以太币置入合约</h2><p>Solidity的selfdestruct做两件事。(其实就是指删除合约地址)</p><ol><li>它使合约变为不可用，有效地删除该地址的bytecode。</li><li>它把合约的所有资金发送到目标地址。</li></ol><p>这里的一个特殊情况是，如果接收地址是一个合约，那么它的<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi9kZXZlbG9wL3NlY3VyaXR5LWNvbnNpZGVyYXRpb25zLmh0bWwjc2VuZGluZy1hbmQtcmVjZWl2aW5nLWV0aGVy" title="https://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether">fallback函数不会被执行<i class="fa fa-external-link"></i></span>。</p><p>这意味着，如果一个合约的函数有一个依赖于该合约的余额低于一定数额的条件语句，那个语句可能会被绕过:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.4.18;</span><br><span class="line"></span><br><span class="line">contract ForceEther &#123;</span><br><span class="line"></span><br><span class="line">  bool youWin = false;</span><br><span class="line"></span><br><span class="line">  function onlyNonZeroBalance() &#123;</span><br><span class="line">      require(this.balance &gt; 0); </span><br><span class="line">      youWin = true;</span><br><span class="line">  &#125;</span><br><span class="line">  // throw if any ether is received</span><br><span class="line">  function() payable &#123;</span><br><span class="line">    revert();</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于那个没有的fallback函数，通常该合约无法收到以太币。<b style="color:red">但是，如果一个合约以这个合约为目标自毁，后退函数则不会被调用</b>。结果this.balance变得大于0，所以攻击者就可以在onlyNonZeroBalance里绕过require语句。</p><p><b style="color:red">缓解措施：永远不要用一个合约的余额作守卫。</b></p><h2 id="调用未知（DoS意外还原）"><a href="#调用未知（DoS意外还原）" class="headerlink" title="调用未知（DoS意外还原）"></a>调用未知（DoS意外还原）</h2><p>这个漏洞出现了在<span class="exturl" data-url="aHR0cHM6Ly93d3cua2luZ29mdGhlZXRoZXIuY29tLw==" title="https://www.kingoftheether.com/">King of Ether<i class="fa fa-external-link"></i></span>智能合约中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract CallToTheUnknown &#123;</span><br><span class="line">  // Highest bidder becomes the Leader. </span><br><span class="line">  // Vulnerable to DoS attack by an attacker contract which reverts all transactions to it.</span><br><span class="line"></span><br><span class="line">    address currentLeader;</span><br><span class="line">    uint highestBid;</span><br><span class="line"></span><br><span class="line">    function() payable &#123;</span><br><span class="line">        require(msg.value &gt; highestBid);</span><br><span class="line">        require(currentLeader.send(highestBid)); // Refund the old leader, if it fails then revert</span><br><span class="line">        currentLeader = msg.sender;</span><br><span class="line">        highestBid = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pwn &#123;</span><br><span class="line">  // call become leader </span><br><span class="line">  function becomeLeader(address _address, uint bidAmount) &#123;</span><br><span class="line">    _address.call.value(bidAmount);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  // reverts anytime it receives ether, thus cancelling out the change of the leader</span><br><span class="line">  function() payable &#123;</span><br><span class="line">    revert();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，攻击者的合约可以先通过向不安全的合约发送足够的以太成为主导。然后，另一个试图成为主导的玩家的交易将由于上面片段中的第25行(revert();)被抛出。虽然是一次简单的攻击，但这会导致合约永久性地拒绝服务，导致合约无效。这可以在遵循相同模式的其他庞式骗局合约中找到。</p><h2 id="短地址攻击"><a href="#短地址攻击" class="headerlink" title="短地址攻击"></a>短地址攻击</h2><p>这种攻击是由Golem团队发现的，详情请看<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdvbGVtcHJvamVjdC5uZXQvaG93LXRvLWZpbmQtMTBtLWJ5LWp1c3QtcmVhZGluZy1ibG9ja2NoYWluLTZhZTlkMzlmY2Q5NQ==" title="https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95">这篇文章<i class="fa fa-external-link"></i></span>。这个漏洞允许攻击者滥用transfer函数并取出比他被准许的更多的ERC20代币。</p><p>注意：为了简单起见，我们会用正常一半大小的文字。</p><p>为了解释这个bug，让我们假设一个钱包里有10000个代币的交易所，和一个在那个交易所钱包里有32个代币余额的用户。让我们再假设这个用户的地址是0x12345600（注意尾部的零）而且他们想要取出比自己余额大的数额。他们就会去交易所，点击代币的取出按钮，<b style="color:#00f">然后输入他们的地址但去掉尾部的零（交易所不验证输入的信息然后允许交易通过，即使攻击者的地址长度是无效的）</b>。</p><p>接着，EVM通过连接函数的签名和参数来计算输入的数据以便交易被执行。</p><p>ERC20的转送函数写为transfer(address to, uint256 amount)。那3个字段如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sig : a9059cbb = web3.sha3(&quot;transfer(address,uint256)&quot;).slice(0,10)</span><br><span class="line">arg1: 123456   = receiving address</span><br><span class="line">arg2: 00000020  = 32 in hexademical (0x20)</span><br><span class="line">----------------------------------------</span><br><span class="line">Concatenated: a9059cbb 123456 00000020</span><br><span class="line">Transaction input data: 0xa9059cbb12345600000020</span><br></pre></td></tr></table></figure><p></p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>仔细观察，交易的长度是2个字节（在现实世界中全字4个字节）。<b style="color:red">在这种情况下，EVM将会为交易补上尾部的零</b>， 变成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xa9059cbb1234560000002000</span><br><span class="line">// a9059cbb = web3.sha3(&quot;transfer(address,uint256)&quot;).slice(0,10)</span><br><span class="line">// 12345600   = receiving address</span><br><span class="line">// 00002000  = 8192 in hexademical (0x2000 == 0x20&lt;&lt;8)</span><br></pre></td></tr></table></figure><p></p><p>这样一来，即使攻击者在交易所中的余额是32个代币，他们也能执行一个数额大得多的、合法的转移。这当然是在发送账户（交易所的钱包）拥有足够的转账余额的基础上。</p><p><b style="color:red">缓解措施：</b></p><ol><li>如果msg.data的大小无效，抛出</li><li>交易所必须对输入信息进行验证</li></ol><h2 id="额外红利"><a href="#额外红利" class="headerlink" title="额外红利"></a>额外红利</h2><p>避免在你的商业逻辑中使用now和block.blockhash，因为他们的结果是可预测的，或者会被矿工操控。想了解更多，请看<span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy93d3cucmVkZGl0LmNvbS9yL2V0aGVyZXVtL2NvbW1lbnRzLzQ4M3JyMS9kb19ub3RfdXNlX2Jsb2NrX2hhc2hfYXNfc291cmNlX29mX3JhbmRvbW5lc3Mv" title="https://link.zhihu.com/?target=https%3A//www.reddit.com/r/ethereum/comments/483rr1/do_not_use_block_hash_as_source_of_randomness/">这里<i class="fa fa-external-link"></i></span>。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="我能做些什么来保护我的智能合约呢"><a href="#我能做些什么来保护我的智能合约呢" class="headerlink" title="我能做些什么来保护我的智能合约呢"></a>我能做些什么来保护我的智能合约呢</h3><p>这在很多地方都有提到，我个人最喜欢的在<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9vbndhcmQtd2l0aC1ldGhlcmV1bS1zbWFydC1jb250cmFjdC1zZWN1cml0eS05N2E4MjdlNDc3MDI=" title="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702">这里<i class="fa fa-external-link"></i></span>。</p><p>其中，我最重要的选择是：</p><ol><li>别写华丽的代码</li><li>使用审计和测试过的代码</li><li>写尽可能多的单元测试</li></ol><h3 id="我能用什么工具来审计和分析我的代码呢？"><a href="#我能用什么工具来审计和分析我的代码呢？" class="headerlink" title="我能用什么工具来审计和分析我的代码呢？"></a>我能用什么工具来审计和分析我的代码呢？</h3><p>首先，solc执行语义检查是走向安全性的一大步，因为编译时可能会发现潜在的错误。</p><ol><li><span class="exturl" data-url="aHR0cDovL3NlY3VyaWZ5LmNoLw==" title="http://securify.ch/">Securify.ch<i class="fa fa-external-link"></i></span>是一个为了智能合约的静态分析工具</li><li><span class="exturl" data-url="aHR0cDovL3JlbWl4LmV0aGVyZXVtLm9yZy8=" title="http://remix.ethereum.org/">Remix<i class="fa fa-external-link"></i></span>也对你的代码静态分析，并能够发现如未初始化的存储指针和重入的错误</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lbG9ucHJvamVjdC9veWVudGU=" title="https://github.com/melonproject/oyente">Oyente<i class="fa fa-external-link"></i></span>是另一个最近发布的智能合约分析工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0lDM0h5ZHJhL0h5ZHJh" title="https://github.com/IC3Hydra/Hydra">Hydra<i class="fa fa-external-link"></i></span>是一个“为了加密经济合约安全性的框架，去中心化安全奖励”</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbWFlaW8vcG9yb3NpdHk=" title="https://github.com/comaeio/porosity">Porosity<i class="fa fa-external-link"></i></span>是一个“基于区块链以太坊智能合约的反编译器”</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RyYWlsb2ZiaXRzL21hbnRpY29yZS8=" title="https://github.com/trailofbits/manticore/">Manticore<i class="fa fa-external-link"></i></span>是一款带EVM支持的动态二进制分析工具</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RyYWlsb2ZiaXRzL2V0aGVyc3BsYXk=" title="https://github.com/trailofbits/ethersplay">Ethersplay<i class="fa fa-external-link"></i></span>是一个EVM的<span class="exturl" data-url="aHR0cHM6Ly9iaW5hcnkubmluamEv" title="https://binary.ninja/">Binary Ninja<i class="fa fa-external-link"></i></span>插件</li></ol><p>最后，通过使用如solgraph之类的工具来图像化你的代码，可以帮助你发现关于函数可见性的潜在bug。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhaW5lb3JzaGluZS9zb2xncmFwaA==" title="https://github.com/raineorshine/solgraph">https://github.com/raineorshine/solgraph<i class="fa fa-external-link"></i></span></p><p>要更深入地了解对智能合约的攻击，请参阅：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0B3ZWthL2Fubm91bmNpbmctdGhlLXdpbm5lcnMtb2YtdGhlLWZpcnN0LXVuZGVyaGFuZGVkLXNvbGlkaXR5LWNvZGluZy1jb250ZXN0LTI4MjU2M2E4NzA3OQ==" title="https://medium.com/@weka/announcing-the-winners-of-the-first-underhanded-solidity-coding-contest-282563a87079">The Underhanded Solidity Contest<i class="fa fa-external-link"></i></span> [<span class="exturl" data-url="aHR0cDovL3Uuc29saWRpdHkuY2Mv" title="http://u.solidity.cc/">1<i class="fa fa-external-link"></i></span>,<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyYWNobmlkL3VzY2MvdHJlZS9tYXN0ZXIvc3VibWlzc2lvbnMtMjAxNw==" title="https://github.com/Arachnid/uscc/tree/master/submissions-2017">2<i class="fa fa-external-link"></i></span>,<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BjaHJpc2V0aC9sZXNzb25zLWxlYXJudC1mcm9tLXRoZS11bmRlcmhhbmRlZC1zb2xpZGl0eS1jb250ZXN0LTgzODg5NjBlMDliMQ==" title="https://medium.com/@chriseth/lessons-learnt-from-the-underhanded-solidity-contest-8388960e09b1">3<i class="fa fa-external-link"></i></span>]</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RyYWlsb2ZiaXRzL25vdC1zby1zbWFydC1jb250cmFjdHMvaXNzdWVz" title="https://github.com/trailofbits/not-so-smart-contracts/issues">Trailofbits/not-so-smart-contracts<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNi8xMDA3LnBkZg==" title="https://eprint.iacr.org/2016/1007.pdf">A survey of attacks on Ethereum Smart Contracts<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb25zZW5zeXMuZ2l0aHViLmlvL3NtYXJ0LWNvbnRyYWN0LWJlc3QtcHJhY3RpY2VzL2tub3duX2F0dGFja3M=" title="https://consensys.github.io/smart-contract-best-practices/known_attacks">Smart contract best practices — Known attacks<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9vbndhcmQtd2l0aC1ldGhlcmV1bS1zbWFydC1jb250cmFjdC1zZWN1cml0eS05N2E4MjdlNDc3MDI=" title="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702">Onward with Smart Contract Security<i class="fa fa-external-link"></i></span></li></ul><p>你可以练习你的智能合约黑客技巧在：<br><span class="exturl" data-url="aHR0cDovL2V0aGVybmF1dC56ZXBwZWxpbi5zb2x1dGlvbnMv" title="http://ethernaut.zeppelin.solutions/">Ethernaut<i class="fa fa-external-link"></i></span>（需要ropsten testnet帐户）<br><span class="exturl" data-url="aHR0cDovL2hhY2t0aGlzY29udHJhY3QuaW8v" title="http://hackthiscontract.io/">HackThisContract<i class="fa fa-external-link"></i></span>（需要rinkeby testnet帐户</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vbG9vbW5ldHdvcms=" title="https://zhuanlan.zhihu.com/loomnetwork">以太坊区块链的可扩展性<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BnYWtvbnN0" title="https://medium.com/@gakonst">Georgios Konstantopoulos<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2xvb20tbmV0d29yay9ob3ctdG8tc2VjdXJlLXlvdXItc21hcnQtY29udHJhY3RzLTYtc29saWRpdHktdnVsbmVyYWJpbGl0aWVzLWFuZC1ob3ctdG8tYXZvaWQtdGhlbS1wYXJ0LTEtYzMzMDQ4ZDRkMTdk" title="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d">How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1)<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2xvb20tbmV0d29yay9ob3ctdG8tc2VjdXJlLXlvdXItc21hcnQtY29udHJhY3RzLTYtc29saWRpdHktdnVsbmVyYWJpbGl0aWVzLWFuZC1ob3ctdG8tYXZvaWQtdGhlbS1wYXJ0LTItNzMwZGIwYWE0ODM0" title="https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834">How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 2)<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIP-141 隔离见证</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-141-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-141-%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p><b style="color:red">这个BIP定义了一个称为“见证”的新结构，它承诺与交易处理树分开的块</b>。该结构包含检查交易有效性所需的数据，但不需要确定交易影响。特别是，脚本和签名被移到这个新的结构中。</p><p><b style="color:red">目击者是通过coinbase交易嵌入到块的现有merkle根目录中的树，以使BIP软叉兼容</b>。未来的硬分叉可以将这棵树放在它自己的分支中。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>整个交易的效果由输出消费（花费）和新输出创造决定。<b style="color:red">其他交易数据，特别是签名仅用于验证区块链状态，而不是确定区块链状态。</b></p><p>通过从交易结构中删除这些数据，这些数据被提交给交易处理树，几个问题得到解决：</p><ul><li><b>无意的延展性变得不可能。</b>由于签名数据不再是交易散列的一部分，因此交易签名方式的变化不再与交易标识相关。<b style="color:#00f">作为交易可延展性的解决方案，这比典型签名方法（BIP62）要优越：</b><ul><li>它可以防止任何类型脚本的非自愿交易可塑性，只要所有输入都被签名（至少使用一次CHECKSIG或CHECKMULTISIG操作）</li><li>如果是m-n CHECKMULTISIG脚本，只有经过m个私钥持有者的同意才能进行交易（相对于只有1个拥有BIP62的私钥持有者）（<b style="color:red">注：隔离见证是需要比特币协议的支持的</b>）</li><li>它防止由于未知的ECDSA签名延展性而导致的非自愿交易延展性(<b style="color:red">我觉得应该是指scriptSig不签名而导致的问题</b>)</li><li><b style="color:red">它允许创建未经证实的交易依赖链而没有交易对手风险，这是离线协议的重要特征，如Lightning Network.</b></li></ul></li><li><b>签名数据的传输变为可选</b>。仅当对等方试图验证事务而不是仅仅检查其存在时才需要它。这样可以减少SPV证明的大小，并有可能提高SPV客户端的隐私，因为他们可以使用相同的带宽下载更多的事务。</li><li>通过将一部分交易数据移动到当前协议未知的结构中，可以通过软分支绕过某些约束，例如：<ul><li>在计算块大小时，见证的大小可以忽略/打折，在一定程度上有效地增加块大小</li><li>可以重新评估或删除硬编码常量，例如最大数据推送大小（520字节）或信号限制</li><li>可以引入新的脚本系统，而不受现有脚本语义的任何限制。例如，在BIP143中描述了用于交易签名验证的新的交易摘要算法</li></ul></li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="交易ID"><a href="#交易ID" class="headerlink" title="交易ID"></a>交易ID</h3><p><b style="color:red">一个新的数据结构witness被定义。每笔交易将有2个ID。</b></p><p>定义txid保持不变：传统序列化格式的双SHA256：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[nVersion] [txins] [txouts] [nLockTime]</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">wtxid定义了一个新的：具有目击者数据的新序列化的双SHA256：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[nVersion] [marker] [flag] [txins] [txouts] [witness] [nLockTime]</span><br></pre></td></tr></table></figure><p></p><ul><li>nVersion，txins，txouts和nLockTime的格式是像传统的序列化。</li><li>marker必须是一个1字节的零值：0x00。</li><li>flag必须是1个字节的非零值。目前，必须使用0x01。</li><li><b style="color:red">witness是交易的所有见证数据的序列化。每个txin都与witness字段相关联。witness字段以var_int开始，以指示txin的堆栈项目的数目。随后是堆栈项目，每个项目以var_int开头以指示长度。见证数据不是脚本。</b></li></ul><p>非见证人程序（定义于下文）txin必须与空的见证字段相关联，使用0x00表示。如果所有的txins都不是witness程序，交易wtxid就等于它的交易txid。</p><h3 id="承诺结构"><a href="#承诺结构" class="headerlink" title="承诺结构"></a>承诺结构</h3><p>添加了一个新的区块规则，它需要对wtxid做出承诺（翻译是这样意思不太懂，也许是指要有wtxid字段吧）。coinbase交易的wtxid被认为是0x0000….0000。</p><p><b style="color:red">witness根hash</b>的计算方法与所有wtxid叶子一样，以类似于hashMerkleRoot块头中的方式计算。（其实就是与交易的默克尔树是一样的。）</p><p><b style="color:red">该承诺记录在coinbase交易的scriptPubKey中。它必须至少有38个字节，其中前6个字节0x6a24aa21a9ed是：</b></p><ul><li>1个字节 - OP_RETURN（0x6a）</li><li>1字节 - 推送以下36个字节（0x24）</li><li>4字节 - 承诺（Commitment）头（0xaa21a9ed）</li><li>32字节 - 承诺哈希：Double-SHA256（见证根哈希|见证保留值）</li><li><b style="color:#00f">第39个字节向前：可选数据，没有共识意义</b></li></ul><p>并且coinbase的输入见证必须由一个32字节的数组组成<code>witness reserved value</code>。</p><p><b style="color:red">如果有多个scriptPubKey匹配的模式，那么具有最高输出的索引的scriptPubKey被假定为承诺（commitment）。</b></p><p><b style="color:#00f">如果块中的所有交易都没有见证数据，则该承诺（commitment）是可选的。</b></p><h3 id="见证程序（就是脚本啦）"><a href="#见证程序（就是脚本啦）" class="headerlink" title="见证程序（就是脚本啦）"></a>见证程序（就是脚本啦）</h3><p>由1字节推送(push)操作码（0至16）组成的scriptPubKey（或redeemScript如BIP16/P2SH中定义的），然后是2至40字节之间的数据推送，具有新的特殊含义。第一次推送的值被称为“版本字节”。下面推送的字节向量称为“见证程序”。（这个意思就是指NVersion + Script序列化后的数据吧！）</p><p><b style="color:red">witness验证逻辑被触发有两种情况。每种情况都决定了witness版本字节和程序的位置，以及scriptSig的形式：</b></p><ol><li>触发scriptPubKey一个版本字节，再加上一个witness程序。scriptSig必须完全为空或验证失败。（“本地witness程序”）</li><li><b style="color:#00f">当scriptPubKey是P2SH脚本时被触发，并且redeemScript推入的BIP16 scriptSig恰好是推送版本字节加推送见证程序</b>。在scriptSig必须是完全的BIP-16的redeemScript或验证失败。（“P2SH witness程序”）</li></ol><p><b style="color:#00f">如果版本字节是0，见证程序是20字节：</b></p><ul><li>它被解释为<code>pay-to-witness-public-key-hash</code>（P2WPKH）程序。</li><li><b style="color:red">witness必须包含2个项目（每个≤520个字节）。第一个是签名，第二个是公钥。</b></li><li>公钥的HASH160必须与20字节的见证程序相匹配。(不知这条的作用是啥，但是感觉很有用的样子)</li><li>在正常的脚本评估之后，使用CHECKSIG操作对照公钥验证签名。验证必须在堆栈上导致一个TRUE。</li></ul><p><b style="color:#00f">如果版本字节为0（版本为0代表什么意思呢），见证程序为32字节：</b></p><ul><li>它被解释为pay-to-witness-script-hash（P2WSH）程序。</li><li>witness必须包含一个输入堆栈以供给脚本，然后是序列化脚本（witnessScript）。</li><li>witnessScript（≤10,000字节）从初始witness堆栈弹出。witnessScript的SHA256加密必须与32字节的见证程序相匹配。</li><li>witnessScript是反序列化的，并且在对其余见证堆栈（对于每个堆栈项≤520字节）的正常脚本评估之后执行。</li><li>该脚本不能失败，并且在堆栈中导致完全一个TRUE。</li></ul><p><b style="color:Red">如果版本字节为0，但见证程序既不是20也不是32字节，则脚本必须失败。</b><br><b style="color:Red">如果版本字节为1到16，则不会再有对witness程序或witness堆栈的进一步解释，并且证人堆栈没有大小限制。这些版本保留给未来的扩展.</b></p><h3 id="其他共识关键限制"><a href="#其他共识关键限制" class="headerlink" title="其他共识关键限制"></a>其他共识关键限制</h3><h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>目前块的总大小限制为1,000,000字节（1MB）。我们改变这个限制如下：</p><p>块重量定义为基本大小 * 3 + 总尺寸。</p><p>基本大小是原始交易序列化时的块大小（以字节为单位），没有任何见证相关数据，如未升级的节点所示。</p><p>总大小是按BIP144所述序列化交易的块大小（以字节为单位），包括基本数据和见证数据。</p><p>新规则是块重 ≤4,000,000。</p><h4 id="SIGOPS"><a href="#SIGOPS" class="headerlink" title="SIGOPS"></a>SIGOPS</h4><p>每块的信息量目前仅限于20,000个。我们改变这个限制如下：</p><p>当前pubkey脚本，签名脚本和P2SH检查脚本中的Sigops的计数是其先前值的4倍。sigop限制同样翻两番，达到80,000。</p><p>每个P2WPKH输入都被计为1 sigop。另外，P2WSH内的操作码witnessScript与先前在P2SH内的操作码相同redeemScript。也就是说，CHECKSIG被认为只有1个sigop，根据参数CHECKMULTISIG被计为1到20个sigops。该规则适用于本地证人计划和P2SH证人计划。</p><h3 id="附加定义"><a href="#附加定义" class="headerlink" title="附加定义"></a>附加定义</h3><p>以下定义不用于达成共识限制，但建议提供符合上述术语的语言。</p><h4 id="事务大小计算"><a href="#事务大小计算" class="headerlink" title="事务大小计算"></a>事务大小计算</h4><p>交易权重定义为基本交易规模 * 3 + 总交易规模（即与从基本规模和总规模计算分块权重相同的方法）。</p><p>虚拟交易大小定义为交易权重/4（四舍五入到下一个整数）。</p><p>基本交易大小是剥离见证数据的序列化交易的大小。</p><p>总交易大小是按BIP144中所述序列化的交易大小（以字节为单位），包括基本数据和见证数据。</p><h4 id="新的脚本语义"><a href="#新的脚本语义" class="headerlink" title="新的脚本语义"></a>新的脚本语义</h4><p>尽管P2WPKH和P2WSH的脚本语言看起来与预先隔离的witness脚本非常相似，但有几处显着的差异。用户不得假定在预先隔离的witness系统中花费的脚本也可以用作P2WPKH或P2WSH脚本。在生产网络中进行大规模部署之前，开发人员应该在testnet上测试脚本，并启用默认的中继策略，并在主网络上激活BIP141之后用少量资金进行测试。</p><p>在BIP143中描述了共识级别的一个主要区别，即作为0版见证程序中用于签名验证的新的交易摘要算法。</p><p>在参考实施版本0.13.1的第​​一版隔离见证中还包括三项接力和采矿政策。基于这些政策的软分叉很可能会在不久的将来提出。为了避免无限期延迟交易确认和永久性资金损失，用户必须仔细观察新的语义：</p><ul><li>在P2WPKH和P2WSH中只接受压缩的公钥（见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0My5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP143<i class="fa fa-external-link"></i></span>）</li><li>P2WSH中OP_IF/NOTIF的参数必须最小</li><li>如果OP_CHECKSIG或OP_CHECKMULTISIG失败（对于预先隔离的证人脚本和P2WSH，则签名必须为空矢量（参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0Ni5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki">BIP146<i class="fa fa-external-link"></i></span>）</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="P2WPKH"><a href="#P2WPKH" class="headerlink" title="P2WPKH"></a>P2WPKH</h3><p>以下示例是版本0的pay-to-witness-public-key-hash（P2WPKH）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">witness:      &lt;signature&gt; &lt;pubkey&gt;</span><br><span class="line">scriptSig:    (empty)</span><br><span class="line">scriptPubKey: 0 &lt;20-byte-key-hash&gt;</span><br><span class="line">                (0x0014&#123;20-byte-key-hash&#125;)</span><br></pre></td></tr></table></figure><p></p><p>scriptPubKey中的’0’表示以下推送是版本0见证程序。见证计划的长度表明它是一种P2WPKH类型。证人必须包含2件物品。witness中公钥的HASH160必须与witness程序相匹配。</p><p>签名被验证为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;signature&gt; &lt;pubkey&gt; CHECKSIG</span><br></pre></td></tr></table></figure><p></p><p>&lt;b style=””color:red&gt;与传统P2PKH输出相比，P2WPKH等价物在scriptPubKey中占用3个字节，并将签名和公钥从ScriptSig移动到见证。(找到数据应该是通过wtxid)</p><h3 id="P2WPKH嵌套在BIP16-P2SH中"><a href="#P2WPKH嵌套在BIP16-P2SH中" class="headerlink" title="P2WPKH嵌套在BIP16 P2SH中"></a>P2WPKH嵌套在BIP16 P2SH中</h3><p>以下示例与P2WPKH相同，但嵌套在BIP16 P2SH输出中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">witness:      &lt;signature&gt; &lt;pubkey&gt;</span><br><span class="line">scriptSig:    &lt;0 &lt;20-byte-key-hash&gt;&gt;</span><br><span class="line">                (0x160014&#123;20-byte-key-hash&#125;)</span><br><span class="line">scriptPubKey: HASH160 &lt;20-byte-script-hash&gt; EQUAL</span><br><span class="line">                (0xA914&#123;20-byte-script-hash&#125;87)</span><br></pre></td></tr></table></figure><p></p><p>scriptSig中的唯一项目与HASH160进行哈希处理，与scriptPubKey中的20字节脚本哈希进行比较，并解释为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;20-byte-key-hash&gt;</span><br></pre></td></tr></table></figure><p></p><p>然后按照前面例子中的描述验证公钥和签名。</p><p>与前面的例子相比，scriptPubKey大1个字节，scriptSig大23个字节。尽管嵌套见证程序的效率较低，但对于自0.6.0版本以来的所有比特币参考客户端，其支付地址都是完全透明且向后兼容的。</p><h3 id="P2WSH"><a href="#P2WSH" class="headerlink" title="P2WSH"></a>P2WSH</h3><p>以下示例是1-of-2多重签名版本0付钱证人脚本哈希（P2WSH）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">witness:      0 &lt;signature1&gt; &lt;1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG&gt;</span><br><span class="line">scriptSig:    (empty)</span><br><span class="line">scriptPubKey: 0 &lt;32-byte-hash&gt;</span><br><span class="line">                (0x0020&#123;32-byte-hash&#125;)</span><br></pre></td></tr></table></figure><p></p><p>scriptPubKey中的’0’表示以下推送是版本0见证程序。见证程序的长度表明它是一个P2WSH类型。证人中的最后一项（“witnessScript”）被弹出，用SHA256散列，与scriptPubKey中的32字节散列相比较，并反序列化：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG</span><br></pre></td></tr></table></figure><p></p><p>该脚本使用来自witness的其余数据执行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;signature1&gt; 1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG</span><br></pre></td></tr></table></figure><p></p><p>P2WSH允许10,000字节的最大脚本大小，因为520字节的推动限制被绕过。</p><p>scriptPubKey占用34个字节，而不是23个字节的BIP16 P2SH。大小的增加提高了可能发生的碰撞攻击的安全性，因为2<sup>80</sup>工作不再可行（截至2015年底，自比特币创建以来，已有2<sup>84</sup>次哈希计算在比特币挖矿中）。<b style="color:red">支出脚本与等效的BIP16 P2SH输出相同，但被移至见证。</b></p><h3 id="P2WSH嵌套在BIP16-P2SH中"><a href="#P2WSH嵌套在BIP16-P2SH中" class="headerlink" title="P2WSH嵌套在BIP16 P2SH中"></a>P2WSH嵌套在BIP16 P2SH中</h3><p>以下示例是相同的1对2多重签名P2WSH脚本，但嵌套在BIP16 P2SH输出中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">witness:      0 &lt;signature1&gt; &lt;1 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIG&gt;</span><br><span class="line">scriptSig:    &lt;0 &lt;32-byte-hash&gt;&gt;</span><br><span class="line">                (0x220020&#123;32-byte-hash&#125;)</span><br><span class="line">scriptPubKey: HASH160 &lt;20-byte-hash&gt; EQUAL</span><br><span class="line">                (0xA914&#123;20-byte-hash&#125;87)</span><br></pre></td></tr></table></figure><p></p><p>scriptSig中的唯一项目与HASH160进行哈希处理，与scriptPubKey中的20字节哈希进行比较，并解释为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;32-byte-hash&gt;</span><br></pre></td></tr></table></figure><p></p><p>P2WSH witnessScript然后按照前面例子中的描述执行。</p><p>与前面的例子相比，scriptPubKey小11个字节（安全性降低），而证人是相同的。但是，它也需要scriptSig中的35个字节。</p><h3 id="可扩展的承诺结构"><a href="#可扩展的承诺结构" class="headerlink" title="可扩展的承诺结构"></a>可扩展的承诺结构</h3><p>在coinbase交易的新承诺是witness root hash和witness reserved value的hash。在witness reserved value目前还没有达成共识的意义，但是将来会为未来的softforks允许新的承诺值。例如，如果未来需要一项新的共识批评（consensus-critical）承诺，则基础承诺将变为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double-SHA256(Witness root hash|Hash(new commitment|witness reserved value))</span><br></pre></td></tr></table></figure><p></p><p>为了向后兼容，Hash(new commitment|witness reserved value)将会转到coinbase见证，并且witness reserved value将被记录在将来的softfork指定的另一个位置。可以通过这种方式添加任何数量的新承诺。</p><p>对比特币没有共识至关重要性的任何承诺，例如合并挖掘，都不得使用该功能witness reserved value来保留升级比特币共识协议的能力。</p><p>承诺之后的可选数据空间也为将来软叉的元数据留有余地，并且不得用于其他目的。</p><h3 id="无信任的未确认交易依赖链"><a href="#无信任的未确认交易依赖链" class="headerlink" title="无信任的未确认交易依赖链"></a>无信任的未确认交易依赖链</h3><p>隔离见证从根本上解决了交易延展性问题，从而以无信任的方式构建未经证实的交易依赖链。</p><p>Alice和Bob两方可能会同意将一定比特币发送到2比2的多重输出（“资金交易”）。如果没有签署资金交易，他们可能会创建另一个交易，在未来时间锁定，将2比2的多重输出投入到第三个账户（“支出交易”）。Alice和Bob将签署消费交易并交换签名。在审查签名后，他们将签署资金交易并将其交易给区块链。如果没有采取进一步行动，支出交易将在锁定时间后确认，并根据原始合同发放资金。<b style="color:red">它还保留了在锁定时间之前撤销原始合同的灵活性，通过锁定时间更短的另一笔支出交易，但只有在双方达成共识的情况下。</b></p><p>BIP62不可能将此类设置作为延展性修复，因为如果双方首次签署资金交易，则无法创建支出交易。如果Alice在Bob之前披露资金交易签名，Bob可以无限期锁定资金，而无需签署支出交易。</p><p>未经证实的交易依赖链是更复杂的支付网络的基本组成部分，比如双工微支付渠道和闪电网络，它们有可能极大地提高比特币系统的可扩展性和效率。</p><h2 id="未来的扩展"><a href="#未来的扩展" class="headerlink" title="未来的扩展"></a>未来的扩展</h2><h3 id="适用于SPV节点的紧凑型欺诈证明"><a href="#适用于SPV节点的紧凑型欺诈证明" class="headerlink" title="适用于SPV节点的紧凑型欺诈证明"></a>适用于SPV节点的紧凑型欺诈证明</h3><p>比特币现在只有两种真正的安全模式。用户或者运行一个全节点来验证系统中所有规则的每个块，或者一个SPV（简单支付验证）客户端，它只验证头部作为一些交易发布的证明。比特币白皮书建议，当SPV节点检测到无效块时，可以接受来自完整节点的警报，提示SPV节点下​​载有问题的块和交易进行验证。但是，这种方法可能会成为DoS攻击媒介，因为几乎不会产生虚警。警报必须具有紧凑但确定性的欺诈证据。</p><p>在目前的比特币协议中，除了少数几个规则外，几乎所有规则都可以生成紧凑的欺诈证据：</p><ol><li>无法证明矿工在coinbase交易输出中引入了太多比特币，而没有显示整个块本身和所有输入交易。</li><li>不可能证明违反任何块特定的约束条件，例如大小和sigop限制，而不显示整个块（以及在sigop限制情况下的所有输入交易）</li><li>如果没有从区块链上回溯到创世区块的所有交易ID，则无法证明花费了一些不存在的输入。</li></ol><p>可以提交额外的见证数据，以允许SPV节点可以快速验证的块无效的简短证明：</p><ol><li>交易费的总和树可以用来构建简短的证明，证明矿工不会为coinbase交易增加额外的费用。类似于块大小和sigop计数限制。</li><li>可以提供交易输入所花费输出的反向链接。这些反向链接包含块散列和瘦客户端可轻松查询和检查以验证输出是否存在的偏移量。</li></ol><p>这些承诺可以通过软分叉包含在可扩展的承诺结构中，并且对不了解这些新规则的节点是透明的。</p><h3 id="新的脚本系统"><a href="#新的脚本系统" class="headerlink" title="新的脚本系统"></a>新的脚本系统</h3><p><b style="color:red">由于version字节在witness程序之前被推送，并且版本未知的程序总是被视为任何人可以花费的脚本，所以可以通过软分叉来引入任何新的脚本系统。作为结构的见证不受任何现有脚本语义和约束的限制，特别是520字节的推送限制，因此允许任意大的脚本和签名。</b></p><p>新的脚本系统的例子包括Schnorr签名，可以显着减少多重交易处理的大小，Lamport签名是量子计算阻力，Merklized抽象语法树允许非常复杂的条件脚本的非常紧凑的见证。</p><h3 id="每个输入锁定时间（Per-input-lock-time）和相对锁定时间（relative-lock-time）"><a href="#每个输入锁定时间（Per-input-lock-time）和相对锁定时间（relative-lock-time）" class="headerlink" title="每个输入锁定时间（Per-input lock-time）和相对锁定时间（relative-lock-time）"></a>每个输入锁定时间（Per-input lock-time）和相对锁定时间（relative-lock-time）</h3><p>目前交易中只有一个nLockTime字段，并且所有输入必须共享相同的值。BIP68使用nSequence字段启用每个输入的相对锁定时间，但锁定时间段和分辨率有限。</p><p><b style="color:red">通过软分叉，可以引入单独的见证结构以允许每个输入的锁定时间和相对锁定时间，以及可以签署和操作新数据的新脚本系统（如BIP65和BIP112）。</b></p><h2 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h2><p><b style="color:red">作为一个软分叉，较旧的软件将继续无需修改即可运行</b>。但是，未升级的节点将不会看到也不会验证证人数据，并将所有见证程序视为任何人可以花费的脚本（除了几个证据程序等于0的边缘情况，脚本必须失败）。钱包应该时刻警惕任何人可以花钱的脚本，并怀疑地对待它们。强烈建议未升级的节点升级以利用新功能。</p><h3 id="未升级的钱包可以做什么"><a href="#未升级的钱包可以做什么" class="headerlink" title="未升级的钱包可以做什么"></a>未升级的钱包可以做什么</h3><ol><li>从未升级和升级的钱包接收比特币</li><li>使用传统P2PKH地址将比特币发送给未升级和升级的钱包（没有任何隔离见证的好处）</li><li>使用P2SH地址将比特币发送到升级的钱包</li><li>通过<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA3MC5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki">BIP70<i class="fa fa-external-link"></i></span>支付协议使用本地见证程序将比特币发送至升级的钱包</li></ol><h3 id="非升级的钱包不能做什么"><a href="#非升级的钱包不能做什么" class="headerlink" title="非升级的钱包不能做什么"></a>非升级的钱包不能做什么</h3><ul><li>验证隔离的证人交易。它假定这样的交易总是有效的</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>该BIP将通过名称为“segwit”的“版本位”BIP9并使用位1进行部署。</p><p>对于比特币主网络，BIP9启动时间将为2016年11月15日午夜UTC（时代邮戳时间戳1479168000），并且BIP9超时时间将为2017年11月15日午夜UTC（时代邮戳时间戳1510704000）。</p><p>对于比特币测试网，BIP9开始时间将为UTC时间2016年5月1日午夜（时间戳1462060800）和BIP9超时时间为UTC时间2017年5月1日（时间戳1493596800）。</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>特别感谢Gregory Maxwell在本BIP和Luke-Jr中提出了许多想法，以便弄清楚如何将其作为软分叉来部署。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>^ 例如，带OP_0的scriptPubKey后跟40字节的非零数据推送将由于程序大小不正确而失败。但是，带OP_0后跟41字节非零数据推送的scriptPubKey将会通过，因为它不被视为见证程序<br>^ 为了向后兼容，对于从0到16的任何版本字节，如果证明程序的CastToBool值为零，则脚本必须失败。然而，像这样的哈希是一个成功的对哈希函数的原像攻击，风险可以忽略不计。<br>^ 使用单个复合约束的原理，而不是两个单独的限制，例如1MB基础数据和3MB见证数据：使用两个单独的限制将使挖掘和费用估计几乎不可能。矿工们需要解决一个复杂的非线性优化问题，以找到在给定两个约束条件的情况下使费用最大化的一组交易，并且钱包将不能知道该支付什么，因为它取决于两个条件中的哪一个最受到实时的矿工们试图用他们的交易来生产积木。这种方法的另一个问题是闲聊。一旦一组事务处理达到基本数据1MB约束条件，通过最低限度地增加费用就可以向证人添加高达3MB的额外数据。在这种情况下，额外见证空间的边际成本实际上变为零。<br>^ <span class="exturl" data-url="aHR0cHM6Ly9saXN0cy5saW51eGZvdW5kYXRpb24ub3JnL3BpcGVybWFpbC9iaXRjb2luLWRldi8yMDE2LUF1Z3VzdC8wMTMwMTQuaHRtbA==" title="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html">https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html<i class="fa fa-external-link"></i></span></p><h2 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a>参考实现</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9wdWxsLzgxNDk=" title="https://github.com/bitcoin/bitcoin/pull/8149">https://github.com/bitcoin/bitcoin/pull/8149<i class="fa fa-external-link"></i></span></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAxNi5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP16支付脚本散列<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0My5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP143版本0witness程序的交易签名验证<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0NC5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki">BIP144隔离见证（同伴节点服务）<i class="fa fa-external-link"></i></span></p><h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>该文件置于公共领域。</p><h2 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNzUxMjM0Nw==" title="https://zhuanlan.zhihu.com/p/27512347">bitcoin 源码解析 - 交易 Transaction(三) - Script<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDE0MS5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">bips/bip-0141.mediawiki<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隔离见证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Secp256k1</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E4%BB%80%E4%B9%88%E6%98%AFSecp256k1.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E4%BB%80%E4%B9%88%E6%98%AFSecp256k1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>本文的阅读需要理解椭圆曲线，了解相关知识请查看我之前的博客文档。</p><p><b style="color:red">secp256k1是指比特币中使用的ECDSA曲线的参数</b>，并且在高效密码学标准（SEC）（Certicom Research，<span class="exturl" data-url="aHR0cDovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZu+8ieS4rei/m+ihjOS6huWumuS5ieOAgg==" title="http://www.secg.org/sec2-v2.pdf）中进行了定义。">http://www.secg.org/sec2-v2.pdf）中进行了定义。<i class="fa fa-external-link"></i></span></p><p>在比特币开始流行之前，secp256k1几乎从未使用过，但由于其几个不错的属性，它现在越来越受欢迎。大多数常用曲线具有随机结构，但secp256k1是以特殊的非随机方式构建的，可以实现特别高效的计算。<b style="color:red">因此，如果实施得到充分优化，它通常比其他曲线快30％以上</b>。<b style="color:#00f">另外，与流行的NIST曲线不同，secp256k1的常量是以可预测的方式选择的，这大大降低了曲线创建者在曲线中插入任何后门的可能性。</b></p><p>下面看一下这里面的函数图：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/Secp256k1%E5%87%BD%E6%95%B0%E5%9B%BE.png?raw=true"></p><p><b style="color:#00f">Secp256k1是secp256k1椭圆曲线y<sup>2</sup> = x<sup>3</sup> + 7在实数上的图形。请注意，因为secp256k1实际上是在字段Z<sub>p</sub>上定义的，所以它的图形实际上看起来像是随机分散的点，而不是像图中这样是连续的点。</b></p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>从标准摘录：</p><p>与Koblitz曲线secp256k1相关联的F<sub>p</sub>上的椭圆曲线域参数由单元T=（p，a，b，G，n，h）指定，其中有限域F<sub>p</sub>由下式定义：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F</span><br><span class="line">= 2256 - 232 - 29 - 28 - 27 - 26 - 24 - 1</span><br></pre></td></tr></table></figure><p></p><p>F<sub>p</sub>上的曲线E：y<sup>2</sup> = x<sup>3</sup> + ax + b由下式定义：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007</span><br></pre></td></tr></table></figure><p></p><p>压缩形式的基点G是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798</span><br></pre></td></tr></table></figure><p></p><p>而在未压缩的形式是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8</span><br></pre></td></tr></table></figure><p></p><p>最后，G的循环因子n(就是指nG=G)和辅因子h如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141</span><br><span class="line">h = 01</span><br></pre></td></tr></table></figure><p></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>secp256k1具有特征p，它的素数域定义为ℤ<sub>p</sub>。常用的一些其他曲线具有特征2，并且在二进制伽罗瓦(Galois)域GF(2<sup>n</sup>)上定义，但secp256k1不是其中之一。</li><li>因为一个常数为零，曲线方程中<code>ax</code>项始终为零，因此曲线方程变为y<sup>2</sup> = x<sup>3</sup> + 7。</li></ul><h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><p><span class="exturl" data-url="aHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMTkwNy93aGF0LWRvZXMtdGhlLWN1cnZlLXVzZWQtaW4tYml0Y29pbi1zZWNwMjU2azEtbG9vay1saWtl" title="https://bitcoin.stackexchange.com/questions/21907/what-does-the-curve-used-in-bitcoin-secp256k1-look-like">secp256k1是什么（Pieter Wuille的比特币堆栈交换答案）<i class="fa fa-external-link"></i></span></p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvU2VjcDI1Nmsx" title="https://en.bitcoin.it/wiki/Secp256k1">Secp256k1<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bitcoin </tag>
            
            <tag> Secp256k1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitcoin中Base58Check编码</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Bitcoin%E4%B8%ADBase58Check.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Bitcoin%E4%B8%ADBase58Check.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>Base58二进制到文本编码被称为Base58Check，用于编码比特币地址。</p><p>更一般地说，Base58Check编码用于将比特币中的字节数组编码为人类可分类的字符串。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最初的比特币客户端源代码解释了base58编码背后的原因：</p><p>base58.h：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 为什么base-58而不是标准的base-64编码？</span><br><span class="line">//  - 不希望0OIl字符在某些字体和字体中看起来相同</span><br><span class="line">//可以用来创建视觉上相同的账号。</span><br><span class="line">//  - 具有非字母数字字符的字符串并不像帐号那么容易被接受。</span><br><span class="line">//  - 如果没有标点符号，电子邮件通常不会换行。</span><br><span class="line">//  - 如果全部是字母数字，Doubleclicking会将整个数字选为一个单词。</span><br></pre></td></tr></table></figure><p></p><h2 id="Base58Check的功能"><a href="#Base58Check的功能" class="headerlink" title="Base58Check的功能"></a>Base58Check的功能</h2><p>Base58Check具有以下功能：</p><ul><li>一个任意大小的payload（<b style="color:red">这个payload其实就是公钥的HASH160的双次hash值</b>）。</li><li>由容易区分的大写和小写字母组成的一组58个字母数字符号（0OIl不使用）(<b style="color:red">主要的原因还是因为可能会产生歧义</b>)</li><li>一个字节的version/application信息。对于这个字节比特币地址使用0x00（未来的可能使用0x05）。</li><li>四个字节（32位）基于SHA256的错误校验码。此校验码可用于自动检测并可能更正印刷错误。</li><li>保留数据中前导零的额外步骤。（这里应该更深入地进行分析才是，但是现在真不太明白这里面的意思。）</li></ul><h2 id="创建一个Base58Check字符串"><a href="#创建一个Base58Check字符串" class="headerlink" title="创建一个Base58Check字符串"></a>创建一个Base58Check字符串</h2><p>Base58Check字符串是从version/application字节和payload创建的，如下所示。</p><ol><li>获取version字节和payload字节，并将它们连接在一起（按字节）。</li><li>取SHA256的前四个字节（SHA256（步骤1的结果））（<b style="color:red">也应该是前面提到的那四个字节的事情</b>）</li><li>将步骤1的结果和步骤2的结果连在一起（按字节顺序）。</li><li>处理步骤3的结果 - 一系列字节 - <b style="color:red">作为单个大端序号</b>，使用正常的数学步骤（bignumber division）和下面描述的base-58字母表转换为base-58。结果应该被标准化为没有任何前导的base-58零（字符’1’）。(<b style="color:red">这里注意前导0对应的Base58Check是1</b>)</li><li>在base58中值为零的前导字符’1’被保留用于表示整个前导零字节，就像它处于前导位置时一样，没有值作为base-58符号。必要时可以有一个或多个前导’1’来表示一个或多个前导零字节。计算第3步结果的前导零字节数（对于旧的比特币地址，至少有一个用于版本/应用程序字节;对于新地址，将永远不会有）。每个前导零字节在最终结果中应由其自己的字符’1’表示。</li><li>将步骤5中的1与步骤4 的结果连接起来。这是Base58Check的结果。</li></ol><p>在描述比特币地址<span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvVGVjaG5pY2FsX2JhY2tncm91bmRfb2ZfdmVyc2lvbl8xX0JpdGNvaW5fYWRkcmVzc2VzI0hvd190b19jcmVhdGVfQml0Y29pbl9BZGRyZXNz" title="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address">技术背景<i class="fa fa-external-link"></i></span>的页面上提供了一个更详细的例子。</p><h2 id="编码比特币地址"><a href="#编码比特币地址" class="headerlink" title="编码比特币地址"></a>编码比特币地址</h2><p>比特币地址是使用以下任一项的散列的Base58Check编码实现的：</p><ul><li>Pay-to-script-hash（p2sh）：有效载荷是：其中redeemScript是钱包知道如何消费的脚本; 版本（这些地址以数字’3’开头）RIPEMD160(SHA256(redeemScript))0x05</li><li>支付到PUBKEY散列（p2pkh）：有效载荷是其中ECDSA_publicKey是钱包知道的私有密钥的公共密钥; 版本（这些地址以数字’1’开头）RIPEMD160(SHA256(ECDSA_publicKey))0x00</li></ul><p>在这两种情况下得到的散列总是恰好为20个字节。这些是大端（最重要的字节在前）。（注意那些限制前导0x00字节的数字编码实现，或者预先增加额外的0x00字节来表示符号 - 你的代码必须正确处理这些情况，否则你可能会生成可以发送到但看不到的有效地址 -导致硬币的永久损失。）</p><h2 id="编码一个私钥"><a href="#编码一个私钥" class="headerlink" title="编码一个私钥"></a>编码一个私钥</h2><p><b style="color:red">Base58Check编码也用于编码钱包导入格式中的<span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvUHJpdmF0ZV9rZXk=" title="https://en.bitcoin.it/wiki/Private_key">ECDSA私钥<i class="fa fa-external-link"></i></span></b>。除了0x80用于version/application字节，并且有效载荷是32字节而不是20（比特币中的私钥是单个32字节无符号的大端整数）之外，它与比特币地址完全相同。对于与未压缩的公钥相关的私钥，这种编码总是会产生一个以’5’开头的51个字符的字符串，或者更具体地说’5H’，’5J’或’5K’。</p><h2 id="Base58符号图表"><a href="#Base58符号图表" class="headerlink" title="Base58符号图表"></a>Base58符号图表</h2><p>比特币中使用的Base58符号图特定于比特币项目，并不打算与比特币之外使用的任何其他Base58实现（排除的字符为：0，O，I和l）相同。</p><table><thead><tr><th>值</th><th>字符</th><th>值</th><th>字符</th><th>值</th><th>字符</th><th>值</th><th>字符</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td></tr><tr><td>4</td><td>5</td><td>5</td><td>6</td><td>6</td><td>7</td><td>7</td><td>8</td></tr><tr><td>8</td><td>9</td><td>9</td><td>A</td><td>10</td><td>B</td><td>11</td><td>C</td></tr><tr><td>12</td><td>D</td><td>13</td><td>E</td><td>14</td><td>F</td><td>15</td><td>G</td></tr><tr><td>16</td><td>H</td><td>17</td><td>J</td><td>18</td><td>K</td><td>19</td><td>L</td></tr><tr><td>20</td><td>M</td><td>21</td><td>N</td><td>22</td><td>P</td><td>23</td><td>Q</td></tr><tr><td>24</td><td>R</td><td>25</td><td>S</td><td>26</td><td>T</td><td>27</td><td>U</td></tr><tr><td>28</td><td>V</td><td>29</td><td>W</td><td>30</td><td>X</td><td>31</td><td>Y</td></tr><tr><td>32</td><td>Z</td><td>33</td><td>a</td><td>34</td><td>b</td><td>35</td><td>c</td></tr><tr><td>36</td><td>d</td><td>37</td><td>e</td><td>38</td><td>f</td><td>39</td><td>g</td></tr><tr><td>40</td><td>h</td><td>41</td><td>i</td><td>42</td><td>j</td><td>43</td><td>k</td></tr><tr><td>44</td><td>m</td><td>45</td><td>n</td><td>46</td><td>o</td><td>47</td><td>p</td></tr><tr><td>48</td><td>q</td><td>49</td><td>r</td><td>50</td><td>s</td><td>51</td><td>t</td></tr><tr><td>52</td><td>u</td><td>53</td><td>v</td><td>54</td><td>w</td><td>55</td><td>x</td></tr><tr><td>56</td><td>y</td><td>57</td><td>z</td></tr></tbody></table><p>编码address_byte_string的算法（由1-byte_version + hash_or_other_data + 4-byte_check_code组成）是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">code_string = &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span><br><span class="line">x = convert_bytes_to_big_integer(hash_result)</span><br><span class="line"></span><br><span class="line">output_string = &quot;&quot;</span><br><span class="line"></span><br><span class="line">while(x &gt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        (x, remainder) = divide(x, 58)</span><br><span class="line">        output_string.append(code_string[remainder])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">repeat(number_of_leading_zero_bytes_in_hash)</span><br><span class="line">    &#123;</span><br><span class="line">    output_string.append(code_string[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">output_string.reverse();</span><br></pre></td></tr></table></figure><p></p><h2 id="版本字节"><a href="#版本字节" class="headerlink" title="版本字节"></a>版本字节</h2><p>以下是一些常见的版本字节：</p><table><thead><tr><th>小数版本</th><th>领导的象征</th><th>使用</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>Bitcoin pubkey hash</td></tr><tr><td>5</td><td>3</td><td>Bitcoin script hash</td></tr><tr><td>21</td><td>4</td><td>Bitcoin (compact) public key (proposed)</td></tr><tr><td>52</td><td>M or N</td><td>Namecoin pubkey hash</td></tr><tr><td>128</td><td>5</td><td>Private key</td></tr><tr><td>111</td><td>m or n</td><td>Bitcoin testnet pubkey hash</td></tr><tr><td>196</td><td>2</td><td>Bitcoin testnet script hash</td></tr></tbody></table><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvTGlzdF9vZl9hZGRyZXNzX3ByZWZpeGVz" title="https://en.bitcoin.it/wiki/List_of_address_prefixes">地址前缀列表<i class="fa fa-external-link"></i></span>是一个完整的列表。</p><h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><p><span class="exturl" data-url="aHR0cDovL2xlbnNjaHVsd2l0ei5jb20vYmFzZTU4" title="http://lenschulwitz.com/base58">在线Base58解码器，编码器和验证器<i class="fa fa-external-link"></i></span></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iL21hc3Rlci9zcmMvYmFzZTU4LmNwcA==" title="https://github.com/bitcoin/bitcoin/blob/master/src/base58.cpp">“Satoshi”C ++ codebase（解码和编码，不需要外部库）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2UtanIvbGliYmFzZTU4" title="https://github.com/luke-jr/libbase58">libbase58 C代码（解码和编码，不需要外部库）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2xlbnNjaHVsd2l0ei5jb20vYjU4L2Jhc2U1OHBlcmwudHh0" title="http://lenschulwitz.com/b58/base58perl.txt">Base58在Perl中解码，编码和验证<i class="fa fa-external-link"></i></span></p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvQmFzZTU4Q2hlY2tfZW5jb2Rpbmc=" title="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58Check encoding<i class="fa fa-external-link"></i></span></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于比特币地址知识，在精通比特币中有详细地介绍，这里我们不做更多的介绍，这篇文章是我翻译的结果。</p><p>在之前我们分析过椭圆曲线的知识，对于确定性钱包的知识我们也做了相关地介绍，还有就是分层确定性钱包的知识。</p><p><b style="color:red">另外Base58Check还有一个极大的好处就是可以校验地址是不是正确的，因为Base58生成的时候是加入了校验码</b>。我觉得比特币团队做的真的是很棒不是吗？详情可以参考：<span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC0zMTIwMS0xLTEuaHRtbA==" title="http://8btc.com/thread-31201-1-1.html">为什么以太坊地址中没有校验值？<i class="fa fa-external-link"></i></span></p><p><b style="color:red">对于比特币地址也要特别注意一下，地址类型也就是version/appication字段其实是自己加入的，和ecdsa本身并没有任何关系。校验码也是自己加上去的而已。我们可以看一下下面的图片.</b></p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%9D%9E%E5%8E%8B%E7%BC%A9%E5%85%AC%E9%92%A5%E7%94%9F%E6%88%90%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B.png?raw=true"></p><p>有一段时间我在分析java的ECKey的代码发现java底层的椭圆曲线算法的实现，这里我就不做更多的说明了。<b style="color:red">关键是我们如何实现分层确定性钱包，这个很简单也很复杂，其实就是找私钥G，至于这个G怎么找，我们可以查看精通比特币里面的说明，这里面只是提到了HMAC-SHA512。看来这里面隐藏了很多的细节因素，我们有时间需要研究一下，HMAC-SHA512的知识了。</b></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Base58Check </tag>
            
            <tag> bitcoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring循环依赖检查</title>
      <link href="//java/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5.html"/>
      <url>//java/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>对于循环依赖检查，一般地数据结构就是DAG（有向无环图图）。所以在Spring中也是这样去实现的。</p><p>在Spring中检查依赖是和注入的方式有很大关系的。</p><h2 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h2><p>Spring容器将每一个正在创建的Bean 标识符放在一个“<b style="color:red">当前创建Bean池</b>”中，Bean标识符在创建过程中将一直保持在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出BeanCurrentlyInCreationException异常表示循环依赖；<b style="color:red">而对于创建完毕的Bean将从“当前创建Bean池”中清除掉</b>。</p><h2 id="setter循环依赖"><a href="#setter循环依赖" class="headerlink" title="setter循环依赖"></a>setter循环依赖</h2><p>对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的Bean来完成的，而且<b style="color:red">只能解决单例作用域的Bean循环依赖</b>。我唯一有印象的就是这里的代码，之后如果再读Spring源码，我们再来进行详细地分析。</p><p>通过提前暴露一个<b style="color:red">单例工厂方法ObjectFactory</b>，从而使其他Bean能引用到该Bean。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决问题的方式是多种多样的，以后一定要想如何去解决一个问题，而不是关注问题本身的解决。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中创建bean的几种方式</title>
      <link href="//java/Spring%E4%B8%AD%E5%88%9B%E5%BB%BAbean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
      <url>//java/Spring%E4%B8%AD%E5%88%9B%E5%BB%BAbean%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近一直在忙于区块链知识的研究，却忘记了Spring的很多知识。其实我主打的知识还是应该是Spring、SpringMVC、Mybatis、Tomcat、SpringBoot、SpringCloud等等。但是实际上我现在对这方面的知识遗忘还是很厉害的。今天就来回顾一下Spring创建Bean的几种方式。</p><h2 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;hello&quot; name=&quot;helloImpl&quot; class=&quot;cn.javass.spring.chapter2.helloworld.HelloImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="有参数的构造方法"><a href="#有参数的构造方法" class="headerlink" title="有参数的构造方法"></a>有参数的构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;bean2&quot; class=&quot;cn.javass.spring.chapter2.HelloImpl2&quot;&gt;</span><br><span class="line">    &lt;!-- 指定构造器参数 --&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="静态工厂方式"><a href="#静态工厂方式" class="headerlink" title="静态工厂方式"></a>静态工厂方式</h2><p>静态工厂的类：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloApiStaticFactory &#123;</span><br><span class="line">    //工厂方法</span><br><span class="line">    public static HelloApi newInstance(String message) &#123;</span><br><span class="line">        //返回需要的Bean实例</span><br><span class="line">        return new HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>xml的配置方式。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用静态工厂方法 --&gt;</span><br><span class="line">&lt;bean id=&quot;bean3&quot; class=&quot;cn.javass.spring.chapter2.HelloApiStaticFactory&quot; factory-method=&quot;newInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="实例工厂方法实例化Bean"><a href="#实例工厂方法实例化Bean" class="headerlink" title="实例工厂方法实例化Bean"></a>实例工厂方法实例化Bean</h2><p>实例工厂类代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package cn.javass.spring.chapter2;</span><br><span class="line"></span><br><span class="line">public class HelloApiInstanceFactory &#123;</span><br><span class="line">    public HelloApi newInstance(String message) &#123;</span><br><span class="line">        return new HelloImpl2(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>xml的定义方式如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—1、定义实例工厂Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;cn.javass.spring.chapter2.HelloApiInstanceFactory&quot;/&gt;</span><br><span class="line">&lt;!—2、使用实例工厂Bean创建Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;bean4&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Spring!&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><p>一个构造方法注入，一个是getter、Setter方法注入。除了注入bean，也可以注入常量、list、array、set、map等各种数据结构。</p><p>当然由于bean的创建方式有工厂的方式进行创建，所以注入的参数也可以通过factory-method进入。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实不管是使用哪种方式的注入，都是生成FactoryBean，但其实我们可以使用多种方式对先有的Spring方式进行扩容。甚至是自己负责new一个对象，然后register到Spring容器里面。拥有这种思路对于我们后期对Springboot的学习很有帮助。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIP-62处理延展性攻击</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-62%E5%A4%84%E7%90%86%E5%BB%B6%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-62%E5%A4%84%E7%90%86%E5%BB%B6%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>这篇文档主要是解决比特币的延展性攻击。</p><p><b style="color:red">交易的延展性，也被称作为是可锻性，啥叫可锻，也即同样一个东西（如一坨金属），它的本质和质量都没有改变，但是它的形状改变了。而这个可锻性，会造成交易ID——TXID的不一致，从而导致用户找不到发送的交易。因为交易的ID就是指交易的hash值。但是由于隔离见证的使用，导致脚本不再是交易结构的一部分（但是逻辑上还是一样的），这样这个扩展性问题就不那么重要了。但是如果旧节点产生的交易，可能还是要使用这样的规则去杜绝扩展性。</b></p><p>注意：本文档是一项正在进行的工作，并未完成，实施或以其他方式适用于部署。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该文件规定了对比特币交易有效性规则的建议修改，以便不可能延展交易的可塑性（至少在交易发送者不选择避开它时）。</p><h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>此BIP根据2条款BSD许可证进行许可。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>截至2014年2月，比特币交易在多个方面具有延展性。这意味着（有效）交易可以在传送中被修改，而不会使其失效，但无法访问相关私钥。</p><p>这个问题有多种原因：（<b style="color:red">感觉这里讲的就是如果同一个输出，发送者发送多笔花费这个输出的交易会怎么样？</b>）</p><ul><li>交易被改后，交易发送者可能无法识别他自己的交易。（因为TXID可能被修改了，链上使用旧的txid是无法找到这笔交易的）</li><li>交易发送者可以花费由原始交易创建的更改的交易。如果修改后的交易被矿机开采，这将变为无效。</li><li>修改后的交易实际上是双重花费，可以在没有恶意的情况下（发送者）创建，但易于被用于其他攻击。</li></ul><p>已知几种延展性来源（<b style="color:red">主要是指哪些部分可以被修改，修改什么</b>）：</p><ol><li>现在的非DER编码的ECDSA签名. 比特币参考客户端使用OpenSSL来验证签名。由于OpenSSL接受的不仅仅是严格遵守DER标准的序列化，而且还是可延展性的来源。自v0.8.0以来，非DER签名不再被中继。（就是说DER签名可以解决问题，非DER签名的交易会有问题。）</li><li>scriptSig中没有推送操作。 <b style="color:red">在scriptSig中脚本操作的任何序列号都会导致预期的数据推送，但不仅仅是推送该数据，会产生具有相同有效性的替代事务。</b></li><li>scriptSig中非标准尺寸的推送操作。 比特币脚本语言具有多个推式运算符（OP_0，单字节推送，最多75字节的数据推送，OP_PUSHDATA1，OP_PUSHDATA2，OP_PUSHDATA4）。由于后者与前者具有相同的结果，它们会带来更多的可能性。(容易遭受DDOS攻击，推送大数据也会导致mempool内存爆满)</li><li>零填充数字推送。 在scriptPubKey操作码使用被解释为数字的输入的情况下，它们可以被填充为零。</li><li>内在的ECDSA签名延展性 ECDSA签名本身已经具有延展性：取数字S的负数（以曲线顺序为模）不会使其无效。（<b style="color:red">这个需要了解椭圆曲线的特性了，对称的点也在曲线上的</b>）</li><li>多余的scriptSig操作。 在脚本开始处添加额外的数据推送，这些数据不会被相应的scriptPubKey消耗，这也是可延展性的来源。(一开始压入一些数字，如果栈不被清空会有很多的问题)</li><li>输入被脚本忽略。 如果scriptPubKey以OP_DROP开头，例如，相应脚本的最后一次数据推送将始终被忽略。</li><li>基于Sighash标志的掩码。 Sighash标志可用于在签名时忽略脚本的某些部分。（修改sighash，这个可以查看DER的结构）。</li><li>交易发起者的新签名。 交易发起者（或任何可以访问相关私钥的人）总是能够创建新的签名，这些签名将相同的输入用于相同的输出。</li></ol><p><b style="color:red">前六个和第七个的一部分可以通过额外的共识规则来解决，但最后两个不能</b>。无法修复＃7意味着即使有了这些新的共识规则，也将始终有可能创建支出交易全都具有延展性的输出。然而，当限制使用一套安全的输出脚本时，<b style="color:red">额外的共识规则可以使支出交易选择性地不可延展（如果花费者选择;因为他自己总是可以绕过＃8和＃9）。</b></p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="新规则"><a href="#新规则" class="headerlink" title="新规则"></a>新规则</h3><p><b style="color:red">引入了七个额外的规则，以准确地与上面列出的七个可延展性来源进行对比：</b></p><ol><li>标准的ECDSA编码签名。 传递给OP_CHECKSIG，OP_CHECKSIGVERIFY，OP_CHECKMULTISIG或OP_CHECKMULTISIGVERIFY的ECDSA签名必须使用严格的DER编码进行编码。为了为OP_CHECKSIG和OP_CHECKMULTISIG故意创建无效签名提供一种紧凑的方式，还允许使用空字节数组（即OP_0的结果）。<b style="color:red">使用非DER签名进行验证会使整个脚本评估为False（而不仅仅是签名验证）</b>。请参阅参考资料：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Mi5tZWRpYXdpa2kjZGVyLWVuY29kaW5n" title="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#der-encoding">DER编码<i class="fa fa-external-link"></i></span>。</li><li>scriptSig中的非推送操作。 ScriptSig中只允许数据推送。评估任何其他操作会使脚本评估为false。请参阅参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Mi5tZWRpYXdpa2kjcHVzaC1vcGVyYXRvcnM=" title="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#push-operators">推送运算符<i class="fa fa-external-link"></i></span>。</li><li>scriptSig中的推送操作是非标准大小类型。 尽可能使用尽可能最小的脚本操作。使用可以用较短方式编码的操作推送数据会使脚本评估为false。请参阅参考：推送运算符。</li><li>零填充数字推送。 任何时候脚本操作码都会消耗一个被解释为数字的堆栈值，它必须以尽可能最短的形式进行编码。’负零’是不允许的。请参阅参考：数字。</li><li>固有的ECDSA签名延展性。 我们要求ECDSA签名内的S值至多是曲线次序（就是n的值）除以2（实质上限制该值到其下半部分范围）。请参阅参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Mi5tZWRpYXdpa2kjbG93LXMtdmFsdWVzLWluLXNpZ25hdHVyZXM=" title="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#low-s-values-in-signatures">签名中的低S值<i class="fa fa-external-link"></i></span>。</li><li>多余的scriptSig操作。 scriptPubKey评估将需要导致一个非零值。如果任何额外的数据元素保留在堆栈上，则脚本评估为false。</li><li>脚本忽略输入 OP_CHECKMULTISIG和OP_CHECKMULTISIGVERIFY消耗的（不必要的）额外堆栈元素必须是空字节数组（OP_0的结果）。其他任何事情都会使脚本评估为false。</li></ol><h3 id="区块有效性"><a href="#区块有效性" class="headerlink" title="区块有效性"></a>区块有效性</h3><p>为了在网络中引入这些新规则，我们添加了v3块和v3交易。交易跳过v2以使交易和​​区块规则之间的版本号保持同步。v2交易的处理与v1交易相同。使用与BIP 0034相同的机制来引入v3块。当过去1000个block中有75％是v3时，会激活一个新的共识规则：</p><ul><li>v3块中的所有交易都必须遵守规则＃1-＃2。</li><li>v3块中的v3（或更高）交易也需要遵循规则＃3-＃7。</li></ul><p>当过去1000个块中的95％为v3或更高时，v2块将完全失效。但请注意，v1（和v2）交易永远保持有效。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>以下是签名，编码和数据推送效果的总结。</p><h3 id="签名中的低位S值"><a href="#签名中的低位S值" class="headerlink" title="签名中的低位S值"></a>签名中的低位S值</h3><p>签名中的值S必须介于<code>0x1</code>和<code>0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0（含）</code>之间。如果S太高，只需将其替换为<code>S&#39;= 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S</code>.</p><p>不保证OpenSSL库生成的签名与此约束一致。参考客户端的0.9.3版本提供了检测和纠正的示例。</p><p>值R的约束与ECDSA不变，其值可以在<code>0x1</code>和<code>0xFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140（含）</code>之间。</p><h3 id="DER编码"><a href="#DER编码" class="headerlink" title="DER编码"></a>DER编码</h3><p>作为参考，这里是如何正确编码DER格式的签名。</p><p>格式如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x30 [总长度] 0x02 [R长度] [R] 0x02 [S长度] [S] [sighash型]</span><br></pre></td></tr></table></figure><p></p><ul><li>总长度：后面所有内容的1字节长度描述符，<b tsyle="color:red">不包括sighash字节。</b></li><li>R长度：后面的R值的1字节长度描述符。</li><li>R：任意长度的大端编码的R值。它不能以任何0x00字节开始，除非接下来的第一个字节是0x80或更高，在这种情况下需要一个0x00。</li><li>S长度：接下来的S值的1字节长度描述符。</li><li>S：任意长度的大端编码的S值。与R相同的规则适用。</li><li>sighash类型：1字节散列类型标志（只允许0x01，0x02，0x03，0x81，0x82和0x83）。</li></ul><p>参考客户端自0.8.0版本开始实施（仅作为中继策略，而不是作为共识规则）。<br>该规则与上面的低S要求相结合导致S长度最多为32（并且R长度最多为33），并且总签名大小最多72字节（平均71.494字节）。</p><h3 id="推动操作"><a href="#推动操作" class="headerlink" title="推动操作"></a>推动操作</h3><ul><li>推空的字节序列必须使用OP_0。</li><li>通过0x10推送一个1字节的字节序列0x01必须使用OP_n。</li><li>推送字节0x81必须使用OP_1NEGATE。</li><li>推送任何其他高达75字节的字节序列时，必须使用正常的数据推送（操作码字节n，其中n是字节数，紧接着推送n字节的数据）。</li><li>推送76到255个字节必须使用OP_PUSHDATA1。</li><li>推送256到520字节必须使用OP_PUSHDATA2。</li><li>OP_PUSHDATA4永远不能使用，因为不允许超过520个字节，下面的操作可以使用其他操作符完成。</li><li>任何其他操作都不被认为是push。（<b style="color:red">意思就是不能使用数字这样直接做推送</b>）</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>堆栈元素的本地数据类型是字节数组，但有些操作将参数解释为整数。使用的编码是带有明确的符号位（最后一个字节的最高位）的小端。数字的最短编码是（以（））之间的十六进制给出的范围边界编码。</p><ul><li>0：OP_0; （00）</li><li>1..16：OP_1..OP_16; （51）..（60）</li><li>-1：OP_1NEGATE; （79）</li><li>-127 ..- 2和17..127：正常的1字节数据推送; （01 FF）..（01 82）和（01 11）..（01 7F）</li><li>-32767 ..- 128和128..32767：正常的2字节数据推送; （02 FF FF）..（02 80 80）和（02 80 00）..（02 FF 7F）</li><li>-8388607 ..- 32768和32768..8388607：正常的3字节数据推送; （03 FF FF FF）..（03 00 80 80）和（03 00 80 00）..（03 FF FF 7F）</li><li>-2147483647 ..- 8388608和8388608..2147483647：正常的4字节数据推送; （04 FF FF FF FF）..（04 00 00 80 80）和（04 00 00 80 00）..（04 FF FF FF 7F）</li><li>任何其他数字都不能被编码。</li></ul><p>特别要注意的是，如果允许使用非最短格式，则零可以编码为（01 80）（负零）。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>交易中继发布了一个新的节点软件版本，它使v3交易标准化，并在scriptSigs满足上述规则时中继它们。v1交易的中继不受影响。支付v3交易创建的输出的v1交易也不受影响。</p><p>电子钱包更新由于v3交易目前是非标准的，因此无法立即开始创建它们。可以检查软件以确认新的规则，但只有当网络的重要部分已升级到兼容的代码时才能启动v3。它的意图是“我希望这个交易受到延展保护”，并且仍然是钱包软件的选择。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzUzODYzMzk2" title="https://www.zhihu.com/question/53863396">比特币的交易延展性指的是什么？<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGtldmluL2Jsb2cuYmlxdS5pby9ibG9iL21hc3Rlci9zb3VyY2UvX3Bvc3RzLzIwMTMtMTAtMjctYml0Y29pbi10cmFuc2FjdGlvbi0wMi5tYXJrZG93bg==" title="https://github.com/bitkevin/blog.biqu.io/blob/master/source/_posts/2013-10-27-bitcoin-transaction-02.markdown">交易的构造、签名与广播<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9ja2NoYWluLmlldGhwYXkuY29tL3RyYW5zYWN0aW9uLW1hbGxlYWJpbGl0eS5odG1s" title="https://blockchain.iethpay.com/transaction-malleability.html">比特币中交易延展性问题<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly8wZGF5emguZ2l0Ym9va3MuaW8vYml0Y29pbl9kZXZlbG9wZXJfZ3VpZGUvY29udGVudC90cmFuc2FjdGlvbl9tYWxsZWFiaWxpdHkuaHRtbA==" title="https://0dayzh.gitbooks.io/bitcoin_developer_guide/content/transaction_malleability.html">交易延展性 | Transaction Malleability<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iaXRjb2luLm9yZy9lbi9kZXZlbG9wZXItZ3VpZGUjYXZvaWRpbmcta2V5LXJldXNl" title="https://bitcoin.org/en/developer-guide#avoiding-key-reuse">Transaction Malleability<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLzIwMTgvMDMvMjgvYmxvY2tjaGFpbi9CSVAtNjIlRTUlQTQlODQlRTclOTAlODYlRTUlQkIlQjYlRTUlQjElOTUlRTYlODAlQTclRTYlOTQlQkIlRTUlODclQkIv" title="http://localhost:4000/2018/03/28/blockchain/BIP-62%E5%A4%84%E7%90%86%E5%BB%B6%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB/">bips/bip-0062.mediawiki<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交易替换 </tag>
            
            <tag> BIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于以太坊的签名</title>
      <link href="//blockchain/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%AD%BE%E5%90%8D.html"/>
      <url>//blockchain/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%AD%BE%E5%90%8D.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>在之前的博文当中我们已经提到过关于区块链技术的基础密码学之<a href="/2018/03/26/算法/关于椭圆曲线的理解/">椭圆曲线</a>的知识.</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在正常的ecdsa算法中发现签名都是（r,s），但是以太坊中的签名返回好像还有一个v，而且在RFC6979中也没有提到这个v，我实在不知道这个v到底是一个什么的东西，今天特地来深入地研究一番。</p><p>这个v其实是用于椭圆曲线点恢复使用的，在椭圆曲线中（ecdsa）点的y轴是经过mod p的，这样你获得的点可能是经过转换的，你可以查看<span class="exturl" data-url="aHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8zODM1MS9lY2RzYS12LXItcy13aGF0LWlzLXY=" title="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v">ECDSA: (v, r, s), what is v?<i class="fa fa-external-link"></i></span>。另外比特币中是直接使用v=0|1，但是以太坊中v=27|28，这又是为啥呢？这主要是为了防止被攻击，可以查看<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3NjYvd2hhdC1kb2VzLXYtci1zLWluLWV0aC1nZXR0cmFuc2FjdGlvbmJ5aGFzaC1tZWFu" title="https://ethereum.stackexchange.com/questions/15766/what-does-v-r-s-in-eth-gettransactionbyhash-mean">What does v, r, s in eth_getTransactionByHash mean?<i class="fa fa-external-link"></i></span>中的回答，主要的说明在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvaXNzdWVzLzE1NQ==" title="https://github.com/ethereum/EIPs/issues/155">EIP 155<i class="fa fa-external-link"></i></span>当中。</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>实施签名需要两个部分：待签名的数据+实施签名的账户。签名过程可以使用web3.eth.sign()来实现，具体代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; let msg = web3.sha3(&apos;today is 20171026&apos;)</span><br><span class="line">&gt; let signature = web3.eth.sign(address, msg)</span><br><span class="line">0x125a275046b65a96f11fdb7cd1072054e67526a76f54b1622fde4e4592d6fe2d5bf664ace77da52c6f94f08a56077e5d7a80048f70c38a92169205df3c9c43ea1b</span><br></pre></td></tr></table></figure><p></p><p>该返回值总共132字节（去掉前面的’0x’的话是130字节）。因为以太坊采用的ECDSA签名算法，根据ECDSA: (v, r, s), what is v?的介绍， 返回值可以分为三个部分：r, s, v。其中前0~66个字节为r， 66~130之间的字节为s， 130~132的字节为v。代码实现如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let r = signature.slice(0, 66)</span><br><span class="line">let s = &apos;0x&apos; + signature.slice(66, 130)</span><br><span class="line">let v = &apos;0x&apos; + signature.slice(130, 132)</span><br><span class="line">v = web3.toDecimal(v)</span><br></pre></td></tr></table></figure><p></p><p>接下来我们可以将它打印出来，在接下来验证签名的部分会用到。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><b style="color:red">签名完成了，我们如何验证某些签名后的数据是哪个账户签名的呢？在web3.js 发布1.0版本以前，验证签名只能通过智能合约的ecrecover函数来实现</b>。新版的web3.js提供了web3.eth.accounts.recover函数用于验证签名。这里我们仍然使用传统的智能合约ecrecover方式。</p><p>ecrecover接收数据的哈希值以及r/s/v等参数作为输入，返回实施该签名的账户地址。因此我们只需要通过合约拿到实施签名的地址，和我们真正的地址进行对比，如果地址一致，就说明验证通过了。</p><p><b style="color:red">智能合约代码如下：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.15;</span><br><span class="line">// 专门写了一个用于验证签名的合约呀</span><br><span class="line">contract Auth &#123;      </span><br><span class="line">    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(address retAddr) &#123;</span><br><span class="line">      bytes memory prefix = &quot;\x19Ethereum Signed Message:\n32&quot;;</span><br><span class="line">      bytes32 prefixedHash = sha3(prefix, hash);</span><br><span class="line">      // 验证过程(这里就可以看出，通过v返回address)</span><br><span class="line">      return ecrecover(prefixedHash, v, r, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来我们调用合约进行交互：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const contract=web3.eth.contract(abi).at(&apos;0x2e2A4cD2869862492C744307310847466c008257&apos;);</span><br><span class="line">console.log(contract.verify(msg, v, r, s));</span><br><span class="line">console.log(address)</span><br></pre></td></tr></table></figure><p></p><p>本地执行结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node sign.js</span><br><span class="line">0xe0803904cbfce8e07745e1b404de43ce6f1e43bc</span><br><span class="line">0xe0803904cbfce8e07745e1b404de43ce6f1e43bc</span><br></pre></td></tr></table></figure><p></p><p>可以看到实施签名的地址和验证后返回的地址一致，签名通过验证。在以太坊中完成对数据的签名和验证还是比较简单的。并且账户不仅可以对交易进行签名，还可以对任意数据进行签名并验证。</p><p><b style="color:red">还有就是我们可以通过发合约来利用solidity帮我们处理一些自己写代码比较复杂的事情，比如说这里的验证签名，这个是一个很好的思路，记下了！</b></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><b style="color:#00f">签名的算法比较奇特，这里我在网上搜索资料的时候发现了一篇<span class="exturl" data-url="aHR0cDovL3d3dy41Yml0ZS5jb20vcG9zdC84NjIuaHRtbA==" title="http://www.5bite.com/post/862.html">DFINITY区块链：密码学技术介绍<i class="fa fa-external-link"></i></span>，我们先不理会这里面关于密码学深入的问题，里面的图其实和椭圆曲线大概是一致的，因为椭圆曲线中基点不停地加之后就是将所有的点联系起来，也就形成了这篇文章中的那些点线。感觉之前在看椭圆曲线的时候，还停留在代数基础上，其实去掉理论就会发现现在变成图了。然后思维就被打开了。</b></p><p>关于验签是如何成功返回公钥的，这个可能是去找所有的公钥进行匹配，哪个公钥成功了就是这个人前的吧！不过确实合约中好像没有公钥，那么这个公钥是如何生成的呢？这个需要进一步地学习，我想生成是可以的因为有私钥，基点等数据，关键就是k这个值。因为<code>P=k*G</code>，只要从公式中导出这个就可以了。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDQ4MTI5Mg==" title="https://zhuanlan.zhihu.com/p/30481292">基于以太坊(Ethereum)完成对数据的签名及验证<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL21lLnRyeWJsb2NrY2hhaW4ub3JnL3dlYjNqcy1zaWduLWVjcmVjb3Zlci1kZWNvZGUuaHRtbA==" title="http://me.tryblockchain.org/web3js-sign-ecrecover-decode.html">区块链语言Solidity校验椭圆曲线加密数字签名（附实例）<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> ecdsa </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隔离见证、闪电网络理解</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E7%90%86%E8%A7%A3.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E3%80%81%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>我记得刚开始接触区块链的时候应该是2017年12月份左右，后来就投入到项目的开发中，但是对于区块链基础知识的学习，我想我还是差得很远，当时去理解隔离见证和雷电网络的时候有点捉襟见肘，大概的意思吧！现在也明白了这里面的意思，但是觉得还是需要写一篇博客记录一下，免得自己又忘记了，这可不是什么好现象。</p><h2 id="隔离见证"><a href="#隔离见证" class="headerlink" title="隔离见证"></a>隔离见证</h2><p>隔离见证已经于2017年8月在比特币上激活了。最近比特币正在朝着下一个扩容方案努力，闪电网络 Lightning Network。闪电网络的启动必须基于更多的用户使用隔离见证地址。</p><h3 id="源起"><a href="#源起" class="headerlink" title="源起"></a>源起</h3><p>现在的比特币网络交易量特别大，但是区块10分钟一个，一个区块限制1M大小，这就造成了比特币网络的拥堵。如果大家了解交易结构就一定知道加解密脚本，这些脚本都是放在区块里面的，于是大家就想如何能把脚本从区块中拿出来单独存储，这样一个区块不就可以容纳更多的交易了吗？于是下图的结构就出现了：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%9A%94%E7%A6%BB%E8%A7%81%E8%AF%81%E5%8C%BA%E5%9D%97%E5%9B%BE%E8%A7%A3.jpg?raw=true"></p><p>隔离见证的其中一个好处是能缓解我们交易堵塞的问题。但是最重要的是为了闪电网络铺路。一种建立在比特币底层网络的智能合约。</p><p>隔离验证确实不是很好的解决之道，因为脚本还是需要存储的，没有脚本的交易，那么这个交易是不是可以随便花费。另外对于钱包节点都是要去检查脚本的准确性，这个还是需要有脚本数据的，所以这个也不是简单的事情吧！</p><h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p>隔离见证可以应用软分叉或者硬分叉，当然最终实施的是软分叉。新的节点是可以兼容后者的，但是旧节点是不是兼容新版本的区块这个是需要考虑的，如果不兼容那么就肯定出现软分叉。但是官方的说明是旧版本的节点不用升级，这句话的话外之音就是旧节点也是支持新版的区块（包含隔离见证）。看来这项技术很好。至于BCH应该是人为的硬分叉了。这部分知识可参考<span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC00NTgzMy0xLTEuaHRtbA==" title="http://8btc.com/thread-45833-1-1.html">隔离见证比任何硬分叉都高级<i class="fa fa-external-link"></i></span></p><p>上篇的文章中提到了Core团队很多的问题，也许确实有问题，但是作为开发者，考虑前后版本兼容也是应该的，毕竟谁都不想出问题。另外还有一点就是一旦一个项目上线，可做的可能真的就不多了，一是改动复杂，程序员不想动，二是工作量比较大！对于这场战争我还是当个第三者吧，看惯了公司风风雨雨，拿刀开干的人还是很少的。一旦变革失败也不会有人同情，core团队可能有自己的考量。毕竟对于资本市场来说一切都是那么的浮躁。</p><h2 id="闪电网络"><a href="#闪电网络" class="headerlink" title="闪电网络"></a>闪电网络</h2><p>闪电网络提供了一个可扩展的微支付通道网络。交易双方若在区块链上预先设有支付通道，就可以多次、高频、双向地通过轧差方式实现瞬间确认的微支付；双方若无直接的点对点支付通道，只要网络中存在一条连通双方的、由多个支付通道构成的支付路径，闪电网络也可以利用这条支付路径实现资金在双方之间的可靠转移。</p><p>上面的这段话可能比较难于理解，总的来说就是通过多签名实现多重交易的划分，这里需要了解比<a href="/2018/03/16/blockchain/bitcoin智能合约的实现/">特币的智能合约</a>和<a href="/2018/03/17/blockchain/bitcoin脚本解析/">P2SH脚本</a>的相关知识。</p><p><b style="color:red">闪电网络并不试图解决单次支付的银货对付问题，其假设是单次支付的金额足够小，即使一方违约另一方的损失也非常小，风险可以承受。因此使用时必须注意“微支付”这个前提。多少资金算“微”，显然应该根据业务而定。</b></p><h3 id="技术本质"><a href="#技术本质" class="headerlink" title="技术本质"></a>技术本质</h3><p><b style="color:red">闪电网络的关键技术有三，后后依赖于前前，依次是：RSMC，HTLC和闪电网络。技术实现虽然复杂，但本质却很简单。</b></p><p><b style="color:#00f">RSMC解决了通道中币单向流动问题，HTLC解决了币跨节点传递的问题。这两个类型的交易组合构成了闪电网络。这里面还会用到我们之前提到的<a href="/2018/03/26/blockchain/BIP-65%20OP-CHECKLOCKTIMEVERIFY/">BIP-65 OP_CHECKLOCKTIMEVERIFY</a>和<a href="/2018/03/26/blockchain/BIP-68使用共识序列号记录相对锁定时间/">BIP-68使用共识序列号记录相对锁定时间</a>，这两篇文档提到了交易锁定的问题，也提到了分叉的问题。</b></p><h3 id="RSMC"><a href="#RSMC" class="headerlink" title="RSMC"></a>RSMC</h3><p>我们先来创建一个序列到期可撤销合约（RSMC），Alice和Bob是合作方，经常有比特币往来，所以他们决定各拿出0.5BTC放入<b style="color:red">通道</b>中，便于业务往来。解释一下下方RSMC交易的结构（图X），左侧为Alice的视角，右侧为Bob的视角。中间Funding Tx为共同可见，C1a和RD1a为Alice持有，C1b和RD1b为Bob持有。交易图中带有尖括号的签名表示待填入。</p><h4 id="创建交易"><a href="#创建交易" class="headerlink" title="创建交易"></a>创建交易</h4><p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/blockchain/RSMC%E4%BA%A4%E6%98%93%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><p>来对上面的图进行一番解释：</p><ol><li>双方各拿出0.5BTC，构建Funding Tx，输出为Alice和Bob的2/2多重签名。此时，Funding Tx未签名，更不广播。</li><li>Alice构造Commitment Tx：C1a和RD1a，并交给Bob签名。C1a的第一个输出为多重签名地址，Alice的另一把私钥Alice2和Bob的2/2多重签名，第二个输出为Bob 0.5BTC。</li><li>RD1a为C1a第一个输出的花费交易，输出给Alice0.5BTC，但此类型交易带有sequence，作用是阻止当前交易进块，只有前向交易有sequence个确认时才能进块。</li><li>Bob构造Commitment Tx：C1b和RD1b，并交给Alice签名。结构与C1a、RD1a是对称关系。</li><li>Bob对C1a和RD1a进行签名，并将签名给Alice；同理，Alice对C1b和RD1b签名，完成后给Bob。此时，由于并未对Funding Tx进行签名，任何一方均无法作恶，任何一方也不会有任何损失。</li><li>双方均完成对commitment Tx的签名并交换后，各自再对Funding Tx进行签名，并交换。此时，Funding Tx是完整的交易，广播之。</li></ol><p>上述过程以及结构图的描述，就是创建RSMC的全部过程。C1a, C1b两笔交易花费的是同一个输出，故他们两个交易只有一个能进块。若Alice广播C1a，则Bob立即拿到0.5BTC（C1a的第二个输出），而Alice需要等C1a得到1000个确认，才能通过RD1a的输出拿到0.5BTC。另一方，若Bob广播C1b，则Alice立即拿到0.5BTC，Bob等待C1b得到1000个确认，才能通过RD1b拿到0.5BTC。也就是说，单方广播交易终止合约的那一方会延迟拿到币，而另一放则立即拿币。</p><h4 id="交易更新"><a href="#交易更新" class="headerlink" title="交易更新"></a>交易更新</h4><p>Alice和Bob各自0.5BTC的余额，此时Alice从Bob处购买了一件商品，价格为0.1BTC，那么余额应该变为Alice 0.4BTC，Bob 0.6BTC。于是创建新的Commitment Tx，对于Alice来说是C2a 和RD2a，对于Bob来说是C2b和RD2b，过程与上面类似。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%98%93%E6%9B%B4%E6%96%B0.jpg?raw=true"></p><p>此时两个状态均是有效的，那么最核心的问题来了，如何才能彻底废弃掉C1a和C1b呢？<br>RSMC采用了一个非常巧妙的方法，在C1a的第一个输出中，采用了Alice2和Bob的多重签名，Alice将Alice2的私钥交给Bob，即表示Alice放弃C1a，承认C2a。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%98%93%E6%9B%B4%E6%96%B02.jpg?raw=true"></p><p>Alice交出Alice2的私钥给Bob，那么Bob就可以修改RD1a的输出给他自己，形成新的交易BR1a。若Alice破坏合约存在C2a的情况下依然广播出C1a，那么Alice的惩罚就是失去她全部的币。Alice交出Alice2的私钥，或者对交易BR1a进行签名，两者是等同的，都是对C1a的放弃。反之亦然，Bob交出Bob2的私钥给Alice即意味放弃C1b，而仅能认可C2b。引入sequence的目的是，阻止后续交易进块（RD1a），给出一个实施惩罚窗口期，当发现对方破坏合约时，可以有1000个块确认的时间去实施惩罚交易，即广播BR1a代替RD1a。若错过1000个块时间窗口，则无法再实施惩罚了（RD1a进块了）。</p><h4 id="交易关闭"><a href="#交易关闭" class="headerlink" title="交易关闭"></a>交易关闭</h4><p>关闭RSMC，直接按照最终的余额构造出一个Commitment TX即可，例如输出为Alice0.1BTC，Bob0.9BTC，无需再设置多重签名，构造惩罚交易等。</p><h4 id="中转交易（真实的闪电网络，HTLC）"><a href="#中转交易（真实的闪电网络，HTLC）" class="headerlink" title="中转交易（真实的闪电网络，HTLC）"></a>中转交易（真实的闪电网络，HTLC）</h4><p>我们来看一下基本的流程图吧！<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%BD%AC%E4%BA%A4%E6%98%93%E5%9B%BE.png?raw=true"><br>这里面的R就是支付的口令，其实就是交易节点之间没有直连的通道，需要其他人待转，这些人会收手续费。这里面需要解决几个问题（我的思考）：</p><ol><li>如何建立初始的支付通道</li><li>如果两个节点间无直接支付通道，如何找到最佳的支付通道。</li><li>如何保证第三方不作弊，防止现金丢失（前面的讲的都是这个问题）</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="RSMC-1"><a href="#RSMC-1" class="headerlink" title="RSMC"></a>RSMC</h4><p>闪电网络的基础是交易双方之间的双向微支付通道，RSMC（Recoverable Sequence Maturity Contract）定义了该双向微支付通道的最基本工作方式。这是要求双方都拿出资金放到合约上，然后输出动态分配，最后确认输出后上链，这样的好处就是支付完全是在链下执行。</p><p><b style="color:red">为了鼓励双方尽可能久地利用通道进行交易，RSMC对主动终止通道方给予了一定的惩罚：主动提出方其资金到账将比对方晚，因此谁发起谁吃亏。这个设计虽然增加了技术复杂度，但应该说是合理的。</b> 这样许多交易就会在区块链下面执行，不会产生交易（只产生预备交易），最后交易才会上链。还有就是交易的凭证怎么保证？所以这个方式或许也有很多技术和现实的缺陷所在。</p><p><b style="color:red">通道余额分配方案的本质是结算准备金。在此安排下，因为要完全控制资金交收风险，每笔交易都不能突破当前结算准备金所施限制。</b></p><h4 id="HTLC"><a href="#HTLC" class="headerlink" title="HTLC"></a>HTLC</h4><p>RSMC只支持最简单的无条件资金支付，HTLC（Hashed Timelock Contract）进一步实现了有条件的资金支付，通道余额的分配方式也因此变得更为复杂。</p><p>通过HTLC，Alice和Bob可以达成这样一个协议：协议将锁定Alice的0.1 BTC，在时刻T到来之前（T以未来的某个区块链高度表述），如果Bob能够向Alice出示一个适当的R（称为秘密），使得R的哈希值等于事先约定的值H(R)，Bob就能获得这0.1 BTC；如果直到时刻T过去Bob仍然未能提供一个正确的R，这0.1 BTC将自动解冻并归还Alice。</p><h2 id="雷电网络"><a href="#雷电网络" class="headerlink" title="雷电网络"></a>雷电网络</h2><p>基于闪电网络的思路，以太坊社区也提出了自己的链下微支付通道解决方案：雷电网络（Raiden Network）。<br>延续了以太坊的风格，把本来较简单的问题复杂智能化。大致与闪电网络相同，但细节有些地方更复杂。例如：第一层面的那个旧版本作废，其实只要加上时间戳看哪个时间新就可以了。但是其额外增加了一个单增的Sequence Number字段来标明哪个有效。还有记录分配余额即可，但雷电网络记录的是增减变动量。在第二个层面上，雷电网络引入了较HTLC更通用和复杂的“Smart Condition”。就是说HTLC中采用的成熟简单地求HASH函数，在雷电网络中替代成了用户可自己设置的任意函数，就是说向外扩展了，更加智能，但同时面临的风险可能就越大。</p><h2 id="Corda"><a href="#Corda" class="headerlink" title="Corda"></a>Corda</h2><p>相近技术的低层思想是相通的，受到闪电网络思想的启发，知名的R3也宣布发布非区块链的分布式账本应用Corda，其本质思想应该是与闪电网络较相近似。<br>关于Corda的资料较少，如整个R3较闭源封闭一样，只是R3 CEV的首席技术官Richard Brown之前在博客中披露些Corda的主要特点：</p><ol><li>没有多余的全局数据共享：有合法需求的参与方才可按照协议获取数据；</li><li>Corda编写和配置在企业间流转，无中心控制者；</li><li>Corda在企业间单个交易水平达成共识，而不是在系统水平上；</li><li>系统设计直接支持监管观察员节点；</li><li>交易直接由交易双方验证，而不是由一大群不相干的验证者进行；</li><li>支持多种共识机制；</li><li>记录了智能合约代码和人类语言法律文件的清晰联系；</li><li>用行业标准工具创建；</li><li>没有原始加密货币。</li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>将交易和智能合约的执行放在链下快速地执行，仅在必要时才将其在链上公开结算执行，这就是闪电网络带给我们的绝佳思路。同时可增加对闪电结链上算时的手续费，减轻链上压力的同时有可能提升矿工收入，因理论上不可能所有交易都闪电。比特币主链上交易有其它任何形式链下交易或侧链交易所无法替代的优点。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjYxMzQ4Nw==" title="https://zhuanlan.zhihu.com/p/32613487">三分钟让你了解什么是Segwit隔离见证<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC00NTgzMy0xLTEuaHRtbA==" title="http://8btc.com/thread-45833-1-1.html">隔离见证比任何硬分叉都高级<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9iaXRjb2luLWV4cGFuc2lvbi1wcm9ibGVt" title="http://www.8btc.com/bitcoin-expansion-problem">比特币扩容为什么选择2MB？<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ2NTE1NDU3" title="https://www.zhihu.com/question/46515457">什么是比特币的闪电网络？<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU4NTY3MDYx" title="https://www.zhihu.com/question/58567061">什么是隔离见证？<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9sbi1ybi1jb3JkYQ==" title="http://www.8btc.com/ln-rn-corda">详解最近大热的闪电网络、雷电网络和CORDA<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbE0wcDNpa1ZCZHcxekU1MElXdE1aQQ==" title="https://mp.weixin.qq.com/s/lM0p3ikVBdw1zE50IWtMZA">6.9Bite酱一闪电网络⚡大白话零门槛讲解<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隔离见证 </tag>
            
            <tag> 闪电网络 </tag>
            
            <tag> 雷电网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIP-65 OP_CHECKLOCKTIMEVERIFY</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-65%20OP-CHECKLOCKTIMEVERIFY.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-65%20OP-CHECKLOCKTIMEVERIFY.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该BIP为比特币脚本系统描述了一个新的操作码（OP_CHECKLOCKTIMEVERIFY），该操作码允许交易输出在未来的某个点之前变得不可花费。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><b style="color:#00f">CHECKLOCKTIMEVERIFY重新定义了现有的NOP2操作码(其实就是OP_CHECKLOCKTIMEVERIFY命令替换了OP_NOP2命令)。执行时，如果以下任何一个条件成立，则脚本解释器将以错误终止：</b></p><ul><li>堆栈是空的;</li><li>堆栈中的顶层项目小于0;</li><li>顶层堆栈项的锁定时间类型（高度vs.时间戳）与nLockTime字段不同;</li><li>顶部堆栈项大于事务的nLockTime字段;</li><li>txin（交易输入）的nSequence字段是0xffffffff;</li></ul><p>否则，脚本执行将继续，如同NOP执行一样。</p><p>交易中的nLockTime字段可防止事务被挖掘，直到达到某个块高度或块时间为止。通过将传给CHECKLOCKTIMEVERIFY的参数与nLockTime字段进行比较，我们间接验证是否已达到所需的块高度或块时间; 直到该块高度或块时间已经达到，交易输出仍然不可花费。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>交易中的nLockTime字段可用于证明 将来可以花费这笔交易输出，方法是构造一个有效的交易开销，并对nLockTime字段进行设置。</p><p>然而，nLockTime字段不能证明在未来的某个时间内不可能花费交易输出，因为无法知道是否创建了支出该输出的其他交易的有效签名。</p><h2 id="第三方托管"><a href="#第三方托管" class="headerlink" title="第三方托管"></a>第三方托管</h2><p><b style="color:red">如果Alice和Bob联合经营一家企业，他们可能希望确保所有资金都保存在需要双方合作支出的二分之二的多重（多签名的交易）交易输出中。但是，他们认识到，在特殊情况下，例如任何一方受到“巴士撞击”，他们都需要备份计划来检索资金。因此，他们任命他们的律师Lenny担任第三方。</b></p><p>在任何时候，Lenny都可以与Alice或Bob合谋窃取资金，这是一个标准的2分之3 多签名。同样，Lenny可能宁愿不立即获得资金，以阻止居心不良的人试图暴力获取他的密钥。</p><p>但是，使用CHECKLOCKTIMEVERIFY可以将资金存储在以下格式的scriptPubKeys中：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line">    &lt;now + 3 months&gt; CHECKLOCKTIMEVERIFY DROP</span><br><span class="line">    &lt;Lenny&apos;s pubkey&gt; CHECKSIGVERIFY</span><br><span class="line">    1</span><br><span class="line">ELSE</span><br><span class="line">    2</span><br><span class="line">ENDIF</span><br><span class="line">&lt;Alice&apos;s pubkey&gt; &lt;Bob&apos;s pubkey&gt; 2 CHECKMULTISIG</span><br></pre></td></tr></table></figure><p></p><p>在任何时候，资金都可以用下面的脚本来支付：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;Alice&apos;s signature&gt; &lt;Bob&apos;s signature&gt; 0</span><br></pre></td></tr></table></figure><p></p><p>Lenny经过3个月后，Alice或Bob中的一个可以用以下脚本支付资金：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;Alice/Bob&apos;s signature&gt; &lt;Lenny&apos;s signature&gt; 1</span><br></pre></td></tr></table></figure><p></p><h2 id="非交互式时间锁定退款"><a href="#非交互式时间锁定退款" class="headerlink" title="非交互式时间锁定退款"></a>非交互式时间锁定退款</h2><p>存在许多协议，其中创建交易输出，这需要双方的合作来花费输出。为确保一方的失败不会导致资金损失，退款交易使用nLockTime提前设置。这些退款交易需要交互式创建，此外，目前易受交易延展性影响。CHECKLOCKTIMEVERIFY可用于这些协议，用非交互式设置取代交互式设置，另外，使交易延展性不成问题。</p><h3 id="双因素钱包"><a href="#双因素钱包" class="headerlink" title="双因素钱包"></a>双因素钱包</h3><p>诸如GreenAddress之类的服务将比特币存储为2比2的多签名脚本ScriptPubKey，使得一个密钥对由用户控制，另一个密钥对由服务控制。为了花费资金，用户使用本地安装的生成所需签名之一的钱包软件，然后使用第二因素身份验证方法来授权该服务创建第二个SIGHASH_NONE签名，该签名在将来的某个时间被锁定，并向用户发送该存储签名。如果用户需要花费资金并且服务不可用，他们会等到nLockTime过期。</p><p>问题是，在许多情况下，用户将不会拥有一些或全部交易输出的有效签名。使用CHECKLOCKTIMEVERIFY而不是按需创建退款签名而是使用以下形式的scriptPubKeys：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line">    &lt;service pubkey&gt; CHECKSIGVERIFY</span><br><span class="line">ELSE</span><br><span class="line">    &lt;expiry time&gt; CHECKLOCKTIMEVERIFY DROP</span><br><span class="line">ENDIF</span><br><span class="line">&lt;user pubkey&gt; CHECKSIG</span><br></pre></td></tr></table></figure><p></p><p>现在，用户总是能够在没有服务合作的情况下花费他们的资金，等待到期时间的到来。</p><h3 id="付款渠道"><a href="#付款渠道" class="headerlink" title="付款渠道"></a>付款渠道</h3><p>Jeremy Spilman风格的支付渠道首先设置一个存款，由2-of-2的多签名，tx1控制的存款，然后调整第二个交易tx2，将tx1的输出用于支付者和收款者。在发布tx1之前，创建一个退款交易tx3，以确保收款人是否可以清除付款人的存款。创建退款交易的过程目前易受交易延展性攻击的影响，此外还要求付款人存储退款。使用与双因子钱包示例中相同的scriptPubKey形式解决了这两个问题。</p><h2 id="用于发布数据的无信任支付"><a href="#用于发布数据的无信任支付" class="headerlink" title="用于发布数据的无信任支付"></a>用于发布数据的无信任支付</h2><p>PayPub协议可以通过首先证明加密文件包含所需数据，然后制作用于付款的scriptPubKeys来支付以无信任方式付款的信息，以便花费它们显示数据的加密密钥。然而，现有的实现有一个重大缺陷：发布者可以无限期地推迟密钥的发布。</p><p>这个问题可以用退款交易技术交互地解决; 使用CHECKLOCKTIMEVERIFY，可以使用以下形式的scriptPubKeys以非交互方式解决问题：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF</span><br><span class="line">    HASH160 &lt;Hash160(encryption key)&gt; EQUALVERIFY</span><br><span class="line">    &lt;publisher pubkey&gt; CHECKSIG</span><br><span class="line">ELSE</span><br><span class="line">    &lt;expiry time&gt; CHECKLOCKTIMEVERIFY DROP</span><br><span class="line">    &lt;buyer pubkey&gt; CHECKSIG</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">数据的买家现在正在提供一个有效期限的安全报价。如果发行商在到期时间到期之前未能接受报价，买家可以通过消费输出来取消报价。</b></p><h2 id="证明牺牲矿工的收费"><a href="#证明牺牲矿工的收费" class="headerlink" title="证明牺牲矿工的收费"></a>证明牺牲矿工的收费</h2><p>证明牺牲一些有限的资源是各种密码协议中的常见技术。已经提出将硬币的牺牲证明为采矿费，作为牺牲可以指向的普遍公共物品，而不是简单地摧毁硬币。然而，这样做并非微不足道，即使是最好的现有技术 - 宣布 - 承诺 - 也会鼓励矿业集中。CHECKLOCKTIMEVERIFY可用于创建任何人都可以花费的产出（因此，假设矿工的行为是理想的和理性的，那么开采费），但只有在未来足够远的时间，大型矿工才能以折扣销售牺牲品。</p><h2 id="冻结资金"><a href="#冻结资金" class="headerlink" title="冻结资金"></a>冻结资金</h2><p>除了使用冷存储，硬件钱包和P2SH multisig输出来控制资金之外，现在资金可以直接在区块链中冻结在UTXO中。使用下面的scriptPubKey，在提供的失效时间之前，没有人能够使用安全输出。这种可靠地冻结资金的能力在需要减少胁迫或没收风险的情况下可能会有用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;expiry time&gt; CHECKLOCKTIMEVERIFY DROP DUP HASH160 &lt;pubKeyHash&gt; EQUALVERIFY CHECKSIG</span><br></pre></td></tr></table></figure><p></p><h2 id="完全替换nLockTime字段"><a href="#完全替换nLockTime字段" class="headerlink" title="完全替换nLockTime字段"></a>完全替换nLockTime字段</h2><p>另外，请注意如果SignatureHash()算法可以选择覆盖脚本的一部分，那么签名可能会要求脚本Sig包含CHECKLOCKTIMEVERIFY操作码，并且还需要执行它们。（CODESEPARATOR操作码非常接近于在比特币的v0.1中实现这一点）。这种每签名功能可以完全取代每个交易的nLockTime字段，因为有效签名现在可以证明交易输出可以花费。</p><h2 id="详细规则"><a href="#详细规则" class="headerlink" title="详细规则"></a>详细规则</h2><p>参考下面转载的参考实现，了解这些语义的精确语义和详细基本原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">case OP_NOP2:</span><br><span class="line">&#123;</span><br><span class="line">    // CHECKLOCKTIMEVERIFY</span><br><span class="line">    //</span><br><span class="line">    // (nLockTime -- nLockTime )</span><br><span class="line"></span><br><span class="line">    if (!(flags &amp; SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))</span><br><span class="line">        break; // not enabled; treat as a NOP</span><br><span class="line"></span><br><span class="line">    if (stack.size() &lt; 1)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // Note that elsewhere numeric opcodes are limited to</span><br><span class="line">    // operands in the range -2**31+1 to 2**31-1, however it is</span><br><span class="line">    // legal for opcodes to produce results exceeding that</span><br><span class="line">    // range. This limitation is implemented by CScriptNum&apos;s</span><br><span class="line">    // default 4-byte limit.</span><br><span class="line">    //</span><br><span class="line">    // If we kept to that limit we&apos;d have a year 2038 problem,</span><br><span class="line">    // even though the nLockTime field in transactions</span><br><span class="line">    // themselves is uint32 which only becomes meaningless</span><br><span class="line">    // after the year 2106.</span><br><span class="line">    //</span><br><span class="line">    // Thus as a special case we tell CScriptNum to accept up</span><br><span class="line">    // to 5-byte bignums, which are good until 2**32-1, the</span><br><span class="line">    // same limit as the nLockTime field itself.</span><br><span class="line">    const CScriptNum nLockTime(stacktop(-1), 5);</span><br><span class="line"></span><br><span class="line">    // In the rare event that the argument may be &lt; 0 due to</span><br><span class="line">    // some arithmetic being done first, you can always use</span><br><span class="line">    // 0 MAX CHECKLOCKTIMEVERIFY.</span><br><span class="line">    if (nLockTime &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // There are two types of nLockTime: lock-by-blockheight</span><br><span class="line">    // and lock-by-blocktime, distinguished by whether</span><br><span class="line">    // nLockTime &lt; LOCKTIME_THRESHOLD.</span><br><span class="line">    //</span><br><span class="line">    // We want to compare apples to apples, so fail the script</span><br><span class="line">    // unless the type of nLockTime being tested is the same as</span><br><span class="line">    // the nLockTime in the transaction.</span><br><span class="line">    if (!(</span><br><span class="line">            (txTo.nLockTime &lt;  LOCKTIME_THRESHOLD &amp;&amp; nLockTime &lt;  LOCKTIME_THRESHOLD) ||</span><br><span class="line">            (txTo.nLockTime &gt;= LOCKTIME_THRESHOLD &amp;&amp; nLockTime &gt;= LOCKTIME_THRESHOLD)</span><br><span class="line">            ))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // Now that we know we&apos;re comparing apples-to-apples, the</span><br><span class="line">    // comparison is a simple numeric one.</span><br><span class="line">    if (nLockTime &gt; (int64_t)txTo.nLockTime)</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    // Finally the nLockTime feature can be disabled and thus</span><br><span class="line">    // CHECKLOCKTIMEVERIFY bypassed if every txin has been</span><br><span class="line">    // finalized by setting nSequence to maxint. The</span><br><span class="line">    // transaction would be allowed into the blockchain, making</span><br><span class="line">    // the opcode ineffective.</span><br><span class="line">    //</span><br><span class="line">    // Testing if this vin is not final is sufficient to</span><br><span class="line">    // prevent this condition. Alternatively we could test all</span><br><span class="line">    // inputs, but testing just this input minimizes the data</span><br><span class="line">    // required to prove correct CHECKLOCKTIMEVERIFY execution.</span><br><span class="line">    if (txTo.vin[nIn].IsFinal())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGVydG9kZC9iaXRjb2luL2NvbW1pdC9hYjBmNTRmMzhlMDhlZTFlNTBmZjcyZjgwMTY4MGVlODRkMGYxYmY0" title="https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4">https://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4<i class="fa fa-external-link"></i></span></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>我们重用BIP66中使用的双阈值IsSuperMajority()切换机制，其阈值相同，但nVersion=4。新规则对于nVersion=4的每个块（高度为H）有效，并且至少有750之前的块（高度为H-1000..H-1）的nVersion&gt;=4。此外，当块之前的1000个块中的950个具有nVersion&gt;=4时，nVersion&lt;4块将变为无效，并且全部进一步的阻止执行新的规则。</p><p>应该注意的是，BIP9涉及永久性地将高位设置为1，这导致nVersion&gt;=所有先前的IsSuperMajority()软分叉，因此nVersion中的位不会永久丢失。</p><h2 id="SPV客户"><a href="#SPV客户" class="headerlink" title="SPV客户"></a>SPV客户</h2><p>尽管SPV客户端（目前）无法验证块，但相信矿工为他们进行验证，但他们能够验证块头并因此可以验证部署规则的子集。如果达到95％的阈值，如果1000个前面的块中的950个<code>nVersion&gt;=4</code>，则SPV客户端应拒绝<code>nVersion&lt;4</code>块，以防止未升级的矿工剩余的5％发生虚假确认。</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>感谢格雷戈里麦克斯韦提出将参数与每个交易的nLockTime进行比较，而不是当前块的高度和时间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>PayPub</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Vuc3lzdGVtL3BheXB1Yg==" title="https://github.com/unsystem/paypub">https://github.com/unsystem/paypub<i class="fa fa-external-link"></i></span></li></ul><p>Jeremy Spilman付款渠道</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9saXN0cy5saW51eGZvdW5kYXRpb24ub3JnL3BpcGVybWFpbC9iaXRjb2luLWRldi8yMDEzLUFwcmlsLzAwMjQzMy5odG1s" title="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html">https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html<i class="fa fa-external-link"></i></span></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Python / python-bitcoinlib</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGVydG9kZC9jaGVja2xvY2t0aW1ldmVyaWZ5LWRlbW9z" title="https://github.com/petertodd/checklocktimeverify-demos">https://github.com/petertodd/checklocktimeverify-demos<i class="fa fa-external-link"></i></span></li></ul><p>JavaScript / Node.js / bitcore</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ydWRkeS9iaXA2NS1kZW1vcw==" title="https://github.com/mruddy/bip65-demos">https://github.com/mruddy/bip65-demos<i class="fa fa-external-link"></i></span></li></ul><h2 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h2><p>该文件置于公共领域。</p><h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jaGlkYW9saWFuLmNvbS9hcnRpY2xlLTY4MC00" title="http://www.chidaolian.com/article-680-4">BIP65：检查锁定时间验证<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2NS5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">bips/bip-0065.mediawiki<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> locktime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIP-68使用共识序列号记录相对锁定时间</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-68%E4%BD%BF%E7%94%A8%E5%85%B1%E8%AF%86%E5%BA%8F%E5%88%97%E5%8F%B7%E8%AE%B0%E5%BD%95%E7%9B%B8%E5%AF%B9%E9%94%81%E5%AE%9A%E6%97%B6%E9%97%B4.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP-68%E4%BD%BF%E7%94%A8%E5%85%B1%E8%AF%86%E5%BA%8F%E5%88%97%E5%8F%B7%E8%AE%B0%E5%BD%95%E7%9B%B8%E5%AF%B9%E9%94%81%E5%AE%9A%E6%97%B6%E9%97%B4.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>该BIP介绍了的相对锁定时间（RLT），RLT使用序列号字段来实现强一致性语义，以使已签名的交易输入在确认其相应的输出后在限定的时间段内保持无效。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>比特币交易每个输入都有一个序列号字段。最初的想法似乎是mempool中的交易将被替换为具有更高序列值的相同输入。虽然这没有得到很好的实施，但假设即使较低的序列号利润更高，矿工会喜欢较高的序列号。然而，一个仅仅依靠利润动机的矿工会完全打破这个假设。此BIP所描述的更改将重新调整新用例的序列号，而不会破坏现有功能。这也为未来扩展和其他使用情况留下了空间。</p><p><b style="color:red">交易nLockTime用于防止在某个日期之前挖掘交易。nSequence将被重新用于防止交易的挖掘，直到花费在某个时间或时间段内的输出块高的确认</b>。除此之外，此功能还允许使用散列时间片合同（HTLC）和BIP112中使用的双向付款渠道。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><b style="color:red">本规范为nVersion大于或等于2的交易定义了序列号的含义，本规范的其余部分都是基于该规则的。</b></p><p>所有对过去的中位时间（MTP）的定义说明都是由BIP113定义的。</p><p>如果序列号的位（1 &lt;&lt; 31）被设置（最高位被设置），则没有共识含义被应用于序列号，并且可以被包括在当前所有可能情况下的任何块中。</p><p><b style="color:red">如果序列号的位（1 &lt;&lt; 31）未被设置，则序列号被解释为编码的相对锁定时间。</b></p><p>序列号编码解释如下：</p><ul><li><b style="color:red">位（1 &lt;&lt; 22）确定相对锁定时间是基于时间的还是基于块的：如果设置该位，则相对锁定时间以512秒为单位指定时间间隔。时间范围从输出的前一个块的中值时间开始，并在前一个块的MTP结束。如果该位未设置，则相对锁定时间将指定多个块。</b></li><li>标志（1 &lt;&lt; 22）是3字节有符号整数中的最高位，用于比特币脚本，作为带有OP_CHECKSEQUENCEVERIFY（BIP 112）的3字节PUSHDATA。</li></ul><p>本规范仅将序列号的16位解释为相对锁定时间，因此必须将0x0000ffff掩码应用于序列字段以提取相对锁定时间。16位规范允许一年的相对锁定时间，其余位允许将来扩展。</p><p><img alt="" data-src="https://github.com/bitcoin/bips/raw/master/bip-0068/encoding.png"></p><p>对于基于时间的相对锁定时间，选择512秒的粒度，因为比特币块每600秒产生一次。所以当使用基于块或基于时间的时候，可以用可用的位数来编码相同的时间量。从序列号转换为秒是通过乘以<code>512=2^9</code>，或等价地向上移位9位来执行的。</p><p>当相对锁定时间是基于时间的时候，它被解释为输入年龄的最小块时间约束。相对基于时间的零锁定时间表示可以包含在任何块中的输入。更一般地说，相对基于时间的锁定时间n可以被包括在任何在其消费的输出的挖矿开采日期之后512*n秒产生的块中，或者之后的任何块中。输出的开采日期等于先前开采的块的开采时间的中间值。</p><p>块产生时间等于其前一块过去的中值时间。</p><p>当相对锁定时间是基于块的时候，它被解释为输入年龄的最小块高度约束。相对基于块的锁定时间为零表示可以包含在任何块中的输入。更一般地说，一个相对块锁定时间n可以包含在它所花费的输出的开采日期之后的n个块中，或者之后的任何块中。</p><p>新规则不适用于coinbase交易输入的nSequence字段。</p><h2 id="履行"><a href="#履行" class="headerlink" title="履行"></a>履行</h2><p>参考实现由以下拉取请求提供 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9wdWxsLzcxODQ=" title="https://github.com/bitcoin/bitcoin/pull/7184">https://github.com/bitcoin/bitcoin/pull/7184<i class="fa fa-external-link"></i></span></p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>值得一提的是格雷戈里麦克斯韦提供了一个简洁明了的描述这种变化的行为，这成为这个BIP文本的基础。</p><p>BIP由BtcDrak，Nicolas Dorier和kinoshitajona编辑。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>该BIP将通过使用位0的“versionbits”BIP9进行部署。</p><p>对于比特币mainnet，该BIP9 开始时间将是午夜2016年5月1日UTC（大纪元时间戳1462060800）和BIP9 超时将是午夜2017年5月1日UTC（大纪元时间戳1493596800）。</p><p>对于比特币testnet，该BIP9 开始时间将是午夜2016年3月1日UTC（大纪元时间戳1456790400）和BIP9 超时将是午夜2017年5月1日UTC（大纪元时间戳1493596800）。</p><p>该BIP必须与BIP112和BIP113同时部署，使用相同的部署机制。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>比特币核心参考客户端软件唯一使用的序列号是禁用检查事务中的nLockTime约束。该BIP保留了该应用程序的语义。</p><p>从规范部分可以看出，该BIP未定义若干位，以便通过设置位（1 &lt;&lt; 31）来允许其他用例，因为其余31位在此BIP下无意义。另外，当位（1 &lt;&lt; 31）未设置时，位（1 &lt;&lt; 23）至（1 &lt;&lt; 30）根本无意义。</p><p>此外，该BIP仅指定16位来实际编码相对锁定时间，这意味着还有6个位未被使用（1 &lt;&lt; 16至1 &lt;&lt; 21）。这样就可以通过软叉提高粒度，或者增加将来最大可能的相对锁定时间。</p><p>从相对锁定时间计算序列号的最有效方法是使用位掩码和位移：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 0 &lt;= nHeight &lt; 65,535 blocks (1.25 years)</span><br><span class="line">nSequence = nHeight;</span><br><span class="line">nHeight = nSequence &amp; 0x0000ffff;</span><br><span class="line"></span><br><span class="line">// 0 &lt;= nTime &lt; 33,554,431 seconds (1.06 years)</span><br><span class="line">nSequence = (1 &lt;&lt; 22) | (nTime &gt;&gt; 9);</span><br><span class="line">nTime = (nSequence &amp; 0x0000ffff) &lt;&lt; 9;</span><br></pre></td></tr></table></figure><p></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>比特币邮件列表讨论：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWFpbC1hcmNoaXZlLmNvbS9iaXRjb2luLWRldmVsb3BtZW50QGxpc3RzLnNvdXJjZWZvcmdlLm5ldC9tc2cwNzg2NC5odG1s" title="https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg07864.html">https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg07864.html<i class="fa fa-external-link"></i></span></p><p>BIP9：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAwOS5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki<i class="fa fa-external-link"></i></span></p><p>BIP112：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDExMi5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki<i class="fa fa-external-link"></i></span></p><p>BIP113：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDExMy5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki<i class="fa fa-external-link"></i></span></p><p>散列时间片契约（HTLCs）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VsZW1lbnRzUHJvamVjdC9saWdodG5pbmcvcmF3L21hc3Rlci9kb2MvZGVwbG95YWJsZS1saWdodG5pbmcucGRm" title="https://github.com/ElementsProject/lightning/raw/master/doc/deployable-lightning.pdf">https://github.com/ElementsProject/lightning/raw/master/doc/deployable-lightning.pdf<i class="fa fa-external-link"></i></span></p><h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jaGlkYW9saWFuLmNvbS9hcnRpY2xlLTY4MC01" title="http://www.chidaolian.com/article-680-5">BIP68：使用序列号的相对锁定时间<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 共识序列号 </tag>
            
            <tag> 交易锁定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于椭圆曲线的理解</title>
      <link href="//%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84%E7%90%86%E8%A7%A3.html"/>
      <url>//%E7%AE%97%E6%B3%95/%E5%85%B3%E4%BA%8E%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E7%9A%84%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一直觉得加密算法比较神奇，但是比特币中使用的椭圆双曲线算法一直让我感觉很神奇，之前看的时候没有看懂，这次认真看了两篇文档之后，终于理解了这种算法的奇妙之处，看来数学这个东西其实没有大家想像的那么难，也许就是很简单的东西堆砌成一个庞然大物，以至于你不再看得清楚了。</p><p>椭圆曲线的形状,并不是椭圆.是因为椭圆曲线的描述方程,类似于计算一个椭圆的周长的方程得名。</p><h2 id="从阿贝尔群开始"><a href="#从阿贝尔群开始" class="headerlink" title="从阿贝尔群开始"></a>从阿贝尔群开始</h2><p>群的定义是定义了二元操作“运算”并且用符号+表示的一个集合。假定我们要操作的群用 𝔾表示，那么我们在这个群上面要定义的“运算”必须符合以下几个属性：</p><ul><li>闭包。如果a和b都是𝔾的成员，那么a+b也是𝔾的成员。</li><li>组合性。(a+b)+c=a+(b+c)</li><li>单位元。存在确切的一个值，称之为单位元，0可以保证该等式成立 a+0=0+a=a</li><li>逆元。每个成员都有一个相反数：对于任意值a必定存在b使得a+b=0</li></ul><p>如果加上第五条这要求：</p><ul><li>交换性a+b=b+a</li></ul><p><b style="color:red">这样的群我们称之为 阿贝尔群。</b></p><h2 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h2><p>椭圆曲线是一个对数函数，<b style="color:red">曲线上的每个点都必须是非奇异的，所谓的”非奇异”或”光滑”的,在数学中是指曲线上任意一点都存在切线。</b>椭圆曲线对于X轴是对称的，记住这点很重要。关于这个函数的更多说明，还是参照引用的文章吧，里面提到的比我说的详细多了。</p><h2 id="椭圆曲线的阿贝尔群"><a href="#椭圆曲线的阿贝尔群" class="headerlink" title="椭圆曲线的阿贝尔群"></a>椭圆曲线的阿贝尔群</h2><p><b style="color:red">其实关于阿贝尔群，大家一定认为加法就是指数学中的那个加法，而对于椭圆曲线，这个加法还不一定非要是数学数字中的加法，这里的加法是指线相交，而加法中的元素也不是数字，而是一个点。举例来说，P+Q=R是指P与Q的连线与曲线相较于点Q，那么对于这个公式P-R=-Q又该如何解释呢？其实减号意味着点对于X轴对称的另一个点，另外公式变换一个P+(-R)=-Q，你再想想对称性，这个公式是不是成立的？这就是这个曲线的妙处所在。至于结合律就更好理解了，3点一线，不管你取那两个点，第三个点都能算出来不是么？至于0就是无穷远处的点就是0，这个适用于，直线平行于X轴或者y轴的时候使用。</b></p><h2 id="关于乘法"><a href="#关于乘法" class="headerlink" title="关于乘法"></a>关于乘法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mP = P + P + ...... + P = Q</span><br></pre></td></tr></table></figure><p>注意这里的乘法就是，一次一次加法算出来的，如果m越大，那么计算的量也就越大。<b style="color:#00f">我们学的椭圆曲线密码体制就是利用以上的这个困难问题来设计的。</b></p><h2 id="素数域Fp"><a href="#素数域Fp" class="headerlink" title="素数域Fp"></a>素数域Fp</h2><p><b style="color:#00f">如果椭圆曲线上一点P，存在最小的正整数n，使得数乘 nP=0∞，则将n称为P的阶，若n 不存在，我们说P是无限阶的。</b></p><p><b style="color:red">事实上，在有限域上定义的椭圆曲线上所有的点的阶n都是存在的。</b></p><h2 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h2><p><b style="color:red">终于到了学习，这个算法是如何进行加解密的过程的原理了，其实就是利用了上面提到的乘法和素数域的知识，另外也有了几个参数，这几个参数对应我们之前在bitcoin中使用的各种参数调节的问题，这里就应该是调节的本质了吧.</b>。好了下面我们来分析》》》</p><p>描述一条Fp上的椭圆曲线，常用到六个参量：T=(p,a,b,n,x,y)。</p><ul><li>（p 、a 、b） 用来确定一条椭圆曲线，p为素数域内点的个数，a和b是其内的两个大数；（这个p就是最后y mod p 的那个值，应该说p的取值决定了n的个数）</li><li>x,y为G基点的坐标，也是两个大数；</li><li>n为点G基点的阶；</li></ul><p>以上六个量就可以描述一条椭圆曲线，有时候我们还会用到h(椭圆曲线上所有点的个数p与n相除的整数部分)。</p><p><b style="color:red">现在我们描述一个利用椭圆曲线进行加密通信的过程</b>：</p><ol><li>A机器选定一条椭圆曲线 Ep(a,b) 并取椭圆曲线上一点，作为基点G。</li><li>A机器选择一个私有密钥k，并生成公开密钥 K=kG。</li><li>A机器将 Ep(a,b) 和点K，G传给用户B。</li><li>B机器接到信息后 ，将待传输的明文编码到Ep(a,b)上一点M（编码方法很多，这里不作讨论），并产生一个随机整数r。</li><li>B机器计算。<code>C1 = M + rK; C2=rG.</code></li><li>B机器将点C1、C2传给A机器。</li><li>A接到信息后，计算C1-kC2，结果就是点M。因为<code>C1-kC2=M+rK-k(rG)=M+rk-r(kG)=M</code>, 再对点M进行解码就可以得到明文。这样值就通过0运算神奇地还原了，注意这里的计算一是设计椭圆计算，椭圆计算是基于数学计算的过程的。</li></ol><p>在这个加密通信中，如果有一个偷窥者H ，他只能看到Ep(a,b)、K、G、C1、C2，而通过K、G 求k 或通过C2、G求r 都是相对困难的，因此，H无法得到A、B间传送的明文信息。</p><h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><p>是基于ECC（Elliptic Curve Cryptosystems，椭圆曲线密码体制，参看ECC）的DH（ Diffie-Hellman）密钥交换算法。其实就是双方互相传送公钥，然后通过双方的公钥计算出双方都知道的加密密钥S（注意这里面没有随机数传送，所以整个过程是安全的。）。</p><p>该算法可以用来解决如下问题：两端（Alice 和 Bob）想要安全的交换信息并且第三方不能获取到该信息。当然这是TLS协议中的目的之一，我们给出一个例子。<br>（其实下面的描述其实是ECDHE,而不是ECDH）</p><ol><li>Alice 和 Bob 生成他们自己的私钥和公钥，即Alice 有 da、Ha = da<em>G；Bob有db、Hb = db </em>G</li><li>Alice把Ha发给Bob，Bob把Hb发给Alice。这样Alice 有da,Ha,Hb，Bob有db,Ha,Hb。</li><li>Alice计算S = da<em>Hb（即自己的私钥乘上Bob的公钥），同样的，Bob计算S = db</em>Ga（自己的私钥乘上Alice的公钥）。两边计算的S是相同的。</li></ol><h2 id="ECDSA签名算法"><a href="#ECDSA签名算法" class="headerlink" title="ECDSA签名算法"></a>ECDSA签名算法</h2><p><b style="color:red">现在有一个场景：Alice想要用私钥签名一个数据，Bob想要使用Alice的公钥验证这个签名；只有Alice能够进行计算签名然后得到签名，每个人都能验证签名值。</b></p><p>首先Alice和Bob拥有相同的椭圆曲线参数，算法被签名称之为ECDSA，是DSA算法的一个变体。</p><p><b style="color:red">ECDSA签名算法的输入 是 数据的哈希值</b>，而不是数据的本身，至于哈希算法选用哪一个就取决于自己了。为了使得ECDSA的输入值的比特数和子群的阶n的比特数一样，哈希值可能会被截断。我们把ECDSA输入称之为Z。<br>算法工作流程如下：</p><ol><li>取一个范围在[1, n - 1]的随机数k</li><li>计算点P=kG (就是计算出公钥)</li><li>计算r = x<sub>P</sub> mod n （算出r的值，n是基点的阶）</li><li>如果 r == 0，执行第一步</li><li>计算s = k<sup>-1</sup> (z + r*d<sub>A</sub>) mod n （d<sub>A</sub>是Alice的公钥，k<sup>-1</sup> 是 k 对n的逆元, k是上面的随机数）</li><li>如果s==0，执行第一步</li><li>二元组(r, s)就是签名值</li></ol><p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/%E7%AE%97%E6%B3%95/ecdsa%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B.png"></p><p>上图中，Alice使用私钥da对z进行签名，生成二元组(r, s)。<br>Bob使用Alice的公钥对(r, s)和Z进行验证。</p><p>现在我们来看看Bob如何验证的：</p><ol><li>计算u<sub>1</sub> = s<sup>-1</sup> * z mod n</li><li>计算u<sub>2</sub> = s<sup>-1</sup> * r mod n</li><li>计算P = u<sub>1</sub>*G + u<sub>2</sub>*H<sub>A</sub></li><li>如果r == x<sub>P</sub> mod n，则验证正确</li></ol><p>过程证明请查看相应的引用。</p><h2 id="椭圆算法总结"><a href="#椭圆算法总结" class="headerlink" title="椭圆算法总结"></a>椭圆算法总结</h2><p>通过最后的示例我们可以看出，椭圆算法的公私钥其实是一样的，其实说白了就双方都不需要知晓别人给定的那个k和r的值，因为kr相乘之后，大家的值都是一致的，但是不能在网上随便传输k和r的值吧，这样还有什么安全性，这里很巧妙地利用了归的技术，隐藏了这种特性的原始值。这种特性就是椭圆曲线的对称性而衍生的阿贝尔群的特性。</p><p>鉴于np=0，所以一个私钥理论上是可以对应多个公钥的，一个公钥也可以对应多个私钥。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yZTYwMzFhYzNkNTA=" title="https://www.jianshu.com/p/2e6031ac3d50">椭圆曲线算法：入门（1）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly80aG91Lndpbi93b3JkcHJlc3MvP3A9MTIwODQ=" title="https://4hou.win/wordpress/?p=12084">椭圆曲线算法（ECC）学习（一)<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jvb2suOGJ0Yy5jb20vYm9va3MvNi9tYXN0ZXJiaXRjb2luMmNuL19ib29rL2NoMDQuaHRtbA==" title="http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch04.html">钱包和地址<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2FuZHJlYS5jb3JiZWxsaW5pLm5hbWUvMjAxNS8wNS8xNy9lbGxpcHRpYy1jdXJ2ZS1jcnlwdG9ncmFwaHktYS1nZW50bGUtaW50cm9kdWN0aW9uLw==" title="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2FuZHJlYS5jb3JiZWxsaW5pLm5hbWUvMjAxNS8wNS8yMy9lbGxpcHRpYy1jdXJ2ZS1jcnlwdG9ncmFwaHktZmluaXRlLWZpZWxkcy1hbmQtZGlzY3JldGUtbG9nYXJpdGhtcy8=" title="http://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/">Elliptic Curve Cryptography: finite fields and discrete logarithms<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ycHJlL2FydGljbGUvZGV0YWlscy83Mjg1MDU5OA==" title="https://blog.csdn.net/mrpre/article/details/72850598">有限域和离散对数问题(ECC椭圆曲线算法2)<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21ycHJlL2FydGljbGUvZGV0YWlscy83Mjg1MDY0NA==" title="https://blog.csdn.net/mrpre/article/details/72850644">ECDH and ECDSA(ECC椭圆曲线算法3)<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 椭圆曲线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识算法概述</title>
      <link href="//blockchain/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.html"/>
      <url>//blockchain/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>一开始就认为共识算法其实比较简单，但是一直没有认真地总结，导致这块知识一直都是短板。其实共识算法的本质是分布式一致性的问题，但是显然这和分布式一致性略有区别。有以下两个主要的区别：</p><ol><li>传统的分布式一致性算法认为，每个节点都不会欺诈，如果出现问题一般都是网络分区，请求顺序的问题。但是共识算法不能保证每一个节点都是正常节点，可能就是欺诈节点。</li><li>传统的一致性算法只要有值就行，不太关心哪个节点写入数据。<b style="color:red">但是共识算法，必须公平地对待每一个节点，选取这个节点必须是公平的，于是就有了POW和POS机制的出现。这个就好像是选择值本来一个很纯粹的事情绑定了特定的业务，所以要处理的事情就变得很复杂了。所以在分析共识算法的时候要将这个点剥离出来，拨出来之后这就是一个分布式一致性的问题。</b></li></ol><p>所以说共识算法，剥离了上面两个方面的因素就是一个纯粹的分布式一致性算法。<b style="color:red">其实说白了共识算法就是分布式一致性在P2P网络中的应用。</b></p><p>其他的分布式协议：<a href="/2018/03/22/算法/Paxos协议详解/">Paxos</a>、<a href="/2018/03/23/算法/Raft算法简介/">Raft</a>。</p><h2 id="从拜占庭将军问题谈起"><a href="#从拜占庭将军问题谈起" class="headerlink" title="从拜占庭将军问题谈起"></a>从拜占庭将军问题谈起</h2><p>这是一个很经典的分布式一致性问题的提出，这里我们就不做很多的说明。可以查看维基百科中关于这点的描述。</p><h2 id="拜占庭容错-BFT"><a href="#拜占庭容错-BFT" class="headerlink" title="拜占庭容错 BFT"></a>拜占庭容错 BFT</h2><p>这是拜占庭将军问题的早期的解决方案。在1982年的论文中提过几个解决方案。方案中把问题往下拆解，认为在“拜占庭将军”的问题可以在“军官与士官的问题”里解决，以降低将军问题的发生。而所谓的“军官与士官的问题”，就是探讨军官与他的士官是否能忠实实行命令。</p><p>其中一个解决方案认为即使出现了伪造或错误的消息。只要有问题的将军的数量不到三分之一，仍可以达到“拜占庭容错”。原因是把同样的标准下放到“军官与士官的问题”时，在背叛的军士官不足三分之一的情况下，有问题的军士官可以很容易的被纠出来。<b style="color:#00f">比如有军官A，士官B与士官C。当A要求B进攻，却要求C撤退时</b>。<b style="color:red">只要B与C交换所收到的命令，就会立刻发现A有问题</b>。<b style="color:#00f">以函数来表示，将军的总数为n，n里面背叛者的数量为t，则只要n &gt; 3t就可以容错。</b></p><p><b style="color:red">另一个解决方案需要有无法消去的签名。在现今许多高度信息安全要求的关键系统里，数字签名就经常被用来实现拜占庭容错，找出有问题的将军。然而，在生命攸关系统里，使用 错误侦测码就可以大幅降低问题的发生。无论系统是否存在拜占庭将军问题。所以需要做密码军算的数字签名也不一定适合这类系统。</b></p><p>假如上述两个解决方案里，将军们无法直接通信时，该论文亦有进一步的解决方案。<br>此外，1980年代还有其他用来达到拜占庭容错的架构被提出，如：FTMP、MMFCS 与 SIFT。</p><h2 id="使用拜占庭容错算法-PBFT"><a href="#使用拜占庭容错算法-PBFT" class="headerlink" title="使用拜占庭容错算法 PBFT"></a>使用拜占庭容错算法 PBFT</h2><p>1999年，卡斯托（Miguel Castro）与李斯克夫（Barbara Liskov）提出了实用拜占庭容错（PBFT）算法。该算法能提供高性能的运算，使得系统可以每秒处理成千的请求，比起旧式系统快了一些。<b style="color:red">后来也有针对BFT算法的各种优化版，但是优化的方向不同，有的是为了加强健壮性，有的是为了加强网络速度等。</b>下面来提一下这个PBFT算法的一些简要知识，具体请查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xZTJhY2QzY2JkOWY=" title="https://www.jianshu.com/p/1e2acd3cbd9f">实用拜占庭容错算法PBFT<i class="fa fa-external-link"></i></span></p><p><img alt="PFBT流程图" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E7%AE%97%E6%B3%95/PBFT%E6%B5%81%E7%A8%8B.png?raw=true"><br>上面是PBFT的图示，下面我们讲个上面流程的故事。</p><ol><li>总司令给军长下命令向前行军500公里；</li><li>军长将消息（不只有命令）传递给所有师长；</li><li>1号2号师长又把消息传给其他师长，3号师长处于叛逃状态；</li><li>军长再次询问各位师长是否同意执行命令。</li><li>所有军官（包括军长和师长）向总司令汇报结果。</li></ol><p><b style="color:#00f">这个算法的实用性为何高于BFT呢？因为在BFT的描述中，我们可以发现每个节点都不知道其他节点的情况，都会去询问所有的人他们所获得情况，进而做出自己的判断（只要大多数人同意的就是正确的）。这个过程达成一致性的时间比较长，而且耗费大量的P2P网络资源，不适合共识算法（规模不大是可以的）</b>。<b style="color:red">PBFT算法就是校验放给一个人去校验就可以了，而不需要全体所有的人来进行校验，你也不知道进行校验的人是谁，所以是安全的，分布式一致性也很容易达成。</b></p><h2 id="节点验证的机制"><a href="#节点验证的机制" class="headerlink" title="节点验证的机制"></a>节点验证的机制</h2><p>节点验证的方式其实是两方面的，一是节点未篡改通讯协议，二是节点的选举极具公平意义。现在区块链上的实现主要是POW和POS两种方式。</p><h2 id="工作量证明-POW"><a href="#工作量证明-POW" class="headerlink" title="工作量证明 POW"></a>工作量证明 POW</h2><p>这是比特币使用的共识机制，主要是通过不停地hash计算，算出nonce已满足难度系数。这样请求不易伪造，而且谁先解决难题谁就有记账权，我觉得这个是不可被攻击的。要想攻击必须具有51%以上的算力。</p><h2 id="权益证明-POS"><a href="#权益证明-POS" class="headerlink" title="权益证明 POS"></a>权益证明 POS</h2><p>这种安全的机制比较简单就是你持有币所获得的权限。</p><p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。</p><p>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p><h2 id="委任权益证明-DPOS"><a href="#委任权益证明-DPOS" class="headerlink" title="委任权益证明 DPOS"></a>委任权益证明 DPOS</h2><p>比特股的DPoS机制，中文名叫做股份授权证明机制（又称受托人机制），它的原理是让每一个持有比特股的人进行投票，由此产生101位代表 , 我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似演唱会的黄牛，大量囤票而丝毫不关心演唱会的内容。</p><h2 id="Casper"><a href="#Casper" class="headerlink" title="Casper"></a>Casper</h2><p>这个协议也是POS，是以太坊正在开发的下一代以太坊共识协议。</p><p>以太坊社区提出的正在研发中的共识协议名为Casper。Casper的基本思路是，任何人抵押足够多的以太币到系统中就可以成为矿工参与到挖矿过程。共识算法要求所有的矿工诚实工作，如果一个矿工有意破坏，不遵守协议，系统就会对矿工做出惩罚：没收之前抵押的以太币。有人把Casper这样的挖矿机制称为“虚拟挖矿”，比特币的矿工要参与挖矿需要先购买矿机，Casper则要先抵押以太币到系统中；比特币的矿工如果不按规则挖矿，则会损失电费以及可能的挖矿收益，而Casper中，不守规则的惩罚更为严重，除了失去挖矿收益，还要销毁“矿机”：抵押的以太币会被系统没收！</p><h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图 DAG"></a>有向无环图 DAG</h2><p>DAG则采用异步机制替代链式检查点的同步策略，在优秀的软件实现中如果能够有效控制网络风暴带来的带宽需求指数增加，其不失为一种对最终一致性场景有较好应用前景的算法。但是DAG的局限性也极为明显，其体系无法被利用在需要进行同步操作或一致性要求较高的操作中（例如支付结算等）。</p><p>第一次提出DAG跟区块链结合是在Nxt社区，可以发现DAG最初出现就是为了解决区块链的效率问题。比特币的效率一直比较低，基于工作量证明共识下的出块机制是一个原因，由于链式的存储结构，整个网络中同时只能有一条链，导致出块无法并发执行。社区有人提出DAG的拓扑结构来存储区块，这个时候更多还是类似侧链的解决思路，不同的链条存储不同类型的交易，这样降低出现双花的可能，在之后某个节点需要合并的时候，几个分支再归并到一个区块。</p><h2 id="共识规则和软分叉"><a href="#共识规则和软分叉" class="headerlink" title="共识规则和软分叉"></a>共识规则和软分叉</h2><p>共识规则决定着每个交易或每个区块的有效性。比特币网络上的每个用户和矿工都遵守着同一套共识规则，代表着他们都愿意接受和同意一个账本。</p><p>当大多数用户和/或矿工决定采用更严格的共识规则时，软分叉就可能出现，这使一些以前有效的交易/区块将变为无效，而不是相反。如果大多数人执行新的规则的话，其他任何违规分叉（统计上）都不会在工作量证明方面赶上新的更严格的共识分叉。遵守旧规则的少数人将始终遵循更长，更严格的分叉，使得网络上的每个人都会最终接受和同意一个账本。</p><p>关于分叉的更多知识，我觉得<span class="exturl" data-url="aHR0cDovL21lLnRyeWJsb2NrY2hhaW4ub3JnL2Jsb2NrY2hhaW4tZHBvcy1ibS1lb3MuaHRtbA==" title="http://me.tryblockchain.org/blockchain-dpos-bm-eos.html">DPOS共识算法-by BM<i class="fa fa-external-link"></i></span>这篇文档讲得挺好的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共识算法的知识很多这里就不做更多地说明了。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JThCJTlDJUU1JThEJUEwJUU1JUJBJUFEJUU1JUIwJTg2JUU1JTg2JTlCJUU5JTk3JUFFJUU5JUEyJTk4IyVFNSVBRiVBNiVFNyU5NCVBOCVFNiU4QiU5QyVFNSU4RCVBMCVFNSVCQSVBRCVFNSVBRSVCOSVFOSU4QyVBRg==" title="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98#%E5%AF%A6%E7%94%A8%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%8C%AF">拜占庭将军问题<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xZTJhY2QzY2JkOWY=" title="https://www.jianshu.com/p/1e2acd3cbd9f">实用拜占庭容错算法PBFT<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mYjVlZGYwMzFhZmQ=" title="https://www.jianshu.com/p/fb5edf031afd">区块链核心技术：拜占庭共识算法之PBFT<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5jaGlkYW9saWFuLmNvbS9hcnRpY2xlLTY4MC0x" title="http://www.chidaolian.com/article-680-1">案例分析软分叉的艺术——政策规则保护<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC00MDExMy0xLTEuaHRtbA==" title="http://8btc.com/thread-40113-1-1.html">以太坊紫皮书（中文版）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzdHRveS9hcnRpY2xlL2RldGFpbHMvNjE2MjQyODc=" title="https://blog.csdn.net/lsttoy/article/details/61624287">[区块链]共识算法（POW,POS,DPOS,PBFT）介绍和心得<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC0zNTQ3NS0xLTEuaHRtbA==" title="http://8btc.com/thread-35475-1-1.html">以太坊共识协议Casper原理是怎样的？<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2NoYWlueC5vcmcvbmV3cy9pbmRleC9kZXRhaWwvaWQvMTQuaHRtbA==" title="http://chainx.org/news/index/detail/id/14.html">拜占庭容错(BFT)算法介绍<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5idGMzOC5jb20vb3RoZXJzL290aGVyX2FsbC80OS5odG1s" title="http://www.btc38.com/others/other_all/49.html">加密的钱包如何获得POS利息<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5idGMzOC5jb20vYWx0Y29pbi9nZW5lcmFsLzQ3Lmh0bWw=" title="http://www.btc38.com/altcoin/general/47.html">深度教程：POS和POW全解析<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5jaGlkYW9saWFuLmNvbS9hcnRpY2xlLTgyOC04" title="http://www.chidaolian.com/article-828-8">盘点区块链共识机制——论PoW，PoS，DPos和DAG的优缺点对比分析<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuNzIzNC5jbi9kYWcvMzYzOTI=" title="https://www.7234.cn/dag/36392">DAG也许是真正的区块链3.0<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL21lLnRyeWJsb2NrY2hhaW4ub3JnL2Jsb2NrY2hhaW4tZHBvcy1ibS1lb3MuaHRtbA==" title="http://me.tryblockchain.org/blockchain-dpos-bm-eos.html">DPOS共识算法-by BM<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 共识算法 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft算法简介</title>
      <link href="//%E7%AE%97%E6%B3%95/Raft%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B.html"/>
      <url>//%E7%AE%97%E6%B3%95/Raft%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>分布式一致性算法中大家最熟悉还是Paxos，但是这个算法理解起来比较难，实现这个算法的难度也很高，最后都会对协议本身进行修改实现。</p><p>为了提高理解性，Raft 将一致性算法分为了几个部分，例如领导选取（leader selection），日志复制（log replication）和安全性（safety），同时它使用了更强的一致性来减少了必须需要考虑的状态。</p><h2 id="几个特性"><a href="#几个特性" class="headerlink" title="几个特性"></a>几个特性</h2><ul><li>强领导者（Strong Leader）：Raft 使用一种比其他算法更强的领导形式。例如，日志条目只从领导者发送向其他服务器。这样就简化了对日志复制的管理，使得 Raft 更易于理解。</li><li>领导选取（Leader Selection）：Raft 使用随机定时器来选取领导者。这种方式仅仅是在所有算法都需要实现的心跳机制上增加了一点变化，它使得在解决冲突时更简单和快速。</li><li>成员变化（Membership Change）：Raft 为了调整集群中成员关系使用了新的联合一致性（joint consensus）的方法，这种方法中大多数不同配置的机器在转换关系的时候会交迭（overlap）。这使得在配置改变的时候，集群能够继续操作。</li></ul><h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>分布式一致性的解决方案就是<b style="color:red">复制状态机</b>, 在一组服务器的状态机产生同样的状态的副本因此即使有一些服务器崩溃了这组服务器也还能继续执行。<b style="color:red">但是集群中有一个Leader节点，Leader选举是使用一个单独的复制状态机,并存储配置信息，防止leader崩溃。</b></p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E7%AE%97%E6%B3%95/%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA.jpg?raw=true"></p><p>从图上我们可以发现共识模块是处理分布式一致性的，Log模块记录操作的记录（这个操作很重要），最后是每台机器的状态机。<b style="color:red">复制状态机是通过复制日志实现的，每台服务器都保存一份日志，日志中包含一系列的命令，状态机会按照顺序执行这些命令。</b></p><p>应用于实际系统的一致性算法一般有以下特性：</p><ul><li>确保安全性（从来不会返回一个错误的结果），即使在所有的非拜占庭（Non-Byzantine）情况下，包括网络延迟、分区、丢包、冗余和乱序的情况下。</li><li>高可用性，只要集群中的大部分机器都能运行，可以互相通信并且可以和客户端通信，这个集群就可用。</li><li>不依赖时序保证一致性，时钟错误和极端情况下的消息延迟在最坏的情况下才会引起可用性问题。</li><li>通常情况下，一条命令能够尽可能快的在大多数节点对一轮远程调用作出相应时完成，一少部分慢的机器不会影响系统的整体性能。</li></ul><h2 id="易于理解的设计"><a href="#易于理解的设计" class="headerlink" title="易于理解的设计"></a>易于理解的设计</h2><p>设计 Raft 的目标有如下几个（我想任何算法都应该是这样的）：</p><ul><li>能提供一个完整的、实际的基础来进行系统构建，减少开发者的工作</li><li>在任何情况下都能保证安全可用。</li><li>对于常规的操作，必须是高效的。</li><li>易于理解（这样才能便于应用）</li><li>它必须能让开发者有一个直观的认识，这样才能使系统构建者们去对它进行扩展。（其实我觉得这点有点啰嗦）</li></ul><p>Raft使用了两种方式来简化算法的复杂度。</p><p><b style="color:#00f">一是问题分解</b>：尽可能将问题分解成为若干个可解决的、可被理解的小问题。例如，在 Raft 中，我们把问题分解成为了<b style="color:#00f">领导选取（leader election）</b>、<b style="color:#00f">日志复制（log replication）</b>、<b style="color:#00f">安全（safety）</b>和<b style="color:#00f">成员变化（membership changes）</b>。</p><p><b style="color:#00f">第二个方法是通过减少需要考虑的状态的数量将状态空间简化，这能够使得整个系统更加一致并且尽可能消除不确定性。</b>特别地，日志之间不允许出现空洞，并且 Raft 限制了限制了日志不一致的可能性。尽管在大多数情况下，我们都都在试图消除不确定性，但是有时候有些情况下，不确定性使得算法更易理解。尤其是，随机化方法使得不确定性增加，但是它减少了状态空间。我们使用随机化来简化了 Raft 中的领导选取算法。</p><h2 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>在所有服务器上持久存在的：（在响应远程过程调用 RPC 之前稳定存储的）</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器最后知道的任期号（从0开始递增）</td></tr><tr><td>votedFor</td><td>在当前任期内收到选票的候选人 id（如果没有就为 null）</td></tr><tr><td>log[]</td><td>日志条目；每个条目包含状态机的要执行命令和从领导人处收到时的任期号</td></tr></tbody></table><p>在所有服务器上不稳定存在的：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知的被提交的最大日志条目的索引值（从0开始递增）</td></tr><tr><td>lastApplied</td><td>被状态机执行的最大日志条目的索引值（从0开始递增）</td></tr></tbody></table><p>在领导人服务器上不稳定存在的：（在选举之后初始化的）</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每一个服务器，记录需要发给它的下一个日志条目的索引（初始化为领导人上一条日志的索引值+1）</td></tr><tr><td>matchIndex[]</td><td>对于每一个服务器，记录已经复制到该服务器的日志的最高索引值（从0开始递增）</td></tr></tbody></table><p><b style="color:red">这个是每台机器内部的状态量，根据这些信息我们可以查看相应的节点状态，每个节点也可以通过这些状态来检查网络中各节点的状态，最终需要leader节点进行同步。</b></p><h3 id="附加日志远程过程调用-（AppendEntries-RPC）"><a href="#附加日志远程过程调用-（AppendEntries-RPC）" class="headerlink" title="附加日志远程过程调用 （AppendEntries RPC）"></a>附加日志远程过程调用 （AppendEntries RPC）</h3><p>由领导人来调用复制日志（5.3节）；也会用作heartbeat</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 id，为了其他服务器能重定向到客户端</td></tr><tr><td>prevLogIndex</td><td>最新日志之前的日志的索引值</td></tr><tr><td>prevLogTerm</td><td>最新日志之前的日志的领导人任期号</td></tr><tr><td>entries[]</td><td>将要存储的日志条目（表示 heartbeat 时为空，有时会为了效率发送超过一条）</td></tr><tr><td>leaderCommit</td><td>领导人提交的日志条目索引值</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>当前的任期号，用于领导人更新自己的任期号</td></tr><tr><td>success</td><td>如果其它服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td></tr></tbody></table><p>接受者需要实现：</p><ol><li>如果 term &lt; currentTerm返回 false（5.1节）(这个应该是发现了最新的leader)</li><li>如果在prevLogIndex处的日志的任期号与prevLogTerm不匹配时，返回 false（5.3节）（发现问题，3解决）</li><li>如果一条已经存在的日志与新的冲突（index 相同但是任期号 term 不同），则删除已经存在的日志和它之后所有的日志（5.3节）（解决2中存在的问题，回滚）</li><li>添加任何在已有的日志中不存在的条目（恢复数据）</li><li>如果leaderCommit &gt; commitIndex，将commitIndex设置为leaderCommit和最新日志条目索引号中较小的一个（获取新日志后更新）</li></ol><p><b style="color:red">这个心跳检测和同步日志消息其实就是检测当前节点与Leader节点异同，如果发现数据异常，根据Leader节点的数据进行回滚，拉取最新的日志，根据日志恢复状态机。如果发现漏了很多日志就同步日志恢复状态机。</b></p><h3 id="投票请求RPC（RequestVote-RPC）"><a href="#投票请求RPC（RequestVote-RPC）" class="headerlink" title="投票请求RPC（RequestVote RPC）"></a>投票请求RPC（RequestVote RPC）</h3><p>由候选人发起收集选票（5.2节）</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求投票的候选人 id</td></tr><tr><td>lastLogIndex</td><td>候选人最新日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最新日志条目对应的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>term</td><td>目前的任期号，用于候选人更新自己</td></tr><tr><td>voteGranted</td><td>如果候选人收到选票为 true</td></tr></tbody></table><p>接受者需要实现：</p><ol><li>如果term &lt; currentTerm返回 false（5.1节）(可能是旧的Leader，但现在有新的了，忽略)</li><li>如果votedFor为空或者与candidateId相同，并且候选人的日志和自己的日志一样新，则给该候选人投票（5.2节 和 5.4节）</li></ol><p><b style="color:#00f">服务器需要遵守的规则：</b></p><p>所有服务器：</p><ul><li>如果commitIndex &gt; lastApplied，lastApplied自增，将log[lastApplied]应用到状态机（5.3节）</li><li>如果 RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则currentTerm赋值为 T，并切换状态为追随者（Follower）（5.1节）</li></ul><p>追随者（followers）: 5.2节</p><ul><li>响应来自候选人和领导人的 RPC</li><li><b style="color:red">如果在超过选取领导人时间之前没有收到来自当前领导人的AppendEntries RPC或者没有收到候选人的投票请求，则自己转换状态为候选人</b></li></ul><p>候选人：5.2节</p><ul><li>转变为选举人之后开始选举：<ul><li>currentTerm自增</li><li>给自己投票</li><li>重置选举计时器</li><li>向其他服务器发送RequestVote RPC</li></ul></li><li>如果收到了来自大多数服务器的投票：成为领导人</li><li><b style="color:red">如果收到了来自新领导人的AppendEntries RPC（heartbeat）：转换状态为追随者</b></li><li>如果选举超时：开始新一轮的选举</li></ul><p>领导人：</p><ul><li>一旦成为领导人：向其他所有服务器发送空的AppendEntries RPC（heartbeat）;在空闲时间重复发送以防止选举超时（5.2节）</li><li>如果收到来自客户端的请求：向本地日志增加条目，在该条目应用到状态机后响应客户端（5.3节）</li><li>对于一个追随者来说，如果上一次收到的日志索引大于将要收到的日志索引（nextIndex）：通过AppendEntries RPC将 nextIndex 之后的所有日志条目发送出去</li><li>如果发送成功：将该追随者的 nextIndex和matchIndex更新</li><li>如果由于日志不一致导致AppendEntries RPC失败：nextIndex递减并且重新发送（5.3节）</li><li>如果存在一个满足N &gt; commitIndex和matchIndex[i] &gt;= N并且log[N].term == currentTerm的 N，则将commitIndex赋值为 N</li></ul><h3 id="Raft-一致性算法的特性"><a href="#Raft-一致性算法的特性" class="headerlink" title="Raft 一致性算法的特性"></a>Raft 一致性算法的特性</h3><p>Raft 算法保证这些特性任何时刻都成立</p><table><thead><tr><th>性质</th><th>描述</th></tr></thead><tbody><tr><td>选举安全原则（Election Safety）</td><td>一个任期（term）内最多允许有一个领导人被选上（5.2节）</td></tr><tr><td>领导人只增加原则（Leader Append-Only）</td><td>领导人永远不会覆盖或者删除自己的日志，它只会增加条目</td></tr><tr><td>日志匹配原则（Log Matching）</td><td>如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同（5.3 节）</td></tr><tr><td>领导人完全原则（Leader Completeness)</td><td>如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的领导人中</td></tr><tr><td>状态机安全原则（State Machine Safety）</td><td>如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目（5.4.3节）</td></tr></tbody></table><p><b style="color:red">Raft 通过首先选出一个领导人来实现一致性，然后给予领导人完全管理复制日志（replicated log）的责任。领导人接收来自客户端的日志条目，并把它们复制到其他的服务器上，领带人还要告诉服务器们什么时候将日志条目应用到它们的状态机是安全的。通过选出领导人能够简化复制日志的管理工作。例如，领导人能够决定将新的日志条目放到哪，而并不需要和其他的服务器商议，数据流被简化成从领导人流向其他服务器。如果领导人宕机或者和其他服务器失去连接，就可以选取下一个领导人。</b></p><p>通过选出领导人，Raft 将一致性问题分解成为三个相对独立的子问题：</p><ul><li>领导人选取（Leader election）： 在一个领导人宕机之后必须要选取一个新的领导人（5.2节）</li><li>日志复制（Log replication）： 领导人必须从客户端接收日志然后复制到集群中的其他服务器，并且强制要求其他服务器的日志保持和自己相同</li><li>安全性（Safety）： Raft 的关键的安全特性是 表-3 中提到的状态机安全原则（State Machine Safety）:如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目。5.4节阐述了 Raft 是如何保证这条原则的，解决方案涉及到一个对于选举机制另外的限制，这一部分会在 5.2节 中说明。</li></ul><p>在说明了一致性算法之后，本章会讨论有关可用性（availability）的问题和系统中时序（timing）的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>raft的Leader选举机制和策略总觉得和redis的集群模式很像，后来查看资料，果然redis内部使用的就是raft协议。也就大概明白raft协议的意思了。这里就不再过多地去说明了。</p><p>但是论文的后面还有大量的实现说明，我在讨论了，可以查看论文原文，里面提到了很多细节问题，都是我们不得不考虑的事情。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5pbmZvcS5jb20vY24vYXJ0aWNsZXMvcmFmdC1wYXBlciM=" title="http://www.infoq.com/cn/articles/raft-paper#">Raft 一致性算法论文译文<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ0JiUVJnbFZJcjNkWWk4Mi9hcnRpY2xlL2RldGFpbHMvNzkzODY1MzY=" title="http://blog.csdn.net/gBbQRglVIr3dYi82/article/details/79386536">图解分布式协议-RAFT<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbndlbnl1YmxvZy9hcnRpY2xlL2RldGFpbHMvNTMzODU2MTY=" title="https://blog.csdn.net/sanwenyublog/article/details/53385616">redis集群实现(五) sentinel的架构与raft协议<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3Mua29uZ3lpeHVleXVhbi5jb20vd2l0Ym9vay8zNi81MTQ=" title="http://s.kongyixueyuan.com/witbook/36/514">etcd 中的raft协议<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式一致性 </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中ThreadLocal学习</title>
      <link href="//java/Java%E4%B8%ADThreadLocal%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/Java%E4%B8%ADThreadLocal%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在java中，并发的操作包中有copyOnWrite，但是这个类不是用来处理数据隔离的，也就是不能达到保持线程上下文的问题，但是ThreadLocal类可以。这里我们简单介绍一下，就不做更多阐述了。以下代码是Java8的实现。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>这个类就是ThreadLocal里面存放数据使用的数据结构了。<b style="color:red">不用我说大家都知道这个类是单例模式的，key呢就是ThreadLocal，也就是说ThreadLocal本身是多例程序，是的就是这样，因为Thread是通过TheadLocal获取的ThreadLocalMap里面的值。</b></p><p>这个Map没有继承Map，而且是利用数组进行的实现，比较简单。<b style="color:red">特别需要说明的就是hash冲突的问题，一旦发生hash冲突就会从当前位置一步一步向下找空余的地方放置新值，找的时候如果没找到就从hash位置开始一个一个向下找。</b>以前在学习数据结构时候就比较好奇这种解决hash键冲突的方式，当时还是觉得这种方式比较不靠谱（主要当前基本都是使用C和C++，特别喜欢使用链表），今天看到这个应用觉得也还是不错的解决之道。</p><p>关于Hash计算就是ThreadLocal中的threadLocalHashCode &amp; （length-1）计算出来。</p><p><b style="color:red">关于初始化和扩容：默认创建16个元素，满三分之二后进行扩容。</b></p><p><b style="color:red">每次数据遍历访问都会进行key的判断，如果元素已经失效就会进行删除，但是这不能完全解决ThreadLocal的内存泄露问题。</b></p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>在Thread里面有两个属性，系统退出时会设置为null，用于释放资源。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 包内访问的元素。</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></pre></td></tr></table></figure><p></p><p>看一下exit方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void exit() &#123;</span><br><span class="line">    if (group != null) &#123;</span><br><span class="line">        group.threadTerminated(this);</span><br><span class="line">        group = null;</span><br><span class="line">    &#125;</span><br><span class="line">    /* Aggressively null out all reference fields: see bug 4006245 */</span><br><span class="line">    target = null;</span><br><span class="line">    /* Speed the release of some of these resources */</span><br><span class="line">    threadLocals = null;</span><br><span class="line">    inheritableThreadLocals = null;</span><br><span class="line">    inheritedAccessControlContext = null;</span><br><span class="line">    blocker = null;</span><br><span class="line">    uncaughtExceptionHandler = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="关于ThreadLocal"><a href="#关于ThreadLocal" class="headerlink" title="关于ThreadLocal"></a>关于ThreadLocal</h2><p>其实这个类只是起着链接ThreadLocalMap和Thread的链接访问而已。具体可以查看代码实现。这里就不做更多的说明了。</p><h2 id="SuppliedThreadLocal"><a href="#SuppliedThreadLocal" class="headerlink" title="SuppliedThreadLocal"></a>SuppliedThreadLocal</h2><p>java8新的类，这里就是将ThreadLocal对象封装在supplier里面，防止为null而已，实现也比较简单。</p><h2 id="关于内存泄露的问题"><a href="#关于内存泄露的问题" class="headerlink" title="关于内存泄露的问题"></a>关于内存泄露的问题</h2><p>我们来看一下ThreadLocalMap中Entry的数据结构，发现是一个弱引用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    // key为ThreadLocal（这个需要深入学习一下）</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</b></p><p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。</p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><p>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏（参考ThreadLocal 内存泄露的实例分析）。<br>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。</p><h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><p>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p><p>ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p>那么如何解决这个问题呢？</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>向Entry中注册ReferenceQueue，利用一个线程定期清除这个Queue里面的被垃圾回收的数据就可以了。但是多付出了一个线程的开销。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5pbXBvcnRuZXcuY29tLzIyMDM5Lmh0bWw=" title="http://www.importnew.com/22039.html">深入分析 ThreadLocal 内存泄漏问题<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paxos协议详解</title>
      <link href="//%E7%AE%97%E6%B3%95/Paxos%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html"/>
      <url>//%E7%AE%97%E6%B3%95/Paxos%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>Paxos协议/算法是分布式系统中比较重要的协议，它有多重要呢？</p><p><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTA5MTAuaHRtbA==" title="https://coolshell.cn/articles/10910.html">&lt;分布式系统的事务处理&gt;<i class="fa fa-external-link"></i></span>：</p><ul><li>Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNTcyMzY1OC8=" title="https://book.douban.com/subject/25723658/">&lt;大规模分布式存储系统&gt;<i class="fa fa-external-link"></i></span>：</p><ul><li>理解了这两个分布式协议之后(Paxos/2PC)，学习其他分布式协议会变得相当容易。</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得一年前去看Paxos的算法，那真是云里雾里根本不知道在讲什么，后来看了网上的一个视频（<span class="exturl" data-url="aHR0cDovL2N4aC5tZS8yMDE0LzA4LzI2L3BheG9zLXN0dWR5Lw==" title="http://cxh.me/2014/08/26/paxos-study/">知行学社的分布式系统与Paxos算法视频课程<i class="fa fa-external-link"></i></span>）终于记住了。但是时间一长又忘记了，但是永远记住了两个规则，我觉得总结的很好。这个视频讲解的也十分到位。</p><ol><li>Prepare阶段喜新厌旧</li><li>Commit阶段后者认同前者</li><li>最终少数服从多数</li></ol><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E7%AE%97%E6%B3%95/basicPaxos%E6%B6%88%E6%81%AF%E6%B5%81.png?raw=true"></p><h2 id="算法的说明"><a href="#算法的说明" class="headerlink" title="算法的说明"></a>算法的说明</h2><p><b style="color:red">首先将议员的角色分为proposers，acceptors，和learners（允许身兼数职）</b>。proposers提出提案，提案信息包括提案编号和提议的value；acceptor收到提案后可以<b style="color:red">接受</b>（accept）提案，若提案获得多数acceptors的接受，则称该提案被<b style="color:red">批准（chosen）</b>；learners只能<b style="color:red">“学习”</b>被批准的提案。划分角色后，就可以更精确的定义问题：</p><ul><li><b style="color:red">决议（value）</b>只有在被proposers提出后才能被批准（未经批准的决议称为“提案（proposal）”）；</li><li>在一次Paxos算法的执行实例中，只<b style="color:red">批准（chosen）</b>一个value；</li><li>learners只能获得<b style="color:red">被批准（chosen）</b>的value。</li></ul><p>另外还需要保证progress。这一点以后再讨论。作者通过不断加强上述3个约束（主要是第二个）获得了Paxos算法。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/%E7%AE%97%E6%B3%95/paxos%E5%8D%8F%E8%AE%AE.png?raw=true"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1：一个acceptor必须接受（accept）第一次收到的提案。</span><br></pre></td></tr></table></figure><p>这个比较好理解。（但是这里忽略了预提交阶段的事情了）。然后下面就是后者认同前者了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2：一旦一个具有value v的提案被批准（chosen），那么之后批准（chosen）的提案必须具有value v。</span><br></pre></td></tr></table></figure><p></p><p>这个是对接收者后者认同前者的说明，但是貌似只是对一个acceptor有约束，所以必须成为所有acceptors的共识，于是有了P2a。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2a：一旦一个具有value v的提案被批准（chosen），那么之后任何acceptor再次接受（accept）的提案必须具有value v。</span><br></pre></td></tr></table></figure><p></p><p>之前说的后者认同前者都是针对acceptor，但如果对于Proposer呢？于是又出现了P2b：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2b：一旦一个具有value v的提案被批准（chosen），那么以后任何proposer提出的提案必须具有value v。</span><br></pre></td></tr></table></figure><p></p><p>但是根据P2b难以提出实现手段。因此需要进一步加强P2b。虽然以上规则很美好，但是总会出现各种异常的情况，但总会出现被大多数人接收的提案（少数服从多数原则）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P2c：如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受（accept）编号小于n</span><br><span class="line">的任何提案，要么他们已经接受（accept）的所有编号小于n的提案中编号最大的那个提案具有value v。</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">最后这一条可能大家都不太明白，其实大概是这样的，当一个Proposer发现自己已经获得超过半数的之后后，就会进行广播说“我的提案通过啦，新的提案就不要再提出来啦”，于是众人开始学习（有点像区块链中挖出矿的幸运儿有木有）。对于掉队的孩子又找到队伍了，发起的旧协议终于到了“我提出一个提案，xxx”，于是其他人对他说“还提这些陈芝麻烂谷子干嘛，我们已经通过这个问题的提案了，就是XXX”，于是新人说那是晚到的邮件啊，我其实早就收到消息了呀！</b>不知你看懂没有，这就是Paxos协议。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>以上就是理解这个Paxos算法的思路，如果你想具体了解这个算法的过程，可以查看视频，也可以看wiki百科里面关于Paxos的示例，写得已经很明白了，只有按照前言中的三条规则向下面走，你一定会明白，这个应该不是特别难于理解。</p><h2 id="决议的发布（主acceptor）"><a href="#决议的发布（主acceptor）" class="headerlink" title="决议的发布（主acceptor）"></a>决议的发布（主acceptor）</h2><p>一个显而易见的方法是当acceptors批准一个value时，将这个消息发送给所有learner。但是这个方法会导致消息量过大。</p><p>由于假设没有Byzantine failures，learners可以通过别的learners获取已经通过的决议。因此acceptors只需将批准的消息发送给指定的某一个learner，其他learners向它询问已经通过的决议。这个方法降低了消息量，但是指定learner失效将引起系统失效。</p><p><b style="color:red">因此acceptors需要将accept消息发送给learners的一个子集，然后由这些learners去通知所有learners。</b></p><p>但是由于消息传递的不确定性，可能会没有任何learner获得了决议批准的消息。当learners需要了解决议通过情况时，可以让一个proposer重新进行一次提案。注意一个learner可能兼任proposer。</p><h2 id="Progress的保证-主Proposer"><a href="#Progress的保证-主Proposer" class="headerlink" title="Progress的保证(主Proposer)"></a>Progress的保证(主Proposer)</h2><p><b style="color:red">根据上述过程当一个proposer发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。如果两个proposer在这种情况下都转而提出一个编号更大的提案，就可能陷入活锁</b>，违背了Progress的要求。这种情况下的解决方案是选举出一个leader，仅允许leader提出提案。但是由于消息传递的不确定性，可能有多个proposer自认为自己已经成为leader。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL25ldy1wbGF5LnR1ZG91LmNvbS92LzQ0NjU5NjkzOC5odG1sP3NwbT1hMmh6cC44MjUzODY5LjAuMA==" title="http://new-play.tudou.com/v/446596938.html?spm=a2hzp.8253869.0.0">paxos和分布式系统<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuL1BheG9zJUU3JUFFJTk3JUU2JUIzJTk1Iy5FNS5BRS45RS5FNC5CRS44Qg==" title="https://zh.wikipedia.org/zh-cn/Paxos%E7%AE%97%E6%B3%95#.E5.AE.9E.E4.BE.8B">Paxos算法<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2NvZGVtYWNyby5jb20vMjAxNC8xMC8xNS9leHBsYWluLXBveG9zLw==" title="http://codemacro.com/2014/10/15/explain-poxos/">图解分布式一致性协议Paxos<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuam9iYm9sZS5jb20vMTA2MzI3Lw==" title="http://blog.jobbole.com/106327/">图解 Paxos 一致性协议<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paxos </tag>
            
            <tag> 分布式一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中volatile解析</title>
      <link href="//java/Java%E4%B8%ADvolatile%E8%A7%A3%E6%9E%90.html"/>
      <url>//java/Java%E4%B8%ADvolatile%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>这几天又想起volatile的知识，我只是知道是为了可见性，多拷贝导致的不一致性，别的好像想不起来了，所以今天就来深入了解一下，免得忘记（网上的文章真长，有比要吗？）。</p><h2 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h2><p>这个是计算机体系结构的相关知识，计算机的数据存储大概是这样的。 CPU-&gt;寄存器-&gt;高速缓存块（cache）【可能不进cache】-&gt; 主存（内存）。所以操作一个对象的时候，可能就有存储多拷贝而引起的数据可见性的问题（多线程的情况下）。硬件上解决的话就是总线锁进行处理。</p><p>对于操作系统还存储内核空间和用户空间的数据拷贝的问题。</p><h2 id="并发三个概念"><a href="#并发三个概念" class="headerlink" title="并发三个概念"></a>并发三个概念</h2><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>多步操作完成一件事的时候才会出现的问题，大多数的操作都是多步完成的。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>多拷贝操作（并发计算等）进行数据回写的时候可能出现的问题。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>一般来说指令在CPU中是顺序执行的，但是CPU有时会进行指令重排序，但是保证不会影响执行的结果，但是会影响逻辑结果。</p><h3 id="指令重排序的危害"><a href="#指令重排序的危害" class="headerlink" title="指令重排序的危害"></a>指令重排序的危害</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>在上面这个例子中，如果线程1执行时语句1和语句2进行了对换，那么当线程2利用inited判断上下文是否被加载成功的时候可能会被误判，这是很危险的。</p><h2 id="Java的内存模型"><a href="#Java的内存模型" class="headerlink" title="Java的内存模型"></a>Java的内存模型</h2><p>基于栈帧的结构每个Java线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p><p>那么来看看java中对并发的处理情况：</p><h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>请分析以下哪些操作是原子性操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">y = x;         //语句2</span><br><span class="line">x++;           //语句3</span><br><span class="line">x = x + 1;     //语句4</span><br></pre></td></tr></table></figure><p></p><p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p><ul><li>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</li><li>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</li><li>语句3与4，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</li></ul><p>所以上面4个语句只有语句1的操作具备原子性。</p><p><b style="color:red">不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</b></p><p><b style="color:red">从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</b></p><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>对于可见性，Java提供了volatile关键字来保证可见性。</p><p><b style="color:red">另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</b></p><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p><b style="color:#00f">在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</b></p><p><b style="color:red">在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</b></p><p><b style="color:red">另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</b></p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h2 id="volatile特性"><a href="#volatile特性" class="headerlink" title="volatile特性"></a>volatile特性</h2><h3 id="volatile关键字的两层语义"><a href="#volatile关键字的两层语义" class="headerlink" title="volatile关键字的两层语义"></a>volatile关键字的两层语义</h3><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排序。</p><h3 id="volatile保证原子性吗？"><a href="#volatile保证原子性吗？" class="headerlink" title="volatile保证原子性吗？"></a>volatile保证原子性吗？</h3><p>不能保证，只能保证线程下次读取的值是最新的。类似于乐观锁而已。</p><h3 id="volatile能保证有序性吗？"><a href="#volatile能保证有序性吗？" class="headerlink" title="volatile能保证有序性吗？"></a>volatile能保证有序性吗？</h3><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>volatile关键字禁止指令重排序有两层意思：</p><ol><li><b style="color:red">当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</b></li><li>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li></ol><h3 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h3><p><b style="color:red">观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令(一种新的学习方法！)</b></p><p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><ol><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li></ol><h2 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h2><p>通常来说，使用volatile必须具备以下2个条件：</p><ol><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol><p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9scGhpbjA1MjAvcC8zOTIwMzczLmh0bWw=" title="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIP125：可选的交易费用替换信号【翻译】</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP125%EF%BC%9A%E5%8F%AF%E9%80%89%E7%9A%84%E4%BA%A4%E6%98%93%E8%B4%B9%E7%94%A8%E6%9B%BF%E6%8D%A2%E4%BF%A1%E5%8F%B7.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/BIP125%EF%BC%9A%E5%8F%AF%E9%80%89%E7%9A%84%E4%BA%A4%E6%98%93%E8%B4%B9%E7%94%A8%E6%9B%BF%E6%8D%A2%E4%BF%A1%E5%8F%B7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>这是关于比特币节点在mempool中去替换广播交易的一些原则，同时也提到了交易替换的变迁历史。原始的实现 -&gt; RBF -&gt; full-RBF -&gt; Opt-in fullRBF. 需要仔细理解方能理解其中的意思。<b style="color:red">也许这里面的信号（signal）也许也可以理解成标记。</b></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今天的许多节点不会在mempool里面用其他使用相同未花费输出替换相应的交易，使得花费者难以调整其先前发送的交易以处理意外的确认延迟或执行其他有用的替换。</p><p>此处所述的 opt-in full Replace-by-Fee (opt-in full-RBF) signaling 政策允许消费者向交易添加信号，表明他们希望能够在未来取代该交易。为了响应这个信号：</p><ul><li>节点允许包含这个信号的交易在其 mempools 中被替换。</li><li>在此信号交易未被确认之前，包含此信号交易的接收人不会用此付款，从而消除了付款人将使用允许的替换物来欺诈他们的风险。（交易确认之后才能继续交易，否则会出现双花的现象。可改动更会发生这个情况）。</li></ul><p>节点和接收人可以继续处理没有信号的交易，就像他们以前处理它们的方式一样，从而保持现有的现状。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>该政策规定了交易可以通过两种方式表明其可以替换。</p><ul><li>显式信令：如果一个交易的任何输入的nSequence数小于（0xffffffff - 1），则认为交易允许替换。</li><li>继承信号：只要其中任何一个祖先表示可替换并且未被确认，没有明确表示信号可替换的交易在本政策下可以被替换。</li></ul><h3 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节</h3><p>比特核心0.12.0预期的初步实施使用以下规则：</p><p>当前在mempool中的一个或多个交易（原始交易）将被替换为花费一个或多个相同输入的新交易（替换交易）</p><ul><li>原始交易处理信号的可替换性可以显式地或通过继承实现，如上述摘要部分所述。</li><li>替换交易不包含先前未出现在mempool中的任何新的未确认输入。（未确认的输入是从当前未确认的交易中消耗输出的输入。）</li><li>替换交易至少支付原始交易支付的金额的绝对费用。</li><li>替换交易还必须支付自己的带宽，其速率等于或高于节点的最低中继费用设置的速率。例如，如果最低中继费为1satoshi/byte，并且替换交易总共为500字节，则替换者必须支付至少500 satoshis的费用，高于原件总和。（修改是有代价的）</li><li>将要从mempool中删除的原始交易及其后代交易的数量总计不得超过100笔交易。</li></ul><p>最初的实现可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9wdWxsLzY4NzE=" title="https://github.com/bitcoin/bitcoin/pull/6871">比特核心PR＃6871<i class="fa fa-external-link"></i></span>中看到， 特别是主分支从5891f870d68d90408aa5ce5b597fb574f2d2cbca提交到16a2f93629f75d182871f288f0396afe6cdc8504（含）。</p><h3 id="接收钱包政策"><a href="#接收钱包政策" class="headerlink" title="接收钱包政策"></a>接收钱包政策</h3><p>向用户显示未经确认的交易或向自动化系统提供有关未确认交易数据的钱包应考虑执行以下操作之一：</p><ul><li>向用户或数据使用者传递更多的关于opt-in full-RBF交易的怀疑（推测）。</li><li>在确认之前忽略选择性（opt-in）交易。</li></ul><p><b style="color:red">因为后代交易也可以通过继承信号在此策略下进行替换，只要任何祖先加入交易的full-RBF交易并保持未确认状态，那么任何用于处理<code>opt-in full-RBF</code>交易的方法都应该被任何后代交易继承。</b></p><h3 id="支出钱包政策"><a href="#支出钱包政策" class="headerlink" title="支出钱包政策"></a>支出钱包政策</h3><p><b style="color:#00f">当想要使用锁定时间时，不希望信号可替换性的钱包应使用最大序列号（0xffffffff）或序列号（0xffffffff-1）; 所有已知的钱包目前都这样做</b>。<b style="color:red">他们还应该注意不要花费任何明确的信号替代性或通过遗传信号未经确认的交易; 除了他们自己创造的交易，大多数钱包目前也不花费任何未经确认的交易。</b></p><p>希望进行替换的钱包应使用明确的信号并符合上述实施细节中描述的标准。一个<span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvVHJhbnNhY3Rpb25fcmVwbGFjZW1lbnQ=" title="https://en.bitcoin.it/wiki/Transaction_replacement">Bitcoin的Wiki页面<i class="fa fa-external-link"></i></span>已经建立，以帮助钱包作者跟踪与交易更换mempool部署策略。</p><p>最初的实现是利用P2P协议拒绝消息来拒绝替换，允许P2P客户端确定他们的替换是否最初被同伴接受。 标准的P2P轻量级客户端的做法是，在侦听来自其他对等方的中继时发送给某些对等方，对等方应该允许客户端确定替换是否已传播。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>Satoshi Nakamoto最初的比特币实现在每个输入中提供了nSequence数字字段，以<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Ryb3R0aWVyL29yaWdpbmFsLWJpdGNvaW4vYmxvYi9tYXN0ZXIvc3JjL21haW4uY3BwI0w0MzQ=" title="https://github.com/trottier/original-bitcoin/blob/master/src/main.cpp#L434">允许<i class="fa fa-external-link"></i></span> 在mempool中替换包含该输入的交易。在接收替换时，节点应该用序号较高的交易替换输入序号较低的交易。</p><p>在那个实施中，替换交易不需要支付额外的费用，所以矿工们没有直接的动机来包括替代品，也没有内置的限制速度，防止过度使用中继节点带宽。Nakamoto 从比特币版本0.3.12中<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9jb21taXQvMDU0NTQ4MThkYzdlZDkyZjU3N2ExYTFlZjY3OTgwNDlmMTdhNTJlNyNkaWZmLTExOGZjYmFhYmExNjJiYTE3OTMzYzc4OTMyNDdkZjNhUjUyMg==" title="https://github.com/bitcoin/bitcoin/commit/05454818dc7ed92f577a1a1ef6798049f17a52e7#diff-118fcbaaba162ba17933c7893247df3aR522">删除了替代品<i class="fa fa-external-link"></i></span>，仅留下评论“暂时禁用替换功能”。</p><p>用较高费用的交易替代交易为消费者提供了一种使他们的愿望与矿工相一致的方式，但是到费用替代（RBF）补丁用来重新启用替代时，一些接收者开始期望他们所看到的第一个交易版本可能是要确认的交易的版本，因此一些用户主张替换应该被禁止。</p><p><b style="color:red">为了解决这些问题，创建了一个RBF变体，要求替换交易支付与原始交易所有输出相同或更大的金额。 这被称为RBF-First Seen Safe（RBF-FSS），并且最初的RBF被称为全RBF。</b> <b style="color:#00f">虽然对于依赖首次交易版本的接受者来说是合适的，但每次使用RBF-FSS都需要在交易中增加额外的输入，导致钱包无法使用，如果他们没有备用输入，则会丧失隐私，当不同来源的输入在相同的交易中被使用时，交易字节大小的浪费将会增加。</b></p><p><b style="color:red">Opt-in full-RBF使用Nakamoto的原始语义（稍作调整以允许锁定时间用户选择退出）表示可以进行替换，为首次使用的用户提供忽略这些交易的能力，同时还有可以提高full-RBF效率的优点。</b></p><p>opt-in full-RBF和nSequence的其他用途之间没有已知的有问题的相互作用。具体来说，选择性全RBF符合比特币0.1实施，BIP68草案（使用共识执行的序列号的相对锁定时间）草案和BIP112（CHECKSEQUENCEVERIFY）草案中提供的达成共识的锁定时间。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>自从比特币首次发布以来，100％的网络哈希率使用选择全RBF语义（序列小于（0xffffffff - 1））来挖掘交易。</p><p>选择全RBF作为节点和矿工之间默认的mempool替换策略，预计会在升级到Bitcoin Core 0.12.0（预计2016年1月/ 2月发布） 并且会和类似节点软件（比如比特币LJR）一样变得普遍。</p><p>在满足两个条件之前，实际更换可能不可靠：</p><ul><li>足够的节点已经升级到支持它，提供了一个中继路径，用于替换从支出钱包到控制大量散列率的矿工。</li><li>足够的散列率已经升级以支持替换，从而允许可以挖掘替换的合理可能性。</li></ul><h2 id="客户支持"><a href="#客户支持" class="headerlink" title="客户支持"></a>客户支持</h2><p>目前没有已知的钱包在默认情况下创建交易，其中nSequence设置在下面（0xffffffff – 1），因此默认情况下没有已知的现有钱包明确指示可替换性。 没有已知的流行钱包默认支付其他用户未确认的交易，因此没有已知的现有钱包表明继承的可替换性。</p><h2 id="也可以看看"><a href="#也可以看看" class="headerlink" title="也可以看看"></a>也可以看看</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvVHJhbnNhY3Rpb25fcmVwbGFjZW1lbnQ=" title="https://en.bitcoin.it/wiki/Transaction_replacement">Bitcoin Wiki上的交易可替换性<i class="fa fa-external-link"></i></span>旨在帮助钱包作者使用RBF</li><li>用于创建选择性全RBF交易的工具：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGVydG9kZC9yZXBsYWNlLWJ5LWZlZS10b29scyNyZXBsYWNlLWJ5LWZlZS10b29scw==" title="https://github.com/petertodd/replace-by-fee-tools#replace-by-fee-tools">https://github.com/petertodd/replace-by-fee-tools#replace-by-fee-tools<i class="fa fa-external-link"></i></span></li><li>Reddit：<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL0JpdGNvaW4vY29tbWVudHMvM3VybThvL29wdGluX3JiZl9pc19taXN1bmRlcnN0b29kX2Fza19xdWVzdGlvbnNfYWJvdXRfaXQv" title="https://www.reddit.com/r/Bitcoin/comments/3urm8o/optin_rbf_is_misunderstood_ask_questions_about_it/">关于选择性RBF的问题<i class="fa fa-external-link"></i></span>旨在帮助社区成员了解opt-in<br>full-RBF.<br>版权<br>该文件置于公共领域。</li></ol><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDEyNS5tZWRpYXdpa2k=" title="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">Opt-in Full Replace-by-Fee Signaling<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交易替换 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币粉尘和空块</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B2%89%E5%B0%98%E5%92%8C%E7%A9%BA%E5%9D%97.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E7%B2%89%E5%B0%98%E5%92%8C%E7%A9%BA%E5%9D%97.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近看了bitcoinj的TransactionOutput类发现了里面的关于粉尘的一些功能。网上搜索关于比特币粉尘的知识，发现了空块攻击和粉尘攻击的一些说明，但是只是简单地进行表述而已。也看到了矿工如何利用各种手段进行作弊，这个可能就是区块链所不能监控的了。所以我觉得区块链的问题还是很多的。</p><h2 id="什么是空块攻击"><a href="#什么是空块攻击" class="headerlink" title="什么是空块攻击"></a>什么是空块攻击</h2><p>空块的意思很明确，就是区块中没有交易，其实不管怎么样应该是有一笔交易的，就是挖矿奖励的coinbase交易。但是呢块被接收是经过大量的计算工作量的，所以这个看起来有点不太现实。从经济的角度来说这是不太靠谱，但是这种攻击最大的好处就是不用启动算力攻击。比如说你有全网1%的算力，那么发起空包攻击的概率也是很大的，但是就是这1%的算力也是不小的投入。算力攻击其实就是能控制全网51%的算力，这个时候你可以随意更改区块的信息。我在想以后会不会出现网络攻击，瘫痪大部分网络，在一小片网络中占据算力，从本质上说，区域网内的机器也可以进行挖矿，所以也比较困难。</p><p>另外个别情况下偶尔一次，也没有问题，但短期内频繁空块就是攻击了，其效果是使交易内存池变大，交易平均确认时间变长。其实已经有很多矿池消灭了空块的，技术上没有难度的。打包空块并不会比打包满块有优势。但是有ASICBoost专利就不同了，空块有利于ASICBoost专利的实施。</p><h2 id="粉尘攻击"><a href="#粉尘攻击" class="headerlink" title="粉尘攻击"></a>粉尘攻击</h2><p>如果要想理解粉尘攻击就必须先理解什么是粉尘。任何会消耗其费用三分之一以上的交易输出都不是比特币系统现在想要处理的东西，所以我们称之为“粉尘输出”，并且它们是非标准的。</p><p>一个典型的输出是33字节（pubkey hash +操作码），需要输入148字节的消耗，所以我们将它们加在一起以找出用于传输这个数值的总数据量。请注意，这个公式对于任何不是付费地址输出的东西都是错误的，不幸的是，我们必须遵循比特币核心的错误以确保我们被认为是标准。一个更好的公式可以估计满足所有不同脚本类型所需的数据大小，或者只是使用硬编码33。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 这个是根据实时的数据进行的计算。</span><br><span class="line">public Coin getMinNonDustValue(Coin feePerKb) &#123;</span><br><span class="line">    final long size = this.unsafeBitcoinSerialize().length + 148;</span><br><span class="line">    // 计算交易费</span><br><span class="line">    return feePerKb.multiply(size).divide(1000);</span><br><span class="line">&#125;</span><br><span class="line">// 默认是费用的3倍</span><br><span class="line">public Coin getMinNonDustValue() &#123;</span><br><span class="line">    return getMinNonDustValue(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的这段代码就是用来计算最小的输出，如果小于这个输出值，我们就认为这个输出是粉尘输出。</p><h2 id="关于小金额的问题"><a href="#关于小金额的问题" class="headerlink" title="关于小金额的问题"></a>关于小金额的问题</h2><p>如果地址上未花费输出比较小，那么很有可能就是使用的时候，这笔钱都不能支付交易费（这就是粉尘判断所不能接受的），这样会损失金额。也可以通过账户不停地将账户的钱转移到大账户里面去，看来不管是何种数字货币，都不能避免零头损失的问题。我们做钱包的应用多少都存在这样的问题。但是以太坊不是基于UTXO，而是基于账户多少能缓解不少的问题。</p><h2 id="广播攻击"><a href="#广播攻击" class="headerlink" title="广播攻击"></a>广播攻击</h2><p>如果不停地向网络广播大量的垃圾交易会阻塞网络，如果我们的节点能检测出这个交易是非法的，并且停止广播，那么这个问题就不会很严重，但是如果修改了代码，不做这个的检测就会出现大问题。比如说矿池大量发送这样的交易，这就会引起灾难性的后果。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
            <tag> 粉尘攻击 </tag>
            
            <tag> 空包攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币地址和脚本</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80%E5%92%8C%E8%84%9A%E6%9C%AC.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80%E5%92%8C%E8%84%9A%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>这两天由于要做多签名的钱包的问题，所以一直在关注比特币钱包的知识，当我看到bitcoinj里面的知识时，发现了ScriptBuilder的类，也发现了bitcoinj文档中有提到怎么使用多签名的钱包，这里就简单带过吧，今天的主题还是要说明钱包的地址和脚本的一些知识。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>首先关于钱包地址大概有以下几种：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">版本前缀（hex）</th><th style="text-align:center">Base58结果的前缀</th></tr></thead><tbody><tr><td style="text-align:center">传统bitcoin地址</td><td style="text-align:center">0x00</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P2SH</td><td style="text-align:center">0x05</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">比特币测试网络地址</td><td style="text-align:center">0x6F</td><td style="text-align:center">m或者n</td></tr><tr><td style="text-align:center">私钥WIF</td><td style="text-align:center">0x80</td><td style="text-align:center">5、K、L</td></tr><tr><td style="text-align:center">BIP-38编码私钥</td><td style="text-align:center">0x0142</td><td style="text-align:center">6P</td></tr><tr><td style="text-align:center">BIP-32编码私钥</td><td style="text-align:center">0x0488B21E</td><td style="text-align:center">xpub</td></tr></tbody></table><p>其实地址的类型和交易的解锁也是有很大的相关关系的。<b style="color:#00f">如果你创造了一种新的地址类型，并配置了相关的加密和解密脚本，那么这个地址是可以工作的，只是没有钱包支持，你需要提供能够利用这种地址类型，发送解密和加密脚本的客户端，这样你的地址就可以生效了，当然你也要兼容其他类型，如果发送的地址类型是其他的，那你的输出脚本要按照对应地址类型的要求来才行</b>。</p><p>比特币地址的生成规则如下：</p><p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/blockchain/%E4%BC%A0%E7%BB%9F%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5.png"></p><h2 id="传统的比特币地址脚本P2PKH"><a href="#传统的比特币地址脚本P2PKH" class="headerlink" title="传统的比特币地址脚本P2PKH"></a>传统的比特币地址脚本P2PKH</h2><p>对于比特币脚本的语言介绍这里不提太多，比特币脚本其实就是一种基于堆栈的脚本语言，堆栈是一个非常简单的数据结构，可以被视为一叠卡片。栈允许两个操作：push和pop（推送和弹出）。</p><p>对于解锁脚本大概是这样的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure><p></p><p>前面输出的锁定脚本是这样的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sig&gt; &lt;pubk&gt;</span><br></pre></td></tr></table></figure><p></p><p>那么整体的脚本是这样的：<br><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/p2pkh%E8%84%9A%E6%9C%AC%E5%9B%BE%E7%A4%BA.png?raw=true"></p><h2 id="P2SH"><a href="#P2SH" class="headerlink" title="P2SH"></a>P2SH</h2><p>Gavin Andresen在bip16提出一种P2SH(pay to Script Hash)方法，主要目的有两个，一是容许发送者构造丰富的交易类型，二是将字节从A-&gt;B的output转移到B-&gt;C的input(A-&gt;B的output script中将是固定长度)。</p><p>对于解锁的脚本是<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH256 6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000 OP_EQUAL</span><br></pre></td></tr></table></figure><p></p><p>我们可以理解成解数学中的难题，hash(x) = 6fe28c0ab6f1b372c1a6 我们只是提供一个x满足这个条件，就可以证明我可以花费这笔钱了。这里<code>6fe28c0ab6f1b372c1a6a246ae63f74f931e8365e15a089c68d6190000000000</code>不是简单的一个数字的hash，而是一段script的hash(简称redeemScript), <b style="color:red">我们可以理解成只要你提供了一段script，它的二进制hash和目标匹配，那么你就可以花费这笔钱了，注意这里是前端脚本执行的输出是x就行了。</b>.</p><p><b style="color:red">请注意，虽然这样的交易很有趣，但它们并不安全，因为它们不包含任何签名，因此任何试图花费它们的交易都可以用将资金发送到其他地方，用不同的交易来替代</b>。</p><h3 id="P2SH地址生成"><a href="#P2SH地址生成" class="headerlink" title="P2SH地址生成"></a>P2SH地址生成</h3><p>可以使用 go-bitcoin-multisig 生成，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nvcm91c2hqcC9nby1iaXRjb2luLW11bHRpc2ln" title="https://github.com/soroushjp/go-bitcoin-multisig">Github地址<i class="fa fa-external-link"></i></span>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig keys --count 3 --concise</span><br></pre></td></tr></table></figure><p></p><p>生成结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">KEY #1  </span><br><span class="line">Private key:  </span><br><span class="line">5JruagvxNLXTnkksyLMfgFgf3CagJ3Ekxu5oGxpTm5mPfTAPez3  </span><br><span class="line">Public key hex:  </span><br><span class="line">04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1JzVFZSN1kxGLTHG41EVvY5gHxLAX7q1Rh  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #2  </span><br><span class="line">Private key:  </span><br><span class="line">5JX3qAwDEEaapvLXRfbXRMSiyRgRSW9WjgxeyJQWwBugbudCwsk  </span><br><span class="line">Public key hex:  </span><br><span class="line">046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">14JfSvgEq8A8S7qcvxeaSCxhn1u1L71vo4  </span><br><span class="line">--------------</span><br><span class="line">--------------</span><br><span class="line">KEY #3  </span><br><span class="line">Private key:  </span><br><span class="line">5JjHVMwJdjPEPQhq34WMUhzLcEd4SD7HgZktEh8WHstWcCLRceV  </span><br><span class="line">Public key hex:  </span><br><span class="line">0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83  </span><br><span class="line">Public Bitcoin address:  </span><br><span class="line">1Kyy7pxzSKG75L9HhahRZgYoer9FePZL4R  </span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><p></p><p>接着我们取出里面所有的Public key（hex格式）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Key A: </span><br><span class="line">04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd </span><br><span class="line">Key B: </span><br><span class="line">046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187 </span><br><span class="line">Key C: </span><br><span class="line">0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83</span><br></pre></td></tr></table></figure><p></p><p>然后就可以使用这三组Public key组合起来（A,B,C）进行多重签名：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bitcoin-multisig address --m 2 --n 3 --public-keys 04a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd,046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187,0411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e83</span><br></pre></td></tr></table></figure><p></p><p>接着就生成了P2SH地址：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---------------------</span><br><span class="line">Your *P2SH ADDRESS* is:  </span><br><span class="line">347N1Thc213QqfYCz3PZkjoJpNv5b14kBd  </span><br><span class="line">Give this to sender funding multisig address with Bitcoin.  </span><br><span class="line">---------------------</span><br><span class="line">---------------------</span><br><span class="line">Your *REDEEM SCRIPT* is:  </span><br><span class="line">524104a882d414e478039cd5b52a92ffb13dd5e6bd4515497439dffd691a0f12af9575fa349b5694ed3155b136f09e63975a1700c9f4d4df849323dac06cf3bd6458cd41046ce31db9bdd543e72fe3039a1f1c047dab87037c36a669ff90e28da1848f640de68c2fe913d363a51154a0c62d7adea1b822d05035077418267b1a1379790187410411ffd36c70776538d079fbae117dc38effafb33304af83ce4894589747aee1ef992f63280567f52f5ba870678b4ab4ff6c8ea600bd217870a8b4f1f09f3a8e8353ae  </span><br><span class="line">Keep private and provide this to redeem multisig balance later.  </span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><p></p><h2 id="多重签名地址"><a href="#多重签名地址" class="headerlink" title="多重签名地址"></a>多重签名地址</h2><p>在bitcoin bips历史上先有M-of-N Transaction(bip-11),然后才有Pay To Script Hash(bip-16)(简称P2SH). 按照这个顺序，其实比特币中实现多重签名有两种方法：</p><h3 id="原始的方法-bip-11"><a href="#原始的方法-bip-11" class="headerlink" title="原始的方法(bip-11)"></a>原始的方法(bip-11)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scriptPubKey : m &#123;pubkey&#125;...&#123;pubkey&#125; n OP_CHECKMULTISIG</span><br><span class="line">scriptSig : OP_0 ...signatures...</span><br></pre></td></tr></table></figure><p>可以查看一下实例：<span class="exturl" data-url="aHR0cHM6Ly9ibG9ja2NoYWluLmluZm8vdHgvMDlkZDk0ZjJjODUyNjIxNzNkYTg3YTc0NWE0NTkwMDdiYjFlZWQ2ZWViNmJmYTIzOGEwY2Q5MWExNmNmNzc5MA==" title="https://blockchain.info/tx/09dd94f2c85262173da87a745a459007bb1eed6eeb6bfa238a0cd91a16cf7790">09dd94f2c85262173da87a745a459007bb1eed6eeb6bfa238a0cd91a16cf7790<i class="fa fa-external-link"></i></span></p><h3 id="用P2SH来实现"><a href="#用P2SH来实现" class="headerlink" title="用P2SH来实现"></a>用P2SH来实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scriptSig: [signature] &#123;[pubkey] OP_CHECKSIG&#125;</span><br><span class="line">scriptPubKey: OP_HASH160 [20-byte-hash of &#123;[pubkey] OP_CHECKSIG&#125; ] OP_EQUAL</span><br></pre></td></tr></table></figure><p>这里{[pubkey] OP_CHECKSIG}就是我们提到redeemScript代码. 实例：<span class="exturl" data-url="aHR0cHM6Ly9ibG9ja2NoYWluLmluZm8vdHgvM2M5MDE4ZThkNTYxNWMzMDZkNzIzOTdmOGY1ZWVmNDQzMDhjOThmYjU3NmE4OGUwMzBjMjU0NTZiNGYzYTdhYw==" title="https://blockchain.info/tx/3c9018e8d5615c306d72397f8f5eef44308c98fb576a88e030c25456b4f3a7ac">3c9018e8d5615c306d72397f8f5eef44308c98fb576a88e030c25456b4f3a7ac<i class="fa fa-external-link"></i></span></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>首先P2SH和MultiSig是完全不同两码事，很多文章将P2SH表述成MultiSig，这是不恰当的。只不过现在可以用P2SH来实现MultiSig。</li><li>比特币的关键是认证，刚开始中本聪提供用私钥认证，后来人发明了用hash(redeemScript)认证.</li><li>P2SH丰富了交易类型，简单易扩展</li></ol><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovLzhidGMuY29tL3RocmVhZC0yMzQ0MC0xLTEuaHRtbA==" title="http://8btc.com/thread-23440-1-1.html">http://8btc.com/thread-23440-1-1.html<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
            <tag> 脚本 </tag>
            
            <tag> 多签名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊智能合同搭建简易指南</title>
      <link href="//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E5%90%8C%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97.html"/>
      <url>//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E5%90%8C%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>本文是翻译的作品。适用于Truffle v3.4.11和Solidity v0.4.15。</p><p>我一直<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXJhb3ovc21hcnQtY29udHJhY3RzLWFuZC1iaXRjb2luLWE1ZDYxMDExZDliMQ==" title="https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1">在使用4年的智能合约<i class="fa fa-external-link"></i></span>，主要是在比特币区块链中。我参与的一些项目是 <span class="exturl" data-url="aHR0cHM6Ly9wb2V4LmlvLw==" title="https://poex.io/">Proof of Existence<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9iaXRjb3JlLmlvLw==" title="https://bitcore.io/">bitcore<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9zdHJlYW1pdW0uaW8v" title="https://streamium.io/">Streamium<i class="fa fa-external-link"></i></span>。在过去的几个月中，我一直在以太坊上探索和工作。</p><p>我已经决定编写一个简短的指南，以减轻未来程序员学习以太坊智能合约开发的难度。我已经将指南分为两部分：如何开始在以太坊建立智能合约以及关于智能合约安全的简要说明。</p><h2 id="以太坊智能合约入门"><a href="#以太坊智能合约入门" class="headerlink" title="以太坊智能合约入门"></a>以太坊智能合约入门</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>本指南假定您对加密货币和区块链的工作方式具有基本的技术理解。如果你还不了解，我建议你先阅读<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5ib29rL2JpdGNvaW5ib29r" title="https://github.com/bitcoinbook/bitcoinbook">Andreas Antonopoulos的精通比特币书籍<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BDb25zZW5TeXMvdGltZS1zdXJlLWRvZXMtZmx5LWVkNDUxODc5MjY3OSMucjVlNHhuYnBo" title="https://medium.com/@ConsenSys/time-sure-does-fly-ed4518792679#.r5e4xnbph">Consensys的“Just Etough Bitcoin for Ethereum”指南<i class="fa fa-external-link"></i></span>，或者至少观看<span class="exturl" data-url="aHR0cDovL3d3dy5pbXBvbmRlcmFibGV0aGluZ3MuY29tLzIwMTMvMDcvaG93LWJpdGNvaW4td29ya3MtdW5kZXItaG9vZC5odG1s" title="http://www.imponderablethings.com/2013/07/how-bitcoin-works-under-hood.html">Scott Driscoll的短片<i class="fa fa-external-link"></i></span>。要继续学习，您应该知道公钥和私钥是什么，为什么区块链需要矿工，如何达成分散化的共识，交易是什么，以及交易脚本和智能合约的概念。</p><p>在使用以太坊之前需要了解的另外两个相关重要的概念是以太坊虚拟机（EVM）和汽油（Gas）。</p><p>以太坊被设计成一个智能合约平台。它的起源实际上与Vitalik Buterin在比特币上作为非常有限的智能合约平台所作的批评有关。在以太坊中由<span class="exturl" data-url="aHR0cDovL2dhdndvb2QuY29tL1BhcGVyLnBkZg==" title="http://gavwood.com/Paper.pdf">以太坊虚拟机（EVM）<i class="fa fa-external-link"></i></span>来执行智能合约。与比特币相比，它为脚本提供了更富有表现力和完整的语言。事实上，它是一种<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XaGl0ZS1QYXBlciNjb21wdXRhdGlvbi1hbmQtdHVyaW5nLWNvbXBsZXRlbmVzcw==" title="https://github.com/ethereum/wiki/wiki/White-Paper#computation-and-turing-completeness">图灵完备<i class="fa fa-external-link"></i></span>的编程语言。一个很好的比喻是，EVM是一个分布式的全球计算机，所有的智能合约都在这里被执行。</p><p>鉴于智能合约在EVM中运行，必须有一种机制来限制每个合同使用的资源。<b style="color:red">在EVM中执行的每一个操作实际上都是由网络中的每个节点同时执行的。这就是gas存在的原因</b>。以太坊交易合同代码可触发数据读取和写入，执行昂贵的计算，如使用密码原语，向其他合同进行呼叫（发送消息）等。这些操作中的每一个都具有以gas量化的成本，并且交易消费的每个gas单位必须在Ether中支付，计算基于gas/ether价格动态变化。此价格从发送交易的以太坊帐户中扣除。交易还有一个gas_limit参数，这个参数是交易可以消耗多少天然气的上限，并被用作防止可能耗尽账户资金的编程错误的安全防范。<span class="exturl" data-url="aHR0cHM6Ly9ldGhlcmV1bS5naXRib29rcy5pby9mcm9udGllci1ndWlkZS9jb250ZW50L2Nvc3RzLmh0bWw=" title="https://ethereum.gitbooks.io/frontier-guide/content/costs.html">你可以在这里阅读更多关于gas的知识<i class="fa fa-external-link"></i></span>。</p><h3 id="1-建立你的环境"><a href="#1-建立你的环境" class="headerlink" title="1.建立你的环境"></a>1.建立你的环境</h3><p>那么你知道基础知识后，让我们使用代码来设置一切！要开始开发以太坊应用程序（或DApps，分布式应用程序，许多人喜欢这么称它们），您需要一个客户端来连接到网络。它将充当您分布式网络的窗口，并提供区块链的视图，视图将呈现所有EVM状态。</p><p>以太坊协议有各种兼容的客户端，最流行的是geth，一种Go语言的实现。但是，这不是最适合开发人员的。我发现的最好的选择是testrpc节点（名字确实很烂）。相信我，它会为你节省很多时间。安装并运行它（根据您的设置，您可能需要预先sudo安装）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g ethereumjs-testrpc </span><br><span class="line">$ testrpc</span><br></pre></td></tr></table></figure><p></p><p>你应该运行testrpc一个新的终端，并在开发时保持运行。每次运行testrpc时，它都会生成10个带有模拟测试资金的新地址供您使用。这不是真正的金钱，你可以安全地尝试任何事情，没有丢失资金的风险。</p><p>在以太坊编写智能合同最流行的语言是<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3Qv" title="https://solidity.readthedocs.io/en/latest/">solidity<i class="fa fa-external-link"></i></span>，因此我们将使用solidity。我们还使用了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RydWZmbGVzdWl0ZS90cnVmZmxl" title="https://github.com/trufflesuite/truffle">Truffle开发框架<i class="fa fa-external-link"></i></span>，该框架有助于创建智能合约，编译，部署和测试。让我们开始吧（再提一下，您可能需要sudo根据您的设置预先安装）：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 首先，我们安装truffle</span><br><span class="line">$ npm install -g truffle</span><br><span class="line"># 让我们来设置我们的项目</span><br><span class="line">$ mkdir solidity-experiments </span><br><span class="line">$ cd solidity-experiments/ </span><br><span class="line">$ truffle init</span><br></pre></td></tr></table></figure><p></p><p>truffle将创建示例项目的所有文件，包括MetaCoin合约，一个代币合约示例。</p><p>通过运行<code>truffle compile</code>来编译示例合约。然后，要使用我们运行的testrpc节点将合约部署到模拟网络，需要运行<code>truffle migrate</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ truffle compile</span><br><span class="line">Compiling ConvertLib.sol...</span><br><span class="line">Compiling MetaCoin.sol...</span><br><span class="line">Compiling Migrations.sol...</span><br><span class="line">Writing artifacts to ./build/contracts</span><br><span class="line">$ truffle migrate</span><br><span class="line">Using network &apos;development&apos;.</span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Deploying Migrations...</span><br><span class="line">  ... 0x686ed32f73afdf4a84298642c60e2002a6d0d736a5478cc8cb22a655ac018a67</span><br><span class="line">  Migrations: 0xa7edbac1156f98907a24d18df8104b5b1bd7027c</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xe3bf1e50d2262d9ffb015091e5f2974c8ebe0d6fd0df97a7dbcde8a0e51c694a</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Deploying ConvertLib...</span><br><span class="line">  ... 0x2e0e6718f01d0da6da2ada13d6e4ad662c5a20e784e04c404e9d4ef1d392bdae</span><br><span class="line">  ConvertLib: 0xf4388ce4d4ce8a443228d65ecfa5149205db049f</span><br><span class="line">  Linking ConvertLib to MetaCoin</span><br><span class="line">  Deploying MetaCoin...</span><br><span class="line">  ... 0xb03a3cde0672a2bd4dda6c01dd31641d95bd680c4e21162b3370ed6db7a5620d</span><br><span class="line">  MetaCoin: 0x4fc68713f7ac86bb84ac1ef1a09881a9b8d4100f</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">  ... 0xb9a2245c27ff1c6506c0bc6349caf86a31bc9f700388defe04566b6d237b54b6</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><p></p><p><em><b style="color:#00f">Mac OS X用户注意：truffle有时会被.DS_Store文件混淆。如果您遇到提及其中某个文件的错误，请将其删除。</b></em></p><p>我们只是将示例合同部署到我们的testrpc节点。Wohoo！那很简单，对吧？现在是时候创建我们自己的合同了！</p><h3 id="写第一个以太坊智能合约"><a href="#写第一个以太坊智能合约" class="headerlink" title="写第一个以太坊智能合约"></a>写第一个以太坊智能合约</h3><p>在本指南中，我们将编写简单的<span class="exturl" data-url="aHR0cHM6Ly9wb2V4LmlvLw==" title="https://poex.io/">存在证明<i class="fa fa-external-link"></i></span>的智能合约。这个想法是创建一个数字公证，存储文档哈希以证明其存在。使用<code>truffle create contract</code>开始吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle create contract ProofOfExistence1</span><br></pre></td></tr></table></figure><p></p><p>现在用你最喜欢的文本编辑器打开contracts/ProofOfExistence1.sol（我使用带有<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvbWxpb24vdmltLXNvbGlkaXR5" title="https://github.com/tomlion/vim-solidity">Solidity语法高亮显示<i class="fa fa-external-link"></i></span>的vim），并粘贴这个代码的初始版本：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.15;</span><br><span class="line">// 存在证明合同，版本1 </span><br><span class="line">contract ProofOfExistence1 &#123;</span><br><span class="line">  // 状态</span><br><span class="line">  bytes32 public proof;</span><br><span class="line">  // 计算并存储文档证明</span><br><span class="line">  // *事务性函数* </span><br><span class="line">  function notarize(string document) &#123;</span><br><span class="line">    proof = proofFor(document);</span><br><span class="line">  &#125;</span><br><span class="line">  // 帮助函数获取文档的sha256 </span><br><span class="line">  // *只读函数* </span><br><span class="line">  function proofFor(string document) constant returns (bytes32) &#123;</span><br><span class="line">    return sha256(document);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">我们将从简单但不正确的事情开始，并朝着更好的解决方案迈进</b>。这是一个Solidity契约的定义，它就像其他编程语言中的一个类。合同具有状态和功能(函数)。区分合同中可能出现的两种功能非常重要：</p><ul><li>只读（constant）函数：不执行任何状态更改的函数。他们只读状态，执行计算并返回值。由于这些功能可以由每个节点本地解决，所以它们不需要gas。标有关键字constant。</li><li>交易功能：<b style="color:red">执行合约状态变更或移动资金的功能。由于这些变化需要在区块链中得到体现，交易功能执行需要向网络发送交易并消耗天然气。</b></li></ul><p>我们上面的合约中各种类型都有一个实例，文章注释中已经标记出来了。下一节，我们将学习如何通过方法的修饰符判断方法的类型，我们如何和智能合约交互。</p><p>这个简单的版本一次仅存储一个证明，使用数据类型bytes32（32个字节），这是sha256散列的大小。交易函数notarize允许将文档的散列存储在我们的智能合约的状态变量proof中。所述变量是公开的，并且也是我们合约用户验证文档是否已公证的唯一方式。我们很快就会做到这一点，但首先…</p><p>让我们部署ProofOfExistence1到网络中！这一次，您必须编辑迁移文件（migrations/2_deploy_contracts.js）以使Truffle部署我们的新合同。用以下内容替换文件中的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ProofOfExistence1 = artifacts.require(&quot;./ProofOfExistence1.sol&quot;);</span><br><span class="line">module.exports = function(deployer) &#123;</span><br><span class="line">  deployer.deploy(ProofOfExistence1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>为了再次运行此迁移，您需要使用重置flag标志，以确保它再次运行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle migrate --reset</span><br></pre></td></tr></table></figure><p></p><p>更多关于truffle迁移工作的信息可以在<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL21pZ3JhdGlvbnM=" title="http://truffleframework.com/docs/getting_started/migrations">这里<i class="fa fa-external-link"></i></span>找到。</p><h3 id="与您的智能合约交互"><a href="#与您的智能合约交互" class="headerlink" title="与您的智能合约交互"></a>与您的智能合约交互</h3><p>现在我们已经部署了合约，让我们操作这个合约吧！我们可以通过函数调用向它发送消息并查看它的公共状态。我们将使用solidity控制台：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ truffle console</span><br><span class="line">// 获得我们部署的合约</span><br><span class="line">truffle(default)&gt; var poe = ProofOfExistence1.at(ProofOfExistence1.address)</span><br><span class="line">// 打印其地址</span><br><span class="line">truffle(default)&gt; poe.address</span><br><span class="line">0x3d3bce79cccc331e9e095e8985def13651a86004</span><br><span class="line">// 让我们注册我们的第一个“document” </span><br><span class="line">truffle(default)&gt; poe.notarize(&apos;An amazing idea&apos;)</span><br><span class="line">&#123; tx: &apos;0x18ac...cb1a&apos;,</span><br><span class="line">  receipt: </span><br><span class="line">   &#123; transactionHash: &apos;0x18ac...cb1a&apos;,</span><br><span class="line">     ...</span><br><span class="line">   &#125;,</span><br><span class="line">  logs: [] &#125;</span><br><span class="line">// 现在让我们得到该文件的证明</span><br><span class="line">truffle(default)&gt; poe.proofFor(&apos;An amazing idea&apos;)</span><br><span class="line">0xa3287ff8d1abde95498962c4e1dd2f50a9f75bd8810bd591a64a387b93580ee7</span><br><span class="line">// 检查合同的状态是否正确地被更改</span><br><span class="line">truffle(default)&gt; poe.proof()</span><br><span class="line">0xa3287ff8d1abde95498962c4e1dd2f50a9f75bd8810bd591a64a387b93580ee7</span><br><span class="line">// 散列符合我们之前计算的那个</span><br></pre></td></tr></table></figure><p></p><p>我们所做的第一件事是获得我们部署的合同的表示并将其存储在一个名为poe的变量中。</p><p>然后我们调用交易方法notarize，这涉及到状态的改变。当我们调用一个交易函数时，我们得到一个Promise，它解析为一个交易对象，而不是实际函数返回的。<b style="color:red">请记住，要改变EVM状态，我们需要花费gas并向网络发送交易</b>。这就是为什么我们得到一个交易信息对象作为Promise的结果，指的是做了这种状态变化的交易。在这种情况下，我们对交易ID没有兴趣，所以我们只丢弃Promise。在编写真实应用程序时，我们需要保存它以检查生成的事务并捕获错误。</p><p>接下来，我们调用只读（constant）函数proofFor。<b style="color:red">请记住用关键字标记您的只读功能constant，否则Truffle将尝试制定一个交易来执行它们</b>。这是告诉我们Truffle没有与区块链互动但只是阅读区块链的一种方式。通过使用这个只读函数，我们获得了“An amazing idea”、“document”的sha256哈希。</p><p>我们现在需要与智能合约的状态进行对比。要检查状态是否被正确更改，我们需要读取proof公共状态变量。为了获得公共状态变量的值，我们可以调用一个同名的函数，该函数返回其值的Promise。在我们的例子中，输出哈希是相同的，所以一切都按预期工作:)。</p><p>有关如何与合约进行交互的更多信息，请阅读<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL2NvbnRyYWN0cw==" title="http://truffleframework.com/docs/getting_started/contracts">Truffle文档的这一部分<i class="fa fa-external-link"></i></span>。</p><p>正如你可以从上面的代码片段看到的，我们的存在证明智能合约的第一个版本似乎正在工作！干得好！不过，它一次只能注册一个文档。我们来创建一个更好的版本。</p><h3 id="迭代合同代码"><a href="#迭代合同代码" class="headerlink" title="迭代合同代码"></a>迭代合同代码</h3><p>让我们更改合同以支持多个文档证明。使用名称复制原始文件contracts/ProofOfExistence2.sol并应用这些更改。主要的变化是：我们将proof变量改为bytes32数组并将其称为证明，我们将其变为私有，并且我们添加一个函数通过迭代该数组来检查文档是否进行公证。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.15;</span><br><span class="line"></span><br><span class="line">// 证明存在契约，版本2 </span><br><span class="line">contract ProofOfExistence2 &#123;</span><br><span class="line">  // 状态</span><br><span class="line">  bytes32[] private proofs;</span><br><span class="line">  // 在合约状态中存储存在证明</span><br><span class="line">  // *transactional function* 事务性函数</span><br><span class="line">  function storeProof(bytes32 proof) &#123;</span><br><span class="line">    proofs.push(proof);</span><br><span class="line">  &#125;</span><br><span class="line">  // 计算并存储文档证明</span><br><span class="line">  // *transactional function* 事务性函数</span><br><span class="line">  function notarize(string document) &#123;</span><br><span class="line">    bytes32 proof = proofFor(document);</span><br><span class="line">    storeProof(proof);</span><br><span class="line">  &#125;</span><br><span class="line">  // 帮助函数获取文档的sha256 </span><br><span class="line">  // *read-only function* 只读函数</span><br><span class="line">  function proofFor(string document) constant returns (bytes32) &#123;</span><br><span class="line">    return sha256(document);</span><br><span class="line">  &#125;</span><br><span class="line">  // 检查一个文档是否已经过公证</span><br><span class="line">  // *read-only function* 只读函数</span><br><span class="line">  function checkDocument(string document) constant returns (bool) &#123;</span><br><span class="line">    bytes32 proof = proofFor(document);</span><br><span class="line">    return hasProof(proof);</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果存储了证明，则返回true </span><br><span class="line">  // *read-only function* 只读函数</span><br><span class="line">  function hasProof(bytes32 proof) constant returns (bool) &#123;</span><br><span class="line">    for (uint256 i = 0; i &lt; proofs.length; i++) &#123;</span><br><span class="line">      if (proofs[i] == proof) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>让我们与新功能进行交互：（请记住更新migrations/2_deploy_contracts.js以包含新合同并运行<code>truffle migrate --reset</code>）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 部署合约</span><br><span class="line">truffle(default)&gt;  migrate --reset</span><br><span class="line">// 获取新版本的合同</span><br><span class="line">truffle(default)&gt; var poe = ProofOfExistence2.at(ProofOfExistence2.address)</span><br><span class="line">// 让我们来检查一下新的文档，它不应该在那里。</span><br><span class="line">truffle(default)&gt; poe.checkDocument(&apos;hello&apos;)</span><br><span class="line">false</span><br><span class="line">// 让我们现在将该文档添加到证明存储</span><br><span class="line">truffle(default)&gt; poe.notarize(&apos;hello&apos;)</span><br><span class="line">&#123; tx: &apos;0x1d2d...413f&apos;,</span><br><span class="line">  receipt: &#123; ... &#125;,</span><br><span class="line">  logs: []</span><br><span class="line">&#125;</span><br><span class="line">// 现在让我们再次检查文档是否已公证！</span><br><span class="line">truffle(default)&gt; poe.checkDocument(&apos;hello&apos;)</span><br><span class="line">true</span><br><span class="line">// success!成功！</span><br><span class="line">// 我们也可以存储其他文档，它们被记录为</span><br><span class="line">truffle(default)&gt; poe.notarize(&apos;some other document&apos;);</span><br><span class="line">truffle(default)&gt; poe.checkDocument(&apos;some other document&apos;)</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p></p><p>这个版本比第一个更好，但仍然有一些问题。请注意，每次我们要检查文档是否经过公证时，我们都需要遍历所有现有的证明。这使得随着更多文件的添加，合同花费越来越多。存储证据的更好的结构是map。幸运的是，Solidity支持map，并称它们为映射。我们将在这个版本中改进的另一件事是删除标记为只读或事务函数的所有额外注释。我想你现在已经理解它了:)</p><p>这是最终版本，应该很容易理解，因为您遵循以前的版本：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.15;</span><br><span class="line">// 存在证明合同，版本3 </span><br><span class="line">contract ProofOfExistence3 &#123;</span><br><span class="line">  mapping (bytes32 =&gt; bool) private proofs;</span><br><span class="line">  // store a proof of existence in the contract state</span><br><span class="line">  // 在合约状态中存储文档存在证明</span><br><span class="line">  function storeProof(bytes32 proof) &#123;</span><br><span class="line">    proofs[proof] = true;</span><br><span class="line">  &#125;</span><br><span class="line">  // 计算和存储文档证明</span><br><span class="line">  function notarize(string document) &#123;</span><br><span class="line">    var proof = proofFor(document);</span><br><span class="line">    storeProof(proof);</span><br><span class="line">  &#125;</span><br><span class="line">  // 帮助函数用于获取文档的sha256 </span><br><span class="line">  function proofFor(string document) constant returns (bytes32) &#123;</span><br><span class="line">    return sha256(document);</span><br><span class="line">  &#125;</span><br><span class="line">  // 检查一个文档是否被公证过</span><br><span class="line">  function checkDocument(string document) constant returns (bool) &#123;</span><br><span class="line">    var proof = proofFor(document);</span><br><span class="line">    return hasProof(proof);</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果存储了证明，则返回true </span><br><span class="line">  function hasProof(bytes32 proof) constant returns(bool) &#123;</span><br><span class="line">    return proofs[proof];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这看起来不错。它和第二个版本完全一样。要试用它，请记住更新迁移文件并再次执行<code>truffle migrate --reset</code>。本教程中的所有代码都可以在此<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmFvei9zb2xpZGl0eS1leHBlcmltZW50cw==" title="https://github.com/maraoz/solidity-experiments">GitHub仓库<i class="fa fa-external-link"></i></span>中找到。</p><h3 id="部署到真正的testnet网络"><a href="#部署到真正的testnet网络" class="headerlink" title="部署到真正的testnet网络"></a>部署到真正的testnet网络</h3><p>一旦您在模拟网络中使用testrpc广泛测试了您的合约，就可以在真实网络中尝试它！为此，我们需要一个真正的testnet/livenet以太坊客户端。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL3dpa2kvQnVpbGRpbmctRXRoZXJldW0=" title="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum">按照这些说明安装geth<i class="fa fa-external-link"></i></span>。</p><p>在开发过程中，你应该在testnet模式下运行节点，这样你就可以测试所有的东西而不用冒险花钱。Testnet模式（也被称为以太坊的Morden）与真实的以太坊基本相同，但以太币表示没有货币价值。不要偷懒，记得总是在testnet模式下开发，如果由于编程错误而失去真正的以太币，你会后悔的（相信我吧，嘿嘿）。</p><p>在testnet模式下运行geth，启用RPC服务器：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --testnet --rpc console 2 &gt;&gt; geth.log</span><br></pre></td></tr></table></figure><p></p><p>这将打开一个控制台，您可以在其中键入基本命令来控制您的节点/客户端。您的节点将开始下载testnet区块链，并且您可以通过检查eth.blockNumber来检查进度。在区块链下载的同时，您仍然可以运行命令。例如，我们创建一个帐户:(记住密码！）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br><span class="line">Passphrase:</span><br><span class="line">Repeat passphrase:</span><br><span class="line">&quot;0xa88614166227d83c93f4c50be37150b9500d51fc&quot;</span><br></pre></td></tr></table></figure><p></p><p>让我们在那里发送一些货币并检查余额。你可以在<span class="exturl" data-url="aHR0cDovL2ZhdWNldC5yb3BzdGVuLmJlOjMwMDEv" title="http://faucet.ropsten.be:3001/">这里<i class="fa fa-external-link"></i></span>免费获得testnet的以太币。只需复制粘贴您刚刚生成的地址，然后这里头会向您发送一些testnet以太币。要检查你的余额，运行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance（eth.accounts[0]）</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>由于您的节点尚未与网络的其余部分同步，因此它不会显示余额。在您等待的时候，请在testnet区块浏览器中检查您的余额。在那里，你还可以看到当前testnet最高的块号（编写本文时为＃1819865），你可以结合eth.blockNumber来知道你的节点何时完全同步。</p><p>一旦您的节点已同步，您就可以使用Truffle将合约部署到测试网络。首先，解锁您的主要帐户，以便truffle可以使用它。并确保它保持一定的余额，否则你将无法将新合约推送到网络。在geth运行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount（eth.accounts [0]，“mypassword”，24 * 3600）</span><br><span class="line">true </span><br><span class="line">&gt; eth.getBalance（eth.accounts [0]）</span><br><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><p></p><p>准备好出发！如果上面的没有正常起作用，请检查上述步骤并确保您已正确完成。现在运行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truffle migrate --reset</span><br></pre></td></tr></table></figure><p></p><p>请注意，这次完成需要更长的时间，因为我们正在连接到实际的网络，而不是testrpc模拟的网络。一旦完成，您可以使用与之前相同的方法与合同进行交互。</p><p>可以在地址<span class="exturl" data-url="aHR0cHM6Ly9yb3BzdGVuLmV0aGVyc2Nhbi5pby9hZGRyZXNzLzB4Y2FmMjE2ZDE5NzVmNzVhYjNmZWQ1MjBlMWUzMzI1ZGFjM2U3OWUwNQ==" title="https://ropsten.etherscan.io/address/0xcaf216d1975f75ab3fed520e1e3325dac3e79e05">0xcaf216d1975f75ab3fed520e1e3325dac3e79e05<i class="fa fa-external-link"></i></span>处找到测试网部署的ProofOfExistence3版本。（随意与它交互并发送您的证明！）</p><p>我将把如何部署到实时网络的细节留给读者。你应该只有在模拟网络和测试网络中广泛测试合同。记住任何编程错误都可能导致livenet资金损失！</p><h2 id="以太坊的智能合约安全很难"><a href="#以太坊的智能合约安全很难" class="headerlink" title="以太坊的智能合约安全很难"></a>以太坊的智能合约安全很难</h2><p>“做到智能合约正确真的很难。” <span class="exturl" data-url="aHR0cDovL2hhY2tpbmdkaXN0cmlidXRlZC5jb20vMjAxNi8wNy8xMy9yZWVudHJhbmN5LXdvZXMv" title="http://hackingdistributed.com/2016/07/13/reentrancy-woes/">EminGünSirer<i class="fa fa-external-link"></i></span></p><p>天性使然，智能合约是定义资金流动的计算机代码，如果没有关于安全性的小记录，我不能结束本指南。我将在未来的帖子中更深入地讨论智能合约安全（编辑：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9vbndhcmQtd2l0aC1ldGhlcmV1bS1zbWFydC1jb250cmFjdC1zZWN1cml0eS05N2E4MjdlNDc3MDI=" title="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702">像这样<i class="fa fa-external-link"></i></span>），但这里有一些快速注释来帮助你入门。</p><p>您应该注意的一些问题（并避免）：</p><ul><li><span class="exturl" data-url="aHR0cDovL2hhY2tpbmdkaXN0cmlidXRlZC5jb20vMjAxNi8wNy8xMy9yZWVudHJhbmN5LXdvZXMv" title="http://hackingdistributed.com/2016/07/13/reentrancy-woes/">重入<i class="fa fa-external-link"></i></span>：不要在合同中执行外部调用。如果你这样做，确保他们是你做的最后一件事。</li><li><span class="exturl" data-url="aHR0cDovL3Zlc3NlbmVzLmNvbS9ldGhlcmV1bS1ncmllZmluZy13YWxsZXRzLXNlbmQtdy10aHJvdy1jb25zaWRlcmVkLWhhcm1mdWwv" title="http://vessenes.com/ethereum-griefing-wallets-send-w-throw-considered-harmful/">发送可能会失败<i class="fa fa-external-link"></i></span>：在发送货币时，您的代码应始终为发送功能失败做好准备。</li><li><span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9zZWN1cml0eS1jb25zaWRlcmF0aW9ucy5odG1sI2dhcy1saW1pdC1hbmQtbG9vcHM=" title="http://solidity.readthedocs.io/en/latest/security-considerations.html#gas-limit-and-loops">循环可能触发gas限制<i class="fa fa-external-link"></i></span>：<b style="color:red">循环状态变量时要小心，这些状态变量可能会增大并且使气体消耗达到极限。</b></li><li><span class="exturl" data-url="aHR0cHM6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNjI2MC9zb2xpZGl0eS1jYWxsc3RhY2stYXR0YWNr" title="https://ethereum.stackexchange.com/questions/6260/solidity-callstack-attack">调用堆栈深度限制<i class="fa fa-external-link"></i></span>：请勿使用递归，并且要注意，如果达到堆栈深度限制，任何调用都可能失败。编辑：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvYmxvYi9tYXN0ZXIvRUlQUy9laXAtMTUwLm1k" title="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md">这不再是一个问题<i class="fa fa-external-link"></i></span>。<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvbnNlblN5cy9zbWFydC1jb250cmFjdC1iZXN0LXByYWN0aWNlcyN0aW1lc3RhbXAtZGVwZW5kZW5jZQ==" title="https://github.com/ConsenSys/smart-contract-best-practices#timestamp-dependence">时间戳依赖性<i class="fa fa-external-link"></i></span>：<b style="color:red">不要在代码的关键部分使用时间戳，因为矿工可以操纵它们</b>。</li></ul><p>这些仅仅是作为可能导致您的智能合约中的资金被盗用或破坏的意外行为的例子。真理是：如果你正在写智能合约，你正在编写处理真钱的代码。你应该非常小心！编写测试，做代码评论，并<span class="exturl" data-url="aHR0cHM6Ly96ZXBwZWxpbi5zb2x1dGlvbnMvc2VjdXJpdHktYXVkaXRz" title="https://zeppelin.solutions/security-audits">审核你的代码<i class="fa fa-external-link"></i></span>。</p><p>避免显而易见的安全问题的最好方法是对语言有深入的了解。如果您有时间，我建议您阅读<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvaW50cm9kdWN0aW9uLXRvLXNtYXJ0LWNvbnRyYWN0cy5odG1s" title="https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html">Solidity文档<i class="fa fa-external-link"></i></span>。我们仍然需要更好的工具来实现可接受的智能合约 （编辑：接近这篇文章的原始出版物，我们发布了<span class="exturl" data-url="aHR0cHM6Ly9vcGVuemVwcGVsaW4ub3JnLw==" title="https://openzeppelin.org/">OpenZeppelin库<i class="fa fa-external-link"></i></span>，并且我们最近发布了<span class="exturl" data-url="aHR0cHM6Ly96ZXBwZWxpbm9zLm9yZy8=" title="https://zeppelinos.org/">zeppelinOS<i class="fa fa-external-link"></i></span>。</p><p>就写这些了！我希望您喜欢阅读本指南并了解您在以太坊编程智能合约的第一步！这仍然是一个非常新的行业，有很多新的应用程序和工具的空间。欢迎随时与我交流想法或原型。</p><p>如果您有兴趣讨论智能合约的安全，请加入我们的<span class="exturl" data-url="aHR0cHM6Ly9zbGFjay5vcGVuemVwcGVsaW4ub3JnLw==" title="https://slack.openzeppelin.org/">闲暇频道<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy8=" title="https://blog.zeppelin.solutions/">在Medium上关注我们<i class="fa fa-external-link"></i></span>，或<span class="exturl" data-url="aHR0cHM6Ly96ZXBwZWxpbi5zb2x1dGlvbnMvYWJvdXQjam9icw==" title="https://zeppelin.solutions/about#jobs">申请与我们合作<i class="fa fa-external-link"></i></span>！我们也可以在<span class="exturl" data-url="aHR0cHM6Ly96ZXBwZWxpbi5zb2x1dGlvbnMvc2VydmljZXM=" title="https://zeppelin.solutions/services">智能合同安全开发<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly96ZXBwZWxpbi5zb2x1dGlvbnMvc2VjdXJpdHktYXVkaXRz" title="https://zeppelin.solutions/security-audits">审计工作<i class="fa fa-external-link"></i></span>中联系交流。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXJhb3o=" title="https://medium.com/@maraoz">Manuel Araoz blog<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy90aGUtaGl0Y2hoaWtlcnMtZ3VpZGUtdG8tc21hcnQtY29udHJhY3RzLWluLWV0aGVyZXVtLTg0OGYwODAwMWYwNQ==" title="https://blog.zeppelin.solutions/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05">The Hitchhiker’s Guide to Smart Contracts in Ethereum<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全编写以太坊的智能合约指南</title>
      <link href="//blockchain/%E5%AE%89%E5%85%A8%E7%BC%96%E5%86%99%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%8C%87%E5%8D%97.html"/>
      <url>//blockchain/%E5%AE%89%E5%85%A8%E7%BC%96%E5%86%99%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%8C%87%E5%8D%97.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p><b style="color:#00f">安全的开发以太坊的智能合约，是非常需要花费精力的。已经有一些好的指南以及汇总，比如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvbnNlblN5cy9zbWFydC1jb250cmFjdC1iZXN0LXByYWN0aWNlcw==" title="https://github.com/ConsenSys/smart-contract-best-practices">Consensys的智能合约最佳实践<i class="fa fa-external-link"></i></span>，和<span class="exturl" data-url="aHR0cDovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9zZWN1cml0eS1jb25zaWRlcmF0aW9ucy5odG1s" title="http://solidity.readthedocs.io/en/latest/security-considerations.html">Solidity官方文档的安全指南<i class="fa fa-external-link"></i></span>。但除非真正写代码，这些概念很难被记住和理解。</b></p><p>本文会尝试一个有点不同的办法。首先解释提升智能合约安全的一些策略，并展示一些不遵从，而引起问题的例子。最后给一些已经调整地，可以直接使用的最佳实践。希望，这能帮助你创建避免某些不安全行为的肌肉记忆，从而在写代码的时候意识到可能的风险。</p><p>不啰嗦了，进入正题吧。</p><h2 id="尽早且明确的暴露问题"><a href="#尽早且明确的暴露问题" class="headerlink" title="尽早且明确的暴露问题"></a>尽早且明确的暴露问题</h2><p>一个简单且强大的最佳实践是，让<span class="exturl" data-url="aHR0cHM6Ly9vbmNvZGluZ3N0eWxlLmJsb2dzcG90LmpwLzIwMDgvMTAvZmFpbC1lYXJseS1mYWlsLWxvdWRseS5odG1s" title="https://oncodingstyle.blogspot.jp/2008/10/fail-early-fail-loudly.html">尽早且明确的暴露问题<i class="fa fa-external-link"></i></span>。接下来，看一个有问题的函数实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 有问题的代码，不要使用！</span><br><span class="line">contract BadFailEarly &#123;</span><br><span class="line">  uint constant DEFAULT_SALARY = 50000;</span><br><span class="line">  mapping(string =&gt; uint) nameToSalary;</span><br><span class="line"></span><br><span class="line">  function getSalary(string name) constant returns (uint) &#123;</span><br><span class="line">    if (bytes(name).length != 0 &amp;&amp; nameToSalary[name] != 0) &#123;</span><br><span class="line">      return nameToSalary[name];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return DEFAULT_SALARY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">为避免合约潜在的问题，或者让合约运行于一个不稳定或不一致的状态。上面例子中的函数getSalary应该在返回结果前，检查参数。那现在的例子有什么问题呢，问题在于，如果条件不满足，将返回默认值。这将掩盖参数的严重问题，因为仍然可以按正常业务逻辑返回值。这虽然是一个比较极端的例子，但却非常常见，原因是大家在程序设计时，担心程序兼容性不够，所以设置一些兜底方案。但真相是，越快失败，越容易发现问题。如果我们不恰当的掩盖错误，错误将扩散到代码的其它地方，从而引起非常难以跟踪的不一致错误。</b>快速失败也是一种很好的思想。下面是一个调整后的示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract GoodFailEarly &#123;</span><br><span class="line">  mapping(string =&gt; uint) nameToSalary;</span><br><span class="line">  </span><br><span class="line">  function getSalary(string name) constant returns (uint) &#123;</span><br><span class="line">    // 快速失败，让程序尽快退出运行 </span><br><span class="line">    if (bytes(name).length == 0) throw;</span><br><span class="line">    // 快速失败，让程序尽快退出运行 </span><br><span class="line">    if (nameToSalary[name] == 0) throw;</span><br><span class="line">    </span><br><span class="line">    return nameToSalary[name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个版本的代码，还展示了另外一种推荐的编码方式，一种将条件预检查分开，分开判断，验证失败的方式。原因是可以使用Solidity提供的修改器的特性，来实现重用。</p><h2 id="在支付时使用（pull）模式而不是（push）模式"><a href="#在支付时使用（pull）模式而不是（push）模式" class="headerlink" title="在支付时使用（pull）模式而不是（push）模式"></a><b style="color:red">在支付时使用（pull）模式而不是（push）模式</b></h2><p>每次ether的转移，都需要考虑对应帐户，潜在的代码执行。一个接收的合约可以实现一个默认的回退函数，这个函数可能抛出错误。由此，我们永远要考虑在send执行中的可能的错误。一个解决方案是，我们应该在支付时使用（pull）模式而不是（push）模式。来看一个看起来没有问题的，关于竞标函数的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 有问题的代码，请不要直接使用！</span><br><span class="line">contract BadPushPayments &#123;</span><br><span class="line">  address highestBidder;</span><br><span class="line">  uint highestBid;</span><br><span class="line"> </span><br><span class="line">  function bid() &#123;</span><br><span class="line">    // 如果throw的话，别人转进来以太币，但是执行的操作却失败了，这样会导致一些问题。</span><br><span class="line">    if (msg.value &lt; highestBid) throw;</span><br><span class="line">    if (highestBidder != 0) &#123;</span><br><span class="line">      // return bid to previous winner</span><br><span class="line">      // 这里调用了send函数, 进行退款（这个操作不是很安全）。</span><br><span class="line">      if (!highestBidder.send(highestBid)) &#123;</span><br><span class="line">        // 发生throw，那么可能别人的投资就失效了</span><br><span class="line">        throw;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    highestBidder = msg.sender;</span><br><span class="line">    highestBid = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述的合约，调用了send函数，检查了返回值，看起来是非常符合常理的。但它在函数中调用了send函数，这带来了不安全，为什么？需要时刻记住的一点是，就像之前说的，<b style="color:red">send会触发另外一个合约的代码执行。</b></p><p><b style="color:#00f">假如某个竞标的地址，它会在每次有人转帐给他时throw。而此时，其它人尝试追加价格竞标时会发生什么呢？那么send调用将总是会失败，从而错误向上抛，让bid函数产生一个异常。一个函数调用如果以错误结束，将会让状态不发生变更（所有的变化都将回滚）。这将意味着，没有人将能继续竞标，合约失效了。</b></p><p>最简单的解决方案是，将支付分离到另一个函数中，让用户请求（pull）金额，而不依赖于余下的合约逻辑：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract GoodPullPayments &#123;</span><br><span class="line">  address highestBidder;</span><br><span class="line">  uint highestBid;</span><br><span class="line">  // 定义一个缓冲队列</span><br><span class="line">  mapping(address =&gt; uint) refunds;</span><br><span class="line">  </span><br><span class="line">  function bid() external &#123;</span><br><span class="line">    if (msg.value &lt; highestBid) throw;</span><br><span class="line">    </span><br><span class="line">    if (highestBidder != 0) &#123;</span><br><span class="line">      // 先把数据放入缓冲队列中（map结构）。然后就返回。</span><br><span class="line">      refunds[highestBidder] += highestBid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    highestBidder = msg.sender;</span><br><span class="line">    highestBid = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function withdrawBid() external &#123;</span><br><span class="line">    // 从缓冲队列中取出数据，进行投票（两阶段分开操作）</span><br><span class="line">    uint refund = refunds[msg.sender];</span><br><span class="line">    // 清零，接下来进行处理</span><br><span class="line">    refunds[msg.sender] = 0;</span><br><span class="line">    // 这里再进行send方法的调用。</span><br><span class="line">    if (!msg.sender.send(refund)) &#123;</span><br><span class="line">      refunds[msg.sender] = refund;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">这次，我们使用一个mapping来存储每个待退款的竞标者的信息，提供了一个withdraw用于退款。</b>如果在send调用时抛出异常，仅仅只是那个有问题的竞标者受到影响。这是一个非常简单的模式，却解决了非常多的问题（比如，可重入）。所以，记住一点，当发送ether时，使用（pull）模式而不是（push）模式。</p><p>我已经实现了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9ibG9iL21hc3Rlci9jb250cmFjdHMvcGF5bWVudC9QdWxsUGF5bWVudC5zb2w=" title="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/payment/PullPayment.sol">一个使用这个模式的合约，可以方便的继承使用。<i class="fa fa-external-link"></i></span></p><h2 id="函数代码的顺序：条件，行为，交互"><a href="#函数代码的顺序：条件，行为，交互" class="headerlink" title="函数代码的顺序：条件，行为，交互"></a>函数代码的顺序：条件，行为，交互</h2><p><b style="color:red">作为尽可能早的暴露问题的原则的一个延伸，一个好的实践是将你的函数结构化为：首先，检查所有前置的条件；然后，对合约的状态进行修改；最后，与其它合约进行交互。</b></p><p>条件，行为，交互。坚持使用这样的函数结构，将会让你避免大部分的问题。下面来看使用了这个模式的一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function auctionEnd() &#123;</span><br><span class="line">  // 1. Conditions(条件)</span><br><span class="line">  if (now &lt;= auctionStart + biddingTime)</span><br><span class="line">    throw; // auction did not yet end</span><br><span class="line">  if (ended)</span><br><span class="line">    throw; // this function has already been called</span><br><span class="line"></span><br><span class="line">  // 2. Effects（行为，进行链外计算）</span><br><span class="line">  ended = true;</span><br><span class="line">  AuctionEnded(highestBidder, highestBid);</span><br><span class="line"></span><br><span class="line">  // 3. Interaction（交互，进行链上交易）</span><br><span class="line">  if (!beneficiary.send(highestBid))</span><br><span class="line">    throw;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这首先符合尽可能早的暴露问题的原则，因为条件在一开始就进行了检查。<b style="color:red">它让存在潜在交互风险的，与其它合约的交互，留到了最后。</b></p><h2 id="留意平台局限性"><a href="#留意平台局限性" class="headerlink" title="留意平台局限性"></a>留意平台局限性</h2><p><b style="color:red">EVM有非常多的关于合约能做的硬限制。这些是平台级的安全考虑，如果你不知道的话，却可以会威胁你的合约安全。</b>下面来看一个看起来正常的，雇员津贴管理的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 不安全的代码，不要直接使用！</span><br><span class="line">contract BadArrayUse &#123;</span><br><span class="line">  address[] employees;</span><br><span class="line">  </span><br><span class="line">  function payBonus() &#123;</span><br><span class="line">    for (var i = 0; i &lt; employees.length; i++) &#123;</span><br><span class="line">      address employee = employees[i];</span><br><span class="line">      uint bonus = calculateBonus(employee);</span><br><span class="line">      employee.send(bonus);</span><br><span class="line">    &#125;     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function calculateBonus(address employee) returns (uint) &#123;</span><br><span class="line">    // some expensive computation ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>读完代码，业务实现非常直接，看起来也没有什么问题，但却潜藏三个问题，基于平台的一些独特性。</p><p><b style="color:red">第一个问题是i的类型将会是uint8，因为如果要存0，如果不指定类型，将自动选择一个占用空间最小的，恰当的类型，在这里将是uint8。所以如果这个数组的大小超过255个元素，这个循环将永远不会结束，最终将导致gas耗尽。</b><b style="color:#00f">应当在定义变量时，尽可能的不要使用var，明确变量的类型，</b>下面我们来修正一下上面的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 仍然是不安全的代码，请不要使用！</span><br><span class="line">contract BadArrayUse &#123;</span><br><span class="line">  address[] employees;</span><br><span class="line">  </span><br><span class="line">  function payBonus() &#123;</span><br><span class="line">    for (uint i = 0; i &lt; employees.length; i++) &#123;</span><br><span class="line">      address employee = employees[i];</span><br><span class="line">      uint bonus = calculateBonus(employee);</span><br><span class="line">      employee.send(bonus);</span><br><span class="line">    &#125;     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function calculateBonus(address employee) returns (uint) &#123;</span><br><span class="line">    // some expensive computation ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第二个你需要考虑的事情是gas的限制。gas是以太坊的一种机制，来对资源的使用收费。<b style="color:red">每一个修改状态的功能调用都会花费gas</b>。<b style="color:red">假如calculateBonus计算津贴时有些复杂的运算，比如需要跨多个项目计算利润。这将消耗非常多的gas，将会很容易的达到交易和区块的gas限制。如果一个交易达到了gas的限制，所有的状态的改变都将会撤销，但消耗的gas不会退回</b>。当使用循环的时候，尤其要注意变量对gas消耗的影响。让我们来优化一下上述的代码，将津贴计算与循环分开。但需要注意的是，拆开后仍然有数组变大后，带来的gas消耗增长的问题：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// UNSAFE CODE, DO NOT USE!</span><br><span class="line">contract BadArrayUse &#123;</span><br><span class="line">  </span><br><span class="line">  address[] employees;</span><br><span class="line">  mapping(address =&gt; uint) bonuses;  </span><br><span class="line">  </span><br><span class="line">  function payBonus() &#123;</span><br><span class="line">    for (uint i = 0; i &lt; employees.length; i++) &#123;</span><br><span class="line">      address employee = employees[i];</span><br><span class="line">      uint bonus = bonuses[employee];</span><br><span class="line">      employee.send(bonus);</span><br><span class="line">    &#125;     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function calculateBonus(address employee) returns (uint) &#123;</span><br><span class="line">    uint bonus = 0;</span><br><span class="line">    // some expensive computation modifying the bonus...</span><br><span class="line">    bonuses[employee] = bonus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">最后，还有一个关于调用栈调用深度的限制。EVM栈调用的硬限制是1024。</b>这意味着如果嵌套调用的深度达到1024，合约调用将会失败。<b style="color:red">一个攻击者可以调用递归的调用我们的合约1023次，从而因为栈深度的限制，让send失败</b>。前述的（pull）模式，可以比较好的避免这个问题（译者注：原链接找不到了，但找下github上的讨论：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9pc3N1ZXMvMTU=" title="https://github.com/OpenZeppelin/zeppelin-solidity/issues/15">https://github.com/OpenZeppelin/zeppelin-solidity/issues/15<i class="fa fa-external-link"></i></span> ）。</p><p>下面是一个最终的修改版，解决了上述的所有问题：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./PullPaymentCapable.sol&apos;;</span><br><span class="line"></span><br><span class="line">contract GoodArrayUse is PullPaymentCapable &#123;</span><br><span class="line">  address[] employees;</span><br><span class="line">  // 还是先存在缓存中</span><br><span class="line">  mapping(address =&gt; uint) bonuses;</span><br><span class="line">  // 从缓存中一起发送红利</span><br><span class="line">  function payBonus() &#123;</span><br><span class="line">    for (uint i = 0; i &lt; employees.length; i++) &#123;</span><br><span class="line">      address employee = employees[i];</span><br><span class="line">      uint bonus = bonuses[employee];</span><br><span class="line">      asyncSend(employee, bonus);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 计算红利的方法，给某一个人计算红利</span><br><span class="line">  function calculateBonus(address employee) returns (uint) &#123;</span><br><span class="line">    uint bonus = 0;</span><br><span class="line">    // some expensive computation...</span><br><span class="line">    bonuses[employee] = bonus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>总结一下，需要记住的：</p><ol><li>使用的变量类型的限制</li><li>合约的gas消耗</li><li>栈调用1024的限制。</li></ol><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>编写测试用例会占用大量的时间，但也能抵消你在添加新功能后<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29mdHdhcmVfcmVncmVzc2lvbg==" title="https://en.wikipedia.org/wiki/Software_regression">回归问题<i class="fa fa-external-link"></i></span>需要花费的时间。回归问题具体是指在添加功能的修改过程中，导致之前的组件出现bug。</p><p>我将尽快写一个更加广泛的关于测试的指南，如果你比较好奇，可以先看看<span class="exturl" data-url="aHR0cDovL3RydWZmbGVmcmFtZXdvcmsuY29tL2RvY3MvZ2V0dGluZ19zdGFydGVkL3Rlc3Rpbmc=" title="http://truffleframework.com/docs/getting_started/testing">关于Truffle的测试指南<i class="fa fa-external-link"></i></span>。</p><h2 id="容错及自动bug奖励"><a href="#容错及自动bug奖励" class="headerlink" title="容错及自动bug奖励"></a>容错及自动bug奖励</h2><p>首先感谢Peter Borah带来的这两个想法的灵感。代码审查和安全审核对保证安全来说还不足够。我们的代码需要做好最坏情况的准备。<b style="color:red">当我们的智能合约中有漏洞时，应该有一种方法可以安全的恢复</b>。<b style="color:#00f">不止如此，我们也应该尽可能早的发现漏洞。下面是一个内置的自动bug奖励机制带来的作用</b>。</p><p>下面我们就来看一个自动bug奖励的假设的代币管理的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./PullPaymentCapable.sol&apos;;</span><br><span class="line">import &apos;./Token.sol&apos;;</span><br><span class="line"></span><br><span class="line">contract Bounty is PullPaymentCapable &#123;</span><br><span class="line">  bool public claimed;</span><br><span class="line">  mapping(address =&gt; address) public researchers;</span><br><span class="line">  </span><br><span class="line">  function() &#123;</span><br><span class="line">    if (claimed) throw;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function createTarget() returns(Token) &#123;</span><br><span class="line">    Token target = new Token(0);</span><br><span class="line">    researchers[target] = msg.sender;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function claim(Token target) &#123;</span><br><span class="line">    address researcher = researchers[target];</span><br><span class="line">    if (researcher == 0) throw;</span><br><span class="line">    </span><br><span class="line">    // check Token contract invariants</span><br><span class="line">    if (target.totalSupply() == target.balance) &#123;</span><br><span class="line">      throw;</span><br><span class="line">    &#125;</span><br><span class="line">    asyncSend(researcher, this.balance);</span><br><span class="line">    claimed = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先，正如前面所述，我们使用PullPaymentCapable来让我们的支付更加安全。这个赏金合约，允许研究者创建当前我们审核的Token合约的副本。任何人都可以参与到这个赏金项目，通过发送交易到这个赏金项目地址。<b style="color:red">如果任何研究者可以攻破他自己的Token合约的拷贝，让一些本不该变的情况变化（比如这里，让总代币发行量与当前代币余额不一致），他将获得对应的赏金。一旦赏金被领取了，合约将不再继续接受新的资金（无名的函数被称为合约的回退函数，在每次合约接收ether时自动执行）。</b></p><p>正如你看到的，它有一个非常好的特性是分离了合约，不需要对原始的Token合约进行修改。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eS9ibG9iL21hc3Rlci9jb250cmFjdHMvQm91bnR5LnNvbA==" title="https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/Bounty.sol">这里有一个完整，任何人都可以使用的版本<i class="fa fa-external-link"></i></span>。</p><p>而对于容错性，我们需要修改我们原来的合约来增加额外的安全机制。<b style="color:red">一种简单的方案是允许合约的监督者可以冻结合约，作为一种紧急的机制</b>。我们来看一个通过继承实现这种行为的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Stoppable &#123;</span><br><span class="line">  address public curator;</span><br><span class="line">  bool public stopped;</span><br><span class="line">  modifier stopInEmergency &#123; if (!stopped) _ &#125;</span><br><span class="line">  modifier onlyInEmergency &#123; if (stopped) _ &#125;</span><br><span class="line">  </span><br><span class="line">  function Stoppable(address _curator) &#123;</span><br><span class="line">    if (_curator == 0) throw;</span><br><span class="line">    curator = _curator;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function emergencyStop() external &#123;</span><br><span class="line">    if (msg.sender != curator) throw;</span><br><span class="line">    stopped = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Stoppable允许指定一个监督者，可以来停止整个合约。实现方式是，通过继承这个合约，在对应的功能上使用修改器stopInEmergency和onlyInEmergency，下面我们来看一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./PullPaymentCapable.sol&apos;;</span><br><span class="line">import &apos;./Stoppable.sol&apos;;</span><br><span class="line"></span><br><span class="line">contract StoppableBid is Stoppable, PullPaymentCapable &#123;</span><br><span class="line">  address public highestBidder;</span><br><span class="line">  uint public highestBid;</span><br><span class="line">  </span><br><span class="line">  function StoppableBid(address _curator)</span><br><span class="line">    Stoppable(_curator)</span><br><span class="line">    PullPaymentCapable() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  function bid() external stopInEmergency &#123;</span><br><span class="line">    if (msg.value &lt;= highestBid) throw;</span><br><span class="line">    </span><br><span class="line">    if (highestBidder != 0) &#123;</span><br><span class="line">      asyncSend(highestBidder, highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">    highestBidder = msg.sender;</span><br><span class="line">    highestBid = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function withdraw() onlyInEmergency &#123;</span><br><span class="line">    suicide(curator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">在上面这个非常简单的例子中，bid可以被一个监督者停止，监督者在合约创建时指定</b>。StoppableBid在正常情况下，只有bid函数可以被调用，而当出现紧急情况时，监督者可以介入，并激活紧急状态。并让bid函数不再可用，同时激活withdraw功能。</p><p>在上面的例子中，紧急模式将允许监督者销毁合约，恢复资金。但在实际场景中，恢复的逻辑更为复杂（举例来说，需要返还资金给每个投资者）。</p><h2 id="限制可存入的资金"><a href="#限制可存入的资金" class="headerlink" title="限制可存入的资金"></a>限制可存入的资金</h2><p><b style="color:#00f">另一个保护我们智能合约远离攻击的方式是限制。攻击者最有可能针对管理数百万美元的高调合同。并不是所有的合约，有这样的高的资金量。尤其是当我们正在初期。在这种情形下，限制合约可以接收的资金量就将非常有用。最简单的方式，可以实现为一个余额的硬上限。</b></p><p>下面是一个简单的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LimitFunds &#123;</span><br><span class="line">  </span><br><span class="line">  uint LIMIT = 5000;</span><br><span class="line">  </span><br><span class="line">  function() &#123; throw; &#125;</span><br><span class="line">  </span><br><span class="line">  function deposit() &#123;</span><br><span class="line">    if (this.balance &gt; LIMIT) throw;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>回退函数里，会拒绝接收所有的直接支付。deposit函数会首先检查合约的余额是否已经超限，超限将直接抛出异常。其它一些更有意思的，<b style="color:red">比如动态上限，管理限制也很容易实现</b>。</p><h2 id="简单和模块化的代码"><a href="#简单和模块化的代码" class="headerlink" title="简单和模块化的代码"></a>简单和模块化的代码</h2><p>安全来自，我们想写的与代码实际可以做的距离。这非常的难以验证，特别是当代码量又大，又混乱时。这就是为什么写简单和模块化的代码变得非常重要。</p><p>这意味着，函数应该尽可能的简单，代码之间的依赖应该极尽可能的少，文件应该尽可能的小，将独立的逻辑放进模块，每块的职责更加单一。</p><p>命名是我们在编码过程中表达我们意图的方式。想一个好的名字，尽可能的让名字清晰。</p><p>让我们来看一个关于<span class="exturl" data-url="aHR0cHM6Ly9zb2xpZGl0eS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvY29udHJhY3RzLmh0bWwjZXZlbnRz" title="https://solidity.readthedocs.io/en/latest/contracts.html#events">Event<i class="fa fa-external-link"></i></span>的差命名的例子。看看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nsb2NraXQvREFPL2Jsb2IvZGV2ZWxvcC9EQU8uc29sI0w2MTgtTDY5MQ==" title="https://github.com/slockit/DAO/blob/develop/DAO.sol#L618-L691">DAO里的函数<i class="fa fa-external-link"></i></span>。其中的函数代码都太长了。</p><p>最大的问题是太长，而且功能复杂。尽可能的让你的函数短小，比如，最多不超过30到40行代码。理想情况下，你应该在1分钟内弄明白函数的意图。另一个问题是关于事件Transfer在第685行的命名。这个名字与一个叫<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nsb2NraXQvREFPL2Jsb2IvZGV2ZWxvcC9EQU8uc29sI0w3NTU=" title="https://github.com/slockit/DAO/blob/develop/DAO.sol#L755">transfer的函数名<i class="fa fa-external-link"></i></span>只有一字之差。这将带来误解。<b style="color:red">一般来说，关于事件的推荐命名是使用Log打头</b>，这样的话，这个事件应该命名为LogTransfer。</p><p>记住，尽可能的将你的合约写得简单，模块化，良好的命名。这将极大的帮助其它人和你自己审查你自己的代码。</p><h2 id="不要从0开始写所有的代码"><a href="#不要从0开始写所有的代码" class="headerlink" title="不要从0开始写所有的代码"></a>不要从0开始写所有的代码</h2><p>最后，正如一句格言所说，“不要从头发明你自己的加密币”。我想它也适用于智能合约代码。你的操作与钱有关，你的数据是公开的，你正在一个全新的成长中的平台上。代价非常高，糟蹋机会的人无处不在。</p><p>上述这些实践帮助我们写出更安全的合约。但最终，我们应该开发出更好的创建智能合约的工具。这里有一些先行者，包括<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1IMnV3VWR6VkQ5SSZhbXA7ZmVhdHVyZT15b3V0dS5iZQ==" title="https://www.youtube.com/watch?v=H2uwUdzVD9I&amp;feature=youtu.be">better type systems<i class="fa fa-external-link"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmV0aGVyZXVtLm9yZy8yMDE1LzEyLzI0L3VuZGVyc3RhbmRpbmctc2VyZW5pdHktcGFydC1pLWFic3RyYWN0aW9uLw==" title="https://blog.ethereum.org/2015/12/24/understanding-serenity-part-i-abstraction/">Serenity Abstractions<i class="fa fa-external-link"></i></span> 和<span class="exturl" data-url="aHR0cHM6Ly93d3cucnNrLmNvLw==" title="https://www.rsk.co/">the Rootstock platform<i class="fa fa-external-link"></i></span>。</p><p>现在已经有非常多的安全的代码，以及框架出现了。我们整合了一部分最佳实践到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wZW5aZXBwZWxpbi96ZXBwZWxpbi1zb2xpZGl0eQ==" title="https://github.com/OpenZeppelin/zeppelin-solidity">Github的资源库Open Zeppelin<i class="fa fa-external-link"></i></span>。欢迎看看以及贡献新代码，以及提供代码审查建议。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>回顾一下，这篇文章中描述的安全模式有：</p><ul><li>尽早且明确的暴露问题。</li><li>使用（pull）模式而不是（push）模式</li><li>代码结构遵从：条件，行为，交互</li><li>注意平台限制</li><li>测试用例</li><li>容错及自动bug奖励</li><li>限制存入的资金</li><li>简单与模块化的代码</li><li>不要从零开始写代码</li></ul><p>如果你想讨论与智能合约相关的问题，欢迎加入Slack，让我们一起来提升智能合约编程标准。</p><h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplcHBlbGluLnNvbHV0aW9ucy9vbndhcmQtd2l0aC1ldGhlcmV1bS1zbWFydC1jb250cmFjdC1zZWN1cml0eS05N2E4MjdlNDc3MDI=" title="https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702">Onward with Ethereum Smart Contract Security<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约 </tag>
            
            <tag> contract </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitcoin脚本解析</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/bitcoin%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/bitcoin%E8%84%9A%E6%9C%AC%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在研究交易中输入输出的相关内容后我发现了一个Script类，于是决定研究一下。</p><p>在讲脚本之前还是先来了解一下比特币地址吧，因为不同的地址将导致不同的脚本解析。在Source类中有这几种类型：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum ScriptType &#123;</span><br><span class="line">    NO_TYPE,</span><br><span class="line">    P2PKH,</span><br><span class="line">    PUB_KEY,</span><br><span class="line">    P2SH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再看一下脚本的验证类型吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public enum VerifyFlag &#123;</span><br><span class="line">    P2SH, // Enable BIP16-style subscript evaluation.</span><br><span class="line">    STRICTENC, // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.</span><br><span class="line">    DERSIG, // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1)</span><br><span class="line">    LOW_S, // Passing a non-strict-DER signature or one with S &gt; order/2 to a checksig operation causes script failure</span><br><span class="line">    NULLDUMMY, // Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.</span><br><span class="line">    SIGPUSHONLY, // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).</span><br><span class="line">    MINIMALDATA, // Require minimal encodings for all push operations</span><br><span class="line">    DISCOURAGE_UPGRADABLE_NOPS, // Discourage use of NOPs reserved for upgrades (NOP1-10)</span><br><span class="line">    CLEANSTACK, // Require that only a single stack element remains after evaluation.</span><br><span class="line">    CHECKLOCKTIMEVERIFY, // Enable CHECKLOCKTIMEVERIFY operation</span><br><span class="line">    CHECKSEQUENCEVERIFY // Enable CHECKSEQUENCEVERIFY operation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><p>当我们说脚本的时候，经常省略了这些把数字压入堆栈的关键字。</p><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_0,OP_FALSE</td><td>0</td><td>0×00</td><td>无</td><td>空</td><td>一个字节空串被推到堆栈中(并非no-op操作，有一个元素压入堆栈)</td></tr><tr><td>N/A</td><td>1-75</td><td>0×01-0x4b</td><td>(特殊)</td><td>数据</td><td>下一个操作码字节是要被压入堆栈的数据</td></tr><tr><td>OP_PUSHDATA1</td><td>76</td><td>0x4c</td><td>(特殊)</td><td>数据</td><td>下一字节是要被压入堆栈的数据的长度</td></tr><tr><td>OP_PUSHDATA2</td><td>77</td><td>0x4d</td><td>(特殊)</td><td>数据</td><td>下两个字节是要被压入堆栈的数据的长度</td></tr><tr><td>OP_PUSHDATA4</td><td>78</td><td>0x4e</td><td>(特殊)</td><td>数据</td><td>下四个字节是要被压入堆栈的数据的长度</td></tr><tr><td>OP_1NEGATE</td><td>79</td><td>0x4f</td><td>无</td><td>-1</td><td>数字-1被压入堆栈</td></tr><tr><td>OP_1,OP_TRUE</td><td>81</td><td>0×51</td><td>无</td><td>1</td><td>数字1被压入堆栈</td></tr><tr><td>OP_2-OP_16</td><td>82-96</td><td>0×52-0×60</td><td>无</td><td>2-16</td><td>与关键名相对应的数字被压入堆栈</td></tr></tbody></table><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_NOP</td><td>97</td><td>0×61</td><td>无</td><td>无</td><td>无任何操作</td></tr><tr><td>OP_IF</td><td>99</td><td>0×63</td><td><expression>if [statements] [else [statements]]* endif</expression></td><td>–</td><td>如果栈项元素值不为0，语句将被执行，栈项元素值被删除。</td></tr><tr><td>OP_NOTIF</td><td>100</td><td>0×64</td><td><expression>if [statements] [else [statements]]* endif</expression></td><td>—</td><td>如果栈项元素值为0，语句将被执行，栈项元素值被删除。</td></tr><tr><td>OP_ELSE</td><td>103</td><td>0×67</td><td><expression>if [statements] [else [statements]]* endif</expression></td><td>—</td><td>如果前述的OP_IF或 OP_NOTIF或OP_ELSE 未被执行，这些语句就会被执行；如果前述的OP_IF或 OP_NOTIF或OP_ELSE被执行，这些语句就不会被执行</td></tr><tr><td>OP_ENDIF</td><td>104</td><td>0×68</td><td><expression>if [statements] [else [statements]]* endif</expression></td><td>—</td><td>结束if/else语言块</td></tr><tr><td>OP_VERIFY</td><td>105</td><td>0×69</td><td>True / false</td><td>无 / False</td><td>如果栈项元素值非真，则标记交易无效。True会被删除，False不会被删除。</td></tr><tr><td>OP_RETURN</td><td>106</td><td>0x6a</td><td>无</td><td>无</td><td>标记交易无效</td></tr></tbody></table><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_TOALTSTACK</td><td>107</td><td>0x6b</td><td>x1</td><td>(alt)x1</td><td>把输入压入辅堆栈的项部，从主堆栈删除。</td></tr><tr><td>OP_FROMALTSTACK</td><td>108</td><td>0x6c</td><td>(alt)x1</td><td>x1</td><td>把输入压入主堆栈的项部，从辅堆栈删除。</td></tr><tr><td>OP_IFDUP</td><td>115</td><td>0×73</td><td>x</td><td>x / x x</td><td>如果栈项元素值不为0，复制该元素值</td></tr><tr><td>OP_DEPTH</td><td>116</td><td>0×74</td><td>无</td><td>&lt;堆栈大小&gt;</td><td>把堆栈元素个数压入堆栈</td></tr><tr><td>OP_DROP</td><td>117</td><td>0×75</td><td>x</td><td>无</td><td>删除栈顶元素</td></tr><tr><td>OP_DUP</td><td>118</td><td>0×76</td><td>x</td><td>x x</td><td>复制栈顶元素</td></tr><tr><td>OP_NIP</td><td>119</td><td>0×77</td><td>x1 x2</td><td>x2</td><td>删除栈顶的下一个元素</td></tr><tr><td>OP_OVER</td><td>120</td><td>0×78</td><td>x1 x2</td><td>x1 x2 x1</td><td>复制栈顶的下一个元素到栈顶</td></tr><tr><td>OP_PICK</td><td>121</td><td>0×79</td><td>xn … x2 x1 x0<n></n></td><td>xn … x2 x1 x0 xn</td><td>把堆栈的第n个元素拷贝到栈顶</td></tr><tr><td>OP_ROLL</td><td>122</td><td>0x7a</td><td>xn … x2 x1 x0<n></n></td><td>… x2 x1 x0 xn</td><td>把堆栈的第n个元素移动到栈顶</td></tr><tr><td>OP_ROT</td><td>123</td><td>0x7b</td><td>x1 x2 x3</td><td>x2 x3 x1</td><td>栈顶的三个元素向左翻转</td></tr><tr><td>OP_SWAP</td><td>124</td><td>0x7c</td><td>x1 x2</td><td>x2 x1</td><td>栈顶的两个元素交换</td></tr><tr><td>OP_TUCK</td><td>125</td><td>0x7d</td><td>x1 x2</td><td>x2 x1 x2</td><td>把栈顶元素拷贝并插入到栈顶下一个元素之后。注意：原文为“插入到栈顶下一个元素之前”，可能有误，翻译时改为“之后”</td></tr><tr><td>OP_2DROP</td><td>109</td><td>0x6d</td><td>x1 x2</td><td>无</td><td>删除栈顶两个元素</td></tr><tr><td>OP_2DUP</td><td>110</td><td>0x6e</td><td>x1 x2</td><td>x1 x2 x1 x2</td><td>复制栈顶两个元素</td></tr><tr><td>OP_3DUP</td><td>111</td><td>0x6f</td><td>x1 x2 x3</td><td>x1 x2 x3 x1 x2 x3</td><td>复制栈顶三个元素</td></tr><tr><td>OP_2OVER</td><td>112</td><td>0×70</td><td>x1 x2 x3 x4</td><td>x1 x2 x3 x4 x1 x2</td><td>把栈底的两个元素拷贝到栈顶</td></tr><tr><td>OP_2ROT</td><td>113</td><td>0×71</td><td>x1 x2 x3 x4 x5 x6</td><td>x3 x4 x5 x6 x1 x2</td><td>以一对元素为单位，向左翻转。注意：原文大意“把第五和第六元素移动到栈顶”，明显有误</td></tr><tr><td>OP_2SWAP</td><td>114</td><td>0×72</td><td>x1 x2 x3 x4 x3 x4</td><td>x1 x2</td><td>以一对元素为单位，交换栈顶的两对元素的位置。</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果标记为已禁用的操作码出现在交易中，必须终止和失败返回。</p><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_CAT</td><td>126</td><td>0x7e</td><td>x1 x2</td><td>out</td><td>连接两个字符串，已禁用</td></tr><tr><td>OP_SUBSTR</td><td>127</td><td>0x7f</td><td>in begin size</td><td>out</td><td>返回字符串的一部分，已禁用</td></tr><tr><td>OP_LEFT</td><td>128</td><td>0×80</td><td>in size</td><td>out</td><td>在一个字符串中保留左边指定长度的子串，已禁用</td></tr><tr><td>OP_RIGHT</td><td>129</td><td>0×81</td><td>in size</td><td>out</td><td>在一个字符串中保留右边指定长度的子串，已禁用</td></tr><tr><td>OP_SIZE</td><td>130</td><td>0×82</td><td>in</td><td>in size</td><td>把栈顶元素的字符串长度压入堆栈(无需弹出元素)</td></tr></tbody></table><h3 id="位逻辑"><a href="#位逻辑" class="headerlink" title="位逻辑"></a>位逻辑</h3><p>如果标记为已禁用的操作码出现在交易中，必须终止和失败返回。</p><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_INVERT</td><td>131</td><td>0×83</td><td>in</td><td>out</td><td>所有输入的位取反，已禁用.</td></tr><tr><td>OP_AND</td><td>132</td><td>0×84</td><td>x1 x2</td><td>out</td><td>对输入的所有位进行布尔与运算，已禁用</td></tr><tr><td>OP_OR</td><td>133</td><td>0×85</td><td>x1 x2</td><td>out</td><td>对输入的每一位进行布尔或运算，已禁用</td></tr><tr><td>OP_XOR</td><td>134</td><td>0×86</td><td>x1 x2</td><td>out</td><td>对输入的每一位进行布尔异或运算，已禁用</td></tr><tr><td>OP_EQUAL</td><td>135</td><td>0×87</td><td>x1 x2</td><td>True / false</td><td>如果输入的两个数相等，返回1，否则返回0。</td></tr><tr><td>OP_EQUALVERIFY</td><td>136</td><td>0×88</td><td>x1 x2</td><td>True / false</td><td>与OP_EQUAL一样，之后运行OP_VERIFY 。</td></tr></tbody></table><h3 id="算术逻辑"><a href="#算术逻辑" class="headerlink" title="算术逻辑"></a>算术逻辑</h3><p>注意：算术逻辑的输入限于有符号32位长整数，但输出有可能会溢出。</p><p>如果任何命令的输入值长度超过4字节，脚本必须中止和失败返回。如果标记为已禁用的操作码出现在交易中，也必须终止和失败返回</p><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_1ADD</td><td>139</td><td>0x8b</td><td>in</td><td>out</td><td>输入值加1</td></tr><tr><td>OP_1SUB</td><td>140</td><td>0x8c</td><td>in</td><td>out</td><td>输入值减1</td></tr><tr><td>OP_2MUL</td><td>141</td><td>0x8d</td><td>in</td><td>out</td><td>输入值乘2，已禁用</td></tr><tr><td>OP_2DIV</td><td>142</td><td>0x8e</td><td>in</td><td>out</td><td>输入值除2，已禁用</td></tr><tr><td>OP_NEGATE</td><td>143</td><td>0x8f</td><td>in</td><td>out</td><td>输入值符号取反</td></tr><tr><td>OP_ABS</td><td>144</td><td>0×90</td><td>in</td><td>out</td><td>输入值符号取正</td></tr><tr><td>OP_NOT</td><td>145</td><td>0×91</td><td>in</td><td>out</td><td>如果输入值为0或1，则输出1或0；否则输出0。I</td></tr><tr><td>OP_0NOTEQUAL</td><td>146</td><td>0×92</td><td>in</td><td>out</td><td>输入值为0输出0；否则输出1。</td></tr><tr><td>OP_ADD</td><td>147</td><td>0×93</td><td>a b</td><td>out</td><td>输出a+b</td></tr><tr><td>OP_SUB</td><td>148</td><td>0×94</td><td>a b</td><td>out</td><td>输出a-b</td></tr><tr><td>OP_MUL</td><td>149</td><td>0×95</td><td>a b</td><td>out</td><td>输出a*b，已禁用</td></tr><tr><td>OP_DIV</td><td>150</td><td>0×96</td><td>a b</td><td>out</td><td>输出a/b, 已禁用</td></tr><tr><td>OP_MOD</td><td>151</td><td>0×97</td><td>a b</td><td>out</td><td>输出a/b的余数，已禁用</td></tr><tr><td>OP_LSHIFT</td><td>152</td><td>0×98</td><td>a b</td><td>out</td><td>把a向左移动b位，保留符号，已禁用</td></tr><tr><td>OP_RSHIFT</td><td>153</td><td>0×99</td><td>a b</td><td>out</td><td>把a向右移动b位，保留符号，已禁用</td></tr><tr><td>OP_BOOLAND</td><td>154</td><td>0x9a</td><td>a b</td><td>out</td><td>如果a和b都不为0，输出1，否则输出0</td></tr><tr><td>OP_BOOLOR</td><td>155</td><td>0x9b</td><td>a b</td><td>out</td><td>如果a或b不为0，输出1，否则输出0</td></tr><tr><td>OP_NUMEQUAL</td><td>156</td><td>0x9c</td><td>a b</td><td>out</td><td>如果a=b则输出1，否则输出0。</td></tr><tr><td>OP_NUMEQUALVERIFY</td><td>157</td><td>0x9d</td><td>a b</td><td>out</td><td>与OP_NUMEQUAL一样，之后要运行OP_VERIFY</td></tr><tr><td>OP_NUMNOTEQUAL</td><td>158</td><td>0x9e</td><td>a b</td><td>out</td><td>如果a!=b则输出1，否则输出0。</td></tr><tr><td>OP_LESSTHAN</td><td>159</td><td>0x9f</td><td>a b</td><td>out</td><td>如果a&lt;b则输出1，否则输出0。</td></tr><tr><td>OP_GREATERTHAN</td><td>160</td><td>0xa0</td><td>a b</td><td>out</td><td>如果a&gt;b则输出1，否则输出0。</td></tr><tr><td>OP_LESSTHANOREQUAL</td><td>161</td><td>0xa1</td><td>a b</td><td>out</td><td>如果a&lt;=b则输出1，否则输出0</td></tr><tr><td>OP_GREATERTHANOREQUAL</td><td>162</td><td>0xa2</td><td>a b</td><td>out</td><td>如果a&gt;=b则输出1，否则输出0</td></tr><tr><td>OP_MIN</td><td>163</td><td>0xa3</td><td>a b</td><td>out</td><td>输出a,b中的最小值</td></tr><tr><td>OP_MAX</td><td>164</td><td>0xa4</td><td>a b</td><td>out</td><td>输出a,b中的最大值</td></tr><tr><td>OP_WITHIN</td><td>165</td><td>0xa5</td><td>x min max</td><td>out</td><td>如果x在min和max之间，则输出1，否则输出</td></tr></tbody></table><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>OP_RIPEMD160</td><td>166</td><td>0xa6</td><td>in</td><td>hash</td><td>输入用RIPEMD-160算法HASH</td></tr><tr><td>OP_SHA1</td><td>167</td><td>0xa7</td><td>in</td><td>hash</td><td>输入用SHA-1算法HASH.</td></tr><tr><td>OP_SHA256</td><td>168</td><td>0xa8</td><td>in</td><td>hash</td><td>输入用SHA-256算法HASH.</td></tr><tr><td>OP_HASH160</td><td>169</td><td>0xa9</td><td>in</td><td>hash</td><td>输入被HASH两次，先用 SHA-256，再用 RIPEMD-160.</td></tr><tr><td>OP_HASH256</td><td>170</td><td>0xaa</td><td>in</td><td>hash</td><td>输入用SHA-256算法HASH两次.</td></tr><tr><td>OP_CODESEPARATOR</td><td>171</td><td>0xab</td><td>无</td><td>无</td><td>所有签名检查只需匹配最近一次执行的OP_CODESEPARATOR 操作数据的签名即可。</td></tr><tr><td>OP_CHECKSIG</td><td>172</td><td>0xac</td><td>sig pubkey</td><td>True / false</td><td>全部交易的输出、输入和脚本(从最近执行的OP_CODESEPARATOR操作到最)都被HASH，OP_CHECKSIG使用的签名必须是该HASH值和公钥的有效签名，如果是真则返回1，否则返回0。</td></tr><tr><td>OP_CHECKSIGVERIFY</td><td>173</td><td>0xad</td><td>sig pubkey</td><td>True / false</td><td>与OP_CHECKSIG一样，但之后执行 OP_VERIFY</td></tr><tr><td>OP_CHECKMULTISIG</td><td>174</td><td>0xae</td><td>x sig1 sig2 …<number of="" signatures="">pub1 pub2<number of="" public="" keys=""></number></number></td><td>True / False</td><td>对于每个签名和公钥对，OP_CHECKSIG 都会被执行，如果公钥列得比签名多，一些公钥/签名对会失败。所有的签名要与公钥匹配。如果所有签名有效，输出1，否则返回0。因为存在BUG，一个未使用的外部值会从堆栈中删除。</td></tr><tr><td>OP_CHECKMULTISIGVERIFY</td><td>175</td><td>0xaf</td><td>x sig1 sig2 …<number of="" signatures="">pub1 pub2 …<number of="" public="" keys=""></number></number></td><td>True / False</td><td>与 OP_CHECKMULTISIG,一样，但是之后运行 OP_VERIFY。</td></tr></tbody></table><h3 id="伪关键字"><a href="#伪关键字" class="headerlink" title="伪关键字"></a>伪关键字</h3><p>这些关键字仅供内部使用，用辅助进行交易匹配，如果使用在实际的交易中则是无效的。</p><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>OP_PUBKEYHASH</td><td>253</td><td>0xfd</td><td>表示公钥用OP_HASH160操作码HASH</td></tr><tr><td>OP_PUBKEY</td><td>254</td><td>0xfe</td><td>表示与OP_CHECKSIG.兼容的一个公钥</td></tr><tr><td>OP_INVALIDOPCODE</td><td>255</td><td>0xff</td><td>匹配任何未指定的操作码</td></tr></tbody></table><h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><table><thead><tr><th>关键字</th><th>操作码</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>OP_RESERVED</td><td>80</td><td>0×50</td><td>交易无效，除非发生在未执行的OP_IF 分支</td></tr><tr><td>OP_VER</td><td>98</td><td>0×62</td><td>交易无效，除非发生在未执行的OP_IF 分支</td></tr><tr><td>OP_VERIF</td><td>101</td><td>0×65</td><td>交易无效，即使发生在未执行的OP_IF 分支</td></tr><tr><td>OP_VERNOTIF</td><td>102</td><td>0×66</td><td>交易无效，即使发生在未执行的OP_IF 分支</td></tr><tr><td>OP_RESERVED1</td><td>137</td><td>0×89</td><td>交易无效，除非发生在未执行的OP_IF 分支</td></tr><tr><td>OP_RESERVED2</td><td>138</td><td>0x8a</td><td>交易无效，除非发生在未执行的OP_IF 分支</td></tr><tr><td>OP_NOP1-OP_NOP10</td><td>176-185</td><td>0xb0-0xb9</td><td>这些关键字被忽略</td></tr></tbody></table><h2 id="bitcoinj脚本实现"><a href="#bitcoinj脚本实现" class="headerlink" title="bitcoinj脚本实现"></a>bitcoinj脚本实现</h2><p>我们来看一下bitcoinj的基本类图，这里面与脚本相关的核心类都是在org.bitcoinj.script包下面。</p><p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/blockchain/%E8%84%9A%E6%9C%AC%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%E5%9B%BE.png"></p><p>这里面的实现其实比较简单，没有什么特别需要说明的。</p><p>我们大概解释这里面的类的含义：</p><ol><li>Script是脚本的核心类，里面保留脚本的二进制格式，和脚本项的列表（动态维护），有关脚本一些限制的设置，byte数组解析为Script脚本，从脚本中获取签名、公钥、地址等，创建输入输出脚本，执行脚本等等操作。</li><li>ScriptError是脚本所有的错误集</li><li>ScriptException是关于脚本的所有异常</li><li>ScriptChunk是脚本的每个命令的抽象</li><li>ScriptOpCodes是存放脚本命令的集合和编码</li><li>TransactionSignature是交易的签名</li><li>ECKey是公私钥的封装（椭圆曲线对称加密算法）</li><li>ScriptBuilder是脚本的生成器，可以生成多种类型钱包的地址脚本。</li></ol><p>关于脚本的执行，其实有3个站，一个是stack用于存放数据的栈，ifstack用于存放if条件相关的栈，altStack是stack的辅助堆栈。涉及altStack的操作符有<code>OP_TOALTSTACK</code>, <code>OP_FROMALTSTACK</code>;</p><h2 id="利用bitcoinj生成多签名钱包"><a href="#利用bitcoinj生成多签名钱包" class="headerlink" title="利用bitcoinj生成多签名钱包"></a>利用bitcoinj生成多签名钱包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Create a random key.</span><br><span class="line">ECKey clientKey = new ECKey();</span><br><span class="line">// We get the other parties public key from somewhere ...</span><br><span class="line">ECKey serverKey = new ECKey(null, publicKeyBytes);</span><br><span class="line"></span><br><span class="line">// Prepare a template for the contract.</span><br><span class="line">Transaction contract = new Transaction(params);</span><br><span class="line">List&lt;ECKey&gt; keys = ImmutableList.of(clientKey, serverKey);</span><br><span class="line">// Create a 2-of-2 multisig output script.</span><br><span class="line">Script script = ScriptBuilder.createMultiSigOutputScript(2, keys);</span><br><span class="line">// Now add an output for 0.50 bitcoins that uses that script.</span><br><span class="line">Coin amount = Coin.valueOf(0, 50);</span><br><span class="line">contract.addOutput(amount, script);</span><br><span class="line"></span><br><span class="line">// We have said we want to make 0.5 coins controlled by us and them.</span><br><span class="line">// But it&apos;s not a valid tx yet because there are no inputs.</span><br><span class="line">SendRequest req = SendRequest.forTx(contract);</span><br><span class="line">wallet.completeTx(req);   // Could throw InsufficientMoneyException</span><br><span class="line"></span><br><span class="line">// Broadcast and wait for it to propagate across the network.</span><br><span class="line">// It should take a few seconds unless something went wrong.</span><br><span class="line">peerGroup.broadcastTransaction(req.tx).get();</span><br></pre></td></tr></table></figure><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL2Jvb2suOGJ0Yy5jb20vYm9va3MvNi9tYXN0ZXJiaXRjb2luMmNuL19ib29rL2NoMDQuaHRtbA==" title="http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch04.html">第四章 密钥和地址<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jvb2suOGJ0Yy5jb20vYm9va3MvNi9tYXN0ZXJiaXRjb2luMmNuL19ib29rL2NoMDYuaHRtbA==" title="http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch06.html">第六章 交易<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvU2NyaXB0" title="https://en.bitcoin.it/wiki/Script">Script<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS9iaXRjb2luX3NjcmlwdHM=" title="http://www.8btc.com/bitcoin_scripts">比特币脚本<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy44YnRjLmNvbS91bmRlcnN0YW5kLWJpdGNvaW4tc2NyaXB0" title="http://www.8btc.com/understand-bitcoin-script">理解比特币脚本<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iaXRjb2luai5naXRodWIuaW8vd29ya2luZy13aXRoLWNvbnRyYWN0cyNwMnNoLXBheS10by1zY3JpcHQtaGFzaA==" title="https://bitcoinj.github.io/working-with-contracts#p2sh-pay-to-script-hash">Working with contracts<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
            <tag> bitcoin </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitcoin智能合约的实现</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/bitcoin%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/bitcoin%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>一提起智能合约，大家首先想到的一定是以太坊的智能合约，但是很少有人会想到比特币也可以搭建智能合约，只是很少有人会在意到这一点，我也是在阅读bitcoinj的源码的时候，发现了一个字段想起来的。这个在交易中的字段名叫<code>sequence</code>。随后去比特币的wiki中查到了比特币contract的描述，下面就简单描述一下，不会直接翻译文档。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式合约是使用比特币区块链和其他人生成合同的方法。契约不会让以前不可能的任何事情变得可能，但是它们允许您以最小化信任的方式解决常见问题。最小的信任通过让人们的判断被排除在循环之外使事情更加方便（主要还是脚本语言非图灵完备的），从而实现完全的自动化。</p><p>通过构建与比特币交互的低信任协议，可以创建全新的产品：</p><ul><li>智能财产是可以通过区块链进行自动交易和借出的财产。</li><li>可转让的虚拟财产是可交易但不重复的数字项目。</li><li>代理人是自主的程序，用于维护自己的钱包，这样用于购买服务时间。货币是通过代理人销售服务获得的。 如果需求超过供应量，那么代理商可以培育可能生存或死亡的孩子，这取决于他们是否能够获得足够的业务。</li><li>分布式市场是实施点对点债券和股票交易的一种方式，允许比特币发展成为国际金融体系的完全竞争者。</li></ul><p>这篇文章下面会举一些列子。</p><h2 id="关于mempool交易替换机制的警告"><a href="#关于mempool交易替换机制的警告" class="headerlink" title="关于mempool交易替换机制的警告"></a>关于mempool交易替换机制的警告</h2><p>这个页面指出的是使用nSequence字段进行交易mempool机制替换的能力。该机制在2010年被禁用，由于担心它容易遭受Dos攻击，最近代码被彻底删除。实现者应该考虑到这一点，并尝试创建不依赖于mempool替换的合约机制，如果他们希望实现其当前实现的实现。 如果比特币在未来发生变化以再次进行mempool替换，该页面将会更新。</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>比特币中的每笔交易都有一个或多个输入和输出。每个输入/输出都有一个与之相关的小型纯函数，称为脚本。脚本可以包含交易本身简化形式的签名。</p><p>每笔交易都可以拥有与之相关的锁定时间。这允许交易处于挂起状态并且可以替换，直到将指定为块索引或时间戳（对于两者都使用相同字段，但小于5亿的值被解释为块索引）指定的未来时间为止。如果交易的锁定时间已经达到，我们说它是最终的。</p><p><b style="color:red">每个交易输入都有一个序列号sequence。在正常交易中，只是将值周围移动，序列号都是UINT_MAX，锁定时间为零。如果锁定时间尚未达到，但所有序列号均为UINT_MAX，则交易也被视为最终(不能修改)。序列号可用于发布新版本的交易，而不会使其他输入签名无效，例如，在交易中的每个输入来自不同方的情况下，每个输入可以以序列号0开始，并且这些数字可以独立增加。</b></p><p><b style="color:red">签名检查是灵活的，因为签名的交易形式可以通过使用SIGHASH标志来控制，这些标志卡在签名末尾。</b>通过这种方式，可以构建各方签订合同的合同，允许其他部分在没有其参与的情况下进行更改。 SIGHASH标志有两个部分，一个模式和ANYONECANPAY修饰符：</p><ul><li>SIGHASH_ALL：这是默认设置。它表示除了输入脚本之外，关于交易的所有内容都已签名。签名输入脚本显然会使构建交易变得不可能，所以它们总是被删除。但请注意，输入的其他属性（如连接的输出和序列号）已被签名;只有不是的脚本。直观地说，它意味着“如果每个人都投入资金并且产出是这样的，我同意投入我的资金”。</li><li>SIGHASH_NONE：输出没有签名，可以是任何东西。用它来表示“只要每个人都投入资金，我同意投入资金，但我不在乎输出结果如何”。该模式允许其他人通过更改输入序列号来更新交易。</li><li>SIGHASH_SINGLE：与SIGHASH_NONE一样，输入已签名，但序号已空白，所以其他人可以创建新版本的交易。但是，唯一被签名的输出是与输入位置相同的输出。用这个来表示“我同意，只要我的输出是我想要的;我不关心其他人”。</li><li>SIGHASH_ANYONECANPAY修饰符可以与上述三种模式结合使用。设置后，只有该输入被签名，其他输入可以是任何东西。</li></ul><p>脚本可以包含CHECKMULTISIG操作码。 此操作码提供n-m检查：您提供多个公钥，并指定必须存在的有效签名的数量。签名的数量可以少于公钥的数量。通过将输出设置为如下形式，输出可能需要使用两个签名：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;pubkey1&gt; &lt;pubkey2&gt; 2 CHECKMULTISIGVERIFY</span><br></pre></td></tr></table></figure><p></p><p>安全创建合同一般有两种模式：</p><ol><li>交易以部分完整或无效的形式在P2P网络外部传递。</li><li>使用两个交易：一个（合同）被创建并签名，但不能立即广播。 相反，其他交易（付款）在合同同意锁定资金后播出，然后广播合同。</li></ol><p>这是为了确保人们总是知道他们同意。</p><p>总之，这些功能让我们可以在区块链之上构建有趣的新金融工具。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>官网列出了很多的示例，这里我们只翻译一个即可。</p><p>想象一下，你在一个网站（例如论坛或维基）上开设一个帐户，并希望与运营商建立可信赖关系，但是你没有任何预先存在的声誉可以利用。一个解决方案是通过向网站支付一些钱来购买信任。但是如果你在某个时候关闭了你的账户，你可能想拿回这笔钱。您可能不相信该网站有足以向提供的花费存款（也就是保证金并不在账户上）。还有一个风险就是该网站有一天可能会消失。</p><p>我们的目标是证明你做出了某种牺牲，所以网站知道你不是spambot(垃圾邮件，这里不知道什么意思，估计类似骗子啥的吧！)，但你不希望他们能够花钱（你的保证金）。如果操作员消失了，你最终不想要他们任何东西，只希望你的钱能够回来。</p><p>我们可以用合同解决这个问题：</p><ul><li>用户和网站互相发送一个新生成的公钥。</li><li>用户创建交易Tx1（付款），将10BTC放入需要用户和网站签名但不广播它的输出。他们使用该网站上一步的密钥。（当前交易网站还不知道）</li><li><b style="color:red">用户发送Tx1的hash值到网站。（不发送本体）</b></li><li><b style="color:red">该网站创建一个交易Tx2（合同）。 Tx2花费Tx1并通过他在第一步中提供的地址将其支付回给用户。请注意，Tx1需要两个签名，所以此事务不能完成。</b> nLockTime被设置为将来某个日期（例如六个月）。input上的序列号被设置为零。</li><li>最后，将不完整（半签名）的交易发回给用户。用户检查合同是否如预期的那样 - 硬币最终会回到他身上 - 但是，除非事情发生变化，否则只能在六个月后。由于序号为零，如果双方同意，合同将来可以修改。input中的脚本尚未完成;只有用户的签名应该是零。他通过签署合同并将新signature放在适当位置来解决这个问题。</li><li>用户广播Tx1，然后广播Tx2。</li></ul><p>在这个阶段，10BTC处于用户和网站都不能独立使用的状态。六个月后，即使网站消失，合同也将完成，用户将收回硬币。</p><p>如果用户希望提早结账，该怎么办？该网站创建一个新版本的Tx2，并将nLockTime设置为零，并将输入序列号设置为UINT_MAX，然后重新签名。该网站将tx交还给用户，用户也签名。然后用户广播交易，提前终止合同并释放硬币。</p><p><b style="color:red">如果六个月快到了，用户希望保留他的账户呢？同样的事情也适用：合同可以用一个更新的nLockTime辞职，序列号1比前一个更高，并重播2 ^ 32次。无论发生什么事，双方都必须同意合同改变。</b></p><p>显然，如果用户原来是滥用（即垃圾邮件发送者），该网站将不允许提前结束合同。如果过多的滥用行为，存款的规模可能会增加，或者合同的长度可能会增加。(这意思是每次改动都需要追加保证金？)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们大概了解了，这个合同的实现过程，不管怎么说还是业务抽象成了一个比特币的执行脚本，最终需要双方的公私钥来实现而已，交易锁定所有人都知道，只有sequence大于1的值，才能使得交易被改动。否则不能改动。<b style="color:red">其实说白了，还是交易本位的思想来实现智能合约。</b>相比于以太坊的智能合约，这种交易本身没有更多的智能化。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvQ29udHJhY3Q=" title="https://en.bitcoin.it/wiki/Contract">Contract<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BtYXJhb3ovc21hcnQtY29udHJhY3RzLWFuZC1iaXRjb2luLWE1ZDYxMDExZDliMQ==" title="https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1">智能合约和比特币<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能合约 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitcoin协议中数字的压缩存储</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/bitcoin%E5%8D%8F%E8%AE%AE%E4%B8%AD%E6%95%B0%E5%AD%97%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/bitcoin%E5%8D%8F%E8%AE%AE%E4%B8%AD%E6%95%B0%E5%AD%97%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>之前提过比特币的compact格式的问题，可那是针对比特币的挖矿难度的计算的。我们在Message类中，经常会见到VarInt这个类，其实这个类是为了协议二进制流中与应用数据中的数字进行的转化约定的实现。这里也涉及到数字压缩的问题，但是这里偏向可变的数字存储，并不是我们之前讲过的压缩存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public VarInt(byte[] buf, int offset) &#123;</span><br><span class="line">    // 取得低8位操作。</span><br><span class="line">    int first = 0xFF &amp; buf[offset];</span><br><span class="line">    if (first &lt; 253) &#123;</span><br><span class="line">        value = first;</span><br><span class="line">        originallyEncodedSize = 1; // 1 data byte (8 bits)</span><br><span class="line">    &#125; else if (first == 253) &#123;</span><br><span class="line">        value = (0xFF &amp; buf[offset + 1]) | ((0xFF &amp; buf[offset + 2]) &lt;&lt; 8);</span><br><span class="line">        originallyEncodedSize = 3; // 1 marker + 2 data bytes (16 bits)</span><br><span class="line">    &#125; else if (first == 254) &#123;</span><br><span class="line">        value = Utils.readUint32(buf, offset + 1);</span><br><span class="line">        originallyEncodedSize = 5; // 1 marker + 4 data bytes (32 bits)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        value = Utils.readInt64(buf, offset + 1);</span><br><span class="line">        originallyEncodedSize = 9; // 1 marker + 8 data bytes (64 bits)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这里比较简单，我就不做更多的说明。在这段代码中我们可以得出如下的结论：</p><ol><li>这里针对的都是无符号的整数</li><li>小于253的数字，直接用一个字节来进行存储。</li><li>大于253小于2^16的数字，使用3个字节存储，其中第一个字节为253，作为标记，后面两位是存储的值，总计需要3字节</li><li>大于2^16小于2^32的数字，使用3个字节存储，其中第一个字节为254，作为标记，后面两位是存储的值，总计需要5字节</li><li>大于2^32小于2^64的数字，使用5个字节存储，其中第一个字节为255，作为标记，后面两位是存储的值，总计需要9字节</li></ol><p>有了这个规则之后，我们看一下编码的函数就更好理解了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public byte[] encode() &#123;</span><br><span class="line">    byte[] bytes;</span><br><span class="line">    switch (sizeOf(value)) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            return new byte[]&#123;(byte) value&#125;;</span><br><span class="line">        case 3:</span><br><span class="line">            return new byte[]&#123;(byte) 253, (byte) (value), (byte) (value &gt;&gt; 8)&#125;;</span><br><span class="line">        case 5:</span><br><span class="line">            bytes = new byte[5];</span><br><span class="line">            bytes[0] = (byte) 254;</span><br><span class="line">            Utils.uint32ToByteArrayLE(value, bytes, 1);</span><br><span class="line">            return bytes;</span><br><span class="line">        default:</span><br><span class="line">            bytes = new byte[9];</span><br><span class="line">            bytes[0] = (byte) 255;</span><br><span class="line">            Utils.uint64ToByteArrayLE(value, bytes, 1);</span><br><span class="line">            return bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bitcoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币的checkpoint理解</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84checkpoint%E7%90%86%E8%A7%A3.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84checkpoint%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在写之前的bitcoinj的网络参数时候，有一个字段叫checkpoints。当时始终没有理解这个是用来做啥的，就知道是检查点，可就是不明白检查什么。今天研读到，bitcoinj中Block的组织方式处的代码的时候又见到了这个字段，但是还是不知其意。但是知道了一个类CheckpointManager，于是今天准备来好好说道这个类。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一开始看到这个类的时候还是不明白作用是啥，但是名字上呢是略知一二，看了说明也是云里雾里，于是网上搜索checkpoint也没有比较好的回答，随着代码的深入阅读，终于搞明白了这个类的作用，这可真是太棒了！在类的说明中也提到了SPV。那么checkpoints和SPV有啥关系呢？</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>我们知道，接收一个新块的时候需要很多的验证，否则可能会被别人进行分叉的攻击等等。检测点，是用于保护网络不受全网51%算力攻击，因为攻击者是不能逆转最后一个检测点前发生的那些交易的。</p><p>检测点是通过硬编码方式写入标准客户端的。意味着标准客户端将在检测点之前将接受所有有效交易，这些交易将是不可逆的。如果任何人试图在检测点前从一个区块对区块链进行分叉，客户端将不会接受这个分叉，这使得那些区块一成不变（set in stone）。</p><p>但其实在CheckpointManager类说明上我们也可以获得一些信息：在整个链中对StoredBlock进行了硬编码。Checkpoints有两个目的：</p><ul><li>他们作为一种安全机制来对抗可能会重写大块历史的巨大重组，只有在时间轴的最新部分中，将区块链限制为一种共识机制。</li><li>它们可以让同步到链头上的新钱包/用户比同步创建块中的所有头部更快。</li></ul><p><b style="color:red">这个意思就是说，你只需要同步检查点数据，以及最新检查点之后的区块，然后你的链就可以建立起来了，这样的好处就是你不需要同步所有的链上的区块。总之你利用这个特性可以简化空间和验证hash的时间，我想SPV一定是基于这种方式进行的实现。这种思路特别像跳跃表的实现。</b></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><b style="color:red">对了这里可能是bitcoinj的实现，至于比特币内部的实现，我是不知道的。但是都是相同的，即使bitcoinj实现方式不同，但是只要被所有区块接受，那就是有效的算法不是吗？</b></p><p><b style="color:red">这里我就不写一大堆的文字，唯一要提示的就是流的编码问题。如果你读的是二进制的文件，那么开头必须是<code>&quot;CHECKPOINTS 1&quot;</code>，如果读的是文件必须是<code>&quot;TXT CHECKPOINTS 1&quot;</code>开头，还有就是txt有范例在resources目录下。SPVStoredBlock需要Compact格式化（序列化）存储，之前讲过compact格式，最长是256，所以有<code>private static final int MAX_SIGNATURES = 256;</code>.下面贴源码和我的注释，这里就不深入地去探讨了。</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">public class CheckpointManager &#123;</span><br><span class="line">    private static final Logger log = LoggerFactory.getLogger(CheckpointManager.class);</span><br><span class="line"></span><br><span class="line">    // 二进制流的头部检查，这个好像没有example，不过知道是这回事就可以了。</span><br><span class="line">    private static final String BINARY_MAGIC = &quot;CHECKPOINTS 1&quot;;</span><br><span class="line">    // 文件格式的开头，查看resources目录下的txt文件即可</span><br><span class="line">    private static final String TEXTUAL_MAGIC = &quot;TXT CHECKPOINTS 1&quot;;</span><br><span class="line">    private static final int MAX_SIGNATURES = 256;</span><br><span class="line"></span><br><span class="line">    // Map of block header time to data.</span><br><span class="line">    // 存放检查点</span><br><span class="line">    protected final TreeMap&lt;Long, StoredBlock&gt; checkpoints = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    protected final NetworkParameters params;</span><br><span class="line">    // sha256hash对象</span><br><span class="line">    protected final Sha256Hash dataHash;</span><br><span class="line"></span><br><span class="line">    // base64编码器</span><br><span class="line">    public static final BaseEncoding BASE64 = BaseEncoding.base64().omitPadding();</span><br><span class="line"></span><br><span class="line">    /** Loads the default checkpoints bundled with bitcoinj */</span><br><span class="line">    public CheckpointManager(Context context) throws IOException &#123;</span><br><span class="line">        this(context.getParams(), null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Loads the checkpoints from the given stream */</span><br><span class="line">    public CheckpointManager(NetworkParameters params, @Nullable InputStream inputStream) throws IOException &#123;</span><br><span class="line">        this.params = checkNotNull(params);</span><br><span class="line">        if (inputStream == null)</span><br><span class="line">            inputStream = openStream(params);</span><br><span class="line">        checkNotNull(inputStream);</span><br><span class="line">        inputStream = new BufferedInputStream(inputStream);</span><br><span class="line">        inputStream.mark(1);</span><br><span class="line">        int first = inputStream.read();</span><br><span class="line">        inputStream.reset();</span><br><span class="line">        if (first == BINARY_MAGIC.charAt(0))</span><br><span class="line">            dataHash = readBinary(inputStream);</span><br><span class="line">        else if (first == TEXTUAL_MAGIC.charAt(0))</span><br><span class="line">            dataHash = readTextual(inputStream);</span><br><span class="line">        else</span><br><span class="line">            throw new IOException(&quot;Unsupported format.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns a checkpoints stream pointing to inside the bitcoinj JAR */</span><br><span class="line">    // 这个可以查看resources目录下的txt文件，你就能明白一二了。</span><br><span class="line">    public static InputStream openStream(NetworkParameters params) &#123;</span><br><span class="line">        return CheckpointManager.class.getResourceAsStream(&quot;/&quot; + params.getId() + &quot;.checkpoints.txt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 看从这个流中是如何进行text读取，解析的步骤表明txt文件的格式。</span><br><span class="line">     * @param inputStream</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    private Sha256Hash readBinary(InputStream inputStream) throws IOException &#123;</span><br><span class="line">        DataInputStream dis = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 信息分解器</span><br><span class="line">            MessageDigest digest = Sha256Hash.newDigest();</span><br><span class="line">            // 将数据读取，并进行分化</span><br><span class="line">            DigestInputStream digestInputStream = new DigestInputStream(inputStream, digest);</span><br><span class="line">            // 转为数据流</span><br><span class="line">            dis = new DataInputStream(digestInputStream);</span><br><span class="line">            digestInputStream.on(false);</span><br><span class="line">            byte[] header = new byte[BINARY_MAGIC.length()];</span><br><span class="line">            dis.readFully(header);</span><br><span class="line">            // 先读取header，查看header是否有效。</span><br><span class="line">            if (!Arrays.equals(header, BINARY_MAGIC.getBytes(&quot;US-ASCII&quot;)))</span><br><span class="line">                throw new IOException(&quot;Header bytes did not match expected version&quot;);</span><br><span class="line">            // 检查索引是否数组越界。</span><br><span class="line">            int numSignatures = checkPositionIndex(dis.readInt(), MAX_SIGNATURES, &quot;Num signatures out of range&quot;);</span><br><span class="line">            for (int i = 0; i &lt; numSignatures; i++) &#123;</span><br><span class="line">                byte[] sig = new byte[65];</span><br><span class="line">                // 读取签名</span><br><span class="line">                dis.readFully(sig);</span><br><span class="line">                // TODO: Do something with the signature here.</span><br><span class="line">            &#125;</span><br><span class="line">            digestInputStream.on(true);</span><br><span class="line">            // 继续读一个整型</span><br><span class="line">            int numCheckpoints = dis.readInt();</span><br><span class="line">            checkState(numCheckpoints &gt; 0);</span><br><span class="line">            final int size = StoredBlock.COMPACT_SERIALIZED_SIZE;</span><br><span class="line">            // 生成缓冲区大小，通过Compact编码读取数据。</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(size);</span><br><span class="line">            for (int i = 0; i &lt; numCheckpoints; i++) &#123;</span><br><span class="line">                if (dis.read(buffer.array(), 0, size) &lt; size)</span><br><span class="line">                    throw new IOException(&quot;Incomplete read whilst loading checkpoints.&quot;);</span><br><span class="line">                // 利用参数从数据中恢复，会进行校验检查</span><br><span class="line">                StoredBlock block = StoredBlock.deserializeCompact(params, buffer);</span><br><span class="line">                buffer.position(0);</span><br><span class="line">                // 存入检查点</span><br><span class="line">                checkpoints.put(block.getHeader().getTimeSeconds(), block);</span><br><span class="line">            &#125;</span><br><span class="line">            // 读取hash</span><br><span class="line">            Sha256Hash dataHash = Sha256Hash.wrap(digest.digest());</span><br><span class="line">            log.info(&quot;Read &#123;&#125; checkpoints, hash is &#123;&#125;&quot;, checkpoints.size(), dataHash);</span><br><span class="line">            // 这里返回的hash，可能是整体文件的hash，也可能是最后的checkpoint的hash</span><br><span class="line">            return dataHash;</span><br><span class="line">        &#125; catch (ProtocolException e) &#123;</span><br><span class="line">            throw new IOException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (dis != null) dis.close();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Sha256Hash readTextual(InputStream inputStream) throws IOException &#123;</span><br><span class="line">        // google的sha256 hash函数</span><br><span class="line">        Hasher hasher = Hashing.sha256().newHasher();</span><br><span class="line">        BufferedReader reader = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            reader = new BufferedReader(new InputStreamReader(inputStream, Charsets.US_ASCII));</span><br><span class="line">            String magic = reader.readLine();</span><br><span class="line">            // 开头TXT CHECKPOINTS 1，这个可以查看txt下的checkpoints文件。</span><br><span class="line">            if (!TEXTUAL_MAGIC.equals(magic))</span><br><span class="line">                throw new IOException(&quot;unexpected magic: &quot; + magic);</span><br><span class="line">            int numSigs = Integer.parseInt(reader.readLine());</span><br><span class="line">            // 多签名的量，依次读取，txt中第二行都是0</span><br><span class="line">            for (int i = 0; i &lt; numSigs; i++)</span><br><span class="line">                reader.readLine(); // Skip sigs for now.</span><br><span class="line">            // 查找有多少的检查点</span><br><span class="line">            int numCheckpoints = Integer.parseInt(reader.readLine());</span><br><span class="line">            checkState(numCheckpoints &gt; 0);</span><br><span class="line">            // Hash numCheckpoints in a way compatible to the binary format.</span><br><span class="line">            hasher.putBytes(ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(numCheckpoints).array());</span><br><span class="line">            final int size = StoredBlock.COMPACT_SERIALIZED_SIZE;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(size);</span><br><span class="line">            for (int i = 0; i &lt; numCheckpoints; i++) &#123;</span><br><span class="line">                byte[] bytes = BASE64.decode(reader.readLine());</span><br><span class="line">                hasher.putBytes(bytes);</span><br><span class="line">                buffer.position(0);</span><br><span class="line">                buffer.put(bytes);</span><br><span class="line">                buffer.position(0);</span><br><span class="line">                StoredBlock block = StoredBlock.deserializeCompact(params, buffer);</span><br><span class="line">                checkpoints.put(block.getHeader().getTimeSeconds(), block);</span><br><span class="line">            &#125;</span><br><span class="line">            HashCode hash = hasher.hash();</span><br><span class="line">            log.info(&quot;Read &#123;&#125; checkpoints, hash is &#123;&#125;&quot;, checkpoints.size(), hash);</span><br><span class="line">            return Sha256Hash.wrap(hash.asBytes());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (reader != null) reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@link StoredBlock&#125; representing the last checkpoint before the given time, for example, normally</span><br><span class="line">     * you would want to know the checkpoint before the earliest wallet birthday.</span><br><span class="line">     *</span><br><span class="line">     * 返回给定时间节点之前最近的StoredBlock类的checkpoints。</span><br><span class="line">     */</span><br><span class="line">    public StoredBlock getCheckpointBefore(long time) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 时间一定要比创世区块时间要晚</span><br><span class="line">            checkArgument(time &gt; params.getGenesisBlock().getTimeSeconds());</span><br><span class="line">            // This is thread safe because the map never changes after creation.</span><br><span class="line">            Map.Entry&lt;Long, StoredBlock&gt; entry = checkpoints.floorEntry(time);</span><br><span class="line">            if (entry != null) return entry.getValue();</span><br><span class="line">            Block genesis = params.getGenesisBlock().cloneAsHeader();</span><br><span class="line">            return new StoredBlock(genesis, genesis.getWork(), 0);</span><br><span class="line">        &#125; catch (VerificationException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);  // Cannot happen.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns the number of checkpoints that were loaded. */</span><br><span class="line">    public int numCheckpoints() &#123;</span><br><span class="line">        return checkpoints.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns a hash of the concatenated checkpoint data. */</span><br><span class="line">    // 返回串联检查点数据的散列。</span><br><span class="line">    public Sha256Hash getDataHash() &#123;</span><br><span class="line">        return dataHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given</span><br><span class="line">     * time, then inserts it into the store and sets that to be the chain head. Useful when you have just created</span><br><span class="line">     * a new store from scratch and want to use configure it all in one go.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.&lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static void checkpoint(NetworkParameters params, InputStream checkpoints, BlockStore store, long time)</span><br><span class="line">            throws IOException, BlockStoreException &#123;</span><br><span class="line">        checkNotNull(params);</span><br><span class="line">        checkNotNull(store);</span><br><span class="line">        checkArgument(!(store instanceof FullPrunedBlockStore), &quot;You cannot use checkpointing with a full store.&quot;);</span><br><span class="line"></span><br><span class="line">        time -= 86400 * 7;</span><br><span class="line"></span><br><span class="line">        checkArgument(time &gt; 0);</span><br><span class="line">        log.info(&quot;Attempting to initialize a new block store with a checkpoint for time &#123;&#125; (&#123;&#125;)&quot;, time, Utils.dateTimeFormat(time * 1000));</span><br><span class="line"></span><br><span class="line">        BufferedInputStream stream = new BufferedInputStream(checkpoints);</span><br><span class="line">        CheckpointManager manager = new CheckpointManager(params, stream);</span><br><span class="line">        StoredBlock checkpoint = manager.getCheckpointBefore(time);</span><br><span class="line">        store.put(checkpoint);</span><br><span class="line">        store.setChainHead(checkpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> checkpoint </tag>
            
            <tag> CheckpointManager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字的压缩存储</title>
      <link href="//%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%97%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.html"/>
      <url>//%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%97%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近在学习比特币的知识，突然发现一个compact合适，然后又想起了以太坊的RLP编码的问题，想着想着，就想着数据是如何压缩存储的。于是上网搜索一下，发现了thift序列化的压缩实现。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管怎么说技术的本质就是数字，再复杂的东西也只是数字累积起来的。在计算机中数据的存储采用补码的方式，当然也有反码的概念，这里就不多说了。我们下面所说的算法就是指zigzag算法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一般来说数据的存储如果遇到1这样的数据还用4个字节的存储是不是很浪费空间，<code>00000000 00000000 00000001</code>有那么多的0是多余的，那么我们可以选择不存储。最后放在一个字节中去存储就会变成<code>00000001</code>,这样就省了不少的空间。</p><h2 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h2><p>可是遇到-1会怎么样呢？(-1)<sub>10</sub> = (11111111 11111111 11111111 11111111)<sub>补</sub>，前面全是1，那怎么处理呢？</p><p>zigzag给出了一个很巧的方法：我们之前讲补码讲过，补码的第一位是符号位，他阻碍了我们对于前导0的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位：</p><p>(-1)<sub>10</sub> = (<font color="red">1</font>1111111 11111111 11111111 11111111)<sub>补</sub> = (11111111 11111111 11111111 1111111<font color="red">1</font>)<sub>符号后移</sub></p><p>但是即使这样，也是很难压缩的，因为数字绝对值越小，他所含的前导1越多。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数：</p><p>(-1)<sub>10</sub> = (<font color="red">1</font>1111111 11111111 11111111 11111111)<sub>补</sub> = (11111111 11111111 11111111 1111111<font color="red">1</font>)<sub>符号后移</sub> = (00000000 00000000 00000000 0000000<font color="red">1</font>)<sub>zigzag</sub></p><p>这样就出现了很多的0，但是如果都是1的话好像也没啥问题，对负数就去1呗。这里还是以去0为主。</p><h2 id="再看整数"><a href="#再看整数" class="headerlink" title="再看整数"></a>再看整数</h2><p>(1)<sub>10</sub> = (<font color="red">0</font>0000000 00000000 00000000 00000001)<sub>补</sub> = (00000000 00000000 00000000 0000001<font color="red">0</font>)<sub>符号后移</sub> = (00000000 00000000 00000000 0000001<font color="red">0</font>)<sub>zigzag</sub></p><h2 id="整型值与zigzag值转化"><a href="#整型值与zigzag值转化" class="headerlink" title="整型值与zigzag值转化"></a>整型值与zigzag值转化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int int_to_zigzag(int n) &#123;</span><br><span class="line">    return (n &lt;&lt;1) ^ (n &gt;&gt;31);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int zigzag_to_int(int n) &#123;</span><br><span class="line">    return (((unsignedint)n) &gt;&gt;1) ^ -(n &amp; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int write_to_buffer(int zz, byte* buf, int size) &#123;</span><br><span class="line">    int ret =0;</span><br><span class="line">    for (int i =0; i &lt; size; i++) &#123;</span><br><span class="line">        if ((zz &amp; (~0x7f)) ==0) &#123;</span><br><span class="line">            buf[i] = (byte)zz;</span><br><span class="line">            ret = i + 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 第八位补一个1</span><br><span class="line">            buf[i] = (byte)((zz &amp;0x7f) |0x80);</span><br><span class="line">            // 换下一个七位，继续进行测试。</span><br><span class="line">            zz = ((unsignedint)zz)&gt;&gt;7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 (~0x7f)<sub>16</sub> = (11111111 11111111 11111111 10000000)<sub>补</sub>. 他的作用就是看除开最后七位后，还有没有信息。这个看起来不是很直观，还是举一个例子吧：</p><p>(-1000)<sub>10</sub> = (11111111 11111111 11111100 00011000)<sub>补</sub> = (00000000 00000000 00000111 11001111)<sub>zigzag</sub></p><p>这个数的转换经过下面几个步骤：</p><ol><li>与(~0x7f)做与操作的结果，高位还有信息，所以，我们把低7位取出来，并在倒数第八位上补一个1(0x80)：<b style="color:red">1</b>1001111</li><li>将这个数右移七位：(00000000 00000000 00000000 00001111)<sub>zigzag</sub></li><li>重复1，但是检测出高位都是0，设置数据为：00001111</li></ol><p>这个时候我们可以最终得出如下的结果：<br>(-1000)<sub>10</sub> = (11111111 11111111 11111100 00011000)<sub>补</sub> = (00000000 00000000 00000111 11001111)<sub>zigzag</sub> = [<b style="color:red">1</b>1001111, 00001111]<sub>压缩后</sub></p><p><b style="color:red">注意：这里每个字节的第一位都是有意义的，如果我们读一个数，只要发现每个字节的第八位是0，就代表这个数字读取就结束了；但是如果是1的话，就只能向下读。这里要注意一旦数据比较大，32位的数据可能就变成40位了，但是这样的数据特别大的时候才会出现。</b></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int read_from_buffer(byte* buf,intmax_size) &#123;</span><br><span class="line">    int ret =0;</span><br><span class="line">    int offset =0;</span><br><span class="line"></span><br><span class="line">    for (int i =0; i &lt; max_size; i++, offset +=7) &#123;</span><br><span class="line">        byte n = buf[i];</span><br><span class="line"></span><br><span class="line">        if ((n &amp;0x80) !=0x80) &#123;</span><br><span class="line">            ret |= (n &lt;&lt;offset);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ret |= ((n &amp;0x7f) &lt;&lt; offset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是上面操作的逆过程而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个设计的比较巧妙，利用高位来标记，的确可以省不少的空间。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBM01ERXhOemN5TkE9PSZhbXA7bWlkPTI2NTAzOTIwODYmYW1wO2lkeD0xJmFtcDtzbj02YTJlY2ZlMjU0OGYxMjFhNDcyNmQwM2JmMjNmNDQ3OCZhbXA7c2NlbmU9MCN3ZWNoYXRfcmVkaXJlY3Q=" title="https://mp.weixin.qq.com/s?__biz=MzA3MDExNzcyNA==&amp;mid=2650392086&amp;idx=1&amp;sn=6a2ecfe2548f121a4726d03bf23f4478&amp;scene=0#wechat_redirect">小而巧的数字压缩算法：zigzag<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币的compact格式说明</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84compact%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84compact%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在分析bitcoinj源码的时候，发现Utils有一些方法时关于compact格式的解析说明。但是代码没怎么看明白，所以记录大概解释一下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger decodeCompactBits(long compact) &#123;</span><br><span class="line">    // 32位中取得高八位</span><br><span class="line">    int size = ((int) (compact &gt;&gt; 24)) &amp; 0xFF;</span><br><span class="line">    // 设置字节数组大小，大小+4</span><br><span class="line">    byte[] bytes = new byte[4 + size];</span><br><span class="line">    // 将第四个字节设置为size</span><br><span class="line">    bytes[3] = (byte) size;</span><br><span class="line">    if (size &gt;= 1) bytes[4] = (byte) ((compact &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">    if (size &gt;= 2) bytes[5] = (byte) ((compact &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">    if (size &gt;= 3) bytes[6] = (byte) (compact &amp; 0xFF);</span><br><span class="line">    return decodeMPI(bytes, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="为啥有Compact格式"><a href="#为啥有Compact格式" class="headerlink" title="为啥有Compact格式"></a>为啥有Compact格式</h2><p>因为生活中总有大数的概念。有时不好表示，所以需要进行编码，就有点像以太坊的RLP编码。</p><h2 id="Compact格式"><a href="#Compact格式" class="headerlink" title="Compact格式"></a>Compact格式</h2><ul><li>“Compact”格式是一个256位数字的一种表示形式</li><li>数字N使用类似于无符号32位数浮点格式</li><li>最高有效8位是基数为256的无符号指数。</li><li><b style="color:red">该指数可以被认为是“N的有效字节数”.比如0x11的有效位数为8位，即有效字节数为1,则compact形式的最高八位应该是0x01,对应的compact形式为0x01000011</b></li><li>较低的23位是尾数。</li><li>位数24（0x800000）表示N的符号。</li><li>N =（-1 ^ sign）尾数 256 ^（指数-3）</li><li>Satoshi的原始实现使用BN_bn2mpi（）和BN_mpi2bn（）。</li><li>MPI使用第一个字节的最高有效位作为符号。</li><li>因此0x1234560000的紧凑型式为（0x05123456）其中0x05123456,最高8位05表示整个数有效位数为5个字节,40位.</li><li>0xc0de000000是紧凑的（0x0600c0de）注意紧凑形式的（0x05c0de00）将为-0x40de000000,24位表示符号</li><li>CBigNum bnProofOfWorkLimit(~uint256(0) &gt;&gt; 32);如果认为有效位为256-32=224=28(0x1c个字节)*8,则取最高24位为尾数即ffffff(24位为符号位,不方便表示符号),如果认为有效位为256-24=232=29(0x1d个字节)*8,则取最高24位为尾数即00ffff,则compact形式为0x1d00ffff(比特币基因块的目标难度位)</li></ul><h3 id="2-1-0x20-0x1d-紧凑形式最高8位-8-2-尾数高位0字节个数-4-32-右移尾数-计算出来hash值0的个最少个数"><a href="#2-1-0x20-0x1d-紧凑形式最高8位-8-2-尾数高位0字节个数-4-32-右移尾数-计算出来hash值0的个最少个数" class="headerlink" title="2.1. [0x20-0x1d(紧凑形式最高8位)]*8+2(尾数高位0字节个数)*4=32(右移尾数,计算出来hash值0的个最少个数)"></a>2.1. [0x20-0x1d(紧凑形式最高8位)]*8+2(尾数高位0字节个数)*4=32(右移尾数,计算出来hash值0的个最少个数)</h3><p>比特币只使用这种“Compact”格式来编码难度目标，无符号256位数量。 所以，所有的符号位的复杂度和使用256的大概可能是一个实施意外。</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><b style="color:red">就是32位整数用来表示256位的数字，最高的8位是指后面有多少字节的数据，低位在前面，高位在后面，这样如果高位为0的话，那么就不用去考虑了。但这里并不是这样，这里最多是3个字节。第24位到代表正负，较低的23位是尾数。注意低位的0是可以被忽略的，因为有长度的说明。</b></p><p><b style="color:#00f">这其实就是有精度限制的，也就是说数字不大的话，精度是可以的，否则就会损失精度。一旦字节长过3（不包括）个字节，那么就会损失精度。大概的意思就是这样。也许浮点数的计算也是这样的吧！这个有利于你理解float、double等一些数据范围比较大的数据的实现。</b></p><p><b style="color:red">当然，如果这个东西是用来序列化整数，那自然是有精度的问题。可是如果就是用来存储数据，类型不是整数，比如说区块信息，那这个东西就很有用了，其实这个东西就是主要用来存放区块信息，比如说返回一个区块头列表，一个区块中所有的交易数据等等。这时候可能就不是compact格式了。其实这里讲的就是如何使用32位数表示256进制的数字</b></p><p><b style="color:red">还有一个注意点：就是一旦发现高位的符号是1，那么如果直接表示的话，可能数字就会变成负数，所以这个时候通常是在数字前面加一个字节0，这样变成Compact格式后也不会出现数字符号改变，唯一的缺点就是损失了一个字节的精度。</b></p><h2 id="关于数字恢复"><a href="#关于数字恢复" class="headerlink" title="关于数字恢复"></a>关于数字恢复</h2><p>我们看到上面的公式为：<code>N =（-1 ^ sign）尾数 256 ^（指数-3）</code>，其实这个公式比较笼统，可能乍看起来是有问题的。其实我觉得应该是<code>N=符号*23位尾数*（256 ^([8位指数-3],这个值不能小于0)）</code>.</p><p>这样的话，这个才是完整的compact解析。</p><p><b style="color:red">对于这个难度值，值越小，前面的0越多，那么挖矿的难度就越大！至于损失精度是没有关系的，因为这个数字只在意解析后的数字前面有多少个0而已，其他无需考虑。</b></p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvbGxvd3RoZWFydC9iaXRjb2luLW5vdGVzL2Jsb2IvbWFzdGVyL2JpZ251bS5oLmFkb2M=" title="https://github.com/followtheart/bitcoin-notes/blob/master/bignum.h.adoc">比特币源码分析之大数类CBigNum<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly95dXNodWFuZ3FpLmNvbS9ibG9nLzIwMTcvdW5kZXJzdGFuZC1iaXRjb2luLWRpZmZpY3VsdHkuaHRtbA==" title="https://yushuangqi.com/blog/2017/understand-bitcoin-difficulty.html">理解与计算比特币难度值Difficulty<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
            <tag> compact </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下如何使用比特币命令</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AF%94%E7%89%B9%E5%B8%81%E5%91%BD%E4%BB%A4.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AF%94%E7%89%B9%E5%B8%81%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>今天由于要去对接usdt，发现usdt其实是颜色币或者称为比特币上的代币。这种币原来是基于omni协议做的。omni基于比特币的客户端做了一个和比特币客户端兼容的代币客户端，负责解析各种货币。具体的知识就不深入探究了。我本来是看到代币输出中出现了“Unable to decode output address ”，重点是这种输出上居然有钱，可以查看这笔代币的调用<span class="exturl" data-url="aHR0cHM6Ly9ibG9ja2NoYWluLmluZm8vdHgvNDgwMTM2NDRjZWVlNWI1NjA1Y2M1ODllY2VlMzVhYjAzZTc5MDBhYWMzODM3Y2JmMDRjYmIzMzU1Y2FhZDBjNQ==" title="https://blockchain.info/tx/48013644ceee5b5605cc589ecee35ab03e7900aac3837cbf04cbb3355caad0c5">https://blockchain.info/tx/48013644ceee5b5605cc589ecee35ab03e7900aac3837cbf04cbb3355caad0c5<i class="fa fa-external-link"></i></span> 。网上也查了一下，其实就是OP_RETURN脚本导致的，其实就是为了附加信息而已。后来想看看原本的脚本输出，突然忘记命令怎么打了，悲剧了，所以还是记录一下吧！</p><p><span class="exturl" data-url="aHR0cHM6Ly9vbW5pZXhwbG9yZXIuaW5mby8=" title="https://omniexplorer.info/">omni浏览器<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9ja2NoYWluLmluZm8v" title="https://blockchain.info/">比特币浏览器<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5vbW5pbGF5ZXIub3Jn" title="http://www.omnilayer.org">omni官网<i class="fa fa-external-link"></i></span></p><h2 id="bitcoin如何安装"><a href="#bitcoin如何安装" class="headerlink" title="bitcoin如何安装"></a>bitcoin如何安装</h2><p>不用安装，官网有二进制的压缩包，所以安装的人很少。鄙人不信这个邪偏要源码编译安装，各种坑（其实我是为了运维能够顺利部署，提前采坑而已）。我发现很少有人在CentOS上安装，于是安装的时候经常出问题，为了安装花了一周时间，哎，大家还是下载二进制版本吧！我搞以太坊的时候也搞了一周，主要是geth节点同步区块慢，而且p2p节点老丢，换成parity节点好一些，但是还是出问题。后来以太坊官网更新了geth节点，立马重新安装问题才解决。为了破节点，前前后后浪费了大半个月。</p><h2 id="bitcoin命令介绍"><a href="#bitcoin命令介绍" class="headerlink" title="bitcoin命令介绍"></a>bitcoin命令介绍</h2><p>不管是bitcoin还是bitcash都有两个节点一个服务端和一个客户端，其实服务端也可以直接执行命令返回。</p><p>首先先运行服务端：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bitcoind</span><br></pre></td></tr></table></figure><p></p><p>这个命令在哪我就不说了，最好做一下ln链接，这样你就可以直接使用这个命令了；当然如果想做一些配置的话，就写一个服务吧。要想知道服务启动的运行参数可以运行<code>bitcoind --help</code>命令，这样更加有利于你写服务脚本。</p><p>然后利用客户端执行一条命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bitcoin-cli getinfo</span><br></pre></td></tr></table></figure><p></p><p>结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bitcoin-cli getinfo</span><br><span class="line">&#123;</span><br><span class="line">    &quot;version&quot; : 90500,</span><br><span class="line">    &quot;protocolversion&quot; : 70002,</span><br><span class="line">    &quot;walletversion&quot; : 60000,</span><br><span class="line">    &quot;balance&quot; : 0.00000000,</span><br><span class="line">    &quot;blocks&quot; : 356480,</span><br><span class="line">    &quot;timeoffset&quot; : 0,</span><br><span class="line">    &quot;connections&quot; : 3,</span><br><span class="line">    &quot;proxy&quot; : &quot;&quot;,</span><br><span class="line">    &quot;difficulty&quot; : 47643398017.80344391,</span><br><span class="line">    &quot;testnet&quot; : false,</span><br><span class="line">    &quot;keypoololdest&quot; : 1514465769,</span><br><span class="line">    &quot;keypoolsize&quot; : 101,</span><br><span class="line">    &quot;paytxfee&quot; : 0.00000000,</span><br><span class="line">    &quot;relayfee&quot; : 0.00001000,</span><br><span class="line">    &quot;errors&quot; : &quot;URGENT: Alert key compromised, upgrade required&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以前我敲命令挺溜的，现在都忘记了，我们来看一下帮助文档吧！也可以使用<code>bitcoind</code>;<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bitcoin-cli help</span><br><span class="line">addmultisigaddress nrequired [&quot;key&quot;,...] ( &quot;account&quot; )</span><br><span class="line">addnode &quot;node&quot; &quot;add|remove|onetry&quot;</span><br><span class="line">backupwallet &quot;destination&quot;</span><br><span class="line">createmultisig nrequired [&quot;key&quot;,...]</span><br><span class="line">createrawtransaction [&#123;&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n&#125;,...] &#123;&quot;address&quot;:amount,...&#125;</span><br><span class="line">decoderawtransaction &quot;hexstring&quot;</span><br><span class="line">decodescript &quot;hex&quot;</span><br><span class="line">dumpprivkey &quot;bitcoinaddress&quot;</span><br><span class="line">dumpwallet &quot;filename&quot;</span><br><span class="line">encryptwallet &quot;passphrase&quot;</span><br><span class="line">getaccount &quot;bitcoinaddress&quot;</span><br><span class="line">getaccountaddress &quot;account&quot;</span><br><span class="line">getaddednodeinfo dns ( &quot;node&quot; )</span><br><span class="line">getaddressesbyaccount &quot;account&quot;</span><br><span class="line">getbalance ( &quot;account&quot; minconf )</span><br><span class="line">getbestblockhash</span><br><span class="line">getblock &quot;hash&quot; ( verbose )</span><br><span class="line">getblockchaininfo</span><br><span class="line">getblockcount</span><br><span class="line">getblockhash index</span><br><span class="line">getblocktemplate ( &quot;jsonrequestobject&quot; )</span><br><span class="line">getconnectioncount</span><br><span class="line">getdifficulty</span><br><span class="line">getgenerate</span><br><span class="line">gethashespersec</span><br><span class="line">getinfo</span><br><span class="line">getmininginfo</span><br><span class="line">getnettotals</span><br><span class="line">getnetworkhashps ( blocks height )</span><br><span class="line">getnetworkinfo</span><br><span class="line">getnewaddress ( &quot;account&quot; )</span><br><span class="line">getpeerinfo</span><br><span class="line">getrawchangeaddress</span><br><span class="line">getrawmempool ( verbose )</span><br><span class="line">getrawtransaction &quot;txid&quot; ( verbose )</span><br><span class="line">getreceivedbyaccount &quot;account&quot; ( minconf )</span><br><span class="line">getreceivedbyaddress &quot;bitcoinaddress&quot; ( minconf )</span><br><span class="line">gettransaction &quot;txid&quot;</span><br><span class="line">gettxout &quot;txid&quot; n ( includemempool )</span><br><span class="line">gettxoutsetinfo</span><br><span class="line">getunconfirmedbalance</span><br><span class="line">getwalletinfo</span><br><span class="line">getwork ( &quot;data&quot; )</span><br><span class="line">help ( &quot;command&quot; )</span><br><span class="line">importprivkey &quot;bitcoinprivkey&quot; ( &quot;label&quot; rescan )</span><br><span class="line">importwallet &quot;filename&quot;</span><br><span class="line">keypoolrefill ( newsize )</span><br><span class="line">listaccounts ( minconf )</span><br><span class="line">listaddressgroupings</span><br><span class="line">listlockunspent</span><br><span class="line">listreceivedbyaccount ( minconf includeempty )</span><br><span class="line">listreceivedbyaddress ( minconf includeempty )</span><br><span class="line">listsinceblock ( &quot;blockhash&quot; target-confirmations )</span><br><span class="line">listtransactions ( &quot;account&quot; count from )</span><br><span class="line">listunspent ( minconf maxconf  [&quot;address&quot;,...] )</span><br><span class="line">lockunspent unlock [&#123;&quot;txid&quot;:&quot;txid&quot;,&quot;vout&quot;:n&#125;,...]</span><br><span class="line">move &quot;fromaccount&quot; &quot;toaccount&quot; amount ( minconf &quot;comment&quot; )</span><br><span class="line">ping</span><br><span class="line">sendfrom &quot;fromaccount&quot; &quot;tobitcoinaddress&quot; amount ( minconf &quot;comment&quot; &quot;comment-to&quot; )</span><br><span class="line">sendmany &quot;fromaccount&quot; &#123;&quot;address&quot;:amount,...&#125; ( minconf &quot;comment&quot; )</span><br><span class="line">sendrawtransaction &quot;hexstring&quot; ( allowhighfees )</span><br><span class="line">sendtoaddress &quot;bitcoinaddress&quot; amount ( &quot;comment&quot; &quot;comment-to&quot; )</span><br><span class="line">setaccount &quot;bitcoinaddress&quot; &quot;account&quot;</span><br><span class="line">setgenerate generate ( genproclimit )</span><br><span class="line">settxfee amount</span><br><span class="line">signmessage &quot;bitcoinaddress&quot; &quot;message&quot;</span><br><span class="line">signrawtransaction &quot;hexstring&quot; ( [&#123;&quot;txid&quot;:&quot;id&quot;,&quot;vout&quot;:n,&quot;scriptPubKey&quot;:&quot;hex&quot;,&quot;redeemScript&quot;:&quot;hex&quot;&#125;,...] [&quot;privatekey1&quot;,...] sighashtype )</span><br><span class="line">stop</span><br><span class="line">submitblock &quot;hexdata&quot; ( &quot;jsonparametersobject&quot; )</span><br><span class="line">validateaddress &quot;bitcoinaddress&quot;</span><br><span class="line">verifychain ( checklevel numblocks )</span><br><span class="line">verifymessage &quot;bitcoinaddress&quot; &quot;signature&quot; &quot;message&quot;</span><br></pre></td></tr></table></figure><p></p><h2 id="以太坊节点"><a href="#以太坊节点" class="headerlink" title="以太坊节点"></a>以太坊节点</h2><p>这里就不做更多的介绍了。因为以太坊的命令使用相对简单。只要使用<code>geth help</code>命令查看一下即可。下面是我写的以太坊启动脚本。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># source function library</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line">USER=root</span><br><span class="line">ENV=&quot;sudo -u $USER -H &quot;</span><br><span class="line">PROG=geth</span><br><span class="line">GETH_CMD=/data/block/go-ethereum/build/bin/geth</span><br><span class="line">GETH_DIR=/data/chain/eth</span><br><span class="line">LOG_PATH=$GETH_DIR/geth.log</span><br><span class="line">NODE_105=&quot;enode://f630e5e22c12a81ae14b7b7779c215b31790da44c87d5f8d781bb59d33aa572c4c13ff33dbdbf2512cdd914b82e9239fc4a6004a26405bd9aed40457f31ade97@192.168.3.105:30303&quot;</span><br><span class="line"># NODE_LIST=&quot;--nodiscover --light --bootnodes $NODE_105&quot;</span><br><span class="line">NODE_LIST=&quot;--nodiscover --syncmode light --bootnodes $NODE_105&quot;</span><br><span class="line"># MINER=&quot;--mine --minerthreads 1&quot;</span><br><span class="line">MINER=&quot;--verbosity 5&quot;</span><br><span class="line">API_OPTS=&quot;--rpc --rpcaddr 0.0.0.0 --rpcapi admin,db,eth,debug,miner,net,shh,txpool,personal,web3 --rpccorsdomain \&quot;*\&quot; --ws --vmdebug --debug&quot;</span><br><span class="line">RUN_TAGS=&quot;$API_OPTS $MINER --datadir $GETH_DIR $NODE_LIST&quot;</span><br><span class="line"></span><br><span class="line">LOCK_FILE=/var/lock/subsys/$PROG</span><br><span class="line">PID_FILE=/var/run/$&#123;PROG&#125;.pid</span><br><span class="line">GETH_CON=`ps -ef | grep geth |grep datadir |wc -l`</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">      [ `id -u` -ne 0  ] &amp;&amp; echo &quot;The user permission denied the service...&quot;  &amp;&amp; exit 0</span><br><span class="line">      [ -x $started ] || exit 5</span><br><span class="line">      # echo -n $&quot;Starting $prog:&quot;</span><br><span class="line">      echo $&quot;Starting $prog:&quot;</span><br><span class="line">      echo &quot;command: $ENV $GETH_CMD $RUN_TAGS&quot;</span><br><span class="line">      $ENV $GETH_CMD $RUN_TAGS &gt;&gt;$LOG_PATH 2&gt;&amp;1 &amp;</span><br><span class="line">      shift</span><br><span class="line">      echo $! &gt; $PID_FILE</span><br><span class="line">      success ||  failure</span><br><span class="line">      retval=$?</span><br><span class="line">      echo</span><br><span class="line">      if [ $retval -eq 0 ]; then</span><br><span class="line">            touch $LOCK_FILE || retval=4</span><br><span class="line">      fi</span><br><span class="line">      return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">     [ `id -u` -ne 0  ] &amp;&amp; echo &quot;The user permission denied the service...&quot;  &amp;&amp; exit 0</span><br><span class="line">     if [ $GETH_CON -gt 0 ]; then</span><br><span class="line">          #cat $PID_FILE | xargs kill -kill</span><br><span class="line">          kill `cat $PID_FILE`</span><br><span class="line">          GETH_PID=`ps -aux |grep geth |grep datadir |awk &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">          while [ -n &quot;$GETH_PID&quot; ]; do</span><br><span class="line">              kill -kill $GETH_PID</span><br><span class="line">              GETH_PID=`ps -aux |grep geth |grep datadir |awk &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">          done</span><br><span class="line">          echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">          success ||  failure</span><br><span class="line">          retval=$?</span><br><span class="line">          echo</span><br><span class="line">          [ $retval -eq 0 ] &amp;&amp;  rm  -rf $LOCK_FILE &amp;&amp; rm -rf $PID_FILE</span><br><span class="line">          return $retval</span><br><span class="line">     else</span><br><span class="line">          echo -e &quot;The apps server is not running... &quot;  &gt;&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">     fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart() &#123;</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status() &#123;</span><br><span class="line">    status -p $&#123;PID_FILE&#125; $PROG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status_q() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">     rh_status_q &amp;&amp; exit 0</span><br><span class="line">     $1</span><br><span class="line">     ;;</span><br><span class="line">stop)</span><br><span class="line">     $1</span><br><span class="line">     ;;</span><br><span class="line">restart)</span><br><span class="line">     $1</span><br><span class="line">     ;;</span><br><span class="line">status)</span><br><span class="line">     rh_status</span><br><span class="line">     ;;</span><br><span class="line">*)</span><br><span class="line"></span><br><span class="line">echo $&quot;Usage: $0 &#123;start|stop|status|restart|status&#125;&quot;</span><br><span class="line">     exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户中心再思考</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E5%86%8D%E6%80%9D%E8%80%83.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E5%86%8D%E6%80%9D%E8%80%83.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在之前写的一篇文章中，我们提到了用户中心的设计，但是我们没有提及如何定位用户中心，以及如何使用用户中心，接下来我们就简要讨论一下这个用户中心的事情。</p><h3 id="用户中心定位"><a href="#用户中心定位" class="headerlink" title="用户中心定位"></a>用户中心定位</h3><p>用户中心应该是独立于系统而存在的，是基础服务的抽象，也就是说用户中心中不应该出现业务的影子，更不应该出现特制的一些东西。用户中心应该是一种服务，这种服务不对外，只针对系统，所以它的服务对象是后端的各个系统，不会直接面向用户。</p><p>当然如果你做成面向用户的一些接口的话也是可以实现的，但是这样做就打破了系统的边界和统一的API服务，因为我们觉得，一个系统不能跨系统请求，除非是基础的服务。一个系统需要其他的数据，也应该由本系统提供，本系统调用基础的服务，而不是基础服务直接对外。当然关于这个问题，还是有很多值得思考的地方，以后我们在实践的过程中应该还会去考虑这些问题。因为我们还要不停地去确定我们的系统边界的问题。</p><h3 id="用户中心颗粒度"><a href="#用户中心颗粒度" class="headerlink" title="用户中心颗粒度"></a>用户中心颗粒度</h3><p>用户中心是一个组系统还是一个系统，我们在具体实施的过程中遇到了这样的问题。其实这个命题不是很准确，我觉得用户中心怎么实现都是可以的，关键你是采用什么样的思想去实现，还有可能就是非技术因素的限制。</p><p>比如我们觉得用户中心包含多个方面，一是SSO，二是Oauth等等，当然最后一定用户信息模块的维护（这个狭义的用户中心）等。因为我们觉得这个更符合微服务话的思想。这个是一个比较理想的实现方式，而实际的实现可能并不是这样的。</p><p>真实的情况我们可能将上面所有的系统融合到一个系统里面去，形成了一个广义的用户中心，或者说是SSO式的用户中心。上面的狭义用户中心的设计会遇到下面这些问题：</p><ul><li>实现比较复杂（开发难度有点高）</li><li>需要处理服务调用间的异常情况</li><li>需要运维支持，可能带来很多沟通成本</li><li>分散的系统也许不是那么安全可靠</li></ul><p>这些缺点的反面就是广义用户中心的优点。只要单台机器，部署简单，省去不少与运维的沟通成本。</p><p>所以用户中心的颗粒度问题要视具体的实现情况来看。可以根据自己的需要进一步拆分系统。</p><h3 id="用户中心设计注意事项"><a href="#用户中心设计注意事项" class="headerlink" title="用户中心设计注意事项"></a>用户中心设计注意事项</h3><p>我与团队在进行上述问题的讨论过程中，又发现了用户中心设计的一些注意事项，或者说我们不得不面对和考量的一些问题。</p><ul><li>用户中心应该保存哪些用户资料信息</li><li>每个系统要求用户中心修改资料，用户中心如何防止有冲突的修改情况。（当然我们每个系统都有user表，如果想特制化，可以利用自己本地的user表，用户中心只是一些基础默认信息，但是有些系统直接使用的，这样还是会存在用户中心资料的修改冲突。）</li><li>信息修改需不需要对外（我们一致认为基础服务不能对外，因为一旦对外，这些基础服务可能就变成了一个业务系统。）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之在用户中心的设计过程中，我们会面对很多的问题，在系统成熟之前，我们可能还要面临更多的设计问题，还要做出更多的思考和总结。</p><p>一个关于系统拆分的问题，原来我们一直在拆分系统，变成了几大块，但是我们发现后来好像有点迷失了，因为我们不知道，系统在哪里？因为我们拆出来的系统好像都是基础模块，而忘记了我们其实是在做一个系统，没有系统来耦合调用这些模块，那我们做的这些基础系统有什么存在的价值。</p><p>而且基础服务的设计也是基于当前的业务，所以很多的时候，我们也许很难真正实现独立的基础服务，有些基础服务就是会和业务耦合，那么我们该如何进行处理呢？耦合可以分为：代码耦合，逻辑耦合和数据耦合（比如数据库的表设计）。如何进行高度解耦也是基础服务设计必不可少的一个考虑因素。</p><p>一个用户中心系统的设计问题，为我们带来了更多的思考，以后我们会单独写一篇文章来专门讨论如何进行系统拆分的问题。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表结构的迁移策略</title>
      <link href="//%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%81%E7%A7%BB%E7%AD%96%E7%95%A5.html"/>
      <url>//%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%81%E7%A7%BB%E7%AD%96%E7%95%A5.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>本来打算进行数据表结构的更改，而更改的过程中必然遇到数据的迁移和有些字段值的恢复。后来因为公司不再关注这块的业务，所以最后，我们没有实施，还有另外一个原因，DBA比较难对付，拼命说合规，与他合作总是打折扣，否则依照我这个暴脾气，即使公司不在乎这个系统了，做完的功能也要上线。有时很多事情本身就是很无奈的。所以说下面的就是我为这次迁移准备的预案，现在看来是实施不了了。记录下来，至少说我努力了，结果就不考虑了，做了是经验，总结也是经验。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>系统在新搭建的时候，可能由于需求的变化，或者后期系统更改的时候发现以前的表结构的设计会是一个软肋，或者表结构设计的并不好，会影响后期的开发，这时候你面临一个选择，在现有的表结构上进行扩展，还是更改现有的表结构，进行一次迁移。</p><p>总的来说这个是一个很难做决定的选项，这个要视具体情况而定了，你可能想使用新的表结构，但是你甩不掉历史的包袱，老结构的数据是一定要转成新的结构的，那么该如何转，一种是停机维护，出问题回滚，下次再来。另一种方式是平滑过渡，其实我比较推崇后一种方式来进行。因为第一种方式的破坏性极强。而且有的时候项目初建的时候的确会有很多没有考虑的地方，所以如果出现这样的问题，那么我们确实需要切换一下表结构，这也是没办法的事情，我们现在遇到的问题就是表结构由于前期需求方向不明，或者我们的策略想的有点简单，项目要求快点上线，导致我们现在的处理不是很好，所以必然要面对一次切换。</p><h2 id="维护方式"><a href="#维护方式" class="headerlink" title="维护方式"></a>维护方式</h2><h3 id="停机维护"><a href="#停机维护" class="headerlink" title="停机维护"></a>停机维护</h3><p>这种方式就是大家要在晚上人特别少的时候进行，这样做的好处是</p><ul><li>没有人使用，不用考虑增量数据，一次性导入没有任何问题。</li><li>出问题回滚，不会影响线上数据</li></ul><p>缺点：</p><ul><li>一般要晚上加班搞</li><li>用户体验差，时间就是金钱，一般没人想停服。</li><li>如果数据量大，停服时间特长，需要评估切换成本。</li></ul><p>有的时候，我们是不得不采用这种方式进行停服维护，但是个人真的不是很推崇这种方式，万不得已也没办法。</p><h3 id="平滑过渡"><a href="#平滑过渡" class="headerlink" title="平滑过渡"></a>平滑过渡</h3><p>其实这种方式就是我比较推崇的方式，这种方式的好处就是不同停服，切换方式比较复杂，需要运维支持。</p><p>首先部署新的结构和新的项目，这个项目不开放，然后从老库导数据。然后将流量引入到新系统中。这里面的问题就是增量数据的问题，迁移过程可以是很长时间。对于增量数据，一种是新旧系统上线后互相推数据，新系统要做幂等性，dba在导数据时也需要实现幂等性，待所有老数据导完后，就可以切服务了。还是就是先切，再导增量数据，这样就是最近数据可能不可见，随后可见。增量数据也可以通过binlog分析得出，也可以通过触发器的方式进行数据的推送。总之方法有很多种。</p><p>还是就是是否需要新旧共存，如果是需要相互导数据。</p><p>优点：</p><ul><li>没有停服压力，切换过程时间一般没限制</li><li>可以在晚上进行，也可白天进行，一般还是流量小的时候进行。</li><li>用户体验好，业务还在跑</li></ul><p>缺点：</p><ul><li>需要处理增量数据的问题，dba不能一次搞定。</li><li>需要考虑数据重复的问题，操作流程比较复杂</li><li>需要介入的人员很多。</li><li>对开发和介入人员的要求很高。</li></ul><h2 id="事情准备"><a href="#事情准备" class="headerlink" title="事情准备"></a>事情准备</h2><p>其实不管以上哪种切换方式，我们都需要在事情开始前进行准备。否则这件事不太好处理，还要想好预案进行处理，出现突发情况又该如何处理等等。</p><ul><li>需要评估数据转换的时间，根据线上数据量和预生产环境中进行一次实验，预估线上数据的转换时间。</li><li>运维需要准备机器，部署线上的环境</li><li>开发人员需要更改旧系统和老系统，一起发布上线实现，增量数据的传输和转换。</li><li>DBA需要在上线之后开始执行转换，但一定要做到幂等性的插入。</li></ul><p>想好应急方案，一般就是旧系统维护一段时间才能真正下线，所以数据最好是双推，这样容错性更好。</p><h2 id="事后检测"><a href="#事后检测" class="headerlink" title="事后检测"></a>事后检测</h2><p>成功转换数据后不能下架老服务，需要检测新服务，没有问题才能下架老服务。在整个过程中我们都必须进行各种评估，出现问题要即时解决，决定是继续还是终止。终止重来也是很令人头疼的事。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说大家或多或少都经历过迁移的事情，我以前的公司都是停服维护，现在我们会采用平滑过度的方案来解决我们的问题。</p><p>但是有一点必须说明平滑过度一定要之前想好方案，否则很多问题是解决不了的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散标的设计之道</title>
      <link href="//%E7%AE%97%E6%B3%95/%E6%95%A3%E6%A0%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93.html"/>
      <url>//%E7%AE%97%E6%B3%95/%E6%95%A3%E6%A0%87%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近再做债权匹配的业务，需求是这样的，将债权（后面改称标的）打包放到一个投资计划里面去，然后接受用户的投资，那么用户投资过来的钱，要直接匹配上债权。当时我们在设计这个算法的时候，我就考虑到了以下几点：</p><ul><li>匹配的标的最好和用户投资的金额相等，不要留有空间，否则会出现等待资金。</li><li>如果出现资金不能单独匹配一个标的就需要和其他的人一起投资进入标的。这样用户的资金开始分散。</li><li>优先使用大额标的匹配用户资金，这样留下来的小额资金能够适应后面的变化。</li><li>用户等待的资金何时进入的问题，如果他人投资的金额每次都能完好匹配进入，那么之前的等待资金就会一直不进入。我们的策略是他人投资加上等待资金，如果能够完好匹配，那么就加上等待资金一起进入。</li><li>因为标的有一定的期限，标的到期可能资金的流转还没结束，必须匹配新的标的，这是我们发现流转资金的在匹配可能会出现路径问题。</li><li>在匹配资金中，只能有一种策略那就是同一个人的资金拆完之后，就不要试图去合并，这样程序的复杂度会攀升。注意不是不能合并，而是复杂度及其的高，最好保持原有的状态，这样处理起来比较方便。</li><li>资金拆解进入标的后，我们一定要做资金的画像，将资金的流转使用图数据库进行记录，以流转图的形式记录下来。</li><li>如果出现新的标的集中，无法完全匹配新产生的债权，那么就会面临新的问题，新的资金拆解，如果程序写的不好，多次轮转之后，我们的资金可能越来越细化，这不是我们想看到的现象。</li><li>散标的多态性：以上说的是标的是固定的状态，但是可能标的是根据资金进行选取，这种方式相对简单很多，但是也有待支付标的，走我们放款的，就是用户选择标的付钱，然后放款给借款人，这里的问题就是及时性，如果不及时可能影响用户的体验。还有就是单笔标的的自由交易，这种也相对比较简单。最讨厌的还是收益复投，这个会有一大堆的小资金，进入就是一个麻烦。</li></ul><h2 id="资金如何整合"><a href="#资金如何整合" class="headerlink" title="资金如何整合"></a>资金如何整合</h2><p>我们看到之前的设计中，我们对资金是有一定的要求的，如果资金本身的数字不规整，那么散标是无法匹配资金的，这会带来很多的麻烦，所以我们不得不考虑规整资金的问题。</p><p>在我们的业务中，可能要求资金必须是100的整数倍，这样资金就规整了，至少我们可以解决很多的问题，但是如果引入收益复投，这样问题就来了，这么散的资金如何进入匹配呢？</p><p>思路就是职责拆分，整合资金是一部分，资金投资是一部分。其实就是整个资金做一次整合变成规整的资金，然后利用规整的资金进行散标匹配，日后的资金结算以规整后的资金为主，如果资金结算具体到某一个人，那么需要这边的职责进行拆分。这样我们原来的散标策略又可以起作用了，也不担心一些问题了。如果一个人的钱是规整的，直接进入匹配，然后在这里记录整资金，这样完美兼容原来的设计。只是收益可能不规整，所有收益的零头可能要做个标计，并且还要确定是谁的部分收益不能进入，这里就是另一种策略了，当然最好保证所有人的收益都是能进入的。这里就不深入讨论了。</p><p>以上就是我们对资金的和散标的处理过程。</p><h2 id="资产固定匹配"><a href="#资产固定匹配" class="headerlink" title="资产固定匹配"></a>资产固定匹配</h2><p>一般发布计划时资产都是固定的，那么我们该如何进入匹配呢？一般我们是根据一些条件先判断能否匹配。比如我们知道金额，就知道一些零头是不能完全匹配的，这样我们直接匹配，不用考虑完全匹配。</p><p>那么我们如何检查是否完全匹配能。一般我们是统计现有的金额和对应的标的量，采用回归的策略进行查找。本来这没啥问题，但是如果用户投资的金额比较大，那么这样的递归速度不是很差？所以我们决定，如果金额很大，先使用大额标的，将要匹配的空间尽量压缩，当到了一定的阈值之后，再来使用精确匹配，匹配掉剩余的值。另外我们还做了一些其他的优化，整个算法测下来，金额的匹配都是相当快得，本来我们还打算走异步匹配，后来发现压根就没有这个必要，最后我们还是使用了同步匹配的策略。</p><p>当然这里需要注意，当你匹配大额资产的时候可能会出现，本来能匹配的资金由于大额资产多了，而不能精确匹配上去，这时候可以考虑退一个大额资产，再进行匹配的策略。总之这个问题不是那么好去解决的。</p><p>还有就是如果我们的资产价值又多了一个，我们的策略是否还会生效，这也是我们不得不面对的一个问题。一般来说资产价值不会有多种，我们利用统计的策略就是为了，一是预检资金能否完全匹配，二是将匹配问题变成一个类似求24点的问题，这样比较简单，但是如果资产的价值情况是多样的，而且数量也是多样的，那么这个问题可能会很严重。这个我们只能使用递归策略找到最优解，这样的性能可能是大家所不能接受的。可以做必要的优化。记录哪些值是走过的，否则这个时间都是浪费的。</p><p>其实还有一种情况就是如果资产价值本身不规整，那么我们该如何处理，一是计划金额不好办，二是用户投资也不能限定。当然最好的思路就是一个资产价值地卖，这样就没问题了。如果实在不行，那可能和前面一样资产分组规整资产，这个确实实现起来比较复杂。这种极端情况应该不怎么出现。</p><p><b style="color:red">总之这里一定要实现：数据、策略、业务三者的分离，不能靠在一起，否则会出现大问题。</b></p><h2 id="轮转资金匹配"><a href="#轮转资金匹配" class="headerlink" title="轮转资金匹配"></a>轮转资金匹配</h2><p>一是资产打包进入匹配，二是根据需要的金额数量定制资产包。其实我比较偏向于第二种方法，这样资金的流程比较简单，但是也会出现一个问题，就是资产包可能由于资产的问题，可以打出相应金额的包，但是不能实现定制，那么这个时候，你不想去拆你的资金都是不能的。</p><p>重点是我们的散标策略必须知道这些，这个时候是有一个前提条件的，那就是金额和资产总价值是恒等的，这比之前的匹配好多了，但是这次需要记录资金的路径。而且是按照价值进行匹配，如果某个价值不能匹配，应该先放在一边进行晾着。</p><p>第一轮匹配完成后，进入拆解匹配剩余资金的流程，这里主要有个策略就是应该优先拆解谁的资金，一是一个人的整资金，二是本身的混合资金。在我看来如果拆混合资金，会导致很多问题，所以最好拆整资金，成分单一无历史包袱，所以最好这样去处理。但是如果只剩混合资金怎么办？那就不得不这样去做，所以这个流程你还是会去处理，这个就比较麻烦了。有些事情你还是逃不掉的。必须去做。</p><p>以上就是轮转资金的匹配策略了，我们要处理的还有很多。</p><h2 id="直投式的匹配"><a href="#直投式的匹配" class="headerlink" title="直投式的匹配"></a>直投式的匹配</h2><p>这里其实分两种情况，一是用户现在自己账户设置为投入多少钱，风险系数，高风险标的不投；那么这时的处理可能不是这么简单了，散标考虑的事情应该很多，掺杂一点业务需求。不过散标匹配相对简单，只是选择谁的资金进入而已。这种是典型的先有资金，后有标的的情况，但是这种方式也不是那么简单地解决。因为你要保证谁的钱先到优先使谁的资金先进入，但是也可能面临将别人的资金拆得比较散的情况；不管这么说这种方式比较简单的。</p><p>但是如果用户投资的金额不足以满足一个标的，标的里面也堆积了很多标的，那么这笔金额是等待，还是找那些急着使用的标的放款。这个我觉得应该使用一个时间段的，如果在这个时间段的标的有个组合能满足标的，为啥不放，但是这样会面临一个风险就是最需要资金的标的可能会饿死，这是很有可能发生的情况。这个问题又回到了之前先有标的后有资金的问题，但是又加了一个紧急度的维度，这样处理起来还是有点麻烦的。</p><p>还有就是标的到了，用户选择标的放款。这种方式就更好了，这样我们其实什么都不用担心，像处理普通业务一样而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也许关于散标匹配的内容还有很多，也没有在网上找到相应的资料的，所以发现这个却成了我们的一个问题，经过一段时间的考虑和实践，我们总结出了一套自己的散标匹配策略。随着实践的深入，我们还会不停地完善这个策略。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P2P </tag>
            
            <tag> 散标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>账务系统平级和层级账户体系设计</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%A6%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%B9%B3%E7%BA%A7%E5%92%8C%E5%B1%82%E7%BA%A7%E8%B4%A6%E6%88%B7%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%A6%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%B9%B3%E7%BA%A7%E5%92%8C%E5%B1%82%E7%BA%A7%E8%B4%A6%E6%88%B7%E4%BD%93%E7%B3%BB%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作为一家互联网金融公司，没有严格的账户处理机制是一种不好的现象，当然我们在处理各种账户体系的过程中其实遇到了各种各样的问题。我一开始可能受到一些前端设计界面的影响，导致在账户体系设计的时候没有考虑到我在后台添加的一个资金批次号的问题。然后我与产品沟通是否需要资金批次号中对应那笔资金的流转进行详细的分析，得到的答案是肯定的，但是我回归界面设计的时候却发现界面的设计上根本就不会体现出资金的批次流转问题，界面提现出来的就是总资金流转的账户设计。然后查看了一些其他家互金的app，确实大家都不会把这种信息透露出来。</p><p>所以说，有的人说的是真话，但是其实是一个伪命题。别人再回答你的问题的时候，得到的答案可能是想当然的，觉得合理就要。但是其实在设计的时候却不会理会这个东西。这其实是一种很好玩的现象。不提了，反思总结一下就好，不用较真。自己理解知晓就好。</p><p>然后我突然明白我在设计系统时陷入一个盲区，没有进行严格区分产品的需求和系统设计的单独隔离的问题。原来沟通是需要广度和深度的。与产品沟通更需要广度，与团队成员沟通更需要一定的深度；与产品沟通要放弃细节，与团队成员沟通需要深入细节；与产品沟通不用说具体设计，而应该说这种设计所导致的宏观表象就可以了，与团队成员沟通不要太专注表象，而应该关注具体的实现策略选择和系统思维的维护上。所以我们需要一层转换底层设计到产品的转化，这种转化我以前一直认为是代码上的，但其实可能也是数据库上。这种转化不一定是严格的具有上下层的，也可能是物理平级逻辑上下层的理论。这是一种很好的思维扩展。</p><p>在某种程度上受到固有一些因素的影响，当然还有自我因素，但是我是不停发展的，我不会局限当前解决问题的思路。调整策略方式，继续前行。</p><p>正是受到这次事件的影响，我不得不考虑我们系统账户设计的问题。后来我们发现我们的设计不足以追踪投入资金批次的流转问题。一开始我的思想是扩展资金进入记录表，在这张表上扩展一些字段记录一下它的流转信息，其实这是一种很好的解决问题的思路，后来团队成员意见是这种方式计算比较麻烦。其实是可以实现的。</p><p>其实这种想法还是将record表当成了record表，后来一想这应该是账户表，账户升级后这张表的账户就会和计划投资账户形成了一种平级的概念，所以这里我提出了一个平级账户的概念。既然是账户表，那就要记录流水表的设计。这时一个平级账户出现了。</p><p>我又仔细一想为何要将这个账户平级，我可以将这个账户移到计划账户的下面，这样的话，账户体系又扩充了一层，本来的平级账户，瞬间变成了层级账户。</p><p>OK，这就是这次思维的变迁过程，平级账户和层级账户都是我自定义的名词，很好的反应出这些问题。那么下面我就来详细分析这里面的内容。</p><h1 id="业务形态问题"><a href="#业务形态问题" class="headerlink" title="业务形态问题"></a>业务形态问题</h1><p>从上面看，其实平级账户我们是从record表的基础上扩展而来的，这样损失了record，但其实我们可以继续建立record表。所以在某种程度上来说，业务表与账户体系之间有着或多或少的联系，这是我们在设计财务系统的时候经常会忽略的问题。没错本人就是善于从问题中分析总结抽出我想要的东西和理论。</p><p>大家也注意到，平级账户可以扩展到层级账户上去，这里大家也许会发现这样的话，层级账户也是和record表是有关系的。这是个很有趣的现象不是么？所以下面我会再写一篇博客专门介绍业务表、流水表和账户表的设计的问题。发现这个规律你就明白，原来被忽略的事情如此简单。</p><h1 id="记录表去哪了"><a href="#记录表去哪了" class="headerlink" title="记录表去哪了"></a>记录表去哪了</h1><p>平级账户我是基于record表进行设置的，但是仔细一想record表怎么办，不去记录了，这不太可能，对于平级账户，记录表计成和原来一模一样就可以了，它关联的是计划账户表。==但其实记录表是可以关联到计划表上面去的，至于关联哪张表这个可以放到下一篇博客中分析，不是本次重点。==</p><p>再来说说层级账户吧，其实record还是可以关联到原来的计划账户上，实现1对多关系，也可以关联到批次账户上实现1对1关系。详细的分析还是留待后面的分析，以及后面的实践中去总结吧！不过这个是个很有趣的问题。</p><h1 id="关于账户管理"><a href="#关于账户管理" class="headerlink" title="关于账户管理"></a>关于账户管理</h1><p>平级账户其实是一种帐两种表现形式。而层级账户是总账明细账的处理流。平级账户提现的是维度账户体系，需要进行多维度地观看账户的信息。</p><p>另外层级账户和平级账户的设计所能提现出来的信息也是不同的；层级账户很有层次，数据零散而具有层次，有些信息就是不停地进行统计获取到，而且可以获得任何形式的数据，缺点就是统计起来比较耗时，很多数据都要统计；而平级账户本身可能是带有一定维度的，这本来是一件好事，但是要想看另一个维度的数据就比较麻烦，可能你没法看。也就是说平级账户体系可以带来多维度的扩展，但是不太利于多元化的统计，因为维度有限。</p><p>这个层级账户可以利用统计来实现维度账户体系的划分，但是实现的时候效率都不是很高，但是统计灵活，数据可以实现多元化扩展。</p><p>这两种账户在对账上也是有所区分的，==以后应该专门写一篇博客来说明如何进行对账处理。== 这两种账户体系都是可以用来进行对账处理的。并且其实对账的工作量是一样的，该做事情还是要做，只是对帐的形式不同罢了。平级账户减少了账户的层次，这时是需要在平级账户加上一些特殊的标记信息，以弥补层级缺失所导致的一些其他问题（信息上的同步、关联等问题）。</p><h1 id="两种体系的后期转化"><a href="#两种体系的后期转化" class="headerlink" title="两种体系的后期转化"></a>两种体系的后期转化</h1><p>如果我们确定了我们的账户体系，后期我们想实现一种账户体系到另一种账户体系的转化你会发现很多的转化问题，或者说就是无法转化，因为老数据的转化就是一个麻烦，烫手的山芋。</p><h1 id="对账和流水"><a href="#对账和流水" class="headerlink" title="对账和流水"></a>对账和流水</h1><p>流水一般分为汇总的总账流水，和明细型的流水，有的账户这两种流水或许都是存在的。一般来说明细流水的具体流水都是汇总之后向上记录汇总的总账流水。（==注：总账或许在业务上是不存在的，或者界面设计的不同界面会提现出不同类型的流水，有总账型的也有基础流水型的，也许还有业务性的记录等等，我们设计的时候其实都应该注意到==）</p><p>对账的实现，如果延时，那么多维度或者平级账户如何保证数据的计算方式是不同的。理论上计算方式的异同决定了对账的准确性，如果计算方式一致，一般是对不出问题的。平级账户一般数据的计算方式就是不同的，所以一般来说对账是没有问题的，但是不能进行细化对账，因为每个账户的维度不同，最后也就是总账对一下，一旦发现问题，可能无法定位到具体的问题所在。</p><p>而层级账户可以解决这个问题，因为账户形式是总-分型的，所以一旦核对不上可以很明显地精确到具体的位置，但是也就是这种层级关系，在数据写入的时候，往往都是相同的方式计算出来的，所以发现问题很难。</p><h1 id="与业务关系"><a href="#与业务关系" class="headerlink" title="与业务关系"></a>与业务关系</h1><p>账户体系的搭建其实不应该和具体的业务耦合在一起，但是在实际的实现过程中，我们发现这种关联性很强。影响的因素可能是法律合规、想法和具体的业务场景有关。其中最有账户破坏性的就是存管，一旦上存管，就必须考虑，系统账户和存管账户的关联。这个可能要做一些中间代码或者中间数据模型转化。</p><p>但是要说这两种账户体系哪种更好，我还是觉得层级账户更好，平级账户其实不能适应需求的变化。</p><h1 id="账户体系选择"><a href="#账户体系选择" class="headerlink" title="账户体系选择"></a>账户体系选择</h1><p>如果从etl的角度来说，可能就是要同时实现这两种账户体系的转化。那是他们需要处理的，也许在他们的结构设计中压根就没有账户这一概念。</p><p>但是从系统的角度来说，应该优先选择层级账户。但是最好不要两种方式一起实现，只要一套就可以了，因为有系统数据的维护成本。系统设计和数据分析的思路完全不同。如果非要两种体系都实现，那就需要分步来做，主流程处理一种账户体系，另一个体系可以通过后台工作线程或者专门的定时器来实现，进行必要的延时操作。有时可能需要进行实时的数据统计。</p><p>所以账户体系的建立还有很长的一段路要走。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个是我自己的原创总结，里面的思维在别人看来可能比较混乱，写博客本身就是一个比较累的过程。还有就是文章本身枯燥乏味。其实这篇文章更多的就是要从各个角度分析我发现这个现象，然后对它进行深入思考，在别人看来可能比较难于理解。</p><p>洋洋洒洒地写了这么多，耗费了不少脑力，就写到这儿吧！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 账务系统 </tag>
            
            <tag> 账务层级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用日志表的设计</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h3 id="1-快照表"><a href="#1-快照表" class="headerlink" title="1. 快照表"></a>1. 快照表</h3><p>表结构修改具有关联性，存储的数据比较多。可维护性很强。</p><h3 id="2-JSON"><a href="#2-JSON" class="headerlink" title="2. JSON"></a>2. JSON</h3><h4 id="2-1-记录修改前后值"><a href="#2-1-记录修改前后值" class="headerlink" title="2.1 记录修改前后值"></a>2.1 记录修改前后值</h4><p>这个性能可能和前面的快照表的性能损耗是一样的，要有很多修改的东西。</p><h4 id="2-2-记录修改后的值"><a href="#2-2-记录修改后的值" class="headerlink" title="2.2 记录修改后的值"></a>2.2 记录修改后的值</h4><p>修改前的值可以用parent_id进行关联，这种方式可以解决我们的问题。但是root没有关联，需要将插入的数据保存一分过来。</p><h4 id="2-3-记录修改的字段的值"><a href="#2-3-记录修改的字段的值" class="headerlink" title="2.3 记录修改的字段的值"></a>2.3 记录修改的字段的值</h4><p>这个和2.2 差不多只是，只序列化修改的字段，这样存储的信息更少。但是如果想要知道哪个字段的修改就无能为力，需要找到所有的更改记录。</p><h3 id="3-操作表-更改表"><a href="#3-操作表-更改表" class="headerlink" title="3. 操作表+更改表"></a>3. 操作表+更改表</h3><p>就是一个记录基本操作信息的表，然后另一张表记录修改哪张表的哪个字段，哪个值被改为哪个值。如果要查改动之前的值就是会有查询的操作，另外就是批量更改可能会产生大量需要更改的数据。</p><h4 id="3-1-原值-现值"><a href="#3-1-原值-现值" class="headerlink" title="3.1 原值+现值"></a>3.1 原值+现值</h4><p>依然还是存储想要的值，但是只有修改的字段的原值和现值。</p><h4 id="3-2-只记录现值"><a href="#3-2-只记录现值" class="headerlink" title="3.2 只记录现值"></a>3.2 只记录现值</h4><p>还是通过parent_id记录修改的历史，但是root必须是原来的值，所以插入的时候需要保存一份在这个地方。</p><p>原值的改动可以在第一次查询使用的时候，通过parent_id找到，这种方式的缺点是，无从知晓上一次本字段是在哪次编辑的，反正找打了就要存下来。如果原值不需要查询，那么在生成日志的时候就一起存下来。有的原值是NULL，这样就达不到缓存的策略，所以可以设置为空字符串也不要设置为NULL，这样缓存策略才能生效。</p><p>其实parent_id这种方式只能保证更改的记录串行而已，但是无法确定一个字段的原值，通过parent-id进行回溯，可能存在次数过多的问题。所以应该在记录filed的这张表设置中加入被修改表的信息，以及修改的记录id的信息，通过记录id和字段名找到所有值，这样就可以知道原来的值是什么了，排序就是事件的发生顺序，所以应该没有问题。</p><h3 id="4-No-SQL的存储"><a href="#4-No-SQL的存储" class="headerlink" title="4. No SQL的存储"></a>4. No SQL的存储</h3><p>这种存储方式，可能会出现数据不好解析的问题，因为我们可能是进行序列化的。MongoDB可能比较适合，我们能进行相应数据的查询。但是普遍没有事务的支持。</p><p>还有一种文档存储就是基于Lucene的存储，一般我们不会直接使用Lucene，而是使用封装好的结构进行存储，比如说solr和EleasticSearch。</p><h3 id="5-列存储"><a href="#5-列存储" class="headerlink" title="5. 列存储"></a>5. 列存储</h3><p>如果进行列存储的话，其实可以解决我们的不少问题。我其实比较倾向于使用列存储的方式来解决我们遇到的问题。表格存储最大的好处就是列信息可以变动。</p><h3 id="6-日志文件打印"><a href="#6-日志文件打印" class="headerlink" title="6. 日志文件打印"></a>6. 日志文件打印</h3><p>日志文件的打印不一定是打入到文件里面去，也可以打印到流里面去。网上有很多网络流的工具，比如apache的flume。</p><p>当然也可以打印到日志文件中，这样由第三方的工具再从日志文件中读取分析。但是读取的数据需要分析存储。当然这需要工具记录上次的读取位置。</p><h3 id="7-MQ中继方式"><a href="#7-MQ中继方式" class="headerlink" title="7. MQ中继方式"></a>7. MQ中继方式</h3><p>将数据直接推送至MQ中，或者直接发给flume，再由flume推送到MQ中。一般有3层机制也有多层的架构机制。</p><p>使用这些机制的原因是一层一层的速度放缓，其实这就是本质，flume快速接受，MQ推送可以暂存一部分数据，然后storm或者spark进行分析，进一步完成数据的分析过程，又是一层的数据放缓，最后存储最终整理或者分析后的数据。</p><p>当然hadoop是用来处理离线数据的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我对通用日志的一些总结信息，想到数据分析的作用，日后如果有新的想法，我会继续加入改进。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式定时器的设计</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h3 id="一、总体概述"><a href="#一、总体概述" class="headerlink" title="一、总体概述"></a>一、总体概述</h3><p>一是分布式定时器的实现需要解决几个问题，一是如何保证任务被触发，而且只能是一台机器去触发，不能不触发或者多台机器的触发，这些都是不可取的。</p><p>二是触发过程的通知，通知的机制选择也是一个很讨厌的过程，一般会考虑以下几个因素：</p><ul><li>及时性</li><li>容错处理（对应重试的策略）</li><li>负载均衡</li><li>并发处理（防止并发的问题）</li><li>推送重试策略</li><li>推送相应的参数</li><li>推送唯一性约束</li><li>推送消息产生时间</li><li>是否需要反馈执行的状态</li><li>是否引入执行状态的检查（主动查询）</li><li>消息堆积的问题</li><li>消息两次间隔时间短，或者重试策略导致的两个连续的消息一起触发的问题（消息产生时如何去重的问题）</li></ul><p>选择不同的推送方式，可能具有以上不同的特性支持，有的推送方式太过于依赖第三方的支持，而第三方可能只有上面的部分特性不能保证所有特性的支持。还是就是第三方的东西我们一般不好改动，必须寻找其他策略进行解决，所以一般不是很推荐第三方的推送机制。</p><p>三是客户系统定时任务的设计，主要涉及以下几个方面。</p><ul><li>幂等性（同样的消息可能多次接收）</li><li>参数化设计（接口的设计最好设计出一些定制参数，同时需要检查参数的正确性）</li><li>如何通知执行状态，这里可能对消息的及时性要求不高，我们可以使用一些消息中间件。</li></ul><h3 id="定时任务分配"><a href="#定时任务分配" class="headerlink" title="定时任务分配"></a>定时任务分配</h3><p>主要需要思考消息去重的问题。</p><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p>这种加锁机制是可以解决我们的问题，而且我们也不需要将任务进行分散到多台机器去执行，所以采用多台机器的加锁机制确实可以解决我们的问题，但是我们不得不考虑以下几个问题：</p><ul><li>多台机器时间不同步的问题，会导致每台机器触发的时间是不一样的，所以必须有同步一下的机制，要么同步时间，要么有消息通知过来，大家一起行动。最好的做法就是锁上加时间，只要我们知道下一次触发是什么时候，我们就可以不放锁，让时间来帮我们放锁，但是还是会有一点小时间差的错误，但是基本上能解决我们的问题。</li><li>因为各种原因，锁抢占可能并不是那么公平，总会有人先获得锁，而且它获得锁的概率很大。</li><li>如果是配置成interval的方式启动定时器，那么会出现每台定时器启动的时机不同导致，原本5分钟执行一次的任务，变成了2，3，2，3这样的时间序列进行，这对我们来说绝不是什么好现象。</li></ul><p>这个最后我们选用的是这种方式实现的，但是我们使用的事quartz集群的方式进行的实现。这个需要看一下quartz集群内部的实现方式了，这里就不提了，后面我们再说吧！但我想一定是通过数据库进行了同步操作，毕竟quartz的源码需要研究一下，还有就是他们建立了10张左右的数据表来进行同步，所以这个需要深入研究的。</p><h4 id="任务分片的方式进行"><a href="#任务分片的方式进行" class="headerlink" title="任务分片的方式进行"></a>任务分片的方式进行</h4><p>任务分片的方式是不进行相应的处理的，基本上是集群中有一台主节点，这台leader进行任务的分配。所以它必须知道集群中有几台机器可达，然后将任务发送到每一台机器，每台机器处理哪些任务等等，这样的话我们就可以实现相应的处理机制。</p><p>这里面有两个点，一是leader的选取和重新选取策略，二是如何知道有几台机器存活。其实就是利用Zookeeper或者其他的同步组件就能实现这些功能。</p><p>如果leader挂了，我们可以使用zk的leader选举机制找到新的leader由它进行新任务的重新分配，如果leader发现有新加入的机器，也要进行任务的重新分配，如果发现有机器减少也需要进行任务的重新分配。机器的在活量，Zookeeper是可以提供给我们的。</p><p>这种方式可以解决我们的问题，其实也可以通过每次竞争，每次都获取分片分配任务，就是每次要做任务的时候，每个人都踊跃当组长，但是权利就是这一次，下次要重新抢组长的位置。再由组长取得任务并进行任务的分配，这种方式就是每次都要重新分配任务，上面的那种方式，除非有改动leader才会重新进行任务的分配。</p><h4 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h4><p>两次相同任务的触发因为某些原因一起发送的问题，这个消息如何进行去重，也是一个非常值得研究的问题。</p><p>主要还是看上一个消息的投递状态，这样我们可以记录任务的最后一个消息的id，然后本次触发可能需要记录上次触发的id，并进行相应的判断处理，执行去重策略。</p><h3 id="推送方式"><a href="#推送方式" class="headerlink" title="推送方式"></a>推送方式</h3><h4 id="http方式推送"><a href="#http方式推送" class="headerlink" title="http方式推送"></a>http方式推送</h4><p>这种推送方式需要考虑推送的状态和最终的推送结果。中间需要考虑重试机制；重试机制有一个问题就是重试花了很长时间，导致下次触发事件发生了需要连续推两次，这样就有一个问题是两次都要推还是只推送一次，还是就是如何防止消息的堆积。</p><p>另外重试几次大概要花多少时间，这个是无法估计的，因为这里包括超时的时间，这个时间是不固定的。如果不希望两次推送一起，就需要实现出重的策略。如果任务不紧急可以实现只推送一次或者几次，失败后就等待下一次的触发。这个可以在加定时任务的时候作为一个配置参数。总之这个东西是需要统筹考虑的。</p><p>总之重试策略不是无限循环的，需要最终的失败情况，如果失败，用户可以选择重新推送。这个后面会讲到。</p><h4 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h4><p>在一定程度上缓解了http推送的问题。这里注意你使用的那种订阅发布模式的实现可能存在未知的问题，比如下面的说明：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ5OTc0Ny9hcnRpY2xlL2RldGFpbHMvNTEyMzI5ODE=" title="http://blog.csdn.net/u011499747/article/details/51232981">redis之发布与订阅(publish/subscribe模式)<i class="fa fa-external-link"></i></span>. 另外还要注意订阅的模式，负载均衡，及时性、消息堆积、消息去重、推送可靠性（是否保证送达）、消费者重连是否会重推等功能。</p><p>以上的这些问题，如果是在http中我们是可以自己定制的，但是在这边很多我们无从改变，我们解决问题也只能采用巧妙的方式进行处理。</p><h4 id="MQ消息队列"><a href="#MQ消息队列" class="headerlink" title="MQ消息队列"></a>MQ消息队列</h4><p>其实MQ的方式也有很多的问题，首先就是消息的堆积处理，因为我们无从判断上一个消息是否被消费，如果没有被消费我们才有下一步的措施，也可以使用回调，判断上一个任务是否被消费，如果被消费才进行，这样一来一回的延时还是挺高的。</p><p>还有MQ是否实现相应的负载均衡策略，每个系统的订阅模式是否支持，是否应该为每个系统定制单独的tag，我觉得这个是必然的。否则这个定时器只是为了单个系统使用的。注意消费的模式一定是点到点的方式。另外就是注意MQ要能实现多Consumer的模式。还是可能还是具体到MQ是如何实现负载均衡的。</p><p>如果有两个相同的消息推过来MQ会作何处理也是一个待解决的问题，因为RocketMQ中是通过多Broker的方式实现的，也就是说一个Broker处理多个队列，一个消息放到一个队列时是顺序发送的，但是同样的消息存到了不同的队列中，那可能存在并发发送的可能性。这样的话，对系统是不利的。</p><p>消费者可能多次接受到推送的消息，所以必须保证消费者的幂等性问题。这也是MQ所不能解决的问题。必须保证幂等性。</p><p>可能还有很多其他需要考虑的问题，这里就写这么多吧，以后想到了，可以再进行相应的补充说明。</p><h4 id="Socket方式"><a href="#Socket方式" class="headerlink" title="Socket方式"></a>Socket方式</h4><p>这种方式和http方式比较类似，但是偏底层，这样的设计可能会影响系统的设计。因为需要自己进行socket编程或者使用netty进行连接。考虑到的问题和http方式是类似的。</p><p>另外Socket可以进行长连接，但是短线了可能需要相应的重连机制。还有就是谁作为Client，谁作为Server这也是必须要解决的问题；可以使服务做为Server，定时器作为Client。</p><p>其实两种方式还是有不少的区别的。</p><h3 id="客户端的设计"><a href="#客户端的设计" class="headerlink" title="客户端的设计"></a>客户端的设计</h3><p>因为是分布式的，所以不能保证推送只推一次，即使是MQ也不能保证，所以我们必须考虑幂等性的设计，还有就是参数化设计和执行反馈。</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>幂等性的设计主要关注，如何实现。一个就是统一的id设置，这种方式可能导致每次都要查询数据库的问题，当然你可以设计为保证几天内的数据是幂等性的。我觉得可以使用拦截器统一过滤，但是这不是绝对的，有的调度消息可能就是不需要幂等性的。</p><p>还有一些可能根据时间来设置，比如说当天是否执行过，如执行过就不执行了。</p><p>还有可能就是设置序列号，记录当前执行过的序列id，发来的序列号小于等于执行过的最大序列号，那么就不执行，否则就进行执行，这样的话客户端需要实现相应的代码，但是这种方式比较靠谱。这个id，我想可以通过时间来实现。这样的话是比较解耦的。因为时间是自然序列，所以用它处理id问题最合适不过的，如果有其他自然序列当然最好了。这符合解决问题的最好方式就是恰好不解决它的思路。</p><p>总之实现幂等性的方式应该还有很多，总能找到很好的解决思路。</p><h4 id="参数化设计"><a href="#参数化设计" class="headerlink" title="参数化设计"></a>参数化设计</h4><p>有的时候定时调用会失败，所以我们不得不进行重试策略，但是重试策略有一个问题，就是时间时效性，或者说客户端这时候接受到消息压根就不知这是历史数据，可能所做的处理和之前推过来是有差异的。</p><p>那么就需要就定时任务接口进行参数化的设计，比如统一当天的数据，不要从系统时间获取，而是可以通过时间参数传过来，统计传过来那天的数据。这样我们点击重试的时候就能够解决我们要重试的可能是那天的数据。这个其实就是本来在你系统获取的数据放到定时器系统中去获取，然后推送过来，这样我们可以进行重试策略。但其实这样就比较依赖定时系统，但一般定时系统的时间是正确的，所以一般不会出问题，这是客户端需要判别消息产生的时间和需要统计的时间是不是同一天的数据，如果不是的话，就判别有错，如果是相差一天的，就判断是否是相差一天的数据。其实这样做也是没有必要的。</p><p>但是有的时候参数数据可能并不是系统提供的，由程序根据相应的状况进行提供，那这样其实就不好办了，我们需要判别这种定时器是否需要考虑隔天重试带来的影响，有的可能是周期任务，当前任务失败，完全可以等待下次任务来处理，所以不需要进行重试的。有的可能需要，而且需要进行相应地重试，但是这种策略可能需要具体业务场景才可能明白解决问题的思路是什么。总之参数化的设计是必然的，这样可以解决很多分布式定时器的问题。</p><p>但是为了方便我觉得，任务的序列号需要传送，任务的产生时间需要传送，如果需要传送任务的数据库id的话，也可以进行传送。这些信息可以让客户端有相应的策略来解决自己定制化的需求问题。</p><p>有关参数化的设计就提到这里，如果有新的想法，我会进行相应的更新。</p><h4 id="执行反馈"><a href="#执行反馈" class="headerlink" title="执行反馈"></a>执行反馈</h4><p>客户端执行完成后，可以回调定时器中心，指明id或者code，让定时器中心去处理。这样的话，定时器中心某个任务下次触发时可以判断上一个任务状态，根据上一个任务的状态判断，当前这个任务是去触发，还是去丢弃。</p><p>我们也可以通过执行状态判断一下，是否有问题，但是其实我们还是有一些信息需要处理。</p><p>这个反馈的问题是，需要客户端的重试策略，盲目利用这个信息做触发判断可能有问题。其实更多的时候大家并不care这个反馈的时效和最终结果是否通知过来，所以这个可能并不是一个很好的做法，而只是为了看看而已。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在分布式系统中其实去重策略的确是一个比较烦人的事情，里面涉及的点其实比较多，我们要解决的问题其实也很多，大家在解决这些问题的时候，需要留心，可能一不小心，你的系统可能就进入了一个不太好解决的泥坑之中。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调度中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高可用用户中心设计</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们公司现在的账户体系比较混乱，每个系统都有一套自己的账户体系，没有办法进行统一的账户管理，比如统计一个人在哪个系统有账号，这样操作是比较麻烦的，还有就是我们如何进行用户行为分析，最终综合用户的信息进行用户的画像。这些都是需要解决的问题。</p><p>常规的用户设计是统一账号和统一登录验证，统一注册等信息。但是结合我们公司的实际，发现这样的话我们的系统可能会出问题，我们无法屏蔽很多细节。我们的现状是：</p><ul><li>系统需要向用户隐藏是同一个公司的这个事实。也就是说我们做了用户中心的设计，但是不能让用户感知这个系统的存在。也就是说多个系统之间的登录都是需要隔离的。离论上不能做统一账号的登录，但是可以做统一账号的验证。</li><li>同一个系统可能有多个马甲app，我想马甲app之间也需要登录隔离，虽然他们调用的是同一个后台系统，那么我们不得不面对一个问题，同一个用户同时下单的逻辑处理，需要后台做这种处理，否则就会出现严重的并发错误，而开发人员可能都没有注意到这个事实的存在，从而导致一些稀奇古怪的事情出现。</li><li>web端与app端应该是需要同时登录的，我们好像没有web的要求，但是好像有微信的web端的事情。假如我们有web端的登录，那么问题来了，我们要不要实现二维码登录web。目前看是可以先不实现的，但是作为设计考量我们不得不考虑这些。</li><li>第三方账户的登录，我们是通过手机号作为唯一标识，那么不太好实现第三方的登录注册。但是我们可以后期实现，如果实现第三方的登录注册，那么问题来了，我们的设计貌似不支持，需要改动，就是改掉手机作为唯一标识的问题，但是想想好像是不影响的，只要数据能插入问题就不大，因为没有手机号，这些用户是不能登录需要手机的app，但是有的系统可以做特殊处理，从而支持第三方账户的登录注册。但是这样做也有缺点，就是用户利用多种方式进行注册，也就是说我们不得不解决一个问题就是用户可能存在多个账户的可能性。加入用户有微信注册的账户，然后又用手机登录，绑定微信，这个时候我们可能需要去系统中用微信的unionId或者openId查找一下是否有用户，有就不能绑定，没有才能绑定。如果有我们可能也知道了这个人有重复号的可能性。这个可能需要在做的时候处理。</li><li>验证保密问题，公司居然都没有人提到这点。不过也对我们是通过手机号进行验证的。但是如果以后我们不在使用手机号，可能我们需要验证问题。还需要判断用户的活动记录，从而决定用户多长时间需要重新验证app的token。比如用户换了手机，那么我们需要加强验证，不许用户名密码登陆，强制验证码登陆，同时更改登陆设备的问题。比如1年没有登陆的用户，我们是否考虑验证问题，因为可能这个号已经弃用，别人申请了这个号，那么这个新号可以冒用别人的身份进行借钱，我不知道公司现在是否有这样的处理机制，可能是出现这种事情的概率还很小，大家都不关心吧！其实就算不验证手机号，1年没操作也应该需要重新风控的吧！异常情况出现了也就是赔钱，还能干嘛。有的公司不处理应该是因为他们不是敏感行业，其实我们真的是不一样，需要更多地为用户考量这些事情，anyway扯远了。验证问题其实需要综合客服系统，还有就是自动决策也是可以的。</li></ul><p>可以看到用户中心得设计其实牵扯的面是比较多的，其实单纯地拆分这个系统，我们发现我们的用户中心被搞重了，因为正常的用户中心不应该考虑token的sso系统，而只是信息的验证和维护提供。我们融进了SSO，还需要将数据推出验证。总之不是一件简单的事情。下面我们具体分析一下设计用户中心的思路。</p><h2 id="用户基本信息的设计"><a href="#用户基本信息的设计" class="headerlink" title="用户基本信息的设计"></a>用户基本信息的设计</h2><p>这些可能需要根据每个公司自己的需要进行建立了，一般推荐看一下Facebook、Twitter、Linkin里面的资料详情，一般基础资料包括个人基础信息、工作信息、朋友信息、个人身份信息（护照、驾照、身份证、户口簿等）、银行卡信息等等。</p><p>信息一般登录后缓存，但是不能全部缓存，之后会提到相关的内容，还有就是实时信息需要写接口单独从数据库查。</p><p>接口的提供一般也是getSimpleInfo和getInfo两种，后者不缓存，前者一般是缓存的，所以可以再扩展就是是否需要实时信息。</p><h2 id="关于用户体系"><a href="#关于用户体系" class="headerlink" title="关于用户体系"></a>关于用户体系</h2><p>我们采用Account-user的账户体系设计，就是用户中心维护Account表作为基础数据或者是默认数据。每个系统可以选择维护user表，或者选择不维护。这样我们可以使有user表系统的用户使用Account表的一些数据作为默认数据，比如说头像什么的。</p><p>如果系统不使用user表，这就表示，它就是使用公共模块的数据，这时候你就发现，有user表的系统默认数据不是空的。其实这是个很有意思的设计。</p><p>再来谈谈用户名密码吧！不同的系统可能想使用不同的用户名密码登陆，然后你就会发现如果我们采用统一的Account体系是没有办法解决这个问题的，这时候user表的强大作用就凸显出来了。我们可以在user表中自己设置user：passwd字段，这样你就特例化了自己系统的账户密码，验证时你自己验证，通过后就不需要用户中心帮助你验证，你直接告诉用户中心，这个人我验证通过了，你不需要验证，你帮这个人生成token吧！你看过程简洁，职责分离，我们用户中心，就是做统一用户的可见性，聚合用户数据，但是从来不会强制你必须使用我的东西，但是你需要告知我一声就可以了，但是token必须我来统一生成。</p><p>但是大家可能会问这样token安全吗？我们的token是安全的；因为我们token的生成方式不同，token对每一个系统的可见性不同，也就是说我们的token验证是有限制的，是隔离的。</p><p>还是就是必须要提的一点就是多马甲app，不能实现单独的密码和账户，但是如果这个系统如果基于user表扩展一张验证表通过app的编号是可以解决这个问题的。这个看具体自己的系统实现吧，这个功能不归用户中心管理。</p><h2 id="多系统用户无缝迁移"><a href="#多系统用户无缝迁移" class="headerlink" title="多系统用户无缝迁移"></a>多系统用户无缝迁移</h2><p>原来有那么多的老系统如何进行无缝的迁移这种平滑过渡也是我们不得不考虑的问题。一般是利用系统进行本系统的上线，但是本系统上线切入一些老系统的时候，我们又不得不面对一个问题，如何在老系统中平滑过渡？</p><p>我们慢慢发现这个其实是个bug，我们系统越多我们需要平滑迁移的次数就越多，而且要做好多我们不太情愿做的事情。因为每个系统再迁入的时候不是立马替换，而是使用两者共存的策略平滑过渡，试运行，通过之后再慢慢迁过来，一是此过程耗时间，二是需要在每个系统迁移的时候都做，加剧了迁移的时长。</p><p>还有就是系统共存时要相互导数据，这个也比较繁琐。涉及数据格式的转换，所以通用用户系统必须考虑数据的广度问题，太窄不行。还有就是一些老数据需要做一次批量导入，这个很难把握一个度，如何切分哪些数据是老的，哪些数据是MQ推来的新数据。不过我觉得先上，然后全量导入，因为导入过的数据是不会再导入的，因为有判断，在确定导入完成后，新系统再对外访问，这样就可以切数据。</p><p>迁移过程，就是一个验证，定型替换的过程，耗时费力。要进行各种评估。</p><h2 id="token层级问题与生成策略"><a href="#token层级问题与生成策略" class="headerlink" title="token层级问题与生成策略"></a>token层级问题与生成策略</h2><p>这里我们简单提提token隔离的问题，上面提到一个用户可能存在多个token，但是你仔细分析，可能各个Token对每个不相关子系统是不可见的。</p><p>我们是会提供一个通用的Token，这个需要用户中心的一些信息，你只要支持通用Token，那么你就和其他一些支持通用Token的系统一样，这样这些系统和标准的用户中心设计是一样的。也就是说我们的系统是支持标准的用户中心SSO Token实现方式的。</p><p>另外就是我们所说的，每个系统是可以单独生成Token的，而且生成的Token可以根据系统编号、系统分组、平台（app、web），如果是app的话，我们还会考虑马甲app的编号。</p><p>但是所有的这些不是必须的，可以让系统自己进行相应的配置的，下面我们可以进行详细的讲解。</p><h3 id="Token的生成存放策略"><a href="#Token的生成存放策略" class="headerlink" title="Token的生成存放策略"></a>Token的生成存放策略</h3><p>我们不是讲Token的生成，关于Token的生成其实方式有很多种，sha1是我常用的，还有uuid、jwt等等各种方式，但这不是我们要讲解的重点。我们主要讲解Token怎么存放，系统如何取得Token进行交互验证。</p><p>首先系统通过传入用户名密码验证，然后我们会帮助生成Token，或者系统自行验证身份调用用户中心，请求用户中心生成Token。用户中心一般完成工作后会返回Token和这个用户的基础信息。当然注册也需要各个系统进行实现。</p><p>各个系统需要传入系统号、分组id号、是否支持web/app同时登陆、app的编号、是否分组、是否支持马甲用户隔离、是否使用公共token。</p><p>如果支持分组，也就是说系统是可以让分组内的用户共享一个Token的，这个是我们考虑到部分系统可能需要建立小全体而进行的设计。</p><p>是否支持马甲用户，是我们考虑马甲用户Token的隔离而使用的。如果为true那么我们就必须考虑为每个马甲生成不同的Token，当然前提是用户是登录了多个马甲。</p><p>==是否web、app分离，有的时候我们是允许用户web和app同时在线的，但是一般的系统都会做联动，也就是app下线了，webToken会跟着下线，这里我们可能要做很多的处理。==</p><p>是否支持通用Token，支持通用Token的话，那么我们很多事情就比较好处理，其他什么的都不用考虑了。</p><p>还有一点是要注意的，我们需要弄清楚以上参数出现的组合，有些值是可以组合的，但是有些值是不能组合的，这个需要具体的分析，==今天我就不写了，想好了再来补吧！==</p><p>那我们如何保存呢？很简单利用系统编码、分组编码、平台（web、app、client）、马甲app编码进行redis key的拼接，这个存放在redis里面，然后对应的系统也如此拼接，取得Token，并进行交互验证，这样我们的设计就完成了。</p><p>我们可能要设计jar让各个系统解耦，不需要他们写代码，我们提供相应的实现即可。这样他们只管处理自己的业务就好。</p><h3 id="公用Token登录隐藏"><a href="#公用Token登录隐藏" class="headerlink" title="公用Token登录隐藏"></a>公用Token登录隐藏</h3><p>下面我们要来聊一下。公共Token登录功能的设计，这里我们只会去了解上面的参数设计，然后帮助登录的时候基于这些参数做一些设计。</p><p>这里面可能只关注一个参数的设计那就是Token是否web、app分开登录的功能。</p><h3 id="Token验证包的设计"><a href="#Token验证包的设计" class="headerlink" title="Token验证包的设计"></a>Token验证包的设计</h3><p>我们需要提供一个功能的jar包，这样做是为了客户端的解耦设计。这个功能的设计涉及公共模块的处理，以及相关策略的编写。</p><h2 id="关于Token如何验证的问题"><a href="#关于Token如何验证的问题" class="headerlink" title="关于Token如何验证的问题"></a>关于Token如何验证的问题</h2><p>关于token的验证，其实我们也在考虑，我们最后发现是两种方式吧，一是由sso统一验证处理，二是sso提供验证生成token，有系统自己维护token验证。</p><h3 id="sso统一处理"><a href="#sso统一处理" class="headerlink" title="sso统一处理"></a>sso统一处理</h3><p>这种方式看似职责比较清晰，而且其他系统与本系统的关系也是比较解耦的；但是每次系统有请求，都要把token传过来进行验证，一是用户中心的压力会变大，二是其他系统也无法做定制化的开发。</p><p>网络的依赖很重，如果多次调用用户中心，也会加大系统出错风险，如果一台机器负载很大，那对用户中心的压力也会增大，导致用户中心，对其他系统的服务能力下降，可能引起系统生态风险，当然你也可以为每个系统设置阈值，但是这个阈值需要使整个系统的负载而确定，如果其他系统请求增加，那么就降低这个系统的阈值。但是每个系统的权重又不一样，你还要设置每个系统的权重，在分配阈值的时候，你还要参考这个系统的权重，可谓不简单。</p><p>所以综上考虑我们最终放弃了这种方式的实现，转而安照下面系统的思路来进行设计。</p><p>但是网上也有使用Getway的方式进行相应地鉴权，这个就是独立地调用用户中心（SSO）进行相应的鉴权，但是这种方式我觉得会加重系统对Getway和SSO系统的依赖，加大他们的压力。同时可能也不太适合我们这种希望逻辑上实现多系统隔离的实际情况。</p><p>但是这种方式最大的好处就是职责隔离，我其实很讨厌职责不清的情况出现。还有就是改动的话，对所有系统是不可见的，这样可以无缝升级。业务系统不在关注鉴权的功能，也不需要实现登录验证的功能。</p><h3 id="SSO验证生成Token，业务系统校验"><a href="#SSO验证生成Token，业务系统校验" class="headerlink" title="SSO验证生成Token，业务系统校验"></a>SSO验证生成Token，业务系统校验</h3><p>这种设计思路是最后我们采用的设计思路，主要是用户中心负责检验用户名密码然后生成Token，存在缓存中，还要决定是否存储用户信息，然后将Token和用户信息返回给业务系统，再由业务系统进行相应地鉴权操作。</p><p>这种方式最大的好处就是减少了网络依赖的问题，同时也可每个系统高度定制化，同时也能实现用户信息的统一管理。这种特性其实特别符合我们希望我们系统能够在逻辑上相互隔离的设计。缺点就是业务系统需要做额外的处理，用户中心只是一个集中协调的角色，不太做一些其他的内容，但是这其实很符合我们现在的现状。</p><h2 id="Token过期的问题"><a href="#Token过期的问题" class="headerlink" title="Token过期的问题"></a>Token过期的问题</h2><p>关于Token我们需要续期策略，如何对Token进行续期也是我们要解决的问题；其实我们是业务系统和用户系统共用token，这样的话就可以将Token的续期问题交由业务系统自己去进行处理。用户中心这边也可以感觉到在活用户数量，已经用户的Token统计信息。</p><h2 id="用户交互分析"><a href="#用户交互分析" class="headerlink" title="用户交互分析"></a>用户交互分析</h2><p>关于用户交互的分析，一是我们需要记录用户的交互信息，但是活跃信息由于每次Token鉴权是交给了业务系统去处理，那么我们其实并不知道用户的活跃信息。</p><p>二是用户的注册信息我们是可以进行保存，我们会记录用户手机型号，浏览器型号，ip地址，注册来源，是否有人推荐等等一系列信息。还有一点就是用户邀请功能的建立，我们的系统设计的时候貌似也没考虑到这个问题。一点一点添加吧！</p><p>三是用户登录信息的保存，这个用户中心也可以进行相应地保存。</p><p>可能还有一些其他信息的保存，这里想到了再来添加吧！另外我觉得用户的活跃信息要么走mq出来，要么打日志进行日志分析才是王道。这也是系统设计的一方面。而且这个开发过程必须加快，或者直接打入到流中，由流数据进行处理。</p><h2 id="Token缓存策略设计"><a href="#Token缓存策略设计" class="headerlink" title="Token缓存策略设计"></a>Token缓存策略设计</h2><p>Redis并不是无限容量的。我们必须计算一个用户登录之后产生的内存。一个用户可能同时存在多个Token，有的是长时间的Token，所以我们可能维护很多Token，这样我们的Redis缓存一定是Cover不了这些信息的。所以我们必须控制Redis里面存储的用户数据库，如果超了，只能继续存到DB中，我们想采取的策略就是LRU策略，关于这种策略这里就不多介绍了。</p><p>但是其实这种实现方式也有一些问题，那就是DB频繁的硬删和插入。所以我们可以这样进行解决，DB里面存储所有人的信息。频繁去更新is_deleted字段，另外就是刷新最后交互时间。</p><p>但是又不得不面对另一个问题，那就是我们是业务系统进行鉴权，他无法操作用户中心的DB，所以用户中心这边可能需要提供一些检查接口来进行支持。总之这种方式可以防止我们系统因为Redis数据量过大而导致的系统卡顿现象的出现。</p><h2 id="系统的高度定制化"><a href="#系统的高度定制化" class="headerlink" title="系统的高度定制化"></a>系统的高度定制化</h2><p>一个高效的系统一定是可定制的，应该开启定制接口，提供定制化的参数。下面就简单分析一下吧，虽然我们不会去处理，也许系统有边界，但是思维从来没有边界，不能让自己的思维停留在系统的实现上，应该站得更高。</p><ul><li>一是我们的Token每个系统的独立是可以配置的，我们会在公共化的jar包中提供相应的定制参数。由每个业务系统定制。Token时长的配置等</li><li>Token存储阈值的配置，这样我们可以动态配置系统的默认行为</li><li>阈值自动优化机制，这个需要系统额外信息的指引，请求量、内存等相关的数据支撑。</li></ul><p>其实我对团队成员所说的，大概就是这些吧！</p><h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><ul><li>分表分库</li><li>通用日志表的设计（觉得列存储，日志分析比较适合）</li><li>通用id的生成策略问题</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户中心设计其实关联了很多的东西，其实并没有那么好实现，我们所采用的方式其实比较新颖。估计业内很少像我这样来处理用户中心这个负载的Token生成策略与验证。我们其实还在开发阶段，但是我经过设计和各种思考觉得这个方案大体是可行的，而且我还带领团队对这个方案进行评估，大家都觉得可行。我相信团队的力量的是无限的。</p><p>总之系统的设计涉及的面其实很多东西，很多系统的设计其实是经不住推敲，一推敲你会发现一大堆的问题急需解决，但这其实并不能带来什么效益。对于团队我是希望大家牢记Google工程师的玩笑：“做正确的事，等着被开除”。但是我会继续带着团队去解决这样的问题。其实我知道团队成员对我的认可来自实力和能力，而外部成员的认可来自绩效。你觉得我会看重哪个方面。不提了，继续前行。</p><p>以后若有新的思考，就会添加新的东西。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2P平台流水冲回与资金介入调整的问题</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/P2P%E5%B9%B3%E5%8F%B0%E6%B5%81%E6%B0%B4%E5%86%B2%E5%9B%9E%E4%B8%8E%E8%B5%84%E9%87%91%E4%BB%8B%E5%85%A5%E8%B0%83%E6%95%B4%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/P2P%E5%B9%B3%E5%8F%B0%E6%B5%81%E6%B0%B4%E5%86%B2%E5%9B%9E%E4%B8%8E%E8%B5%84%E9%87%91%E4%BB%8B%E5%85%A5%E8%B0%83%E6%95%B4%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><b style="color:#00f"><br>最近我们系统在上线的时候，发现了一个错误，提现成功的回调有异步和同步两个过程，然后我们都处理了，结果导致用户的账户金额被扣了两次，无奈第三方支付渠道有问题，我们也没办法进行解决。然后我就在想我们要去处理冲回的问题。也许还有人工介入账户调整的问题。我们引入流水表的设计，但是这个流水是否应该可改，我觉得是可以变动的。</b></p><p><b style="color:red">因为我们前期的思考都是针对系统阶段的设计，或者都是正常的系统设计思维，但是我们没有察觉到如果出现异常应该怎么处理。在对应的财务系统中一般出现异常都是要进行相应地冲回处理，处理完之后，系统也就恢复正常了。但是这个里面其实没那么简单。我们有很多需要考虑的问题：</b></p><ul><li>级联业务的处理流程</li><li>账户平衡的维持</li><li>操作记录的记录，以及能够识别哪些调整是有风险的。</li><li>冲回流水该以什么样的名义记录。</li><li>系统应该如何处理和展示冲回流水。</li><li>系统异常我们的应急机制是什么？</li></ul><p>下面我们来讨论一下。</p><h2 id="冲回策略"><a href="#冲回策略" class="headerlink" title="冲回策略"></a>冲回策略</h2><p>其实吧，这里面应该是有多种情况的处理的。一个考虑点是账户平衡；一是错误的处理流没有破坏账户平衡；二是处理的处理流破坏了账务平衡，比如说漏调整了一个账户。另一个方面是级联问题；一是错误的处理流程是单独的，不会影响其他的业务流水；二是错误的处理流水关联了其他处理流水，这样会是一个灾难性的后果；还有一个方便就是涉及的调整量的问题，一是调整量巨大很耗时，几乎不能这么操作；二是数据量还行勉强操作；三是波及的量不是很大，比如说只是一个用户，那么这个可以直接调整。</p><h3 id="调整数据量的问题"><a href="#调整数据量的问题" class="headerlink" title="调整数据量的问题"></a>调整数据量的问题</h3><p>正常情况下这个问题应该是不存在的，这个问题其实有两个层次的方面。一方面是波及的业务多，这个是我们没有办法的事情，但是这个问题可能只是影响了一个人，理论上问题不大；另一方面是波及的人特别多，这时候来处理可能就比较棘手，而且用户的体验应该也会变差。最恐怖的就是两者都有吧，涉及的业务流巨大，而且还波及了一大波用户甚至所有用户，这个时候我们就比较麻烦了。</p><p>波及多个用户这个是正常情况，因为大家都在用，相同的错误多处出现是正常的情况，所以波及多个用户是很正常的现象。重点是我们要防止级联故障，但是这个只能说靠测试团队的测试。但说实话，我们现在的测试团队，并没有深入测试过里面的流水金额是否严格准确。所以一定要将具有级联业务流水的地方，进行严格的测试才能发布到线上的，否则就会出现大面积的数据调整问题。</p><h3 id="级联业务流水"><a href="#级联业务流水" class="headerlink" title="级联业务流水"></a>级联业务流水</h3><p>对于级联业务流水，我的团队成员曾提出只调整总的业务流水，而不去理会下层数量巨大的子流水。其实这种方式是可以解决问题，但是这样怎么进行对账？而且本来账户平衡态会被打破，所以这种方式其实不是很好。但是如果说，子账户的调整放到后面去调整这个还是可以接受的。</p><p>总之对于级联流水的冲回确实会涉及到大面积的数据更改和数据插入操作。所以最好在代码质量上就杜绝这个问题，但是如何杜绝需要严格的测试验收流程。目前的我们可能还做不到这点。</p><h3 id="账户平衡"><a href="#账户平衡" class="headerlink" title="账户平衡"></a>账户平衡</h3><p>不管是冲回还是人工手工调额，最后账户要回归到平衡的状态中。维持账户平衡是我们系统不得不去处理的一个流程。所以接下来我们不得不想办法去维护我们的账户平衡，并做相应的检查，判断用户的行为是非法调整。</p><p>但是由于我们系统还没有引入真正的公司账户，所以现在整个系统很难说能保证账户平衡。只能通过各种资金的进入记录去搜查。日后这块的缺漏也需要补上。</p><p>另外还需要DBA介入维护，将旧数据同步成新的数据结构版本。这个后期的事情，今天的主题不是这个。</p><h3 id="如何调整"><a href="#如何调整" class="headerlink" title="如何调整"></a>如何调整</h3><p>综上，我们的调整策略有多种。针对级联账户要一次调整多个账户。大数据量要想办法处理。</p><p>真正的还是回归账户调整的具体措施上，这个要分情况来看：</p><ul><li>调整资金的流入和流出。这个就是人工的操作，请注意这个部分的操作比较单一，一般不影响其他流水。而且正常来说，这还是一种正常的业务，比如为一个人提款，为一个充值，别人走的可能是线上操作。而且操作完成后一般没有账户平衡问题的。</li><li>流水错误，账户平衡。这里的处理方式有两种，一种是根据流水增加调整流水，另一种是，直接建一笔流水冲回当前流水，然后再建立正确的流水进行处理，这两种方式各有好处，至于选用哪种方式，需要看具体的业务要求了。不过第二种看起来比较繁琐，却是最明确的调整方式了。第一种看起来简单，但是容易出错。需要计算差值。</li><li>流水错误，账户不平衡。这个也要分情况看待了，可能是一个金额没调，也可能是多个账户调错了，还有可能是调整的账户错了。不管哪种情况，我们也可以根据之前的策略，先冲回在新建，这种方式也是可以解决问题的。直接进行调整也是可以的办法。</li></ul><p>从上面我们可以看出主要的调整策略还是两种，一种是直接建立调整的流水让账户直接回归正常状态。二是先冲回错误流水，使账户回归正常状态，然后再建立一笔新的流水以恢复账户的金额准确性，并且恢复当时的处理业务。</p><h2 id="操作预警"><a href="#操作预警" class="headerlink" title="操作预警"></a>操作预警</h2><p>这个主要还是根据账户的平衡性进行预判，如果出现不正常的状态就进行示警性的提示，让用户注意到自己操作的危险性。</p><p>还有就是根据产生的错误流水进行调整，判断调整是否正确，否则不让调整。这样做的好处就是防止人工误操作，流水是我们的调整依据。</p><p>但是不要从整体账户的平衡去判断，而是根据那笔流水的性质，从业务平衡上去判断。因为错误的流水是多笔，调整一笔任然是不平衡的。多级账户比较麻烦，要从下面一层一层改。否则不好判断的。</p><h2 id="记录操作日志"><a href="#记录操作日志" class="headerlink" title="记录操作日志"></a>记录操作日志</h2><p>作为一个管理系统，谁在这个系统中做了什么操作还是需要记录下来，这样也是为了后期便于查账什么的。</p><h2 id="调整流水名义"><a href="#调整流水名义" class="headerlink" title="调整流水名义"></a>调整流水名义</h2><p>调整的流水应该还是与具体的业务有关，因为我们一般是根据业务流水进行调整。如果是直接调整账户，这其实是新的业务类型了。</p><h2 id="显示的问题"><a href="#显示的问题" class="headerlink" title="显示的问题"></a>显示的问题</h2><p>其实从显示的角度来说，我们应该采用先冲回在建一笔的操作，我们新建调整记录表，在这张表里面，我们可以记录这三张表的调整关系。同时也在原流水和冲回流水中加上标记，记为非展示流水，新的流水记为展示流水，这样比较明晰。所以，我比较推崇先冲回再新建的方式。</p><p>另外冲回的流水是否需要向用户展示，这也是一个要充分考虑的问题。</p><p>因为我们现在是通过业务类型向用户展示数据，但是一旦我们有其他的流水类型也调整了相应账户的流水，那么问题来了，这些流水可能展示不出来，用户看到的流水是有问题的。所以我们必须维护一张展示型流水的表，一是为了汇集各种流水，二是为了屏蔽流水表底层的实现逻辑。底层流水按照既定的方式进行累加，展示的流水可根据需要接受需要展示的流水，一旦涉及用户账户的流水就插入到展示流水里面去，这样两级流水业务拆分，一切都是那么地自然。逻辑处理起来也比较方便。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是自我的实践总结，或许在以后的过程中会有新的理解。主要提到了流水的冲回和信息的展示问题。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P2P </tag>
            
            <tag> 账务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2P平台流水设计与业务设计反思</title>
      <link href="//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/P2P%E5%B9%B3%E5%8F%B0%E6%B5%81%E6%B0%B4%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%8D%E6%80%9D.html"/>
      <url>//%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/P2P%E5%B9%B3%E5%8F%B0%E6%B5%81%E6%B0%B4%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%B8%9A%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%8F%8D%E6%80%9D.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在上一篇的博客中我们提到了平级和层级账户的设计，其实里面或多或少有反应出账户表的设计其实和业务表有很大的关联。所以本次讨论基本上是关于三个类型数据的设计，业务表，账户表和流水表。</p><p>在业务表里面又可以分为两种；一种是用于显示的业务交易类型的数据，二是基本用于交易的数据。</p><p>流水表的设计理论上是有明细流水和汇总流水这两种方式。它不应该直接给用户来显示，所以上面我们提到了显示交易类型的交易业务数据。</p><p>账户表的设计，这里我们不得不提就是账户关联的可能是用户、也可能是企业集团等，也可能是一个产品，也可能是一个事物，也可能是一种中间态。还有就是账户颗粒度的问题。账户分为两种一种是有真实现金的账户，一种是完全的记账的账户。</p><h2 id="三权分立"><a href="#三权分立" class="headerlink" title="三权分立"></a>三权分立</h2><p>这里的三权分立指的是业务、账户、流水这三个类型。基本的思想是这样的，先有业务，然后才会去调整账户，调整账户就必须记录本次的调整流水。</p><p>但是注意上面也提到过业务可能是可感知性的业务，但是还有一些业务是非感知性的业务，就比如说每日计息，正常的做法是直接调整金额并计入流水。并没有业务的影子，那我们可以通过把计息作为一种系统内部业务处理，或者说本次计息是一个事件，我要把这个事件记录下来，那么这个记录下来的事件就可以被当做是业务记录。然后再去调整账户并记录流水。</p><p>当然，这只是一种思想，这种思想有利于我们下面对这个东西的处理。解决流水不同形式的显示问题。</p><h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><p>一种是与账户或者现金有关的交易类型。这个时候我们一般会先建立一笔业务记录，然后通过业务记录记录流水，然后记录账户信息。这种形式的数据其实比较明显地展示出系统的边界，也就是说你很铭感地知道你要在这个地方建立记录数据。因为这里是显示的。</p><p>第二种可能就是隐藏的业务，可能有些中间的数据你是觉得可以记录也可以不记录的数据，或者有的时候团队成员觉得这部分的数据是可以不予显示的，那么我们会面临很多的选择问题，是否需要记录。还有一些可能你都没察觉到这里面要想想一些数据是否要记录，所以以后我们还是要关注一下中间数据。</p><p>处理中间数据我们需要对中间的数据进行定性分析，然后决定你存储这个数据的方式和抽象。一旦抽象的比较好，也许你的系统设计就会比较灵活了，具有很强的灵活性。</p><p>还有就是系统产生的业务，上面也提到了每日计息的列子，以及我们的思维方式。抽象出事件的概念，这个事件就是我们的业务类型。</p><p>还有就是显示性的业务，可能是多种业务的杂合，也就是说多种业务进行的整合业务，这个其实是为了汇总显示。这给系统带来了一定的维护成本。另外就是这种数据可能也并不是一定要存到数据库里面去，存到不同的地方就要考虑结构，查询速度、读速度、如何保证并发访问没问题，如何保证数据不损坏，数据一致性也能得到保证。==以后可以单独写一篇关于数据存储的博客来简单讨论一下。== 下面还会在讲到这些内容。</p><h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2><p>上面也提到了账户的建立，如果是财务系统账户的主体应该是公司、系统、分账的维度问题等等。</p><p>但是对于具体的业务系统的账户，应该是一个具体的实体，也可能是一个抽象的实体，比如说一次投资建立的临时账户。所以账户这个东西其实不是一个很简单的东西。</p><p>上一篇博客讲到了平级和层级账户体系，对应会计中的复帐和明细账。一般来说我们会为一个总的实体分配一个大的账户，然后根据里面的维度细化，进一步进行子账户的设计。然后不同的实体之间的账户是不会相关联的。</p><p>其实对于业务系统的设计还是应该采用层级账户的设计思想，但是如果说系统出现问题，层级账户少了一层，如果新加一层比较麻烦，而新加的那一层也只是为了解决统计的问题，那么其实是可以不加的，那么我们就要考虑使用平级账户来处理。而且有的时候账户与业务你不一定分的清楚。有些业务形式比如每一次投资记录，可以使用一次投资一个账户的概念来解决问题，也可以记录总账，但是每次投资就是记录，不在当做账户处理。记录中可以记录投资的详情。</p><p>这里的一个点就是不同的结构导致的最后扩展性支持是不一样的，还有就是统计是否会麻烦。需要根据具体的场景来进行相应的设计方案选型。</p><p>另外记住账户不是确切存在的一个实体，它应该与业务有所关联，至于这个业务是什么我们上面也说了，要学会抽象，没有单独存在的账户。</p><h2 id="流水"><a href="#流水" class="headerlink" title="流水"></a>流水</h2><p>一旦账户变动就必须建立流水。流水反映了账户变动的实质。不能把业务记录当成流水，业务记录只是一个事情，流水是跟着账户走的，而流水的出现是因为业务导致的账户变动。所以流水表中也会记录业务的类型。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>流水表的设计基本和通用日志表的设计有很多的相似之处，我们的流水表设计基本上是根据快照表的方式建立的，我觉得这种是最好的解决方案，如果想了解更多，就去看一下我的关于通用日志表设计的博客。</p><p>流水表的信息一般包括，各种账户的信息，包括调整前金额，调整的金额和调整后的金额。这个是金额方面的设计，一般我们会加上remark说明字段。还会加上多态关联的信息。也许会加个字段序列化一些额外信息。有的时候两笔流水间有关系，我们可能还会加上parent_id找父流水的设计。</p><p>我们也会在流水中加入业务类型的一个字段。OK，以上的这些设计都是没有问题的，但是我们要面对的可能是流水的重回和结构化的查询问题。</p><p>我们可能遇到以下的问题：</p><ul><li>流水过滤的问题：如果我们在查询特定正常情况下的流水，进行某种业务流水的展示，本来这没有什么问题，但是一旦重回流水进来，可能你原来的查询条件是不能拿到的，或者一个随机的调整流水波及到了你的账户，那么怎么获取呢？我一般是想通过where语句中，找到对应的账户调整额不为0的。这样列表就出来了。但是好像不好走索引。</li><li>流水显示的问题：一般是加上一个is_show的字段，然后我们生成的时候加上某种判断策略。</li><li>冲回流水的标记问题，应该打上标记。还有就是调整流水的标记问题。</li></ul><p>其他其实问题不大，最大的问题就是流水的冲回问题和调整问题。这导致的流水过滤真是件令人感到麻烦的事。一般的做法就是抽象多功能的业务记录，不直接展示流水信息。但是微信的那种到账通知应该展示的是流水信息，但和推送系统有关，与我们无关。</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>添加业务记录来展示流水，这种方式最大的好处就是可以集成各种流水数据和各个层级的流水数据，以后流水很多，分的也比较散，这样你是没有办法找到流水数据的，而且你还要聚合。有了这一层之后我们就可以解耦，前端也好展示，聚合过来的数据我们还可以分表分库。这样是一种比较好的做法。</p><p>但是重回和数据调整对业务记录也是有影响的，只是这种影响应该不大，我们也可以在业务异常中显示重回的数据。</p><p><b style="color:red">那我们应该展示的数据是什么？这里又有一个问题，一笔流水中可能展示多个账户的调整，而用户在操作时应该只是单笔账户的微调，比如提现功能，用户并不关心充值中账户，应该向用户展示余额或者可用余额账户就可以了。充值中更应该在账户信息中提现出来，但是不会在流水（前端可能显示为交易）显示出来。然后充值到账后，前端的交易记录才会显示。这里请注意一个细节就是交易记录里面只会展示一个账户的调整，而且还不是双向账户的微调。所以这个交易记录表就是给用户特列化一种交易信息展示，只会显示用户账户一侧的资金变化，而不会展示另一边的账户信息的变化。</b></p><p>这下我们就更清晰于账户资金变动的显示了。那么这张表是需要高度抽象的，一般信息有如下的信息：</p><ul><li>交易时间</li><li>交易的说明（比如说利息到账）</li><li>交易前金额（非必填）</li><li>交易的金额（必填）</li><li>交易后金额（非必填）</li><li>交易的账户（这个其实应该和交易说明类似）</li><li>具体的产品分类（这个产品可能有很多，所以要加入这个维度）</li><li>交易的状态（表明这次交易是否成功）</li><li>是否用户可见（主要用于冲回等）</li><li>remark字段</li><li>extra存放序列化信息</li></ul><h4 id="加层业务层处理"><a href="#加层业务层处理" class="headerlink" title="加层业务层处理"></a>加层业务层处理</h4><p>这个可以查看上面的详细分析过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>账户的设计其实没想象中的那么简单，也没想象中那么难，你要抽象出你想要的那个东西就可以了。重点还是抽象能力，系统的设计也是抽象能力的一种体现，抽象的好，那你的系统是完备的，否则，你的系统就是不完备的。玩不出一个新花样出来。</p><p><b style="color:red">不过确实我们当时确实没有考虑从用户的角度分析表，还有就是零散的各种数据确实需要统一的地方进行集合处理，否则会出大问题的。这次又学到了不少的知识。</b></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P2P </tag>
            
            <tag> 账务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>债权打包资金选取策略</title>
      <link href="//%E7%AE%97%E6%B3%95/%E5%80%BA%E6%9D%83%E6%89%93%E5%8C%85%E8%B5%84%E9%87%91%E9%80%89%E5%8F%96%E7%AD%96%E7%95%A5.html"/>
      <url>//%E7%AE%97%E6%B3%95/%E5%80%BA%E6%9D%83%E6%89%93%E5%8C%85%E8%B5%84%E9%87%91%E9%80%89%E5%8F%96%E7%AD%96%E7%95%A5.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我现在有个需求就是，在一些定额的债权订单中，进行打包，需要从这些不同额的债权中打出比如100w、1000w等各种金额不等的债权。其实一开始想这个问题的时候我也没啥思路，网上也没有看到比较好的解决思路，最后明白有这个时间，不如自己写代码来进行实现。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>债权的选取具有一定的规律性，越老的订单需要先打包。所以在一些特殊情况下，一些策略的实现也是要做必要的调整。</p><p>如果无法配平，我的策略就是打包超过，然后人工剔除，也可以人工选择加入一笔债权。这当然是弥补措施不是我们解决问题之道。</p><h2 id="思路与实现"><a href="#思路与实现" class="headerlink" title="思路与实现"></a>思路与实现</h2><p>我实现的那一版的思路是一定有一个调整额，而之前也有考虑过配平，这就类似于之前写的关于散标匹配的算法。因为在我看来金额固定的情况下，可以选取一个调整额，然后每笔债权留单，最后利用留下来的单子进行配平即可。</p><p>最后我选取了一个阈值，然后按照这种思路实现了我们的打包策略，由于债权分布良好，所以我一直在想，如果金额不定的话，我们如何进行适配。</p><p>这个当然就是后面的思考了。我后来想到的思路是阈值通过金额的最小公倍数进行计算，然后到了调整的阈值时，进行配平。留单的策略就是最小公倍数除以金额，得到的就是要留该金额多少单。这种方式最大的问题就是如果金额非常散，那么可能一开始就没有单子被选中，一直处于留单状态，这对我们的系统没有好处，可以设置最大的阈值，但是这样就解决不了我们的问题。如果说留单成功了，那么下面就是类似求24点的问题了。</p><p>之前我们提到了散标匹配的算法，所以你应该明白这里也可以使用递归的方式进行债券的选取，但是可能不太适合老的优先原则。我觉得还是使用留单的技术，先用老的单子填补阈值开外的空间。等达到阈值的时候，再利用递归的方式，填补阈值进行配平。</p><h2 id="递归的方式"><a href="#递归的方式" class="headerlink" title="递归的方式"></a>递归的方式</h2><p>如果需要进行配平，基本上就是在最后的时候进行简单配平，或者使用递归的思想进行实现，比如果100w的包，先按照规则将可能即将失效的先放进去90w或者多一些，然后统计剩余的债权量，通过递归回溯的方式去配平最后的10w左右的量。因为债权基本都是500-2000，以500递增的倍数，所以可以进行计数统计，配平的时候再去取债权。因为我们关注的是数字本身而不是债权。关心债权的原因是，要不最旧的先打进去。</p><p><b style="color:red">这种递归我称为计数式的递归使用。</b></p><h2 id="债权预热"><a href="#债权预热" class="headerlink" title="债权预热"></a>债权预热</h2><p>基本上对方要债权包都是整数的，所以可以在债权进入的时候，按1w先打个小包，之后打包的时候，直接按时间选择一定的数量就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>具体实现代码就不写了，这涉及到公司的机密，还有就是代码太长，一大堆异常情况的判断不太适合在这里贴出来。总之思想就是这样的，结合具体的业务场景进行细节的拆分，你总能得到你想要的那个解决方案。这就是我们不得不处理的事情，发现并解决问题。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近24小时热点问题</title>
      <link href="//%E7%AE%97%E6%B3%95/%E6%9C%80%E8%BF%9124%E5%B0%8F%E6%97%B6%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98.html"/>
      <url>//%E7%AE%97%E6%B3%95/%E6%9C%80%E8%BF%9124%E5%B0%8F%E6%97%B6%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前段时间我们在处理论坛帖子的问题，这时候产品提出来一个需求就是他想做热们帖子的功能，这些帖子要求是1小时内活跃度的排名，意思是还有日活跃度、周活跃度和月活跃度，还有天活跃度，天以上的我们可以通过定时器进行统计计算。活跃度是点击、点赞、查看量算出来的综合排名，这样我们还要进行常规的计算等等。</p><p>他还要一小时，3小时的活跃度啥的，具体的忘记了。哦，想起来了，他想要最近24小时的活跃度。然后每小时更新一次这样的需求。</p><h2 id="初始方法"><a href="#初始方法" class="headerlink" title="初始方法"></a>初始方法</h2><p>想想这个最近24小时活跃度，正常大家都是认为是前24小时，卧槽这不是要死人吗，每次用户请求我们都要查询一遍，这样可不行的。后来才明白是上24小时区间的活跃度，这才是正常点的思路。</p><p>不过想想一小时统计一次数据，这样可能真的不行，于是我在想如何进行不统计的排名呢？重点是统计之后还要计算，然后排序。后来想来想去，就是建立一个队列。但是想想不对当前的点击量等数据应该是要存放的。而且放入redis中，你还要找到所有的值进行计算然后再排名。这样也不是很好的做法。</p><p>大家都知道redis里面有有序表，哎，让他帮我们维护吧，我们自己来维护问题实在是太多了。</p><p>统计的方法时行不通的，只能缓存。</p><h2 id="后来的想法"><a href="#后来的想法" class="headerlink" title="后来的想法"></a>后来的想法</h2><p>接着我的想法是维持一个一天的数据，然后在24点的时候清零一下数据。重新开始计算，本来觉得这个想法挺好的，不过后来一想不对，时间的维度为啥一天一定是0-24点，1-25点不行？</p><p>然后思维扩展起来了。</p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>最后的方案就是特别赞，我当时就觉得哇，这么棘手的问题都解决了。</p><p>方案就是维持24个队列，这24个队列分别对应于0-24，1-25，2-26….23-47。</p><p>然后每发生一个时间就向这24个队列写数据，每个都写。然后根据系统当前时间决定使用哪个区间的数据。一个区间的数据一旦使用过就清零，然后重新接受数据，24小时后，这个区间就有了前24个小时的数据，这样我们的最近一小时活跃度的问题就解决了。</p><p>但是注意当前区间这一小时的值怎么办？好办暂存，用完之后那个区间替换当前区间，当前的区间再作为一个临时区间处理，这样利用25个队列，这个问题圆满解决。</p><p>这个有点像地理里面的新一天旧一天的感觉，这就是我们最终的方案，解决这个问题之后，心情特好。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于流的思考</title>
      <link href="//java/%E5%85%B3%E4%BA%8E%E6%B5%81%E7%9A%84%E6%80%9D%E8%80%83.html"/>
      <url>//java/%E5%85%B3%E4%BA%8E%E6%B5%81%E7%9A%84%E6%80%9D%E8%80%83.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>我们知道在JDK中定义了各种各样的流，java.io包下的流都是基本的流，这就是传统的BIO模式。</p><p>我们看一下java.nio中也定义了一种新的流方式，其中涉及到Buffer、Channel和Selector。</p><p>最近我们有一个签章的系统，需要调用第三方的服务，另外需要签名，我们是将合同的模块放在了本地的磁盘上，读取的时候进行加载，签好名然后传送第三方进行电子签，这里面涉及到大量的网络流处理，所以这些处理起来比较费劲。我们也在极力去想优化解决的方案。</p><p>由于第三方都是提供jar给我们，然后我们按照他们的方式进行签署，这样对我们的优化的空间有所不利，还有如果第三方升级接口，我们看了老的代码进行自己实现的优化，可能就要跟着进行更改，这个对于我们是不利的。但是不使用第三方的jar才能进行大面积的优化，否则会面临很多的问题。</p><p>优化的方案无非就是尽量使用内存和队列。还有就是使用NIO技术。</p><h3 id="加载模板的优化"><a href="#加载模板的优化" class="headerlink" title="加载模板的优化"></a>加载模板的优化</h3><p>首先我们能想到的就是先优化模板的加载，一般我们都是从磁盘读流，然后将流给第三方的接口进行签署，这种有一个缺点就是还是在读磁盘，这可不是好现象，而且模板是固定的，没有必要每次都去读磁盘。我们的做法是将模板加载到内存中，然后使用这个内存的Byte数组形成一种内存流，然后将这个流放入第三方的调用函数中进行加载。</p><p>这种方式就是不用频繁访问磁盘，而是一直在访问内存，可以帮助我们解决不少的问题。但是有一个缺点是一旦模板更改，系统一直在使用老模板，但是改模板的场景一般比较少。而且如果后台有管理模板的功能，那么我们就不得不解决这个问题了，还有就是模板数量可能也是动态的，那么我们要处理的事情就会很多。</p><p>其实流就是加上读取的位置标识，这和我们在使用C的file文件的方式是一样的。</p><h3 id="签署优化"><a href="#签署优化" class="headerlink" title="签署优化"></a>签署优化</h3><p>我们也想放内存，但是出现一个问题就是每次签署生成的合同文件是不同的，这和模板有很大的区别。但是同时签署的合同可能并不是很多，所以我们任然可以内存，而不是回写磁盘。</p><p>但是这里会有几个问题需要解决：</p><ul><li>gc的回收任务加重，会带来不少的问题</li><li>内存中的这个对象会很大，很可能被直接放入老年代，或者直接放到了方法区里面去了，这也不是好现象。</li></ul><p>所以这里的优化相对来说很难进行实现。</p><h3 id="使用NIO进行优化"><a href="#使用NIO进行优化" class="headerlink" title="使用NIO进行优化"></a>使用NIO进行优化</h3><p>比如我们将签好的模板回写磁盘的时候，可以使用NIO方式。网络请求调用，分析第三方的jar包，进行改造使用NIO的方式来调优，但是这种方式复杂度比较高。</p><h3 id="使用Java8的Stream"><a href="#使用Java8的Stream" class="headerlink" title="使用Java8的Stream"></a>使用Java8的Stream</h3><p>都说java8的Stream引入同时也带来并发能力，但是我没有更多使用过，所以目前对于效果也不是特别清楚。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ServiceLocator模式学习</title>
      <link href="//java/ServiceLocator%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/ServiceLocator%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>关于这个模式第一次见应该是Dubbo的服务加载器了，由于看Dubbo的源码已经很久远了，记不住了。只知道所有的服务都是通过ServiceLocator进行加载的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实ServiceLocator的实现就像是策略模式之前加上了一层路由转发，也可以说有点像网络中的路由器，通过这个路由器找到对应的服务，所以我觉得起名字叫ServiceRouter也不是不可以呀！如果说看成交换机也行！当然路由规则也是多种多样的，一是直接在系统启动的时候，在ServiceLocator中放入服务即可。还有一种方式就是通过放置资源，用类加载器加载，然后利用反射进行初始化也可以。总之方式是多种多样的就看你的实现了。</p><h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><p>我们先来说说这个SPI机制，感觉有点像ServiceLocator的泛型版，但是所有的实现都是基于反射实现，类的配置是META-INF里面。我觉得在某些方面我们可以认为，这个ServiceLoader就是ServiceLocator的实现方式之一。</p><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>利用java的命名服务，我们可以将所有的资源都给一个命名，然后我们通过名称找到相应的资源，这种实现方式还是和ServiceLocator的实现有些不一样的。我感觉这种更类似于，先登记在使用，而所有人的登记是放在一个登记的中心。而ServiceLocator并没有中心的这个概念在里面，所以我觉得这个也是比较明显的不同。但是如果广义上来说，这个也是一样的，实现方式不同而已，但是目的都达到了。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式其实就是各种产品已经做好了，等着挑选，如果调好了产品就进行制作。工厂模式（包括抽象工厂）是两种抽象一是产品，二是工厂。有4个维度去解析，一个工厂可生产不同商品，不同工厂生产不同商品等等，总之这种模式比较固定，一般来说没有灵活的空间，不能进行后期的定制化操作。或者定制化操作是非常复杂的。但是也可认为是有ServiceLocator的模式在里面的。因为我们在使用策略模式的使用，也经常使用工厂模式去生成策略。我觉得工厂模式很像交换机，ServiceLocator是路由器，不信你自己再仔细想想他们的区别。</p><h2 id="AOP-DI"><a href="#AOP-DI" class="headerlink" title="AOP/DI"></a>AOP/DI</h2><p>这里我就不介绍AOP和DI的基本概念了，我相信大家都是懂得。我们来讲如何实现AOP/DI，大家知道Spring实习AOP/DI的方式其实大体来说有两种，AOP是代理类的实现，至于DI则是通过扫描方式实现的。</p><p>ServiceLocator和DependencyInjection是实现IoC的两种不同方式。第三种方式是FactoryPattern。ServiceLocator强调预先定义资源映射，隔离资源的具体实现，也就是在所实现类的外部某处RegisterService，例如在应用程序初始化时。DependencyInjection强调辅助创建和管理对象，在创建对象是可采用构造函数注入和属性Setter注入等方式。</p><p>当然所有的功能我们可以在类中通过反射的方式来进行实现，没有反射类，其实我们什么也做不了，有了反射之后，一切都变得很强大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得分析问题一定是辩证统一，所有事物都是相通的，但是又有所区别的。问题还是要看透事情的本质，这样才能更好地理解问题。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWVmcmVlci9hcnRpY2xlL2RldGFpbHMvOTM0MjUxOQ==" title="http://blog.csdn.net/iefreer/article/details/9342519">服务定位器模式（Service Locator Pattern）详解和代码示范<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9nYW9jaHVuZG9uZy9hcmNoaXZlLzIwMTMvMDQvMTIvc2VydmljZV9sb2NhdG9yX3BhdHRlcm4uaHRtbA==" title="http://www.cnblogs.com/gaochundong/archive/2013/04/12/service_locator_pattern.html">Service Locator 模式<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ServiceLocator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitcoinj中的上下文NetworkParameters</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Bitcoinj%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87NetworkParameters.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Bitcoinj%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87NetworkParameters.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>关于上下文要说的东西可就多了，什么是上下文，说到底上下文就是传参。广义的上下文就是你可以获取数据，狭义的就是和当前执行环境有关，那么这个环境又是什么呢？闭包算吗？要我说，系统的环境变量是上下文，java的Properties是上下文，Servlet中的ServletContext是上下文，Spring中的ApplicationContext是上下文，当然Spring中的Environment也是上下文，Mybatis里面的Configuration也是上下文。扯了这么多，就引出了bitcoinj的上下文是什么？NetworkParameters就是上下文，这里有很多参数都是应用会使用的，也有不少的类聚合了NetworkParameters。我们先来看一下类图吧！</p><p><img alt="" data-src="https://raw.githubusercontent.com/gavin-account/blog-pics/master/blockchain/NetworkParamerers%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p><h2 id="NetworkParameters"><a href="#NetworkParameters" class="headerlink" title="NetworkParameters"></a>NetworkParameters</h2><p>NetworkParameters包含bitcoin链实例工作需要的数据。这是一个抽象类，具体实例可在params包中被发现。有4个实现类：一个是主网络MainNetParams，一个是为了测试网，另外两个是为了单元测试和本地app开发。虽然这些类包含一些别号，我们鼓励去调用get的静态方法。</p><p>这个类所有的实现类都在org.bitcoinj.params这个包下面。</p><h3 id="alert通知的公钥"><a href="#alert通知的公钥" class="headerlink" title="alert通知的公钥"></a>alert通知的公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final byte[] SATOSHI_KEY = Utils.HEX.decode(&quot;04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284&quot;);</span><br></pre></td></tr></table></figure><h3 id="网络标识信息"><a href="#网络标识信息" class="headerlink" title="网络标识信息"></a>网络标识信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** The string returned by getId() for the main, production network where people trade things. */</span><br><span class="line">// getId返回的字符串，用于交换事物的主要生产网络。我们的网络id</span><br><span class="line">public static final String ID_MAINNET = &quot;org.bitcoin.production&quot;;</span><br><span class="line">/** The string returned by getId() for the testnet. */</span><br><span class="line">// 测试网络的getId返回</span><br><span class="line">public static final String ID_TESTNET = &quot;org.bitcoin.test&quot;;</span><br><span class="line">/** The string returned by getId() for regtest mode. */</span><br><span class="line">// regtest模式下的getID返回值，打开regtest的方式是：./bitcoind -regtest -daemon</span><br><span class="line">public static final String ID_REGTEST = &quot;org.bitcoin.regtest&quot;;</span><br><span class="line">/** Unit test network. */</span><br><span class="line">// 单元测试网络返回的getID</span><br><span class="line">public static final String ID_UNITTESTNET = &quot;org.bitcoinj.unittest&quot;;</span><br><span class="line"></span><br><span class="line">/** The string used by the payment protocol to represent the main net. */</span><br><span class="line">// 主网络的支付协议字符串表示</span><br><span class="line">public static final String PAYMENT_PROTOCOL_ID_MAINNET = &quot;main&quot;;</span><br><span class="line">/** The string used by the payment protocol to represent the test net. */</span><br><span class="line">public static final String PAYMENT_PROTOCOL_ID_TESTNET = &quot;test&quot;;</span><br><span class="line">/** The string used by the payment protocol to represent unit testing (note that this is non-standard). */</span><br><span class="line">public static final String PAYMENT_PROTOCOL_ID_UNIT_TESTS = &quot;unittest&quot;;</span><br><span class="line">public static final String PAYMENT_PROTOCOL_ID_REGTEST = &quot;regtest&quot;;</span><br></pre></td></tr></table></figure><p>regtest是bitcoin在本地搭建的测试网络，也就是启动bitcoin的时候自成一格区块链网。进入开发模式。</p><h3 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 创建创世区块</span><br><span class="line">private static Block createGenesis(NetworkParameters n) &#123;</span><br><span class="line">    Block genesisBlock = new Block(n, Block.BLOCK_VERSION_GENESIS);</span><br><span class="line">    Transaction t = new Transaction(n);</span><br><span class="line">    try &#123;</span><br><span class="line">        // A script containing the difficulty bits and the following message:</span><br><span class="line">        //</span><br><span class="line">        //   &quot;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&quot;</span><br><span class="line">        byte[] bytes = Utils.HEX.decode</span><br><span class="line">                (&quot;04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73&quot;);</span><br><span class="line">        t.addInput(new TransactionInput(n, t, bytes));</span><br><span class="line">        ByteArrayOutputStream scriptPubKeyBytes = new ByteArrayOutputStream();</span><br><span class="line">        Script.writeBytes(scriptPubKeyBytes, Utils.HEX.decode</span><br><span class="line">                (&quot;04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f&quot;));</span><br><span class="line">        scriptPubKeyBytes.write(ScriptOpCodes.OP_CHECKSIG);</span><br><span class="line">        t.addOutput(new TransactionOutput(n, t, FIFTY_COINS, scriptPubKeyBytes.toByteArray()));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // Cannot happen.</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    genesisBlock.addTransaction(t);</span><br><span class="line">    return genesisBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpDiscovery-Details"><a href="#HttpDiscovery-Details" class="headerlink" title="HttpDiscovery.Details[]"></a>HttpDiscovery.Details[]</h3><p>这个是用来查找P2P节点的种子的。HttpDiscovery这个类会通过detail里面的uri读取文件，会使用detail中的key进行签名的验证。返回的流是GZIP格式的，按照protobuf的格式进行解析，其实就是peerseeds.proto文件的说明，解析就是按照这个标准来的，这样我们的节点就可以先连接上种子节点，进而进入P2P网络。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还有就是一些全局的参数了，这里不做过多的说明。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 创始区块</span><br><span class="line">protected Block genesisBlock;</span><br><span class="line">protected BigInteger maxTarget;</span><br><span class="line"></span><br><span class="line">// 端口号</span><br><span class="line">protected int port;</span><br><span class="line">// 表示消息源网络，当流状态未知时，用于查找下一条消息。</span><br><span class="line">protected long packetMagic;  // Indicates message origin network and is used to seek to the next message when stream state is unknown.</span><br><span class="line">protected int addressHeader; // 地址头部</span><br><span class="line">protected int p2shHeader;    //</span><br><span class="line">protected int dumpedPrivateKeyHeader;</span><br><span class="line">// 用于检测，多少个块开始进行挖矿难度调整</span><br><span class="line">protected int interval;</span><br><span class="line">// 大概的解释是两周内区块要多少时间，秒</span><br><span class="line">protected int targetTimespan;</span><br><span class="line">// alert消息的公钥</span><br><span class="line">protected byte[] alertSigningKey;</span><br><span class="line">protected int bip32HeaderPub;</span><br><span class="line">protected int bip32HeaderPriv;</span><br><span class="line"></span><br><span class="line">/** Used to check majorities for block version upgrade */</span><br><span class="line">// 用来检查多数区块的版本升级</span><br><span class="line">protected int majorityEnforceBlockUpgrade;</span><br><span class="line">protected int majorityRejectBlockOutdated;</span><br><span class="line">protected int majorityWindow;</span><br><span class="line"></span><br><span class="line">// 在旧的钱包中这个字段可能是空值。在这种情况下，我们通过端口号进行启发式地推导</span><br><span class="line">protected String id;</span><br><span class="line">// coinbase交易所需的块的深度是可以花费的。（钱可以花到哪个块高）</span><br><span class="line">protected int spendableCoinbaseDepth;</span><br><span class="line">// 补贴减少块数</span><br><span class="line">protected int subsidyDecreaseBlockCount;</span><br><span class="line"></span><br><span class="line">// 可接受的地址编码（可接受的地址前缀）</span><br><span class="line">protected int[] acceptableAddressCodes;</span><br><span class="line">// dns种子节点</span><br><span class="line">protected String[] dnsSeeds;</span><br><span class="line">// 地址节点种子</span><br><span class="line">protected int[] addrSeeds;</span><br><span class="line">// httpDiscovery的种子节点</span><br><span class="line">protected HttpDiscovery.Details[] httpSeeds = &#123;&#125;;</span><br><span class="line">// 检查点（需要深入学习）</span><br><span class="line">protected Map&lt;Integer, Sha256Hash&gt; checkpoints = new HashMap&lt;&gt;();</span><br><span class="line">// 消息序列化</span><br><span class="line">protected transient MessageSerializer defaultSerializer = null;</span><br></pre></td></tr></table></figure><p></p><p>现在我也不是很清楚这里面每一个变量的作用，等用到NetworkParameters类及其子类的时候，我们会发现这些字段的具体意思。</p><h2 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h2><p>工具类，持有所有的注册NetworkParameters，用于自动地址发现。默认只有MainNetParams和TestNet3Params被使用。如果你使用TestNet2，RegTestParams或者UnitTestParams，是哟register和unregister方法进行添加和取消。</p><h2 id="AbstractBitcoinNetParams"><a href="#AbstractBitcoinNetParams" class="headerlink" title="AbstractBitcoinNetParams"></a>AbstractBitcoinNetParams</h2><p>这个类是继承NetworkParameters，也是一个抽象的接口。是比特币类型网络的参数。这里面加入了一个<code>public static final int REWARD_HALVING_INTERVAL = 210000;</code>,还有一个方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 检查我们是否在奖励减半点。</span><br><span class="line">public final boolean isRewardHalvingPoint(final int height) &#123;</span><br><span class="line">    // 当挖矿，挖到一定程度之后，开始奖励减半。</span><br><span class="line">    return ((height + 1) % REWARD_HALVING_INTERVAL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>还有一个难度检测的点：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 检查我们是否处于难度转换点。</span><br><span class="line">public final boolean isDifficultyTransitionPoint(final int height) &#123;</span><br><span class="line">    return ((height + 1) % this.getInterval()) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面是一个检查区块的工作量证明的方法，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock,</span><br><span class="line">    final BlockStore blockStore) throws VerificationException, BlockStoreException &#123;</span><br><span class="line">    final Block prev = storedPrev.getHeader();</span><br><span class="line"></span><br><span class="line">    // Is this supposed to be a difficulty transition point?</span><br><span class="line">    if (!isDifficultyTransitionPoint(storedPrev.getHeight())) &#123;</span><br><span class="line"></span><br><span class="line">        // No ... so check the difficulty didn&apos;t actually change.</span><br><span class="line">        // 如果不是难度调整，那么两个区块的计算难度是一致的，否则就是不对的</span><br><span class="line">        if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())</span><br><span class="line">            throw new VerificationException(&quot;Unexpected change in difficulty at height &quot; + storedPrev.getHeight() +</span><br><span class="line">                    &quot;: &quot; + Long.toHexString(nextBlock.getDifficultyTarget()) + &quot; vs &quot; +</span><br><span class="line">                    Long.toHexString(prev.getDifficultyTarget()));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We need to find a block far back in the chain. It&apos;s OK that this is expensive because it only occurs every</span><br><span class="line">    // two weeks after the initial block chain download.</span><br><span class="line">    final Stopwatch watch = Stopwatch.createStarted();</span><br><span class="line">    Sha256Hash hash = prev.getHash();</span><br><span class="line">    StoredBlock cursor = null;</span><br><span class="line">    // 两周左右的Block间隔</span><br><span class="line">    final int interval = this.getInterval();</span><br><span class="line">    // 看起来是要检查链的完整性</span><br><span class="line">    for (int i = 0; i &lt; interval; i++) &#123;</span><br><span class="line">        // 先取得当前的block</span><br><span class="line">        cursor = blockStore.get(hash);</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            // This should never happen. If it does, it means we are following an incorrect or busted chain.</span><br><span class="line">            // 如果链是断的，才会调用到这里</span><br><span class="line">            throw new VerificationException(</span><br><span class="line">                    &quot;Difficulty transition point but we did not find a way back to the last transition point. Not found: &quot; + hash);</span><br><span class="line">        &#125;</span><br><span class="line">        // 向前回溯</span><br><span class="line">        hash = cursor.getHeader().getPrevBlockHash();</span><br><span class="line">    &#125;</span><br><span class="line">    checkState(cursor != null &amp;&amp; isDifficultyTransitionPoint(cursor.getHeight() - 1),</span><br><span class="line">            &quot;Didn&apos;t arrive at a transition point.&quot;);</span><br><span class="line">    watch.stop();</span><br><span class="line">    // 上面的代码执行时间超过50ms，记录日志，就是一个检测点而已。</span><br><span class="line">    if (watch.elapsed(TimeUnit.MILLISECONDS) &gt; 50)</span><br><span class="line">        log.info(&quot;Difficulty transition traversal took &#123;&#125;&quot;, watch);</span><br><span class="line"></span><br><span class="line">    // interval块之前的区块</span><br><span class="line">    Block blockIntervalAgo = cursor.getHeader();</span><br><span class="line">    // 取得时间差</span><br><span class="line">    int timespan = (int) (prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());</span><br><span class="line">    // Limit the adjustment step.</span><br><span class="line">    // 限制调整步骤</span><br><span class="line">    final int targetTimespan = this.getTargetTimespan();</span><br><span class="line">    if (timespan &lt; targetTimespan / 4)</span><br><span class="line">        timespan = targetTimespan / 4;</span><br><span class="line">    if (timespan &gt; targetTimespan * 4)</span><br><span class="line">        timespan = targetTimespan * 4;</span><br><span class="line"></span><br><span class="line">    // 计算出新的区块难度</span><br><span class="line">    BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget());</span><br><span class="line">    // 对区块难度进行调整</span><br><span class="line">    newTarget = newTarget.multiply(BigInteger.valueOf(timespan));</span><br><span class="line">    newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan));</span><br><span class="line"></span><br><span class="line">    // 如果难度超过了，maxTarget就进行调整</span><br><span class="line">    if (newTarget.compareTo(this.getMaxTarget()) &gt; 0) &#123;</span><br><span class="line">        log.info(&quot;Difficulty hit proof of work limit: &#123;&#125;&quot;, newTarget.toString(16));</span><br><span class="line">        newTarget = this.getMaxTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int accuracyBytes = (int) (nextBlock.getDifficultyTarget() &gt;&gt;&gt; 24) - 3;</span><br><span class="line">    long receivedTargetCompact = nextBlock.getDifficultyTarget();</span><br><span class="line"></span><br><span class="line">    // The calculated difficulty is to a higher precision than received, so reduce here.</span><br><span class="line">    // 计算的区块难度很难接受，那么就调整一下</span><br><span class="line">    BigInteger mask = BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);</span><br><span class="line">    newTarget = newTarget.and(mask);</span><br><span class="line">    long newTargetCompact = Utils.encodeCompactBits(newTarget);</span><br><span class="line"></span><br><span class="line">    // 查看一下计算出的区块难度和真实的区块难度是否匹配。</span><br><span class="line">    if (newTargetCompact != receivedTargetCompact)</span><br><span class="line">        throw new VerificationException(&quot;Network provided difficulty bits do not match what was calculated: &quot; +</span><br><span class="line">                Long.toHexString(newTargetCompact) + &quot; vs &quot; + Long.toHexString(receivedTargetCompact));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从这里可以看出，区块难度计算为：<code>difficulty = [prev_target] * 【前2015个区块生成所用的时间】 / 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数）</code>,但是前2015个区块生成所用的时间在这里有以下的调整，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (timespan &lt; targetTimespan / 4)</span><br><span class="line">    timespan = targetTimespan / 4;</span><br><span class="line">if (timespan &gt; targetTimespan * 4)</span><br><span class="line">    timespan = targetTimespan * 4;</span><br></pre></td></tr></table></figure><p></p><h2 id="MainNetParams"><a href="#MainNetParams" class="headerlink" title="MainNetParams"></a>MainNetParams</h2><p>MainNetParams继承AbstractBitcoinNetParams，这里指的是主链上的配置信息。实例化了一些参数，我们可以看一下这个类：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2013 Google Inc.</span><br><span class="line"> * Copyright 2015 Andreas Schildbach</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package org.bitcoinj.params;</span><br><span class="line"></span><br><span class="line">import org.bitcoinj.core.*;</span><br><span class="line">import org.bitcoinj.net.discovery.*;</span><br><span class="line"></span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">import static com.google.common.base.Preconditions.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Parameters for the main production network on which people trade goods and services.</span><br><span class="line"> */</span><br><span class="line">public class MainNetParams extends AbstractBitcoinNetParams &#123;</span><br><span class="line">    public static final int MAINNET_MAJORITY_WINDOW = 1000;</span><br><span class="line">    public static final int MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED = 950;</span><br><span class="line">    public static final int MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 750;</span><br><span class="line"></span><br><span class="line">    public MainNetParams() &#123;</span><br><span class="line">        super();</span><br><span class="line">        // 一个周期有多少个区块 2周/10min=2016</span><br><span class="line">        interval = INTERVAL;</span><br><span class="line">        // 一个周期多长时间，两周转化为秒</span><br><span class="line">        targetTimespan = TARGET_TIMESPAN;</span><br><span class="line">        // 进行compact格式编码最后返回BigDecimal而已</span><br><span class="line">        maxTarget = Utils.decodeCompactBits(0x1d00ffffL);</span><br><span class="line">        // base58编码输出的私钥的第一个字节</span><br><span class="line">        dumpedPrivateKeyHeader = 128;</span><br><span class="line">        // base58编码地址的第一个字节。这和acceptableAddressCodes[0]是一样的，其他类型的地址第一个字节，可以查看acceptableAddressCodes数组</span><br><span class="line">        addressHeader = 0;</span><br><span class="line">        // Base58编码的p2sh地址的第一个字节，BIP-0013引入</span><br><span class="line">        p2shHeader = 5;</span><br><span class="line">        // 支持两种地址类型，addressHeader和p2shHeader</span><br><span class="line">        acceptableAddressCodes = new int[] &#123; addressHeader, p2shHeader &#125;;</span><br><span class="line">        // 默认端口号</span><br><span class="line">        port = 8333;</span><br><span class="line">        // 头部字节用于标识网络包的开始</span><br><span class="line">        packetMagic = 0xf9beb4d9L;</span><br><span class="line">        // 在base58里序列化的4字节头部信息，到xpub，这是为了分层确定性钱包制定的。</span><br><span class="line">        bip32HeaderPub = 0x0488B21E; //The 4 byte header that serializes in base58 to &quot;xpub&quot;.</span><br><span class="line">        // 上面那个是公钥，这里是私钥</span><br><span class="line">        bip32HeaderPriv = 0x0488ADE4; //The 4 byte header that serializes in base58 to &quot;xprv&quot;</span><br><span class="line"></span><br><span class="line">        // 用来检查多数区块的版本升级，最新块中的块数，在这个点触发一个通知给用户，让用户升级他们的客户端，这里客户端可能理解不了新的区块。</span><br><span class="line">        majorityEnforceBlockUpgrade = MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE;</span><br><span class="line">        // 过期区块的升级（旧版本）</span><br><span class="line">        majorityRejectBlockOutdated = MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED;</span><br><span class="line">        // 采样窗口从中获取块的版本号，以确定现在是否新块版本是多数。</span><br><span class="line">        majorityWindow = MAINNET_MAJORITY_WINDOW;</span><br><span class="line"></span><br><span class="line">        // 设置创世区块的一些信息</span><br><span class="line">        genesisBlock.setDifficultyTarget(0x1d00ffffL);</span><br><span class="line">        genesisBlock.setTime(1231006505L);</span><br><span class="line">        genesisBlock.setNonce(2083236893);</span><br><span class="line">        // 本机的id，&quot;org.bitcoin.production&quot;</span><br><span class="line">        id = ID_MAINNET;</span><br><span class="line">        // 补贴减少的块数</span><br><span class="line">        subsidyDecreaseBlockCount = 210000;</span><br><span class="line">        // 钱可以花到哪个块高</span><br><span class="line">        spendableCoinbaseDepth = 100;</span><br><span class="line">        // 或许创世块的hash</span><br><span class="line">        String genesisHash = genesisBlock.getHashAsString();</span><br><span class="line">        // 检查hash是不是正确的</span><br><span class="line">        checkState(genesisHash.equals(&quot;000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f&quot;),</span><br><span class="line">                genesisHash);</span><br><span class="line"></span><br><span class="line">        // This contains (at a minimum) the blocks which are not BIP30 compliant. BIP30 changed how duplicate</span><br><span class="line">        // transactions are handled. Duplicated transactions could occur in the case where a coinbase had the same</span><br><span class="line">        // extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.</span><br><span class="line">        // Having these here simplifies block connection logic considerably.</span><br><span class="line">        // 这个包含一些BIP30不兼容的区块。 BIP30解决了重复的交易的处理问题。重复交易在coinbase有相同的extraNonce和相同的输出但是出现在不同区块高度，</span><br><span class="line">        // 并且重新组织处理非常复杂。有了这些可以大大简化块连接逻辑。 等到用的时候再来看看吧</span><br><span class="line">        checkpoints.put(91722, Sha256Hash.wrap(&quot;00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e&quot;));</span><br><span class="line">        checkpoints.put(91812, Sha256Hash.wrap(&quot;00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f&quot;));</span><br><span class="line">        checkpoints.put(91842, Sha256Hash.wrap(&quot;00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec&quot;));</span><br><span class="line">        checkpoints.put(91880, Sha256Hash.wrap(&quot;00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721&quot;));</span><br><span class="line">        checkpoints.put(200000, Sha256Hash.wrap(&quot;000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf&quot;));</span><br><span class="line"></span><br><span class="line">        // 默认的dns种子节点。</span><br><span class="line">        dnsSeeds = new String[] &#123;</span><br><span class="line">                &quot;seed.bitcoin.sipa.be&quot;,         // Pieter Wuille</span><br><span class="line">                &quot;dnsseed.bluematt.me&quot;,          // Matt Corallo</span><br><span class="line">                &quot;dnsseed.bitcoin.dashjr.org&quot;,   // Luke Dashjr</span><br><span class="line">                &quot;seed.bitcoinstats.com&quot;,        // Chris Decker</span><br><span class="line">                &quot;seed.bitnodes.io&quot;,             // Addy Yeow</span><br><span class="line">                &quot;bitseed.xf2.org&quot;,              // Jeff Garzik</span><br><span class="line">                &quot;seed.bitcoin.jonasschnelli.ch&quot;,// Jonas Schnelli</span><br><span class="line">                &quot;bitcoin.bloqseeds.net&quot;,        // Bloq</span><br><span class="line">                &quot;seed.ob1.io&quot;,                  // OpenBazaar</span><br><span class="line">        &#125;;</span><br><span class="line">        // http种子节点。（java居然还有这种神奇的语法）</span><br><span class="line">        httpSeeds = new HttpDiscovery.Details[] &#123;</span><br><span class="line">                // Andreas Schildbach</span><br><span class="line">                new HttpDiscovery.Details(</span><br><span class="line">                        ECKey.fromPublicOnly(Utils.HEX.decode(&quot;0238746c59d46d5408bf8b1d0af5740fe1a6e1703fcb56b2953f0b965c740d256f&quot;)),</span><br><span class="line">                        URI.create(&quot;http://httpseed.bitcoin.schildbach.de/peers&quot;)</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 获得活跃节点的ip地址列表，这里应该是一些默认的ip</span><br><span class="line">        addrSeeds = new int[] &#123;</span><br><span class="line">                0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,</span><br><span class="line">                0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,</span><br><span class="line">                0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,</span><br><span class="line">                0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,</span><br><span class="line">                0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,</span><br><span class="line">                0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,</span><br><span class="line">                0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,</span><br><span class="line">                0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,</span><br><span class="line">                0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,</span><br><span class="line">                0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,</span><br><span class="line">                0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,</span><br><span class="line">                0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,</span><br><span class="line">                0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,</span><br><span class="line">                0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,</span><br><span class="line">                0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,</span><br><span class="line">                0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,</span><br><span class="line">                0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,</span><br><span class="line">                0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,</span><br><span class="line">                0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,</span><br><span class="line">                0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,</span><br><span class="line">                0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,</span><br><span class="line">                0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,</span><br><span class="line">                0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,</span><br><span class="line">                0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,</span><br><span class="line">                0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,</span><br><span class="line">                0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,</span><br><span class="line">                0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,</span><br><span class="line">                0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,</span><br><span class="line">                0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,</span><br><span class="line">                0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,</span><br><span class="line">                0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,</span><br><span class="line">                0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,</span><br><span class="line">                0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,</span><br><span class="line">                0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,</span><br><span class="line">                0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,</span><br><span class="line">                0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,</span><br><span class="line">                0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,</span><br><span class="line">                0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,</span><br><span class="line">                0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,</span><br><span class="line">                0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 单例模式</span><br><span class="line">    private static MainNetParams instance;</span><br><span class="line">    public static synchronized MainNetParams get() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new MainNetParams();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPaymentProtocolId() &#123;</span><br><span class="line">        return PAYMENT_PROTOCOL_ID_MAINNET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>RegTestParams是regtest网络的参数；TestNet2Params是版本2的测试链，这个链主要是为了单元测试使用。TestNet3Params就是版本3的测试网络网络，也是现在使用的测试网络。UnitTestParams是bitcoinj的单元测试网络。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
            <tag> bitcoinj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitcoinj中协议抽象学习</title>
      <link href="//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Bitcoinj%E4%B8%AD%E5%8D%8F%E8%AE%AE%E6%8A%BD%E8%B1%A1%E5%AD%A6%E4%B9%A0.html"/>
      <url>//blockchain/%E6%AF%94%E7%89%B9%E5%B8%81/Bitcoinj%E4%B8%AD%E5%8D%8F%E8%AE%AE%E6%8A%BD%E8%B1%A1%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>我们内部的比特币钱包系统是通过Bitcoinj实现的，但是我们发现这个系统里面有很多不符合我们应用开发的地方，所以呢，我决定进行源码阅读，但是读起来比较费劲，一段时间后很容易忘记，所以干脆写一些博客来记录一下。在读的过程中我发现了Message这个类，仔细一看这个类貌似和协议是有关系的，所以今天就来深入学习探索一下，由于很多地方我也不是很明白，所以难免理解上是有错误的。日后回来修改吧！先来看一下类图：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/blockchain/bitcoinj%E4%B8%ADMessage%E7%B1%BB%E5%9B%BE.png?raw=true"></p><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Message数据结构可以被序列化为bitcoin的序列化结构。特殊类型的message可以在blockchain中使用，也可以在wire中使用，都是从这个类派生。Message类不是线程安全的。我们也要注意的是Block类也是继承Message的，所以说可能在比特币中，Block也被看作成一个消息协议。但也许Block也只是复用里面的东西而已。</p><p><b style="color:red">在Message中，协议是存放在payload这个字节数组中，用offset标记有效数据的开始位置（前面可能是标记啥的，这个需要后面阅读代码的时候进行深一步解析，不过我猜测就是因为父消息包含子消息放在了同一个byte数组里面），cursor用于标记已经解析到的数据位置。length表示数据的长度。内部还有MessageSerializer的实例，这个是序列化的接口类，实现类这个需要看了。还有网络信息参数NetworkParameters。</b></p><p>内部有一个自检的函数，看似是非常有用的一个方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 自我检查（已解析字段反序列化，与原字段进行比较查看结果）</span><br><span class="line">* @param payload ：包含消息内容的Bitcoin协议格式化字节数组</span><br><span class="line">* @param offset    偏移</span><br><span class="line">*/</span><br><span class="line">private void selfCheck(byte[] payload, int offset) &#123;</span><br><span class="line">    // 如果不是VersionMessage的话</span><br><span class="line">    if (!(this instanceof VersionMessage)) &#123;</span><br><span class="line">        // 取得已经解析的部分</span><br><span class="line">        byte[] payloadBytes = new byte[cursor - offset];</span><br><span class="line">        System.arraycopy(payload, offset, payloadBytes, 0, cursor - offset);</span><br><span class="line">        // 调用序列化进行序列化</span><br><span class="line">        byte[] reserialized = bitcoinSerialize();</span><br><span class="line">        // 检查当前解析序列化结果的值是不是正常的。</span><br><span class="line">        if (!Arrays.equals(reserialized, payloadBytes))</span><br><span class="line">            throw new RuntimeException(&quot;Serialization is wrong: \n&quot; +</span><br><span class="line">                    Utils.HEX.encode(reserialized) + &quot; vs \n&quot; +</span><br><span class="line">                    Utils.HEX.encode(payloadBytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个类里面还有一些功能就是修改属性之后，可能需要修改payload这个字节数组。还有就是对内容进行序列化。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 调整长度</span><br><span class="line">protected void adjustLength(int newArraySize, int adjustment) &#123;</span><br><span class="line">    if (length == UNKNOWN_LENGTH)</span><br><span class="line">        return;</span><br><span class="line">    // Our own length is now unknown if we have an unknown length adjustment.</span><br><span class="line">    if (adjustment == UNKNOWN_LENGTH) &#123;</span><br><span class="line">        length = UNKNOWN_LENGTH;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调整长度</span><br><span class="line">    length += adjustment;</span><br><span class="line">    // Check if we will need more bytes to encode the length prefix.</span><br><span class="line">    // 检查我们是否需要风度哦的字节数来编码长度前缀</span><br><span class="line">    if (newArraySize == 1)</span><br><span class="line">        length++;  // The assumption here is we never call adjustLength with the same arraySize as before.</span><br><span class="line">    else if (newArraySize != 0)</span><br><span class="line">        // 不知道这里操作的意义。</span><br><span class="line">        length += VarInt.sizeOf(newArraySize) - VarInt.sizeOf(newArraySize - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一开始并没有看懂这个调整长度后面代码的意思，这里我们可以看一下VarInt类里面的实现，你就明白了。VarInt主要的作用是对long整型进行编码，我们看一下里面的一个方法就明白了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int sizeOf(long value) &#123;</span><br><span class="line">    // if negative, it&apos;s actually a very large unsigned long value</span><br><span class="line">    if (value &lt; 0) return 9; // 1 marker + 8 data bytes</span><br><span class="line">    if (value &lt; 253) return 1; // 1 data byte</span><br><span class="line">    if (value &lt;= 0xFFFFL) return 3; // 1 marker + 2 data bytes</span><br><span class="line">    if (value &lt;= 0xFFFFFFFFL) return 5; // 1 marker + 4 data bytes</span><br><span class="line">    return 9; // 1 marker + 8 data bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这就是编码的方式，取得一个long编码需要的字节大小，最大9个字节。再去看一下adjustLength的代码你就明白它在做什么了。</p><h2 id="EmptyMessage"><a href="#EmptyMessage" class="headerlink" title="EmptyMessage"></a>EmptyMessage</h2><p>这个是代表某种父消息，但是父消息只有头部信息，没有payload。比如说getaddr命令、verack命令等。</p><h2 id="AddressMessage"><a href="#AddressMessage" class="headerlink" title="AddressMessage"></a>AddressMessage</h2><p>这个代表P2P网络中的“addr”，它的内容就是<code>private List&lt;PeerAddress&gt; addresses;</code>,限制最大的量是1024.下面看一下解析的方法吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void parse() throws ProtocolException &#123;</span><br><span class="line">    // 先读容量大小</span><br><span class="line">    long numAddresses = readVarInt();</span><br><span class="line">    // Guard against ultra large messages that will crash us.</span><br><span class="line">    if (numAddresses &gt; MAX_ADDRESSES)</span><br><span class="line">        throw new ProtocolException(&quot;Address message too large.&quot;);</span><br><span class="line">    addresses = new ArrayList&lt;&gt;((int) numAddresses);</span><br><span class="line">    for (int i = 0; i &lt; numAddresses; i++) &#123;</span><br><span class="line">        // payload是地址传递。</span><br><span class="line">        PeerAddress addr = new PeerAddress(params, payload, cursor, protocolVersion, this, serializer);</span><br><span class="line">        addresses.add(addr);</span><br><span class="line">        cursor += addr.getMessageSize();</span><br><span class="line">    &#125;</span><br><span class="line">    length = new VarInt(addresses.size()).getSizeInBytes();</span><br><span class="line">    // The 4 byte difference is the uint32 timestamp that was introduced in version 31402</span><br><span class="line">    length += addresses.size() * (protocolVersion &gt; 31402 ? PeerAddress.MESSAGE_SIZE : PeerAddress.MESSAGE_SIZE - 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在知道PeerAddress的使用了，也知道这个类的作用了吧！反序列化的过程基本是类似的。</p><p>更多的不用细看了，我们的主要目的是了解bitcoinj是如何工作的，如果要改代码再去追寻细节的知识。</p><h2 id="AlertMessage"><a href="#AlertMessage" class="headerlink" title="AlertMessage"></a>AlertMessage</h2><p>我们知道比特币有一个紧急通知的功能，而且私钥只有几个人知道，这个AlertMessage就是用来接收这个广播消息的。我们看一下字段吧。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private byte[] content; // 内容</span><br><span class="line">private byte[] signature; // 签名</span><br><span class="line"></span><br><span class="line">// See the getters for documentation of what each field means.</span><br><span class="line">private long version = 1; // 匹配的版本</span><br><span class="line">private Date relayUntil; // 停止广播的时间</span><br><span class="line">private Date expiration; // 消息失效的时间（到期后消息不再显示）</span><br><span class="line">private long id; // 这个消息的唯一id</span><br><span class="line">private long cancel; // 任何小于给定的id（指cannel），都认为是被删除的</span><br><span class="line">private long minVer, maxVer; // 如果是指定的版本有问题，这个表示的就是这个意思</span><br><span class="line">private long priority; // 消息权重</span><br><span class="line">private String comment, statusBar, reserved; // comment不显示，给开发人员的说明。statusBar是GUI状态栏会显示的消息。reserved是保留字段。</span><br></pre></td></tr></table></figure><p></p><p>关于里面的意义就不解析了，因为一般我们不用太关心去处理警告，关于公钥可以在类<code>org.bitcoinj.params.TestNet3Params</code>看到。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alertSigningKey = Utils.HEX.decode(&quot;04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a&quot;);</span><br></pre></td></tr></table></figure><p></p><h2 id="GetAddrMessage"><a href="#GetAddrMessage" class="headerlink" title="GetAddrMessage"></a>GetAddrMessage</h2><p>这个就是刚才我们说EmptyMessage例子，是EmptyMessage的子类。</p><h2 id="GetBlocksMessage"><a href="#GetBlocksMessage" class="headerlink" title="GetBlocksMessage"></a>GetBlocksMessage</h2><p>getblocks命令的P2P协议消息。这个是请求部分遗失的区块头部信息。这个区块的信息随后会使用GetDataMessage进行下载。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 版本</span><br><span class="line">protected long version;</span><br><span class="line">// 头部信息</span><br><span class="line">protected List&lt;Sha256Hash&gt; locator;</span><br><span class="line">// 结束的区块hash</span><br><span class="line">protected Sha256Hash stopHash;</span><br></pre></td></tr></table></figure><p></p><p>我们从Sha256Hash类中可以知道，hash长度32字节（16进制标识的话是64个字符），里面的方法我就不做更多说明了。</p><h2 id="GetDataMessage"><a href="#GetDataMessage" class="headerlink" title="GetDataMessage"></a>GetDataMessage</h2><p>getdata命令的网络消息类型，代表区块的内容或者事务给出他们的hash。GetDataMessage没啥东西，但是父类ListMessage的属性如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private long arrayLen;</span><br><span class="line">// For some reason the compiler complains if this is inside InventoryItem</span><br><span class="line">protected List&lt;InventoryItem&gt; items;</span><br></pre></td></tr></table></figure><p></p><p>InventoryItem就是这个消息的内容实体，是基类的话，getData应该是可以返回复合消息的。我们来看一下这个类的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class InventoryItem &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 4 byte uint32 type field + 32 byte hash</span><br><span class="line">     */</span><br><span class="line">    static final int MESSAGE_LENGTH = 36;</span><br><span class="line">    </span><br><span class="line">    public enum Type &#123;</span><br><span class="line">        Error,</span><br><span class="line">        Transaction,</span><br><span class="line">        Block,</span><br><span class="line">        FilteredBlock</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final Type type;</span><br><span class="line">    public final Sha256Hash hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个数据总长64个字节，type占32字节，hash占32字节。</p><h2 id="GetHeadersMessage"><a href="#GetHeadersMessage" class="headerlink" title="GetHeadersMessage"></a>GetHeadersMessage</h2><p>基本没做什么，继承自GetBlocksMessage，是getheaders命令的使用，注意我们这里的分析都是返回结果，但是没有先关的请求参数协议，这个如果后面我们分析到了，再做说明，这里提一下，需要特别注意的地方。</p><h2 id="GetUTXOsMessage"><a href="#GetUTXOsMessage" class="headerlink" title="GetUTXOsMessage"></a>GetUTXOsMessage</h2><p>这个命令现在好像只有比特现金有实现，可以查看：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW54dC9iaXRjb2lueHTjgILlj6blpJbor6Lpl67lhbbku5boioLngrnnmoR1dHhv77yM5Y+v6IO95Lya6KKr5qy66aqX44CC5LiA6Iis6YO95piv6Ieq5bex5YGaaW5kZXjov5vooYzmn6Xmib7jgII=" title="https://github.com/bitcoinxt/bitcoinxt。另外询问其他节点的utxo，可能会被欺骗。一般都是自己做index进行查找。">https://github.com/bitcoinxt/bitcoinxt。另外询问其他节点的utxo，可能会被欺骗。一般都是自己做index进行查找。<i class="fa fa-external-link"></i></span><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final int MIN_PROTOCOL_VERSION = 70002;</span><br><span class="line">/** Bitmask of service flags required for a node to support this command (0x3) */</span><br><span class="line">public static final long SERVICE_FLAGS_REQUIRED = 3;</span><br><span class="line">private boolean includeMempool;</span><br><span class="line">private ImmutableList&lt;TransactionOutPoint&gt; outPoints;</span><br></pre></td></tr></table></figure><p></p><p>TransactionOutPoint也是一个ChildMessage，是交易的输出内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static final int MESSAGE_LENGTH = 36;</span><br><span class="line"></span><br><span class="line">/** Hash of the transaction to which we refer. */</span><br><span class="line">private Sha256Hash hash;</span><br><span class="line">/** Which output of that transaction we are talking about. */</span><br><span class="line">private long index;</span><br><span class="line"></span><br><span class="line">// This is not part of bitcoin serialization. It points to the connected transaction.</span><br><span class="line">Transaction fromTx;</span><br><span class="line"></span><br><span class="line">// The connected output.</span><br><span class="line">TransactionOutput connectedOutput;</span><br></pre></td></tr></table></figure><p></p><p>TransactionOutPoint就是为了聚合不同交易的输出作为新交易的输入。</p><h2 id="HeadersMessage"><a href="#HeadersMessage" class="headerlink" title="HeadersMessage"></a>HeadersMessage</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// The main client will never send us more than this number of headers.</span><br><span class="line">public static final int MAX_HEADERS = 2000;</span><br><span class="line"></span><br><span class="line">private List&lt;Block&gt; blockHeaders;</span><br></pre></td></tr></table></figure><p>Block就是区块的信息类。</p><h2 id="InventoryMessage"><a href="#InventoryMessage" class="headerlink" title="InventoryMessage"></a>InventoryMessage</h2><p>拥有更长区块链的对等节点比其他节点有更多的区块，可以识别出哪些区块们是其他节点需要“补充”的。它会识别出第一批可供分享的500个区块，通过使用inv（inventory）消息把这些区块的哈希值传播出去。缺少这些区块的节点便可以通过各自发送的getdata消息来请求得到全区块信息，用包含在inv消息中的哈希值来确认是否为正确的被请求的区块，从而读取这些缺失的区块。</p><p>这个类是inv的P2P消息的实例，继承自ListMessage。取得头部信息后，通过GetDataMessage获得具体的消息。</p><h2 id="MemoryPoolMessage"><a href="#MemoryPoolMessage" class="headerlink" title="MemoryPoolMessage"></a>MemoryPoolMessage</h2><p>这个mempool的信息，请求一个远程的节点来宣布所有的交易都在他们的内存池中，可能在连接上还设置了Bloom过滤器。在inv消息中返回交易hash列表。注意这和TxConfidenceTable对象不同，后者不会尝试去追踪阻塞的交易，只是为交易持有一段区域。mempool消息没有字段的。其实就是发送mempool，对方回复一个inv</p><h2 id="NotFoundMessage"><a href="#NotFoundMessage" class="headerlink" title="NotFoundMessage"></a>NotFoundMessage</h2><p>当有getdata的请求时，如果没有数据在mempool中的话，就会返回这个消息。</p><h2 id="PartialMerkleTree"><a href="#PartialMerkleTree" class="headerlink" title="PartialMerkleTree"></a>PartialMerkleTree</h2><p>这是默克尔树的结构，使用深度遍历。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// the total number of transactions in the block</span><br><span class="line">private int transactionCount;</span><br><span class="line"></span><br><span class="line">// node-is-parent-of-matched-txid bits</span><br><span class="line">private byte[] matchedChildBits;</span><br><span class="line"></span><br><span class="line">// txids and internal hashes</span><br><span class="line">private List&lt;Sha256Hash&gt; hashes;</span><br></pre></td></tr></table></figure><p></p><p>通过上面的数组我们知道这是一颗完全二叉树。</p><h2 id="ping-pong"><a href="#ping-pong" class="headerlink" title="ping/pong"></a>ping/pong</h2><p>应该是检测活跃的消息：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private long nonce;</span><br><span class="line">private boolean hasNonce;</span><br></pre></td></tr></table></figure><p></p><h2 id="RejectMessage"><a href="#RejectMessage" class="headerlink" title="RejectMessage"></a>RejectMessage</h2><p>如果我们发送的交易被拒绝，就会返回这个消息<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private String message, reason;</span><br><span class="line">public enum RejectCode &#123;</span><br><span class="line">    /** The message was not able to be parsed */</span><br><span class="line">    MALFORMED((byte) 0x01),</span><br><span class="line">    /** The message described an invalid object */</span><br><span class="line">    INVALID((byte) 0x10),</span><br><span class="line">    /** The message was obsolete or described an object which is obsolete (eg unsupported, old version, v1 block) */</span><br><span class="line">    OBSOLETE((byte) 0x11),</span><br><span class="line">    /**</span><br><span class="line">        * The message was relayed multiple times or described an object which is in conflict with another.</span><br><span class="line">        * This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.</span><br><span class="line">        */</span><br><span class="line">    DUPLICATE((byte) 0x12),</span><br><span class="line">    /**</span><br><span class="line">        * The message described an object was not standard and was thus not accepted.</span><br><span class="line">        * Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which</span><br><span class="line">        * it is willing to relay further. Other transactions are neither relayed nor mined, though they are considered</span><br><span class="line">        * valid if they appear in a block.</span><br><span class="line">        */</span><br><span class="line">    NONSTANDARD((byte) 0x40),</span><br><span class="line">    /**</span><br><span class="line">        * This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant</span><br><span class="line">        * defining them as dust (this is no longer used).</span><br><span class="line">        */</span><br><span class="line">    DUST((byte) 0x41),</span><br><span class="line">    /** The messages described an object which did not have sufficient fee to be relayed further. */</span><br><span class="line">    INSUFFICIENTFEE((byte) 0x42),</span><br><span class="line">    /** The message described a block which was invalid according to hard-coded checkpoint blocks. */</span><br><span class="line">    CHECKPOINT((byte) 0x43),</span><br><span class="line">    OTHER((byte) 0xff);</span><br><span class="line"></span><br><span class="line">    byte code;</span><br><span class="line">    RejectCode(byte code) &#123; this.code = code; &#125;</span><br><span class="line">    static RejectCode fromCode(byte code) &#123;</span><br><span class="line">        for (RejectCode rejectCode : RejectCode.values())</span><br><span class="line">            if (rejectCode.code == code)</span><br><span class="line">                return rejectCode;</span><br><span class="line">        return OTHER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private RejectCode code;</span><br><span class="line">private Sha256Hash messageHash;</span><br></pre></td></tr></table></figure><p></p><h2 id="SendHeadersMessage"><a href="#SendHeadersMessage" class="headerlink" title="SendHeadersMessage"></a>SendHeadersMessage</h2><p>一个新的协议，sendheaders，一个节点更喜欢通过headers消息，而不是inv消息收到一个新的block。</p><h2 id="UTXOsMessage"><a href="#UTXOsMessage" class="headerlink" title="UTXOsMessage"></a>UTXOsMessage</h2><p>代表未花费的列表”utxos”，是通过GetUTXOsMessage发送而返回的结果。比特核心团队都是不支持的，这个和GetUTXOsMessage是一致的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 高度</span><br><span class="line">private long height;</span><br><span class="line">// 区块头部</span><br><span class="line">private Sha256Hash chainHead;</span><br><span class="line">// 小端存储的bitset显示输出是否被发现（检查输出是否被使用过吧）</span><br><span class="line">private byte[] hits;   // little-endian bitset indicating whether an output was found or not.</span><br><span class="line">// 输出列表（查询匹配到的输出）</span><br><span class="line">private List&lt;TransactionOutput&gt; outputs;</span><br><span class="line">// 每个输出的块高</span><br><span class="line">private long[] heights;</span><br></pre></td></tr></table></figure><p></p><h2 id="VersionAck"><a href="#VersionAck" class="headerlink" title="VersionAck"></a>VersionAck</h2><p>verack命令，Client发送，会从server返回version消息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我从core包下暂时就发现这些Message，里面有各种消息的说明，基本上都是有的。但是也有没有，应该是有漏网之鱼的。其实在bitcoin的包下面也有协议的说明，这里就不深入分析，以后我会进行深入的分析。另外这些Message是如何使用的会在接下来看代码的时候有更多的了解。关于序列化和解序列化，这里就不做更多的说明了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比特币 </tag>
            
            <tag> bitcoinj </tag>
            
            <tag> message </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊智能合约部署调用</title>
      <link href="//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E8%B0%83%E7%94%A8.html"/>
      <url>//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%83%A8%E7%BD%B2%E8%B0%83%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>之前一直在学习以太坊的知识，后来停了两周，于是让下面两个人帮忙学习一下。之前我在学习的时候，成功地发布了智能合约，但是在调用的时候出现了问题，没有调用成功。下面来总结一下智能合约的知识，加上一些自我的理解，只是理解，因为这种新技术，还是需要研究完源码之后才能最终确定。之前看过精通比特币，叹为观止，也在研究bitcoinj的源码，但是有些吃力，有时间还是要继续。</p><h2 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h2><p>这个就不做更多的解释了，人类社会一切皆以信用为准。传统方式解决信用问题一般都是法律合同、进行公证、背书、押金等等手段，但是这些问题解决了吗？还是没有，社会的信用问题还是存在，老赖也是比比皆是。于是就有了用代码来代替合同，来重构信用的问题。因为代码是死的，没有情感，也没有人情，就是一个冰冷、严肃的法官。任何在这里只会得到公正的判决，没有同情分，没有金权交易。</p><p>也许是自欺欺人，这种东西被金融参与后，就不再那么单纯，从而成了一种金融噱头，开始在市场中疯狂割韭菜。这就是我们说的代币，以及基于代币衍生出的各种情怀。</p><p>OK，这就是智能合约。良好的愿景，只是还在天上飘！</p><h2 id="solidity"><a href="#solidity" class="headerlink" title="solidity"></a>solidity</h2><p>这是以太坊的智能合约语言，你要说它最像语言中的哪种，我觉得它跟Go走得近。这也难怪，搞了一个ABI格式，这个ABI格式就是合约的解析结果，主要是方法相关的数据。我用node.js编译了一个合约，我们来看一下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; constant: false,</span><br><span class="line">    inputs: [Object],</span><br><span class="line">    name: &apos;vote&apos;,</span><br><span class="line">    outputs: [],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;nonpayable&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: true,</span><br><span class="line">    inputs: [Object],</span><br><span class="line">    name: &apos;proposals&apos;,</span><br><span class="line">    outputs: [Object],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;view&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: true,</span><br><span class="line">    inputs: [],</span><br><span class="line">    name: &apos;chairperson&apos;,</span><br><span class="line">    outputs: [Object],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;view&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: false,</span><br><span class="line">    inputs: [Object],</span><br><span class="line">    name: &apos;delegate&apos;,</span><br><span class="line">    outputs: [],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;nonpayable&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: true,</span><br><span class="line">    inputs: [],</span><br><span class="line">    name: &apos;winningProposal&apos;,</span><br><span class="line">    outputs: [Object],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;view&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: false,</span><br><span class="line">    inputs: [Object],</span><br><span class="line">    name: &apos;giveRightToVote&apos;,</span><br><span class="line">    outputs: [],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;nonpayable&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: true,</span><br><span class="line">    inputs: [Object],</span><br><span class="line">    name: &apos;voters&apos;,</span><br><span class="line">    outputs: [Object],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;view&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; constant: true,</span><br><span class="line">    inputs: [],</span><br><span class="line">    name: &apos;winnerName&apos;,</span><br><span class="line">    outputs: [Object],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;view&apos;,</span><br><span class="line">    type: &apos;function&apos; &#125;,</span><br><span class="line">  &#123; inputs: [Object],</span><br><span class="line">    payable: false,</span><br><span class="line">    stateMutability: &apos;nonpayable&apos;,</span><br><span class="line">    type: &apos;constructor&apos; &#125; ] &#125;</span><br></pre></td></tr></table></figure><p></p><p>这个由于是node的输出，所以会出现Object的对象，以太坊系统在启动的时候会attach一个js console。所以我们node使用web3连上去，会有和节点类似的js console。至于怎么做的，我想大家都明白，我也没研究这么深，这里面的知识太多了，还是需要去研究源码才行，目前我只研究到启动中如何加载账户的地方。</p><p>那么如何理解这个ABI呢？网络中的协议，只要符合这个ABI规范，那么你可以使用说有的语言去调用智能合约，你调用的就是这个ABI里面定义的一个方法。这就是我对ABI最直观的认识。</p><h2 id="如何发布智能合约"><a href="#如何发布智能合约" class="headerlink" title="如何发布智能合约"></a>如何发布智能合约</h2><p>我是利用官方的web3进行调用的，当然官方提供了很多其他语言的实现，但是有些操作麻烦。但是web3的调用方式是最直接的，因为，你可以使用node，随心所欲地进行变量的输出，有交互式shell。有时直接node运行一个命令，有时进入node shell，import一个模块，做一些基础的工作，然后自己直接shell操作，可方便了。这样我可以自己进行web3命令的进一步封装。超赞。</p><p>我是使用solc这个npm库，进行编译的，所以需要首先<code>npm install -g solc</code>进行安装。然后写了一个file模块遍历指定目录下的所有<code>*.solc</code>结尾的文件，读取内容（不要担心文件太大，内存放不下，怎么可能？智能合约没多大，大了就是程序员有问题）。为了使用配置，所以又引入yml文件解析模块，进行配置参数的读取。build模块负责链接节点进行web3链接和合约的编译。deploy模块负责解锁地址，发布合约，提供发布回调记录合约地址、交易hash。</p><h3 id="合约编译"><a href="#合约编译" class="headerlink" title="合约编译"></a>合约编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// find solidity文件，并读取内容进行编译</span><br><span class="line">var input = &#123;&#125;;</span><br><span class="line">new fileUtils(conf.build.dir, (filePath, data) =&gt; &#123;</span><br><span class="line">    input[filePath] = data;</span><br><span class="line">&#125;).listAllSync();</span><br><span class="line"></span><br><span class="line">// compile all contracts</span><br><span class="line">let compiledContract = solc.compile(&#123; sources: input &#125;, 1);</span><br><span class="line">// 取得合约的ABI</span><br><span class="line">let abi = compiledContract.contracts[conf.build.contract].interface;</span><br><span class="line">// 合约的二进制代码</span><br><span class="line">let bytecode = compiledContract.contracts[conf.build.contract].bytecode;</span><br><span class="line">// hex start with 0x</span><br><span class="line">bytecode = bytecode.startsWith(&apos;0x&apos;) ? bytecode : &apos;0x&apos;.concat(bytecode);</span><br><span class="line">// 取得合约类型（其实就是compiledContract.contracts[conf.build.contract]）</span><br><span class="line">let MyContract = web3.eth.contract(JSON.parse(abi));</span><br></pre></td></tr></table></figure><p>这就是build的大致内容，这个合约其实就是ABI的抽象。下面看一下deploy的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">deploy() &#123;</span><br><span class="line">    this.unlockAccount();</span><br><span class="line"></span><br><span class="line">    this.demoContract = this.MyContract.new(67,&quot;gavin&quot;, &quot;wybert&quot;, &quot;jacket&quot;, &#123;</span><br><span class="line">        data: this.bytecode,</span><br><span class="line">        from: this.sendAddress,</span><br><span class="line">        gas: 4692000</span><br><span class="line">    &#125;, (err, myContract) =&gt; &#123;</span><br><span class="line">        if (!err) &#123;</span><br><span class="line">            console.log(&quot;合约发布成功！&quot;);</span><br><span class="line">            if (!myContract.address) &#123;</span><br><span class="line">                console.log(&quot;合约发布交易hash：&quot;, myContract.transactionHash);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&quot;合约发布成功后地址：&quot;, myContract.address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;合约发布失败：&quot;, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&quot;发布的智能合约：&quot;, this.demoContract);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlockAccount() &#123;</span><br><span class="line">    return web3.personal.unlockAccount(this.sendAddress, this.password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意这里是先解锁节点中第一个地址，然后使用第一个地址去调用发布合约。注意这个地址是我搭建一个以太坊私有集群，所以这段代码这样写是没有问题。但是一般为了安全，节点中没有账户的，所以这段代码或许不是那么实用。如果是这种情况，我们该如何处理呢？由于实践起来比较麻烦，这里我就不写代码，进行试验了。</p><p>在web3中有sendRawTransaction的方法，还有一个sign方法，一个是用于发送原始的交易信息，一个是用于对数据进行签名。有了这两个方法之后，我们就再也不用去理会节点了，节点就是一个广播器而已，不需要存放账户。需要的时候我们自己会进行签名。</p><h3 id="合约调用"><a href="#合约调用" class="headerlink" title="合约调用"></a>合约调用</h3><p>协议写好了，那么如何进行智能合约的调用呢？这里还是用到ABI。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过ABI找到Contract类</span><br><span class="line">let MyContract = web3.eth.contract(JSON.parse(abi));</span><br><span class="line">// 利用地址进行实例化</span><br><span class="line">let myContract = MyContract.at(&quot;0x26f3476d4e84d44d1c8c159cbe06fed55c3cfbe8&quot;);</span><br><span class="line">// 解锁账户</span><br><span class="line">web3.personal.unlockAccount(web3.eth.accounts[0], this.password);</span><br><span class="line">// 发起调用，方法为proposals， 参数为0</span><br><span class="line">myContract.proposals.sendTransaction(0 ,&#123;from: web3.eth.accounts[0]&#125;)</span><br></pre></td></tr></table></figure><p></p><p>注意所有的调用我都是在node console下进行的。上面只是简化的代码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; s.proposals.sendTransaction(900000, &#123;from: build.web3.eth.accounts[0]&#125;)</span><br><span class="line">&apos;0x68aaa4ee619f3940a31080fc17d5fa47bde4d5851dd4846f0d6d7bc0b79d3519&apos;</span><br></pre></td></tr></table></figure><p></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在学习这种分布式的系统的时候，其实你可以认为这就是分布式的系统。唯一的区别就是，这些系统是一样的，也许你会说怎么可能一样，我说一样的意思它们遵守着相同的协议，这些协议才是区块链的精髓，学习什么其他的东西其实是舍近求远，但是区块链协议的介绍，官网文档却没怎么见到，所以很奇怪。难道是怕被超越？这就不清楚了。</p><p><b style="color:red">不管是node客户端，ruby客户端还是python、java等，都是协议的提现。现在感觉他们只是调用节点的客户端，但其实里面包含了大量的以太坊官方协议，所以要想学好区块链，直接去看这些协议，然后加上p2p网络，区块处理，分叉处理等等，这就是一个小型的区块链节点了。但是有一点，缺少服务的协议，因为每个节点即是客户节点也是服务节点。</b></p><p><b style="color:red">而智能合约，语言层面的接口就是ABI，调用协议就是以太坊的底层协议而已。</b></p><p><b style="color:red">关于java客户端的实现，其实以太坊提供了，合约到java代码的转换，其实你可以认为，生成的java代码就是智能合约接口的代理实现类而已。</b>以下是命令的简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./solc/solc.exe contract/library/MintableToken.sol --bin --abi --optimize -o ./contract/library/</span><br><span class="line">./web3j/bin/web3j solidity generate ./contract/library/MintableToken.bin ./contract/library/MintableToken.abi -o ../java/ -p com.mo9.smartcontract.d_library</span><br></pre></td></tr></table></figure><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly9iaXRzaHVvLmNvbS90b3BpYy81OTRhOGMyMjhlODIyZmNiNDQ0MzE3ZWM=" title="https://bitshuo.com/topic/594a8c228e822fcb444317ec">【连载】以太坊源码分析（3）深入解析ABI<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络配置</title>
      <link href="//linux/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.html"/>
      <url>//linux/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>今天it给我配了一台工作站，然后他告诉我，我需要配置一下网络才能使用。我很奇怪网络不是很容易配的吗？而且使用dhcp就好了。突然我发现自己错了，也许他的意思是让我配成静态的地址。后来进去之后发现确实无法联网，经过一般查看，最后发现是em1的网卡（这台工作站的网卡名叫em1）的配置中<code>ONBOOT=no</code>, 改成yes，重启网卡服务之后，获取到了ip地址，并能成功上网。</p><p>之前自己也是最小化安装Centos，网卡一般都要自己配置一下才能上网，我知道配置的方式，但是呢，怎么配一般记不住。之前不管解决什么问题总是不记录，现在发现记忆力下降了，有点记不住东西，所以开博是必要的。今天就来总结一下网络的配置问题，同时也回想一下之前用Fuel5.6 搭建OpenStack的实战，当时为了搭建OpenStack，我花了很长时间重试了很多次，最后终于完成了。安装过程为了安装能继续，我不得不在路由表被改变的情况下去修改路由表，有时DNS也被改了，又不得不立马去修改DNS，每台机器（当然是虚拟机）的ping一直开着监控，一旦发现ping不通，立马解决问题，修改网络配置。好了，我们开始吧！</p><h2 id="查看机器的网卡"><a href="#查看机器的网卡" class="headerlink" title="查看机器的网卡"></a>查看机器的网卡</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>这里最简单的方法就是ifconfig命令。<b style="color:red">以前学习网络知识的时候已经知道网络中几乎所有的命令都是简化ip命令的功能，比如ifconfig、route等等。所以IP命令非常复杂，反正我是记不住的，遇到具体网络命令的需求，知道一些基础命令，确实需要ip命令支持才会查文档。</b>下面是工作站ifconfig命令的输出。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">em1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.6.68  netmask 255.255.255.0  broadcast 192.168.6.255</span><br><span class="line">        inet6 fe80::c170:563c:9ce1:51dd  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether f8:b1:56:dd:f3:2d  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 7254  bytes 862196 (841.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 411  bytes 80714 (78.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        device interrupt 20  memory 0xf7c00000-f7c20000  </span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 112  bytes 10688 (10.4 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 112  bytes 10688 (10.4 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 52:54:00:f1:8a:c9  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0-nic: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 52:54:00:f1:8a:c9  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p></p><p>其实我的工作站只有一块物理网卡，后面的两块应该是虚拟网卡。虚拟网卡是有类型的，具体可以参考VMware中对虚拟网卡的描述，以前我写过一篇博客记录，但是后来免费云回收了我的空间，我以前写得的文章全部被删除了。我也使用云盘，后来我用的那个盘不维护了，我丢失了大量的植物学资料，挺生气的。所以现在不敢使用免费的云了。关于虚拟网卡的类型如下：</p><ul><li>bridged(桥接模式): 就像和宿主机一样是当前网络中的以太机器，这个网卡类型的好处就是可以上网，外部网络可以主动访问这块网卡。重点是与宿主机在同一个网段。注意子网掩码的配置。</li><li>host-only(主机模式)：就相当于虚拟机网络是一个独立的网络，宿主机呢有两个网卡，一个接外网，一个连到了这个独立的网络中，但是宿主机没有nat功能。也就是说外网无法访问这个网络，这个机器也无法访问外网。</li><li>NAT(网络地址转换模式)：这个就像宿主机连了一台交换机，然后内网的机器组网。宿主机提供nat功能，这样虚机可以访问外网，但是外网无法访问内网。我曾经在宿主机配置过路由表，希望宿主机所在网络的机器能够通过宿主机访问虚拟机，最后没有成功。</li></ul><p>OK下面解释一下输出的字段意思吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）</span><br><span class="line">第二行：网卡的mac地址、IP地址、子网、掩码</span><br><span class="line">第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节</span><br><span class="line">第四、五行：接收、发送数据包情况统计</span><br><span class="line">第七行：接收、发送数据字节数统计信息。</span><br></pre></td></tr></table></figure><p></p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>也可以通过这个服务来看：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># service network status</span><br><span class="line">Configured devices:</span><br><span class="line">lo em1 virbr0</span><br><span class="line">Currently active devices:</span><br><span class="line">lo em1</span><br></pre></td></tr></table></figure><p></p><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether f8:b1:56:dd:f3:2d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.6.68/24 brd 192.168.6.255 scope global dynamic em1</span><br><span class="line">       valid_lft 7025sec preferred_lft 7025sec</span><br><span class="line">    inet6 fe80::c170:563c:9ce1:51dd/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: virbr0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noqueue state DOWN qlen 1000</span><br><span class="line">    link/ether 52:54:00:f1:8a:c9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen 1000</span><br><span class="line">    link/ether 52:54:00:f1:8a:c9 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><h3 id="查看网卡设备信息"><a href="#查看网卡设备信息" class="headerlink" title="查看网卡设备信息"></a>查看网卡设备信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lspci | grep -i net</span><br><span class="line">03:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168B PCI Express Gigabit Ethernet controller (rev 01)</span><br><span class="line">04:00.0 Network controller: Atheros Communications Inc. AR9285 Wireless Network Adapter (PCI-Express) (rev 01)</span><br></pre></td></tr></table></figure><h2 id="修改网卡接口名"><a href="#修改网卡接口名" class="headerlink" title="修改网卡接口名"></a>修改网卡接口名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/udev/rules.d/70-persistent-net.rules</span><br></pre></td></tr></table></figure><p>修改下列字段便成。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME=&quot;eth0&quot;和 NAME=&quot;wlan0&quot;</span><br></pre></td></tr></table></figure><p></p><p>随后重启Ubuntu。</p><h2 id="修改网卡的配置"><a href="#修改网卡的配置" class="headerlink" title="修改网卡的配置"></a>修改网卡的配置</h2><p>我们先来看一下我的网卡信息：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=em1</span><br><span class="line">UUID=6eda348b-2aeb-4736-b4e2-f939d14b6844</span><br><span class="line">DEVICE=em1</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure><p></p><p>简单看一下说明吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0</span><br><span class="line">BOOTPROTO=static #设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址</span><br><span class="line">BROADCAST=192.168.0.255 #对应的子网广播地址</span><br><span class="line">HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址</span><br><span class="line">IPADDR=12.168.1.2 #如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址</span><br><span class="line">IPV6INIT=no # 是否支持IPv6</span><br><span class="line">IPV6_AUTOCONF=no</span><br><span class="line">NETMASK=255.255.255.0 #网卡对应的网络掩码</span><br><span class="line">NETWORK=192.168.1.0 #网卡对应的网络地址</span><br><span class="line">ONBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备</span><br><span class="line">GATEWAY：192.168.0.1 # 网关地址</span><br><span class="line">HWADDR/MACADDR：MAC地址。只需设置其中一个，同时设置时不能相互冲突。</span><br><span class="line">PEERDNS：是否指定DNS。如果使用DHCP协议，默认为yes。yes：如果DNS设置，修改/etc/resolv.conf中的DNS; no：不修改/etc/resolv.conf中的DNS</span><br><span class="line">DNS&#123;1, 2&#125;：DNS地址。当PEERDNS为yes时会被写入/etc/resolv.conf中。</span><br><span class="line">NM_CONTROLLED：是否由Network Manager控制该网络接口。修改保存后立即生效，无需重启。被其坑过几次，建议一般设为no。</span><br></pre></td></tr></table></figure><p></p><h2 id="修改网关"><a href="#修改网关" class="headerlink" title="修改网关"></a>修改网关</h2><p><code>vi /etc/sysconfig/network</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=Aaron</span><br><span class="line">GATEWAY=192.168.1.1</span><br></pre></td></tr></table></figure><p></p><h2 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h2><p>修改对应网卡的DNS的配置文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/resolv.conf</span><br></pre></td></tr></table></figure><p></p><p>修改以下内容<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8 </span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure><p></p><h2 id="修改路由表"><a href="#修改路由表" class="headerlink" title="修改路由表"></a>修改路由表</h2><p>先看一下系统的路由表吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# route </span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 em1</span><br><span class="line">192.168.6.0     0.0.0.0         255.255.255.0   U     100    0        0 em1</span><br></pre></td></tr></table></figure><p></p><p>修改路由表的命令如下，可以是删除或者是添加：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add/del default gw 192.168.1.1</span><br></pre></td></tr></table></figure><p></p><p>default值得是0.0.0.0，就是不管是什么地址，全部向这个网关发送即可。当然指定ip的话会优先匹配。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9wZWlkYS9hcmNoaXZlLzIwMTMvMDIvMjcvMjkzNDUyNS5odG1s" title="http://www.cnblogs.com/peida/archive/2013/02/27/2934525.html">每天一个linux命令（52）：ifconfig命令<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hY2Nlc3MucmVkaGF0LmNvbS9kb2N1bWVudGF0aW9uL3poLUNOL1JlZF9IYXRfRW50ZXJwcmlzZV9WaXJ0dWFsaXphdGlvbi8zLjUvaHRtbC9UZWNobmljYWxfR3VpZGUvVmlydHVhbF9OZXR3b3JrX0ludGVyZmFjZV9Db250cm9sbGVyX1ZOSUMuaHRtbA==" title="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Virtualization/3.5/html/Technical_Guide/Virtual_Network_Interface_Controller_VNIC.html">3.7. 虚拟网络接口卡（虚拟网卡）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vbmV0d29yay1iYXNpYy9jb250ZW50LzEyLmh0bWw=" title="https://wizardforcel.gitbooks.io/network-basic/content/12.html">网络基本功（十三）：细说Linux网络配置（下）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9zaHVhaXhmL2FyY2hpdmUvMjAxMS8xMS8yOS8yMjY3ODYzLmh0bWw=" title="http://www.cnblogs.com/shuaixf/archive/2011/11/29/2267863.html">Linux修改网络配置<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2VudG9zLm9yZy9kb2NzLzQvaHRtbC9yaGVsLXJnLWVuLTQvczEtbmV0d29ya3NjcmlwdHMtaW50ZXJmYWNlcy5odG1s" title="https://www.centos.org/docs/4/html/rhel-rg-en-4/s1-networkscripts-interfaces.html">Red Hat Enterprise Linux 4: Reference Guide<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> ifconfig </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中BlockingQueue学习</title>
      <link href="//java/Java%E4%B8%ADBlockingQueue%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/Java%E4%B8%ADBlockingQueue%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>线程池中都会出现一个队列叫做阻塞队列，今天来学习一下阻塞队列的实现。</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>这个类继承了Queue接口加了一些方法。下面是常用的方法：</p><table><thead><tr><th>方法名</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>add</td><td>增加一个元索</td><td>如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>element</td><td>返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>offer</td><td>添加一个元素并返回true</td><td>如果队列已满，则返回false</td></tr><tr><td>poll</td><td>移除并返问队列头部的元素</td><td>如果队列为空，则返回null</td></tr><tr><td>peek</td><td>返回队列头部的元素</td><td>如果队列为空，则返回null</td></tr><tr><td>put</td><td>添加一个元素</td><td>如果队列满，则阻塞</td></tr><tr><td>take</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则阻塞</td></tr><tr><td>drainTo</td><td>向给定的集合中移队列中的元素，可以指定移多少</td><td>返回移进去多少变量</td></tr></tbody></table><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>经过前面的学习，都知道了大概的实现思路，大同小异，所以下面的分析都不细讲了，只是列出重点来将讲一下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements BlockingQueue&lt;E&gt;, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><p>看来这类的集合都是继承AbstractQueue，实现了BlockingQueue接口而已。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这里面的实现和ArrayDeque里面的实现，其实差不多，只是单向操作，里面的索引名称换成了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 每次take的索引</span><br><span class="line">int takeIndex;</span><br><span class="line"></span><br><span class="line">/** items index for next put, offer, or add */</span><br><span class="line">// 放入的索引</span><br><span class="line">int putIndex;</span><br></pre></td></tr></table></figure><p></p><p>至于加锁嘛，使用的加锁机制和LinkedBlockingDeque差不多，来看字段：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** Main lock guarding all access */</span><br><span class="line">final ReentrantLock lock;</span><br><span class="line">/** Condition for waiting takes */</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">/** Condition for waiting puts */</span><br><span class="line">private final Condition notFull;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">ArrayBlockingQueue 不支持扩容机制，初始化大小之后不能进行改变。</b></p><p><b style="color:red">插入元素的时候队列满了，需要等待。等待的时长可以进行设置(两种实现方式)：</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 不阻塞的添加方式</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 持续等待的阻塞添加方式</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            // 等待队列为空的时候插入</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 温和的持续等待阻塞方式</span><br><span class="line">public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 不知道这个方法的作用</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 会进行循环等待</span><br><span class="line">        while (count == items.length) &#123;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return false;</span><br><span class="line">            // Condition还有这个方法呢。</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        insert(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>取数据时的等待：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)</span><br><span class="line">            // 队列为空的时候等待</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return extract();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 循环间歇性等待</span><br><span class="line">        while (count == 0) &#123;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return null;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        return extract();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里面的操作并没有使用System.arraycopy或者Arrays.copyOf，都是数组下标的直接操作。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>这也是链表结构的实现。基本的和LinkedBlockingDeque差不多。<b style="color:red">在LinkedBlockingQueue中计数使用的是原子类。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这是不同的地方，计数使用了原子类</span><br><span class="line">private final AtomicInteger count = new AtomicInteger();</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">锁也分开执行，一个用于放，一个用于取</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting takes */</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">/** Lock held by put, offer, etc */</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting puts */</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">元素操作的方式是，尾部插入、头部出。这是一个链表实现的。</b></p><p><b style="color:#00f">理论上链表是没有容量限制的，但是这个队列是有容量限制，是通过计数实现。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    putLock.lock(); // Never contended, but necessary for visibility</span><br><span class="line">    try &#123;</span><br><span class="line">        int n = 0;</span><br><span class="line">        for (E e : c) &#123;</span><br><span class="line">            if (e == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            if (n == capacity)</span><br><span class="line">                throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">            enqueue(new Node&lt;E&gt;(e));</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们看一下put的实现吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果满了，就阻塞等待</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            // 为何加入元素以后还要通知，可能是因为一个一个通知吧！</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock(); // 解锁</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">注意这里的offer方法有所区别，offer(E e, long timeout, TimeUnit unit)队列满的时候，会阻塞等待；offer(E e)这个是直接返回，没有阻塞等待。poll方法也是，poll(long timeout, TimeUnit unit)是阻塞获取的，poll()是同步返回的。注意这里是Java8的实现；以后的博文没有特殊说明，代码指的是都是Java8的代码，之前分析都是Java7的代码。</b></p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>看了一下基本的实现和PriorityQueue的实现是一致的。我们看一下锁机制。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Lock used for all public operations</span><br><span class="line"> */</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Condition for blocking when empty</span><br><span class="line"> */</span><br><span class="line">private final Condition notEmpty;</span><br></pre></td></tr></table></figure><p></p><p>这个类的内部有一个PriorityQueue的属性，看了上面的说明主要是为了在进行序列化和解序列化的时候支持PriorityQueue老的版本。（注：这里是java8的代码）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private PriorityQueue&lt;E&gt; q;</span><br></pre></td></tr></table></figure><p></p><p>这里面我们看一下tryGrow的方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void tryGrow(Object[] array, int oldCap) &#123;</span><br><span class="line">    lock.unlock(); // must release and then re-acquire main lock</span><br><span class="line">    Object[] newArray = null;</span><br><span class="line">    // cas方式进行加锁</span><br><span class="line">    if (allocationSpinLock == 0 &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,</span><br><span class="line">                                    0, 1)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int newCap = oldCap + ((oldCap &lt; 64) ?</span><br><span class="line">                                    (oldCap + 2) : // grow faster if small</span><br><span class="line">                                    (oldCap &gt;&gt; 1));</span><br><span class="line">            if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123;    // possible overflow</span><br><span class="line">                int minCap = oldCap + 1;</span><br><span class="line">                if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    throw new OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            if (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = new Object[newCap];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            allocationSpinLock = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (newArray == null) // back off if another thread is allocating</span><br><span class="line">        // 没有获得cas锁，主动请求放弃线程执行</span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock();</span><br><span class="line">    if (newArray != null &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        System.arraycopy(array, 0, newArray, 0, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">这就是扩容的策略，注意这里进行锁粒度的优化，重新扩容的时候使用了cas锁，需要扩容替换的时候才使用lock锁，这样做的目的无非就是进一步提高并发度，确实很有意义。获取乐观锁的线程也就是一个，没有获得锁的知道别人正在扩容，所以也不会做啥事，这个真的很棒。这就是一个很好的锁粒度化的实例，使用了不同锁来实现，以前都是相同的锁进行粒度化，想想还是可能会串行。新建一个数组进行处理，也是一个很好的办法。注意这里的lock加了锁但是没有释放，会不会出现死锁？答案肯定是不会。你也许会问为啥？我们看一下下面的代码就知道了。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    int n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    while ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    try &#123;</span><br><span class="line">        Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">        if (cmp == null)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        else</span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + 1;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">这个实现和PriorityQueue的基本差不多，我们还是回答上面的问题吧，注意Lock锁是可重入锁，由于tryGrow都是在增加的方法里面调用，所以这个锁的释放过程还是会在finally语句中调用。但是单独调用这个方法的话，的确会死锁。可重入锁内部实现应该都加入与线程相关的属性。这样实现才是可靠的。关于锁的实现，我们后面会进行分析，现在还没看到那里的代码。</b></p><p>其他的实现也比较简单，没有LinkedBlockingQueue那么复杂，这里就不深入介绍了。</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p><b style="color:#00f">DelayQueue是一个支持延时获取元素的无界阻塞队列，队列使用PriorityQueue来实现，它里面比较出彩的地方就是使用了Leader/Follower 模式，来减少线程为是否过期轮询，这样提高了系统效率。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延时期满时才能从队列中提取元素。</b> PriorityQueue 是一种优先级的队列，队列中的元素会按照优先级进行排序。</p><h3 id="Delayed接口"><a href="#Delayed接口" class="headerlink" title="Delayed接口"></a>Delayed接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Delayed extends Comparable&lt;Delayed&gt; &#123;</span><br><span class="line">    long getDelay(TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delayed接口有一个getDelay()方法接口，该方法用来告知延迟到期有多长的时间，或者延迟在多长时间之前已经到期，是不是很简单。为了排序Delayed 接口还继承了Comparable 接口，因此必须实现compareTo()，使其可以进行元素的比较。</p><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">    implements BlockingQueue&lt;E&gt; &#123;</span><br></pre></td></tr></table></figure><p>没有特别说明的，就是所有的元素必须继承Delayed接口而已。</p><h3 id="属性一探"><a href="#属性一探" class="headerlink" title="属性一探"></a>属性一探</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line">private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line">private Thread leader = null;</span><br><span class="line">private final Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><p>这里我们可以看出，锁机制。这里面的基础实现是基于PriorityQueue，线程是标识有线程在取数据。</p><h3 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h3><p>这里就不提构造函数和add方法了，add就是调用offer。我们来看一下offer方法吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        q.offer(e);</span><br><span class="line">        if (q.peek() == e) &#123;</span><br><span class="line">            // 如果队头是刚插入的e（队列可能还有其他元素）</span><br><span class="line">            leader = null;</span><br><span class="line">            // 通知取元素。</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意下面的这个方法，是offer的重载方法，但是不像之前那样是阻塞的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e, long timeout, TimeUnit unit) &#123;</span><br><span class="line">    return offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为是无界队列，因此不会出现”队满”(超出最大值会抛异常)，指定一个等待时间将元素放入队列中并没有意义，队列没有达到最大值那么会入队成功，达到最大值，则失败，不会进行等待。</p><h3 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h3><p>我们再来看一下poll方法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        // 判断等待时间到没有到</span><br><span class="line">        if (first == null || first.getDelay(NANOSECONDS) &gt; 0)</span><br><span class="line">            return null;</span><br><span class="line">        else</span><br><span class="line">            return q.poll();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从这个方法中我们应该知道，这个Delayed接口的comparedTo方法实现，一定是按照还剩多长时间到了可用作为比较的条件，但是在这个类中，没有说明。所以我们在设计元素类的时候还是需要注意一下。下面我们看一下poll另一个重载方法，会阻塞等待的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    //超时等待时间</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //可中断的获取锁</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        //无限循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            //获取队头元素</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            //队头为空，也就是队列为空</span><br><span class="line">            if (first == null) &#123;</span><br><span class="line">                //达到超时指定时间，返回null </span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                else</span><br><span class="line">                    // 如果还没有超时，那么再available条件上进行等待nanos时间</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //获取元素延迟时间</span><br><span class="line">                long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                //延时到期</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return q.poll(); //返回出队元素</span><br><span class="line">                //延时未到期，超时到期，返回null</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                first = null; // don&apos;t retain ref while waiting</span><br><span class="line">                // 超时等待时间 &lt; 延迟时间 或者有其它线程再取数据</span><br><span class="line">                if (nanos &lt; delay || leader != null)</span><br><span class="line">                    //在available 条件上进行等待nanos 时间</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                else &#123;</span><br><span class="line">                    //超时等待时间 &gt; 延迟时间 并且没有其它线程在等待，那么当前元素成为leader，表示leader 线程最早 正在等待获取元素</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                    //等待  延迟时间 超时</span><br><span class="line">                        long timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        //还需要继续等待 nanos</span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                        // 下面会进入新的等待循环</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        //清除 leader</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //唤醒阻塞在available 的一个线程，表示可以取数据了</span><br><span class="line">        if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>来梳理梳理这里的逻辑：</p><ol><li>如果队列为空，如果超时时间未到，则进行等待，否则返回null</li><li>队列不空，取出队头元素，如果延迟时间到，则返回元素，否则 如果超时 时间到 返回null</li><li>超时时间未到，并且超时时间&lt; 延迟时间或者有线程正在获取元素，那么进行等待</li><li>超时时间&gt; 延迟时间，那么肯定可以取到元素，设置leader为当前线程，等待延迟时间到期。<h3 id="take函数"><a href="#take函数" class="headerlink" title="take函数"></a>take函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            if (first == null)</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return q.poll();</span><br><span class="line">                first = null; // don&apos;t retain ref while waiting</span><br><span class="line">                if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>DelayQueue 内部通过组合PriorityQueue 来实现存储和维护元素顺序的。</li><li>DelayQueue 存储元素必须实现Delayed 接口，通过实现Delayed 接口，可以获取到元素延迟时间，以及可以比较元素大小（Delayed 继承Comparable）</li><li>DelayQueue 通过一个可重入锁来控制元素的入队出队行为</li><li><b style="color:red">DelayQueue 中leader 标识 用于减少线程的竞争，表示当前有其它线程正在获取队头元素。</b></li><li>PriorityQueue 只是负责存储数据以及维护元素的顺序，对于延迟时间取数据则是在DelayQueue 中进行判断控制的。</li><li>DelayQueue 没有实现序列化接口</li></ol><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue是一个比较特别的队列，由于在线程池方面有所应用，为了更好的理解线程池的实现原理，笔者花了些时间学习了一下该队列源码(JDK1.8)，此队列源码中充斥着大量的CAS语句. <b style="color:red">SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。</b></p><p>下面写一个类来进行验证一下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.concurrent;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line">public class SynchronousQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Thread putThread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;put thread start&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;put thread end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread takeThread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;take thread start&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;take from putThread: &quot; + queue.take());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;take thread end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        putThread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        takeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一种输出结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">put thread start</span><br><span class="line">take thread start</span><br><span class="line">take from putThread: 1</span><br><span class="line">put thread end</span><br><span class="line">take thread end</span><br></pre></td></tr></table></figure><p></p><p>从结果可以看出，put线程执行queue.put(1) 后就被阻塞了，只有take线程进行了消费，put线程才可以返回。可以认为这是一种线程与线程间一对一传递消息的模型。</p><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS9qYXZhLXN5bmNocm9ub3VzcXVldWUv" title="http://ifeve.com/java-synchronousqueue/">Java并发包中的同步队列SynchronousQueue实现原理<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFueWFuMTk4ODA1MDkvYXJ0aWNsZS9kZXRhaWxzLzUyNTYyMDM5" title="http://blog.csdn.net/yanyan19880509/article/details/52562039">java并发之SynchronousQueue实现原理<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> BlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中Queue学习</title>
      <link href="//java/Java%E4%B8%ADQueue%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/Java%E4%B8%ADQueue%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在上一篇的博文中，我们分析了Deque的知识，其实感觉是反了，应该是先分析Queue，分析完之后再去分析Deque，不过这都没啥关系，单向的队列或许更容易学习。</p><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p>还是先从Queue接口开始吧，这个接口继承Collection，Queue接口定义了几个方法。</p><table><thead><tr><th>方法名</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>add</td><td>增加一个元索</td><td>如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>element</td><td>返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>offer</td><td>添加一个元素并返回true</td><td>如果队列已满，则返回false</td></tr><tr><td>poll</td><td>移除并返问队列头部的元素</td><td>如果队列为空，则返回null</td></tr><tr><td>peek</td><td>返回队列头部的元素</td><td>如果队列为空，则返回null</td></tr></tbody></table><h2 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue"></a>AbstractQueue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueue&lt;E&gt;</span><br><span class="line">    extends AbstractCollection&lt;E&gt;</span><br><span class="line">    implements Queue&lt;E&gt; &#123;</span><br></pre></td></tr></table></figure><p>继承了AbstractCollection，实现了Queue接口。主要是提供了Queue的基础实现。都是一些常规的方法，这里就不做更多的介绍了。</p><h2 id="一些基础实现"><a href="#一些基础实现" class="headerlink" title="一些基础实现"></a>一些基础实现</h2><p>我们知道Deque是继承于Queue的，所以只要实现Deque的类基本上都是Queue的实现。在上一篇的博文中我们提到了LinkedList、ArrayDeque和LinkedBlockingDeque都是Queue的实现了，这里就不多介绍了。</p><h2 id="优先队列-PriorityQueue"><a href="#优先队列-PriorityQueue" class="headerlink" title="优先队列 PriorityQueue"></a>优先队列 PriorityQueue</h2><p>实际上是一个堆（不指定Comparator时默认为最小堆）。<b style="color:red">队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。</b>队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。新建对象的时候可以指定一个初始容量，其容量会自动增加。</p><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><p>继承自AbstractQueue，实现了序列化接口。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line">private transient Object[] queue;</span><br><span class="line">private int size = 0;</span><br><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br><span class="line">private transient int modCount = 0;</span><br></pre></td></tr></table></figure><p>感觉这里面的都是老朋友了，默认初始化容量是11个。基础的数据结构是数组，优先级通过比较器来进行实现。最大无限制，应该是留下来进行扩展使用的。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>就是进行数组的初始化（必须大于1）和比较器的传入（可为空）。比较值得一看的构造器应该是下面的两个：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public PriorityQueue(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    if (c instanceof SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (c instanceof PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">        this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        this.comparator = null;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initFromPriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123;</span><br><span class="line">    if (c.getClass() == PriorityQueue.class) &#123;</span><br><span class="line">        this.queue = c.toArray();</span><br><span class="line">        this.size = c.size();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initElementsFromCollection(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    // If c.toArray incorrectly doesn&apos;t return Object[], copy it.</span><br><span class="line">    if (a.getClass() != Object[].class)</span><br><span class="line">        a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">    int len = a.length;</span><br><span class="line">    if (len == 1 || this.comparator != null)</span><br><span class="line">        for (int i = 0; i &lt; len; i++)</span><br><span class="line">            if (a[i] == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">    this.queue = a;</span><br><span class="line">    this.size = a.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void initFromCollection(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    // 在整个树中建立堆不变量（如上所述），在调用之前不假设元素的顺序。</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>主要是通过原来的集合中的比较器作为当前PriorityQueue的比较器而已，插入的方式就不说了，原来是数组，所以直接调用toArray方法进行赋值即可。如果原来不是有序的话，可能还要进行排序吧！可能比较器不一样，排序的规则也不一样，这个就是下面三个方法在处理的一些事情。这里注意的是，如果是Collection的话，需要进行排序。heapify()的目的是建立一个二叉树，其实就是堆结构。</p><h3 id="扩展策略"><a href="#扩展策略" class="headerlink" title="扩展策略"></a>扩展策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    int oldCapacity = queue.length;</span><br><span class="line">    // Double size if small; else grow by 50%</span><br><span class="line">    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">                                        (oldCapacity + 2) :</span><br><span class="line">                                        (oldCapacity &gt;&gt; 1));</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b style="color:red">原来容量大小小于64时双倍扩展还要加上一个2；大于64，50%扩展.</b></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>以offer方法为例吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    // 这是队列满了才进行扩容吗？&gt;=可能会发生同步问题，而导致大于问题的存在。</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        // 最起码保证当前容量能加1</span><br><span class="line">        grow(i + 1);</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)</span><br><span class="line">        // 如果没有元素的话，不用移位操作</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        // 如果队列有元素.就要通过当前位置</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">神奇，居然是队列满了，才进行相应的扩容操作。</b>接着分析<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    // 是否使用comparator比较器</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void siftUpUsingComparator(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        // 很像是在使用二分法</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">        // 取得parent处的元素</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        // 将e移出来，放到后面，原来是这样的。</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果k&lt;0,不是会有异常吗？，其实就是找到了合适的位置插入</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">一开始没有看明白这里面在干啥，现在明白了，原来是使用类似二分法，将比插入元素大的值，不停地向后移，直到找到合适的位置插入。siftUpComparable(k, x);的实现是相似的。可是如果插入的X是最大的，最后的key会不会小于0，如果key小于0，最后那句执行不就出现异常了么？注意经过推演，初始k一定大于0，而且k永远是整数，而k右移一位也不会改变属性还是大于0，所以最终k只能为0跳出循环，因为k-1会先减到0。所以k最小值为0，也就是如果出现上述情况，会按照理想的状态放入到索引0处。</b></p><p><b style="color:red">其实这个操作是在向二叉树里面插入元素而已。因为正常大家都是通过链表实现二叉树，这里是通过数组来实现二叉树，所以一时间没有看懂。这里也可以看出，这个是一个小根堆的结构。</b></p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>我们以poll为例吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[0];</span><br><span class="line">    // 取得最后一个元素</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    // 最后的元素清除</span><br><span class="line">    queue[s] = null;</span><br><span class="line">    // 如果是0的话，队列是空的啥都不做。</span><br><span class="line">    if (s != 0)</span><br><span class="line">        // 从最后一个元素开始，找到一个新的最小值。</span><br><span class="line">        siftDown(0, x);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">这里看起来是只要返回最前面的那个元素就好了，的确每次插入都能保证，最小的值在前面，也好理解。</b> 这样看来siftDown就是再将最小的值移到前面去。我们看一下这里面的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是堆的维护，关于堆的实现请看下面的引用。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>看了一下内部的迭代器实现，并没有按照堆内顺序进行返回，而是按照数组的顺序进行返回，所以返回的数组并不是有序的，这点要注意。</p><h3 id="关于堆"><a href="#关于堆" class="headerlink" title="关于堆"></a>关于堆</h3><p><b style="color:red">其实堆就是一个完全二叉树，分为小端堆和大端堆。与平衡二叉树相比：</b></p><ul><li>堆整体没有顺序，但是每条路径有顺序。</li><li>堆维护成本比较低，每次调整，都要取最右边的那个元素过来进行重新调整。但是调整要比平衡二叉树要快很多。</li><li>如果是用来排序的话，堆的成本还是挺高的。如果是动态排序，堆的维护成本却能大大降低。</li></ul><h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9lbmQvYXJjaGl2ZS8yMDEyLzEwLzI1LzI3Mzg0OTMuaHRtbA==" title="http://www.cnblogs.com/end/archive/2012/10/25/2738493.html">java中queue的使用<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemRwMDcyL2FydGljbGUvZGV0YWlscy8xNDE1MDg3Nw==" title="http://blog.csdn.net/zdp072/article/details/14150877">大话数据结构十四：二叉树的顺序存储结构（数组实现）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MC9hcnRpY2xlL2RldGFpbHMvNjg1NzgwMTE=" title="http://blog.csdn.net/u013309870/article/details/68578011">堆排序HeapSort（Java）<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Queue </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中双向队列Deque</title>
      <link href="//java/Java%E4%B8%AD%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.html"/>
      <url>//java/Java%E4%B8%AD%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>今天来简单研究一下双向队列的实现。以前用C语言实现的时候，我最喜欢使用链表的方式进行实现。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双向队列在java中的接口规范是Deque。我们先来看一下继承的结构。（这里漏画了Deque是继承Queue，Queue继承Collection）</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/java/deque%E7%B1%BB%E5%9B%BE.png?raw=true"></p><p>再来看一下Deque里面定义的一些方法：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/java/Deque%E6%96%B9%E6%B3%95.png?raw=true"></p><p>这里面需要分两个维度去看，一个是Queue里面的方法，二是queue加入的方法。这里我在<a href="/2018/03/03/java/java中list学习/">java中list学习</a> 这篇博客中已经有过详细的介绍了。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>这个估计没啥可讲的，因为之前我在<a href="/2018/03/03/java/java中list学习/">java中list学习</a> 这篇博客中已经有过详细的介绍了。</p><h2 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h2><h3 id="大概思路"><a href="#大概思路" class="headerlink" title="大概思路"></a>大概思路</h3><p>对于数组实现的Deque来说，数据结构上比较简单，只需要一个存储数据的数组以及头尾两个索引即可。由于数组是固定长度的，所以很容易就得到数组的头和尾，那么对于数组的操作只需要移动头和尾的索引即可。</p><p>特别说明的是ArrayDeque并不是一个固定大小的队列，每次队列满了以后就将队列容量扩大一倍（doubleCapacity()），因此加入一个元素总是能成功，而且也不会抛出一个异常。也就是说ArrayDeque是一个没有容量限制的队列。</p><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><p>先看一下继承结构<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;</span><br><span class="line">                           implements Deque&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><p></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public ArrayDeque() &#123;</span><br><span class="line">    // 默认初始化16个</span><br><span class="line">    elements = (E[]) new Object[16];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayDeque(int numElements) &#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayDeque(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void allocateElements(int numElements) &#123;</span><br><span class="line">    int initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    // Find the best power of two to hold elements.</span><br><span class="line">    // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full.</span><br><span class="line">    if (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        // 如果不是2的倍数，就进行修正</span><br><span class="line">        // 根据所给的数组长度，得到一个比该长度大的最小的2^p的真实长度，并建立真实长度的空数组</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        if (initialCapacity &lt; 0)   // Too many elements, must back off</span><br><span class="line">            initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements</span><br><span class="line">    &#125;</span><br><span class="line">    elements = (E[]) new Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码看，ArrayDeque默认初始化16个；你可以指定大小，但是会被修正成大过initialCapacity的最小2的n次方的值。</p><h3 id="添加的操作"><a href="#添加的操作" class="headerlink" title="添加的操作"></a>添加的操作</h3><p>我们看一下添加的函数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head = (head - 1) &amp; (elements.length - 1)] = e;</span><br><span class="line">    // 如果队列满了就进行扩容处理</span><br><span class="line">    if (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException()</span><br><span class="line">    // tail指向的地方是没有值得的</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    // 避免tail+1越界，&amp;操作之后就不用对长度进行取余，主要还是因为2的指数倍</span><br><span class="line">    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Double the capacity of this deque.  Call only when full, i.e.,</span><br><span class="line">* when head and tail have wrapped around to become equal.</span><br><span class="line">*</span><br><span class="line">* 当队列首尾指向同一个引用时，扩充队列的容量为原来的两倍，并对元素重新定位到新数组中</span><br><span class="line">*/</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head == tail;// tail=head代表数组满了，一开始tail与head一定不相交，一旦相交就要扩容。</span><br><span class="line">    int p = head;</span><br><span class="line">    int n = elements.length;</span><br><span class="line">    int r = n - p; // number of elements to the right of p</span><br><span class="line">    // 容量增一倍</span><br><span class="line">    int newCapacity = n &lt;&lt; 1;</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a = new Object[newCapacity];</span><br><span class="line">    // 拷贝数组head右边的元素，放到新数组的0开始，长度是r</span><br><span class="line">    // 这里注意，tail&lt;head的情况，不过这边都可以处理（主要还是因为满了的话tail一般都是小于head的）</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);</span><br><span class="line">    // 将左侧元素，复制到后面，这个时候head就是0了</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);</span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = 0;</span><br><span class="line">    // tail为n，是因为队列满了</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">我们可以看出，tail==head就是队列满了，(head+1)&amp;(length-1)==tail就是队列空掉的条件。一旦队列满了就会立即扩容，方式就是双倍扩容。</b></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他的方法就不用说了，即使不知道也大概明白思路。对于出队，当然要检查队列是不是空的，如果是空的就不用处理了（或者返回null），感觉还是要看一下源码确认一下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    int h = head;</span><br><span class="line">    E result = elements[h]; // Element is null if deque empty</span><br><span class="line">    // 如果取得值为空，就表示队列空了</span><br><span class="line">    if (result == null)</span><br><span class="line">        return null;</span><br><span class="line">    // 如果有值就移除</span><br><span class="line">    elements[h] = null;     // Must null out slot</span><br><span class="line">    // 重新设置head</span><br><span class="line">    head = (h + 1) &amp; (elements.length - 1);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">    // tail向后移，防止出现负数</span><br><span class="line">    int t = (tail - 1) &amp; (elements.length - 1);</span><br><span class="line">    E result = elements[t];</span><br><span class="line">    // 如果为null啥都不做</span><br><span class="line">    if (result == null)</span><br><span class="line">        return null;</span><br><span class="line">    // 不为null，移除。tail后移</span><br><span class="line">    elements[t] = null;</span><br><span class="line">    tail = t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的感觉这个类的实现，还是比较简单的，比较容易理解。</p><h2 id="双向并发阻塞队列-LinkedBlockingDeque"><a href="#双向并发阻塞队列-LinkedBlockingDeque" class="headerlink" title="双向并发阻塞队列 LinkedBlockingDeque"></a>双向并发阻塞队列 LinkedBlockingDeque</h2><p>LinkedBlockingDeque是双向链表实现的双向并发阻塞队列。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)；并且，该阻塞队列是支持线程安全。</p><p>此外，LinkedBlockingDeque还是可选容量的(防止过度膨胀)，即可以指定队列的容量。如果不指定，默认容量大小等于Integer.MAX_VALUE。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/java/LinkedBlockingDeque%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE.jpg?raw=true"></p><h3 id="继承结构-1"><a href="#继承结构-1" class="headerlink" title="继承结构"></a>继承结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedBlockingDeque&lt;E&gt;</span><br><span class="line">    extends AbstractQueue&lt;E&gt;</span><br><span class="line">    implements BlockingDeque&lt;E&gt;,  java.io.Serializable &#123;</span><br></pre></td></tr></table></figure><p>LinkedBlockingDeque继承于AbstractQueue，它本质上是一个支持FIFO和FILO的双向的队列。AbstractQueue只是基础的Queue的实现而已。</p><p>LinkedBlockingDeque实现了BlockingDeque接口，它支持多线程并发。当多线程竞争同一个资源时，某线程获取到该资源之后，其它线程需要阻塞等待。</p><h3 id="属性一探"><a href="#属性一探" class="headerlink" title="属性一探"></a>属性一探</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br><span class="line">private transient int count;</span><br><span class="line">private final int capacity;</span><br><span class="line">final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">// 等待takes操作的Condition</span><br><span class="line">private final Condition notEmpty = lock.newCondition();</span><br><span class="line">// 等待puts操作的Condition</span><br><span class="line">private final Condition notFull = lock.newCondition();</span><br></pre></td></tr></table></figure><p>lock是控制对LinkedBlockingDeque的互斥锁，当多个线程竞争同时访问LinkedBlockingDeque时，某线程获取到了互斥锁lock，其它线程则需要阻塞等待，直到该线程释放lock，其它线程才有机会获取lock从而获取cpu执行权。</p><p>notEmpty和notFull分别是“非空条件”和“未满条件”。通过它们能够更加细腻进行并发控制。</p><p><b style="color:#00f">若某线程(线程A)要取出数据时，队列正好为空，则该线程会执行notEmpty.await()进行等待；当其它某个线程(线程B)向队列中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。此时，线程A会被唤醒从而得以继续运行。 此外，线程A在执行取操作前，会获取takeLock，在取操作执行完毕再释放takeLock。</b><br><b style="color:#00f">若某线程(线程H)要插入数据时，队列已满，则该线程会它执行notFull.await()进行等待；当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。此时，线程H就会被唤醒从而得以继续运行。 此外，线程H在执行插入操作前，会获取putLock，在插入操作执行完毕才释放putLock。</b></p><p>这里看一下Node链表的结构吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Deque里面的Node的class定义，这是一个链表结构</span><br><span class="line">static final class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123;</span><br><span class="line">        item = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>其他构造函数就不看了，主要来看一下这个构造函数，加入元素的时候使用了锁。<b style="color:red">注意这个初始化元素使用的是尾部插入法</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public LinkedBlockingDeque(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this(Integer.MAX_VALUE);</span><br><span class="line">    // 取得lock</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 从未竞争过，但是对于可视性来说是必要</span><br><span class="line">    lock.lock(); // Never contended, but necessary for visibility</span><br><span class="line">    try &#123;</span><br><span class="line">        for (E e : c) &#123;</span><br><span class="line">            if (e == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            // 逐条加入</span><br><span class="line">            if (!linkLast(new Node&lt;E&gt;(e)))</span><br><span class="line">                throw new IllegalStateException(&quot;Deque full&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">本来再想锁的粒度问题，我想如果linkLast这个函数也加了锁，不就有问题了吗，查了这个函数发现是私有方法，没有加锁，没毛病。加锁的实现和功能的实现是分离，这个也是常规的做法。</b></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>这里面设计几个方面：</p><ol><li>队列先加锁</li><li>执行插入</li><li>通知所有阻塞监听队列内容的线程</li><li>释放放锁</li></ol><p>这里我们只是举个例子，不进行源代码的深入分析, 下面的源码就是对上面过程的实现。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    return offerLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // 新建节点</span><br><span class="line">    Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 将“新节点”添加到双向链表的末尾</span><br><span class="line">        return linkLast(node);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean linkLast(Node&lt;E&gt; node) &#123;</span><br><span class="line">    // 如果“双向链表的节点数量” &gt; “容量”，则返回false，表示插入失败。</span><br><span class="line">    if (count &gt;= capacity)</span><br><span class="line">        return false;</span><br><span class="line">    // 将“node添加到链表末尾”，并设置node为新的尾节点</span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    node.prev = l;</span><br><span class="line">    last = node;</span><br><span class="line">    if (first == null)</span><br><span class="line">        first = node;</span><br><span class="line">    else</span><br><span class="line">        l.next = node;</span><br><span class="line">    // 将“节点数量”+1</span><br><span class="line">    ++count;</span><br><span class="line">    // 插入节点之后，唤醒notEmpty上的等待线程。</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="删除获取"><a href="#删除获取" class="headerlink" title="删除获取"></a>删除获取</h3><p>获取方式有3种：</p><ul><li>一种是取数据不删除数据</li><li>取数据移除数据并不阻塞，没有返回null即可</li><li>取数据移除数据并没有会阻塞等待</li></ul><p>刚才提到通知的问题，我们在线程池中也大概了解到阻塞队列，取消息的时候会阻塞，那么我们就来看看这个阻塞是如何实现的。下面是take的实现，属于第三种。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    return takeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E takeFirst() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 获取锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        E x;</span><br><span class="line">        // 若“队列为空”，则一直等待。否则，通过unlinkFirst()删除第一个节点。</span><br><span class="line">        while ( (x = unlinkFirst()) == null)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkFirst() &#123;</span><br><span class="line">    // assert lock.isHeldByCurrentThread();</span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        return null;</span><br><span class="line">    // 删除并更新“第一个节点”</span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = null;</span><br><span class="line">    f.next = f; // help GC</span><br><span class="line">    first = n;</span><br><span class="line">    if (n == null)</span><br><span class="line">        last = null;</span><br><span class="line">    else</span><br><span class="line">        n.prev = null;</span><br><span class="line">    // 将“节点数量”-1</span><br><span class="line">    --count;</span><br><span class="line">    // 删除节点之后，唤醒notFull上的等待线程。</span><br><span class="line">    notFull.signal();</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">在takeFirst方法中，我们发现notEmpty.await();阻塞等待，但是注意这里的lock.lock();你可能认为发生了死锁，其实并没有，这就是Lock，condition的组合使用，Condition是基于Lock生成的对象，notEmpty.await();是会释放lock锁的，被唤醒继续执行的时候会重新尝试获取lock锁，只是这个被封装了一下，变得不那么清除了而已。</b></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><b style="color:#00f">这部分的知识就不用说了，使用了内部的迭代器。内部类的迭代器遍历有一个好处就是没有Collection的传入，也可复用外部类的方法。总之呢，就是利用了内部类的机制，做自己想做的事情，这种设计思路，我们也可以使用，一定要活学活用。</b>这个迭代器比别的多了缓存的实现。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">private abstract class AbstractItr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    // next是下一次调用next()会返回的节点。</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    // nextItem是next()返回节点对应的数据。</span><br><span class="line">    E nextItem;</span><br><span class="line">    // 上一次next()返回的节点。</span><br><span class="line">    private Node&lt;E&gt; lastRet;</span><br><span class="line">    // 返回第一个节点</span><br><span class="line">    abstract Node&lt;E&gt; firstNode();</span><br><span class="line">    // 返回下一个节点</span><br><span class="line">    abstract Node&lt;E&gt; nextNode(Node&lt;E&gt; n);</span><br><span class="line"></span><br><span class="line">    AbstractItr() &#123;</span><br><span class="line">        final ReentrantLock lock = LinkedBlockingDeque.this.lock;</span><br><span class="line">        // 获取“LinkedBlockingDeque的互斥锁”</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取“双向队列”的表头</span><br><span class="line">            next = firstNode();</span><br><span class="line">            // 获取表头对应的数据</span><br><span class="line">            nextItem = (next == null) ? null : next.item;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放“LinkedBlockingDeque的互斥锁”</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取n的后继节点</span><br><span class="line">    private Node&lt;E&gt; succ(Node&lt;E&gt; n) &#123;</span><br><span class="line">        // Chains of deleted nodes ending in null or self-links</span><br><span class="line">        // are possible if multiple interior nodes are removed.</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node&lt;E&gt; s = nextNode(n);</span><br><span class="line">            if (s == null)</span><br><span class="line">                return null;</span><br><span class="line">            else if (s.item != null)</span><br><span class="line">                return s;</span><br><span class="line">            else if (s == n)</span><br><span class="line">                return firstNode();</span><br><span class="line">            else</span><br><span class="line">                n = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新next和nextItem。</span><br><span class="line">    void advance() &#123;</span><br><span class="line">        final ReentrantLock lock = LinkedBlockingDeque.this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // assert next != null;</span><br><span class="line">            next = succ(next);</span><br><span class="line">            nextItem = (next == null) ? null : next.item;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回“下一个节点是否为null”</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return next != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回下一个节点</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        if (next == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        lastRet = next;</span><br><span class="line">        E x = nextItem;</span><br><span class="line">        advance();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除下一个节点</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        Node&lt;E&gt; n = lastRet;</span><br><span class="line">        if (n == null)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        lastRet = null;</span><br><span class="line">        final ReentrantLock lock = LinkedBlockingDeque.this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (n.item != null)</span><br><span class="line">                unlink(n);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>关于双向队列的知识就是这么多了，其实底层还是那样，要么是数组实现，要么是链表实现。但是在实现的过程确实有比较巧妙的设计。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3l3YW5nMTIzNDUvcC8zNTAzNDgwLmh0bWw=" title="http://www.cnblogs.com/skywang12345/p/3503480.html">Java多线程系列–“JUC集合”09之 LinkedBlockingDeque<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deque </tag>
            
            <tag> 双端队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WeakHashMap的原理</title>
      <link href="//java/WeakHashMap%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
      <url>//java/WeakHashMap%E7%9A%84%E5%8E%9F%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WeakHashMap和HashMap一样，WeakHashMap也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以为null。不过WeakHashMap的键是“弱键”(注：源码中Entry中的定义是这样的：private static class Entry&lt;K,V&gt; extends WeakReference<object>implements Map.Entry&lt;K,V&gt;，即Entry实现了WeakReference类)，当WeakHashMap某个键不再正常使用时，会被从WeakHashMap自动删除。更精确的说，对于一个给定的键，其映射的存在并不能阻止垃圾回收器对该键的丢弃，这就使该键称为被终止的，被终止，然后被回收，这样，这就可以认为该键值对应该被WeakHashMap删除。因此，WeakHashMap使用了弱引用作为内部数据的存储方案，，WeakHashMap可以作为简单缓存表的解决方案，当系统内存不足时，垃圾收集器会自动的清除没有在任何其他地方被引用的键值对。如果需要用一张很大的Map作为缓存表时，那么可以考虑使用WeakHashMap。</object></p><p><b style="color:red">在WeakHashMap实现中，借用了ReferenceQueue这个“监听器”来保存被GC回收的”弱键”，然后在每次使用WeakHashMap时，就在WeakHashMap中删除ReferenceQueue中保存的键值对。即WeakHashMap的实现是通过借用ReferenceQueue这个“监听器”来优雅的实现自动删除那些引用不可达的key的。这个我在上一篇的博客中已经做了说明。</b><a href="/2018/03/07/java/Java引用Reference学习/">Java引用Reference学习</a></p><p>WeakHashMap是通过数组table保存Entry(键值对)；每个Entry实际上就是一个链表来实现的。当某“弱键”不再被其它对象引用，就会被GC回收时，这个“弱键”也同时被添加到ReferenceQueue队列中。当下一步我们需要操作WeakHashMap时，会先同步table、queue，table中保存了全部的键值对，而queue中保存的是GC回收的键值对；同步他们，就是删除table中被GC回收的键值对。</p><p>我们可以在WeakHashMap的源码中看到这样的一个属性：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 申明的WeakEntries的queue指针</span><br><span class="line">*/</span><br><span class="line">private final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</span><br></pre></td></tr></table></figure><p></p><p>我们来看一下内部Entry类的定义，你就会明白很多事情了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 原来将Entry定义为WeakReference，这样就会自动消失。</span><br><span class="line"> */</span><br><span class="line">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    V value;</span><br><span class="line">    int hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 创建一个新的Entry</span><br><span class="line">    */</span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">            ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">            int hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        // 传入ReferenceQueue和hash，这个可能是在已有头Entry的基础上使用</span><br><span class="line">        super(key, queue);</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.hash  = hash;</span><br><span class="line">        this.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="如何创建Entry"><a href="#如何创建Entry" class="headerlink" title="如何创建Entry"></a>如何创建Entry</h2><p>在进行put操作的时候，会进行Key的建立。大家注意这个弱引用不是指我们put的key是弱引用，而是指内部定义的Entry是弱引用，不要忘记这一点。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // null key的处理</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    int h = hash(k);</span><br><span class="line">    // 获取所有的桶</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    // 找到链表的头</span><br><span class="line">    int i = indexFor(h, tab.length);</span><br><span class="line"></span><br><span class="line">    // 遍历链表，查找元素，有替换</span><br><span class="line">    for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">        if (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    // 获取链表头</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    // 这里需要注意，这是头部插入法</span><br><span class="line">    tab[i] = new Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    if (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * 2);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="移除失效元素"><a href="#移除失效元素" class="headerlink" title="移除失效元素"></a>移除失效元素</h2><p>进一步研读代码我们可以发现，size方法，getTable等一些的操作中，都会调用一个叫expungeStaleEntries的方法，这个方法的内容如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从桶中移除失效的key-value（Entry）</span><br><span class="line"> */</span><br><span class="line">private void expungeStaleEntries() &#123;</span><br><span class="line">    // 从Queue中取被回收的数据，然后进行删除操作</span><br><span class="line">    for (Object x; (x = queue.poll()) != null; ) &#123;</span><br><span class="line">        synchronized (queue) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            int i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            // 进行删除的操作</span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            while (p != null) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                if (p == e) &#123;</span><br><span class="line">                    if (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    else</span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    // Must not null out e.next;</span><br><span class="line">                    // stale entries may be in use by a HashIterator</span><br><span class="line">                    e.value = null; // Help GC</span><br><span class="line">                    size--;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其实就是从Queue中取得，被垃圾回收机制回收的Entry，然后从Map中删除这个Entry，这是一种懒删除的方式，我们之前已经学习了Java的Reference机制，这里就不多研究了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得这种数据结构，可能面临丢失数据的风险，所以使用场景是哪些不怕丢失数据的地方。我想了一下，什么数据不怕丢，最容易想到的就是可以恢复的数据；然后我想到了内存缓存，的确缓存数据最不怕丢失，因为缓存数据往往都是可以想办法恢复的。所以当我们缓存的数据比较多的时候，使用这个数据结构的确可以帮助我们在系统内存紧张的时候，放弃缓存，然后重新缓存。但是Weak的特性是每次gc都极可能丢失，也会带来不少的问题。总之呢，这种开发的思想真的很好。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WeakHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java引用Reference学习</title>
      <link href="//java/Java%E5%BC%95%E7%94%A8Reference%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/Java%E5%BC%95%E7%94%A8Reference%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近在看一些数据结构的源码的时候发现了Reference这个类，突然就想起来关于Java引用的知识，并不了解里面真实的知识，今天就来深入源码来好好学习一番。所有的源码都在java.lang.ref包下面。注意体会里面的设计模式，多想想总有收获。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><b style="color:red">Java引用体系中我们最熟悉的就是强引用类型，如 A a= new A();这是我们经常说的强引用StrongReference，jvm gc时会检测对象是否存在强引用，如果存在由根对象对其有传递的强引用，则不会对其进行回收，即使内存不足抛出OutOfMemoryError。</b></p><p><b style="color:#00f">除了强引用外，Java还引入了SoftReference，WeakReference，PhantomReference，FinalReference.Java额外引入这个四种类型引用主要目的是在jvm 在gc时，按照引用类型的不同，在回收时采用不同的逻辑。可以把这些引用看作是对对象的一层包裹，jvm根据外层不同的包裹，对其包裹的对象采用不同的回收策略，或特殊逻辑处理。 这几种类型的引用主要在jvm内存缓存、资源释放、对象可达性事件处理等场景会用到。</b></p><h2 id="对象可达性判断"><a href="#对象可达性判断" class="headerlink" title="对象可达性判断"></a>对象可达性判断</h2><p>垃圾回收时会依据两个原则来判断对象的可达性：</p><ul><li>单一路径中，以最弱的引用为准</li><li>多路径中，以最强的引用为准</li></ul><h2 id="ReferenceQueue-amp-Reference"><a href="#ReferenceQueue-amp-Reference" class="headerlink" title="ReferenceQueue &amp; Reference"></a>ReferenceQueue &amp; Reference</h2><p>Reference作为SoftReference，WeakReference，PhantomReference，FinalReference这几个引用类型的父类。主要有两个字段referent、queue，一个是指所引用的对象，一个是与之对应的ReferenceQueue。Reference类有个构造函数 <code>Reference(T referent, ReferenceQueue&lt;? super T&gt; queue)</code>，可以通过该构造函数传入与Reference相伴的ReferenceQueue。</p><p>ReferenceQueue本身提供队列的功能，有入队(enqueue)和出队(poll,remove,其中remove阻塞等待提取队列元素)。<b style="color:red">ReferenceQueue对象本身保存了一个Reference类型的head节点，Reference封装了next字段，这样就是可以组成一个单向链表。这种元素包含Queue的方式，确实</b>同时ReferenceQueue提供了两个静态字段NULL，ENQUEUED. Null是内部定义的一个空类。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static ReferenceQueue&lt;Object&gt; NULL = new Null&lt;&gt;();</span><br><span class="line">static ReferenceQueue&lt;Object&gt; ENQUEUED = new Null&lt;&gt;();</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">这两个字段的主要功能：NULL是当我们构造Reference实例时queue传入null时，会默认使用NULL，这样在enqueue时判断queue是否为NULL,如果为NULL直接返回，入队失败。ENQUEUED的作用是防止重复入队，reference后会把其queue字段赋值为ENQUEUED,当再次入队时会直接返回失败。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; /* Called only by Reference class */</span><br><span class="line">    synchronized (r) &#123;</span><br><span class="line">        // 如果已经enqueue了，就不需要再做</span><br><span class="line">        if (r.queue == ENQUEUED) return false;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            // 设置ENQUEUE</span><br><span class="line">            r.queue = ENQUEUED;</span><br><span class="line">            // 没有设置head的话，r开始为链表的头元素，否则就是头结点的插入</span><br><span class="line">            r.next = (head == null) ? r : head;</span><br><span class="line">            head = r;</span><br><span class="line">            // queue长度+1；</span><br><span class="line">            queueLength++;</span><br><span class="line">            if (r instanceof FinalReference) &#123;</span><br><span class="line">                // 如果是FinalReference的话，VM里面的计数+1</span><br><span class="line">                sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">            &#125;</span><br><span class="line">            // 通知所有的lock.wait，这个是Reference里面的线程ReferenceHandler调用</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们来看看Reference的线程组，wait和notify调用的实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line">    // 加入某个线程组里面去，取个名字</span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        super(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line"></span><br><span class="line">            Reference r;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (pending != null) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    Reference rn = r.next;</span><br><span class="line">                    pending = (rn == r) ? null : rn;</span><br><span class="line">                    r.next = r;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 否则就进行阻塞等待，是在ReferenceQueue中调用的notify方法</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Fast path for cleaners</span><br><span class="line">            // 如果Reference实现了Cleaner接口，那么就调用clean方法来获取我们想要的值</span><br><span class="line">            // 做一些清理操作。这个类在dt.jar中实现的。</span><br><span class="line">            if (r instanceof Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReferenceQueue q = r.queue;</span><br><span class="line">            // 将ReferenceQueue加入到Queue中</span><br><span class="line">            if (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">Reference与ReferenceQueue之间是如何工作的呢？Reference里有个静态字段pending，同时还通过静态代码块启动了Reference-handler thread。当一个Reference的referent被回收时，垃圾回收器会把reference添加到pending这个链表里，然后Reference-handler thread不断的读取pending中的reference，把它加入到对应的ReferenceQueue中。我们可以通过下面代码块来进行把SoftReference，WeakReference，PhantomReference与ReferenceQueue联合使用来验证这个机制。为了确保SoftReference在每次gc后，其引用的referent都被回收，我们需要加入-XX:SoftRefLRUPolicyMSPerMB=0参数，这个原理下文中会在讲。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 为了确保System.gc()后,SoftReference引用的referent被回收需要加入下面的参数</span><br><span class="line"> * -XX:SoftRefLRUPolicyMSPerMB=0</span><br><span class="line"> */</span><br><span class="line">public class ReferenceTest &#123;</span><br><span class="line">    private static List&lt;Reference&gt; roots = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ReferenceQueue rq = new ReferenceQueue();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int i=0;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 这个是只读取pending里面的值</span><br><span class="line">                        Reference r = rq.remove();</span><br><span class="line">                        System.out.println(“reference:”+r);</span><br><span class="line">                        //为null说明referent被回收</span><br><span class="line">                        System.out.println( “get:”+r.get());</span><br><span class="line">                        i++;</span><br><span class="line">                        System.out.println( “queue remove num:”+i);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;100000;i++) &#123;</span><br><span class="line">            byte[] a = new byte[1024*1024];</span><br><span class="line">            // 分别验证SoftReference,WeakReference,PhantomReference</span><br><span class="line">            Reference r = new SoftReference(a, rq);</span><br><span class="line">            //Reference r = new WeakReference(a, rq);</span><br><span class="line">            //Reference r = new PhantomReference(a, rq);</span><br><span class="line">            roots.add(r);</span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            System.out.println(“produce”+i);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过jstack命令可以看到对应的Reference Handler thread<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“Reference Handler” #2 daemon prio=10 os_prio=31 tid=0x00007f8fb2836800 nid=0x2e03 in Object.wait() [0x000070000082b000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        – waiting on &lt;0x0000000740008878&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        – locked &lt;0x0000000740008878&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">当reference与referenQueue联合使用的主要作用就是当reference指向的referent回收时(或者要被回收 如下文要讲的Finalizer)，提供一种通知机制，通过queue取到这些reference，来做额外的处理工作。当然，如果我们不需要这种通知机制，我们就不用传入额外的queue,默认使用NULL queue就会入队失败。</b></p><h2 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h2><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 <b style="color:red">JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近使用情况和创建时间来综合决定是否回收该referent。这部分需要考虑Hotspot的源码</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=new String(&quot;abc&quot;);                                     // 强引用  </span><br><span class="line">SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);     // 软引用</span><br></pre></td></tr></table></figure><p></p><p>SoftReference的源代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SoftReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 时间戳时钟，垃圾回收机制更新</span><br><span class="line">     */</span><br><span class="line">    static private long clock;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用getter的时候会进行更新。当soft引用被声明时，VM使用这个字段，但是这个不是要求</span><br><span class="line">     */</span><br><span class="line">    private long timestamp;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent) &#123;</span><br><span class="line">        super(referent);</span><br><span class="line">        this.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SoftReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">        this.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用的时候计数</span><br><span class="line">     */</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        T o = super.get();</span><br><span class="line">        if (o != null &amp;&amp; this.timestamp != clock)</span><br><span class="line">            this.timestamp = clock;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">这里需要特别注意的是：如果错误地使用了软引用，可能会引起频繁的gc，这个是大家都不想见到的，所以使用的时候还是需要注意一下。</b></p><h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p><b style="color:red">弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。相比SoftReference来说，WeakReference对JVM GC几乎是没有影响的。</b></p><p><b style="color:red">弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</b></p><p>其实任何一个引用都可以与ReferenceQueue关联。</p><h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p><b style="color:red">“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</b></p><p><b style="color:red">虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</b></p><h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><p>就是我们平时的new，强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。</p><h2 id="FinalReference"><a href="#FinalReference" class="headerlink" title="FinalReference"></a>FinalReference</h2><p><b style="color:red">FinalReference 引用类型主要是为虚拟机提供的，提供 对象被gc前需要执行finalize方法的对象 的机制。</b></p><p>FinalReference 很简单就是extend Reference类，没有做其他逻辑，只是把访问权限改为package,因此我们是无法直接使用的。Finalizer类是我们要讲的重点，它继承了FinalReference，并且是final 类型的。Finalize实现很简单，也是利用上面我们讲的ReferenceQueue VS Reference机制。</p><h3 id="FinalizerThread"><a href="#FinalizerThread" class="headerlink" title="FinalizerThread"></a>FinalizerThread</h3><p><b style="color:red">Finalizer静态代码块里启动了一个deamon线程，我们通过jstack命令查看线程时，总会看到一个Finalizer线程，就是这个原因:</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 启动一个FinalizerThread线程</span><br><span class="line">    */</span><br><span class="line">static &#123;</span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    for (ThreadGroup tgn = tg;</span><br><span class="line">            tgn != null;</span><br><span class="line">            tg = tgn, tgn = tg.getParent());</span><br><span class="line">    Thread finalizer = new FinalizerThread(tg);</span><br><span class="line">    // 执行权限稍微低一些</span><br><span class="line">    finalizer.setPriority(Thread.MAX_PRIORITY - 2);</span><br><span class="line">    finalizer.setDaemon(true);</span><br><span class="line">    finalizer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>FinalizerThread run方法是不断的从queue中去取Finalizer类型的reference，然后执行runFinalizer释放方。我们来看一下这个方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void runFinalizer() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // 如果已经执行过Finalized方法，返回</span><br><span class="line">        if (hasBeenFinalized()) return;</span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object finalizee = this.get();</span><br><span class="line">        if (finalizee != null &amp;&amp; !(finalizee instanceof java.lang.Enum)) &#123;</span><br><span class="line">            // 调用finalizee方法</span><br><span class="line">            invokeFinalizeMethod(finalizee);</span><br><span class="line">            /* Clear stack slot containing this variable, to decrease</span><br><span class="line">                the chances of false retention with a conservative GC */</span><br><span class="line">            finalizee = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable x) &#123; &#125;</span><br><span class="line">    super.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">可以看出如果finalize方法中抛出异常会被直接吃掉</b></p><h3 id="如何使用Finalizer"><a href="#如何使用Finalizer" class="headerlink" title="如何使用Finalizer"></a>如何使用Finalizer</h3><p><b style="color:red">只要类覆写了Object 上的finalize方法，方法体非空。那么这个类的实例都会被Finalizer引用类型引用的。下文中我们简称Finalizer 型的referent为finalizee。</b></p><p>Finalizer的构造函数是private的，也就是不能通过new 来生成一个Fianlizer reference。只能通过静态的register方法来生成。同时Finalizer有个静态字段unfinalized，维护了一个未执行finalize方法的reference列表，在构造函数中通过add()方法把Finalizer引用本身加入到unfinalized列表中，同时关联finalizee和queue,实现通知机制。维护静态字段unfinalized的目的是为了一直保持对未未执行finalize方法的reference的强引用，防止被gc回收掉。</p><p>那么register是被VM何时调用的呢？JVM通过VM参数 RegisterFinalizersAtInit 的值来确定何时调用register，RegisterFinalizersAtInit默认为true,则会在构造函数返回之前调用。</p><h3 id="何时入queue"><a href="#何时入queue" class="headerlink" title="何时入queue"></a>何时入queue</h3><p>当一个finalizee 只剩Finalizer引用，没有其他引用时，需要被回收了，GC就会把该finalizee对应的reference放到Finalizer的refereneQueue中,等待FinalizerThread来执行finalizee的finalize方法，然后finalizee对象才能被GC回收。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5hbmRyb2lkc3Rhci5jbi9qYXZhJUU1JUFEJUE2JUU0JUI5JUEwJUU2JTk1JTk5JUU3JUE4JThCJUU0JUI5JThCcmVmZXJlbmNlJUU4JUFGJUE2JUU4JUE3JUEzLw==" title="http://www.androidstar.cn/java%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%E4%B9%8Breference%E8%AF%A6%E8%A7%A3/">java学习教程之Reference详解<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF6aGltYXpoL2FydGljbGUvZGV0YWlscy8xOTc1MjQ3NQ==" title="http://blog.csdn.net/mazhimazh/article/details/19752475">Java 7之基础 - 强引用、弱引用、软引用、虚引用<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDQxMjcxOS9hcnRpY2xlL2RldGFpbHMvNTIwMzU3OTI=" title="http://blog.csdn.net/u010412719/article/details/52035792">《Java源码分析》：ReferenceQueue、Reference及其子类<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解System类及系统启动</title>
      <link href="//java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3System%E7%B1%BB%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.html"/>
      <url>//java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3System%E7%B1%BB%E5%8F%8A%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>Java中有很多的类我们不得不一探究竟，首先我们就来看看这个System类，同时也能了解系统启动时初始化的一些信息，如果还想去底层探究的，就不得不查看Hotspot的源码了，好了，我们开始。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>System类是一个JDK工具类，其实也是整个系统的代表。这个类是final类型的，不能继承，不能被实例化。具体的信息可以查看源码。System类包含几个有用的类属性和方法。其中的操作多数和系统相关。其功能主要如下：</p><ul><li>标准输入输出，如out、in、err，以及设置</li><li>外部定义的属性和环境变量的访问，如getenv()/setenv()和getProperties()/setProperties()；</li><li>加载文件和类库的方法，如load()和loadLibrary()。</li><li>一个快速拷贝数组的方法：arraycopy()</li><li>一些jvm操作，如gc()、runFinalization()、exit()，该部分并未在源码的java doc中提到，可能因为本身不建议主动调用吧。而且这几个方法都仅仅是Runtime.getRuntime()的调用，两者没有区别。</li></ul><p>下面是这些功能的一个简图。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/java/system%E5%8A%9F%E8%83%BD%E5%9B%BE.png?raw=true"></p><h2 id="关于系统属性"><a href="#关于系统属性" class="headerlink" title="关于系统属性"></a>关于系统属性</h2><p>我们在System的类的注释上，可以看到有哪些系统属性，这里简单列一下：</p><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>java.version</td><td>Java Runtime Environment version</td></tr><tr><td>java.vendor</td><td>Java Runtime Environment vendor</td></tr><tr><td>java.vendor.url</td><td>Java vendor URL</td></tr><tr><td>java.home</td><td>Java installation directory</td></tr><tr><td>java.vm.specification.version</td><td>Java Virtual Machine specification version</td></tr><tr><td>java.vm.specification.vendor</td><td>Java Virtual Machine specification vendor</td></tr><tr><td>java.vm.specification.name</td><td>Java Virtual Machine specification name</td></tr><tr><td>java.vm.version</td><td>Java Virtual Machine implementation version</td></tr><tr><td>java.vm.vendor</td><td>Java Virtual Machine implementation vendor</td></tr><tr><td>java.vm.name</td><td>Java Virtual Machine implementation name</td></tr><tr><td>java.specification.version</td><td>Java Runtime Environment specification version</td></tr><tr><td>java.specification.vendor</td><td>Java Runtime Environment specification vendor</td></tr><tr><td>java.specification.name</td><td>Java Runtime Environment specification name</td></tr><tr><td>java.class.version</td><td>Java class format version number</td></tr><tr><td>java.class.path</td><td>Java class path</td></tr><tr><td>java.library.path</td><td>List of paths to search when loading libraries</td></tr><tr><td>java.io.tmpdir</td><td>Default temp file path</td></tr><tr><td>java.compiler</td><td>Name of JIT compiler to use</td></tr><tr><td>java.ext.dirs</td><td>Path of extension directory or directories</td></tr><tr><td>os.name</td><td>Operating system name</td></tr><tr><td>os.arch</td><td>Operating system architecture</td></tr><tr><td>os.version</td><td>Operating system version</td></tr><tr><td>file.separator</td><td>File separator (“/“ on UNIX)</td></tr><tr><td>path.separator</td><td>Path separator (“:” on UNIX)</td></tr><tr><td>line.separator</td><td>Line separator (“\n” on UNIX)</td></tr><tr><td>user.name</td><td>User’s account name</td></tr><tr><td>user.home</td><td>User’s home directory</td></tr><tr><td>user.dir</td><td>User’s current working directory</td></tr></tbody></table><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>我们看到类的开头有这样的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static native void registerNatives();</span><br><span class="line">static &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>类中的静态代码块调用了一个native方法registerNatives()，可以猜到该方法应该是一个入口方法，看一下注释：通过静态初始化注册native方法，该方法会令vm通过调用initializeSystemClass方法来完成初始化工作。果然如此，那么接下来我们看下initializeSystemClass方法吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static void initializeSystemClass() &#123;</span><br><span class="line">    // 初始化props</span><br><span class="line">    props = new Properties();</span><br><span class="line">    // 这是一个本地方法</span><br><span class="line">    initProperties(props);</span><br><span class="line">    // 保存并删除系统的一些配置，这里要查看VM的实现了</span><br><span class="line">    sun.misc.VM.saveAndRemoveProperties(props);</span><br><span class="line"></span><br><span class="line">    //获取系统相关的换行符</span><br><span class="line">    lineSeparator = props.getProperty(&quot;line.separator&quot;);</span><br><span class="line">    // 主要是系统参数的一些设置，版本号啥的</span><br><span class="line">    sun.misc.Version.init();</span><br><span class="line"></span><br><span class="line">    //分别创建in、out、err的实例对象，并通过setXX0()初始化，查看setXX0()方法可知，这是个native方法，将系统的标准流管理到类内的对象</span><br><span class="line">    FileInputStream fdIn = new FileInputStream(FileDescriptor.in);</span><br><span class="line">    FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);</span><br><span class="line">    FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);</span><br><span class="line">    setIn0(new BufferedInputStream(fdIn));</span><br><span class="line">    setOut0(new PrintStream(new BufferedOutputStream(fdOut, 128), true));</span><br><span class="line">    setErr0(new PrintStream(new BufferedOutputStream(fdErr, 128), true));</span><br><span class="line">    //加载zip包以获取java.util.zip.ZipFile这个类，以便之后加载利库使用</span><br><span class="line">    loadLibrary(&quot;zip&quot;);</span><br><span class="line"></span><br><span class="line">    // 设置平台相关的信号处理</span><br><span class="line">    Terminator.setup();</span><br><span class="line"></span><br><span class="line">    // 初始化sun.misc相关的环境变量</span><br><span class="line">    sun.misc.VM.initializeOSEnvironment();</span><br><span class="line"></span><br><span class="line">    // 主线程不会在同一个线程组中添加相同的线程，我们必须在这里自己实现。看代码就是主线程自己把自己加到了自己的线程组中......</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    current.getThreadGroup().add(current);</span><br><span class="line"></span><br><span class="line">    // 该方法就是实例化一个JavaLangAccess</span><br><span class="line">    setJavaLangAccess();</span><br><span class="line"></span><br><span class="line">    // 子系统在初始化的时候可以调用sun.misc.VM.isBooted()，以保证在application类加载器启动前不做任何事。booted()其实就是改了个状态,使isBooted()变为true。</span><br><span class="line">    sun.misc.VM.booted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h2><p>文件描述符类的实例用作底层机器特定结构的不透明句柄，表示打开的文件，打开的套接字或字节的另一个源或接收器。文件描述符的主要实际用途是创建一个FileInputStream或FileOutputStream来包含它。应用不应该自己的FileDescriptor类。</p><h2 id="Terminator"><a href="#Terminator" class="headerlink" title="Terminator"></a>Terminator</h2><p>这个类是设置平台相关的信号处理，我们来看一下这个类。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Terminator &#123;</span><br><span class="line">    // SignalHandler是终止触发事件的管理</span><br><span class="line">    private static SignalHandler handler = null;</span><br><span class="line"></span><br><span class="line">    /* Invocations of setup and teardown are already synchronized</span><br><span class="line">     * on the shutdown lock, so no further synchronization is needed here</span><br><span class="line">     */</span><br><span class="line">    static void setup() &#123;</span><br><span class="line">        if (handler != null) return;</span><br><span class="line">        // 默认的接口实现</span><br><span class="line">        SignalHandler sh = new SignalHandler() &#123;</span><br><span class="line">            // 所以这个接口不需要实现，直接使用即可了</span><br><span class="line">            public void handle(Signal sig) &#123;</span><br><span class="line">                // 终止号</span><br><span class="line">                Shutdown.exit(sig.getNumber() + 0200);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        handler = sh;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 加入信号处理</span><br><span class="line">            Signal.handle(new Signal(&quot;INT&quot;), sh);</span><br><span class="line">            Signal.handle(new Signal(&quot;TERM&quot;), sh);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            // When -Xrs is specified the user is responsible for</span><br><span class="line">            // ensuring that shutdown hooks are run by calling</span><br><span class="line">            // System.exit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void teardown() &#123;</span><br><span class="line">        /* The current sun.misc.Signal class does not support</span><br><span class="line">         * the cancellation of handlers</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的SignalHandler是一个接口，这里使用的是匿名类的实现。我们看一下SignalHandler。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package sun.misc;</span><br><span class="line"></span><br><span class="line">public abstract interface SignalHandler &#123;</span><br><span class="line">    public static final SignalHandler SIG_DFL = new NativeSignalHandler(0L);</span><br><span class="line"></span><br><span class="line">    public static final SignalHandler SIG_IGN = new NativeSignalHandler(1L);</span><br><span class="line"></span><br><span class="line">    public abstract void handle(Signal paramSignal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们看一下Signal类的处理。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">package sun.misc;</span><br><span class="line"></span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 信号类</span><br><span class="line"> */</span><br><span class="line">public final class Signal &#123;</span><br><span class="line">    // 信号对应处理器</span><br><span class="line">    private static Hashtable handlers = new Hashtable(4);</span><br><span class="line">    // 信号编号对信号的映射</span><br><span class="line">    private static Hashtable signals = new Hashtable(4);</span><br><span class="line">    // 编号</span><br><span class="line">    private int number;</span><br><span class="line">    // 名称</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public int getNumber() &#123;</span><br><span class="line">        return this.number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object paramObject) &#123;</span><br><span class="line">        if (this == paramObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((paramObject == null) || (!(paramObject instanceof Signal))) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Signal localSignal = (Signal) paramObject;</span><br><span class="line">        return (this.name.equals(localSignal.name)) &amp;&amp; (this.number == localSignal.number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return this.number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;SIG&quot; + this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过name创建signal</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    public Signal(String name) &#123;</span><br><span class="line">        this.number = findSignal(name);</span><br><span class="line">        this.name = name;</span><br><span class="line">        if (this.number &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unknown signal: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param paramSignal</span><br><span class="line">     * @param paramSignalHandler</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IllegalArgumentException</span><br><span class="line">     */</span><br><span class="line">    public static synchronized SignalHandler handle(Signal paramSignal, SignalHandler paramSignalHandler)</span><br><span class="line">            throws IllegalArgumentException &#123;</span><br><span class="line">        // 取得信号编号</span><br><span class="line">        long l1 = (paramSignalHandler instanceof NativeSignalHandler) ? ((NativeSignalHandler) paramSignalHandler).getHandler() : 2L;</span><br><span class="line"></span><br><span class="line">        long l2 = handle0(paramSignal.number, l1);</span><br><span class="line">        if (l2 == -1L) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Signal already used by VM or OS: &quot; + paramSignal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 信号编号到信号的映射</span><br><span class="line">        signals.put(new Integer(paramSignal.number), paramSignal);</span><br><span class="line">        synchronized (handlers) &#123;</span><br><span class="line">            SignalHandler localSignalHandler = (SignalHandler) handlers.get(paramSignal);</span><br><span class="line">            // 先移除信号，然后重新加入信号映射</span><br><span class="line">            handlers.remove(paramSignal);</span><br><span class="line">            if (l1 == 2L) &#123;</span><br><span class="line">                handlers.put(paramSignal, paramSignalHandler);</span><br><span class="line">            &#125;</span><br><span class="line">            if (l2 == 0L)</span><br><span class="line">                return SignalHandler.SIG_DFL;</span><br><span class="line">            if (l2 == 1L)</span><br><span class="line">                return SignalHandler.SIG_IGN;</span><br><span class="line">            if (l2 == 2L) &#123;</span><br><span class="line">                return localSignalHandler;</span><br><span class="line">            &#125;</span><br><span class="line">            return new NativeSignalHandler(l2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 抛出一个信号，进行处理</span><br><span class="line">     * @param paramSignal</span><br><span class="line">     * @throws IllegalArgumentException</span><br><span class="line">     */</span><br><span class="line">    public static void raise(Signal paramSignal)</span><br><span class="line">            throws IllegalArgumentException &#123;</span><br><span class="line">        if (handlers.get(paramSignal) == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unhandled signal: &quot; + paramSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        raise0(paramSignal.number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void dispatch(int paramInt) &#123;</span><br><span class="line">        // 通过信号编号，找到信号</span><br><span class="line">        final Signal localSignal = (Signal) signals.get(new Integer(paramInt));</span><br><span class="line">        // 找到信号的处理handler</span><br><span class="line">        SignalHandler localSignalHandler = (SignalHandler) handlers.get(localSignal);</span><br><span class="line"></span><br><span class="line">        // 处理信号</span><br><span class="line">        Runnable local1 = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                this.val$handler.handle(localSignal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 启动处理线程</span><br><span class="line">        if (localSignalHandler != null)</span><br><span class="line">            new Thread(local1, localSignal + &quot; handler&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 信号的查找是本地方法，没有解</span><br><span class="line">    private static native int findSignal(String paramString);</span><br><span class="line"></span><br><span class="line">    // 信号处理办法</span><br><span class="line">    private static native long handle0(int paramInt, long paramLong);</span><br><span class="line"></span><br><span class="line">    private static native void raise0(int paramInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个代码比较简单就不多讲了。</p><h2 id="VM-initializeOSEnvironment-方法"><a href="#VM-initializeOSEnvironment-方法" class="headerlink" title="VM.initializeOSEnvironment()方法"></a>VM.initializeOSEnvironment()方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void initializeOSEnvironment() &#123;</span><br><span class="line">    if (!booted)</span><br><span class="line">        OSEnvironment.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下OSEnvironment的实现。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package sun.misc;</span><br><span class="line"></span><br><span class="line">import sun.io.Win32ErrorMode;</span><br><span class="line"></span><br><span class="line">public class OSEnvironment &#123;</span><br><span class="line">    public static void initialize() &#123;</span><br><span class="line">        Win32ErrorMode.initialize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里面好像是win32的系统。具体还是看源码吧，本地方法实在没发看，或许要反编译jvm.dll文件。</p><h2 id="setJavaLangAccess"><a href="#setJavaLangAccess" class="headerlink" title="setJavaLangAccess"></a>setJavaLangAccess</h2><p>来看一下这个方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static void setJavaLangAccess() &#123;</span><br><span class="line">    // Allow privileged classes outside of java.lang</span><br><span class="line">    sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess()&#123;</span><br><span class="line">        public sun.reflect.ConstantPool getConstantPool(Class klass) &#123;</span><br><span class="line">            return klass.getConstantPool();</span><br><span class="line">        &#125;</span><br><span class="line">        public void setAnnotationType(Class klass, AnnotationType type) &#123;</span><br><span class="line">            klass.setAnnotationType(type);</span><br><span class="line">        &#125;</span><br><span class="line">        public AnnotationType getAnnotationType(Class klass) &#123;</span><br><span class="line">            return klass.getAnnotationType();</span><br><span class="line">        &#125;</span><br><span class="line">        public &lt;E extends Enum&lt;E&gt;&gt;</span><br><span class="line">                E[] getEnumConstantsShared(Class&lt;E&gt; klass) &#123;</span><br><span class="line">            return klass.getEnumConstantsShared();</span><br><span class="line">        &#125;</span><br><span class="line">        public void blockedOn(Thread t, Interruptible b) &#123;</span><br><span class="line">            t.blockedOn(b);</span><br><span class="line">        &#125;</span><br><span class="line">        public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) &#123;</span><br><span class="line">            Shutdown.add(slot, registerShutdownInProgress, hook);</span><br><span class="line">        &#125;</span><br><span class="line">        public int getStackTraceDepth(Throwable t) &#123;</span><br><span class="line">            return t.getStackTraceDepth();</span><br><span class="line">        &#125;</span><br><span class="line">        public StackTraceElement getStackTraceElement(Throwable t, int i) &#123;</span><br><span class="line">            return t.getStackTraceElement(i);</span><br><span class="line">        &#125;</span><br><span class="line">        public int getStringHash32(String string) &#123;</span><br><span class="line">            return string.hash32();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于这个类的使用，可以看一下我的另一篇博客：<a href="/2018/03/06/java/SharedSecrets深入理解/">SharedSecrets深入理解</a>, 可以看一下里面的JavaLangAccess的实例。</p><h2 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3l3YW5nMTIzNDUvcC9pb18wOS5odG1s" title="http://www.cnblogs.com/skywang12345/p/io_09.html">FileDescriptor总结<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SharedSecrets深入理解</title>
      <link href="//java/SharedSecrets%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"/>
      <url>//java/SharedSecrets%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看JDK的一些源码，发现一些类总是会使用到SharedSecrets这个类，发现这不是JDK API里面的类，原来在dt.jar包里面。但是看了源码之后总觉得不是很明白，此类其实没有太多的注释说明。<span class="exturl" data-url="aHR0cDovL2hnLm9wZW5qZGsuamF2YS5uZXQvamRrOC9qZGs4L2pkay9maWxlL3RpcC9zcmMvc2hhcmUvY2xhc3Nlcy9zdW4vbWlzYy9TaGFyZWRTZWNyZXRzLmphdmE=" title="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/sun/misc/SharedSecrets.java">http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/sun/misc/SharedSecrets.java<i class="fa fa-external-link"></i></span> 这个就是这个类的内容。一开始没有懂这里面的意思，那么现在我们来深入理解一下。</p><h2 id="从属性开始"><a href="#从属性开始" class="headerlink" title="从属性开始"></a>从属性开始</h2><p>我们来看一下这个类的属性：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SharedSecrets &#123;</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static JavaUtilJarAccess javaUtilJarAccess;</span><br><span class="line">    private static JavaLangAccess javaLangAccess;</span><br><span class="line">    private static JavaIOAccess javaIOAccess;</span><br><span class="line">    private static JavaNetAccess javaNetAccess;</span><br><span class="line">    private static JavaNetHttpCookieAccess javaNetHttpCookieAccess;</span><br><span class="line">    private static JavaNioAccess javaNioAccess;</span><br><span class="line">    private static JavaIOFileDescriptorAccess javaIOFileDescriptorAccess;</span><br><span class="line">    private static JavaSecurityProtectionDomainAccess javaSecurityProtectionDomainAccess;</span><br><span class="line">    private static JavaSecurityAccess javaSecurityAccess;</span><br><span class="line">    private static JavaUtilZipFileAccess javaUtilZipFileAccess;</span><br><span class="line">    private static JavaAWTAccess javaAWTAccess;</span><br></pre></td></tr></table></figure><p></p><p>然后再去看看具体方法，发现都是这个类的getter和setter方法，具体看起来是没有啥可理解的。那么具体是什么意思呢？</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>那么我们来解释一下，就看一下注释里面的说明。</p><p>“共享私有”库，这是在其他包中调用私有实现方法的一种机制，而不用使用反射。好了就解释这么多，下面是英文原文。</p><p>/*<em> A repository of “shared secrets”, which are a mechanism for<br>calling implementation-private methods in another package without<br>using reflection. A package-private class implements a public<br>interface and provides the ability to call package-private methods<br>within that package; the object implementing that interface is<br>provided through a third package to which access is restricted.<br>This framework avoids the primary disadvantage of using reflection<br>for this purpose, namely the loss of compile-time checking. </em>/</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>可能上面的说明还是比较空洞，不知道要表达什么意思，我们来看一些具体的示例就好了。</p><p>在JAAS的ProtectionDomain类中有两个地方使用了SharedSecrets，我们来看看具体是怎么使用的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    // Set up JavaSecurityAccess in SharedSecrets</span><br><span class="line">    // 在SharedSecrets设置好JavaSecurityAccess</span><br><span class="line">    // 设置java安全访问，这里是使用匿名实现类实现的。</span><br><span class="line">    // 一直在找JavaSecurityAccess的实现类，这里有一个，居然是匿名类难怪找不到。</span><br><span class="line">    SharedSecrets.setJavaSecurityAccess(</span><br><span class="line">        new JavaSecurityAccess() &#123;</span><br><span class="line">            // 执行交叉特权</span><br><span class="line">            public &lt;T&gt; T doIntersectionPrivilege(</span><br><span class="line">                PrivilegedAction&lt;T&gt; action,</span><br><span class="line">                final AccessControlContext stack,</span><br><span class="line">                final AccessControlContext context)</span><br><span class="line">            &#123;</span><br><span class="line">                if (action == null) &#123;</span><br><span class="line">                    throw new NullPointerException();</span><br><span class="line">                &#125;</span><br><span class="line">                return AccessController.doPrivileged(</span><br><span class="line">                    action,</span><br><span class="line">                    new AccessControlContext(</span><br><span class="line">                        stack.getContext(), context).optimize()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 执行交叉特权</span><br><span class="line">            public &lt;T&gt; T doIntersectionPrivilege(</span><br><span class="line">                PrivilegedAction&lt;T&gt; action,</span><br><span class="line">                AccessControlContext context)</span><br><span class="line">            &#123;</span><br><span class="line">                return doIntersectionPrivilege(action,</span><br><span class="line">                    AccessController.getContext(), context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    SharedSecrets.setJavaSecurityProtectionDomainAccess(</span><br><span class="line">            // 设置默认的JavaSecurityProtectionDomainAccess</span><br><span class="line">        new JavaSecurityProtectionDomainAccess() &#123;</span><br><span class="line">            public ProtectionDomainCache getProtectionDomainCache() &#123;</span><br><span class="line">                return new ProtectionDomainCache() &#123;</span><br><span class="line">                    private final Map&lt;Key, PermissionCollection&gt; map =</span><br><span class="line">                        Collections.synchronizedMap</span><br><span class="line">                            (new WeakHashMap&lt;Key, PermissionCollection&gt;());</span><br><span class="line">                    public void put(ProtectionDomain pd,</span><br><span class="line">                        PermissionCollection pc) &#123;</span><br><span class="line">                        map.put((pd == null ? null : pd.key), pc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    public PermissionCollection get(ProtectionDomain pd) &#123;</span><br><span class="line">                        return pd == null ? map.get(null) : map.get(pd.key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>是的这个类中有两个静态块，用于实例化一些基础的类库。我们来看一下JavaSecurityProtectionDomainAccess和JavaSecurityAccess这两个接口，发现找不到，但是在dt.jar中可以找到；接着我尝试去找实现类发现也找不到，但是终于在这里我找到了相应的实现类，可谓不容易，不过也让我彻底明白了，这个类的实际意义，我想大家也应该明白这里面的作用了吧！很棒的设计，但是代码隐藏太深，如果不是去看到这个示例，我可能永远都不理解这个类的用意。</p><p>我想这个类的具体作用还是要从属性出发，发现很多属性都和Java的security相关。</p><p>不管这么多了，这个类的设计方式值得我们学习，但是会使代码难于理解。</p><h2 id="JavaLangAccess示例"><a href="#JavaLangAccess示例" class="headerlink" title="JavaLangAccess示例"></a>JavaLangAccess示例</h2><p>我也在网上看到这样的实例，挺好玩的。使用JavaLangAccess和SharedSecrets来获取JVM中的实例。</p><h3 id="SharedSecrets和JavaLangAccess的作用"><a href="#SharedSecrets和JavaLangAccess的作用" class="headerlink" title="SharedSecrets和JavaLangAccess的作用"></a>SharedSecrets和JavaLangAccess的作用</h3><p>当我们需要对使用Log的类名进行的推断的时候，我们就需要知道JVM里面的实例对象了，这时候我们就需要使用到SharedSecrets和JavaLangAccess，通过这两个类来获取Java栈帧中存储的类信息，然后进行挑选，从而找出调用的类。</p><p>接下来看一下SharedSecrets和JavaLangAccess的使用方式：</p><p>测试环境：为了方便，在mybatis源码工程里面利用junit进行测试，创建新类testLang.java，也可以自己创建java工程进行测试。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.ibatis.logging;</span><br><span class="line"></span><br><span class="line">import sun.misc.JavaLangAccess;</span><br><span class="line">import sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line">public class testLang &#123;</span><br><span class="line">    public void testPrint() &#123;</span><br><span class="line">        JavaLangAccess access = SharedSecrets.getJavaLangAccess();</span><br><span class="line">        Throwable throwable = new Throwable();</span><br><span class="line"></span><br><span class="line">        int depth = access.getStackTraceDepth(throwable);</span><br><span class="line"></span><br><span class="line">        //输出JVM栈帧中的所有类实例</span><br><span class="line">        for (int i = 0; i &lt; depth; i++) &#123;</span><br><span class="line">            StackTraceElement frame = access.getStackTraceElement(throwable, i);</span><br><span class="line">            System.out.println(frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在LogFactoryTest.java文件中添加方法,这里使用了junit：</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">  public void yumsTest() &#123;</span><br><span class="line">    //System.err.println(&quot;Yumaosheng TEST&quot;);</span><br><span class="line">    testLang t = new testLang();</span><br><span class="line">      t.testPrint();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p>执行结果，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.logging.testLang.testPrint(testLang.java:12)</span><br><span class="line">org.apache.ibatis.logging.LogFactoryTest.yumsTest(LogFactoryTest.java:52)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)</span><br><span class="line">org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)</span><br><span class="line">org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)</span><br><span class="line">org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)</span><br><span class="line">org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)</span><br><span class="line">org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)</span><br><span class="line">org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)</span><br><span class="line">org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)</span><br><span class="line">org.junit.runners.ParentRunner.run(ParentRunner.java:309)</span><br><span class="line">org.junit.runner.JUnitCore.run(JUnitCore.java:160)</span><br><span class="line">com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)</span><br><span class="line">com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)</span><br><span class="line">com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)</span><br><span class="line">com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:497)</span><br><span class="line">com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p></p><p>我们会发现代码输出了所有JVM栈帧中的实例对象的类名。也就是说我们使用JavaLangAccess和SharedSecrets可以获取栈帧中的所有实例对象的类名称，接下来我们需要剔除掉不可能是调用类的名字。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们发现SharedSecrets这个类挺有趣的，但是注意这个类只是工具，具体的实现都是通过属性来完成，而属性的填充可能是JVM在加载类的时候填入的，所以只要了解接口的作用，我们只要取得里面的接口实例来做一些我们觉得好玩的事情。这就是这个类所不同的地方，凡是此类不能防止set方法只执行一次，所以要在setter方法中做限制，我们发现有些是做了限制的，有些没有。我觉得java8引入函数式编程之后，这个方式或许应该被替代了。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXVtczQ2Ny9hcnRpY2xlL2RldGFpbHMvNTMwMDUyOTI=" title="http://blog.csdn.net/yums467/article/details/53005292">使用JavaLangAccess和SharedSecrets来获取JVM中的实例<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SharedSecrets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecurityManager深入学习</title>
      <link href="//java/SecurityManager%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/SecurityManager%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SecurityManager在Java中被用来检查应用程序是否能访问一些有限的资源，例如文件、套接字(socket)等等。它可以用在那些具有高安全性要求的应用程序中。通过打开这个功能， 我们的系统资源可以只允许进行安全的操作。</p><p>当Java虚拟机启动时，它首先通过检查系统属性java.security.manager来确定SecurityManager是否打开了。如果打开了，那么SecurityManager实例将被创建，它可以被用来检查不同的权限。默认情况下，SecurityManager是关闭的，但是这里有一些方法可以打开SecurityManager。</p><ol><li>可以指定JVM命令<code>-Djava.security.manager</code> 使SecurityManager运行。</li><li>通过程序打开SecurityManager</li></ol><p>现在，如果我们真的想通过我们的程序打开SecurityManager，我们也能做到。 System类中有一个叫 setSecurityManager() 的方法可以做到这一点。这个方法的参数是一个SecurityManager实例。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager sm=new SecurityManager();</span><br><span class="line">System.setSecurityManager(sm);</span><br></pre></td></tr></table></figure><p></p><p>通过这个,我们可以打开SecurityManager.。如果之后我们想要关闭SecurityManager, 我们该怎么做? 下面的代码能做到吗？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager sm=System.getSecurityManager();</span><br><span class="line">if(sm!=null)&#123;</span><br><span class="line">    System.setSecurityManager(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码只有你在位于${JAVA_HOME}/lib/security目录下或者其他指定目录下的java.policy文件中指定了一个权限才会奏效。 这个权限是:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;</span><br></pre></td></tr></table></figure><p></p><p>上面的一行将被用来允许代码设置SecurityManager.</p><ol><li>在build文件中</li></ol><p>如果我们使用Ant构建应用程序时, 我们可以加上<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sysproperty key=&quot;java.security.manager&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="JAAS简介"><a href="#JAAS简介" class="headerlink" title="JAAS简介"></a>JAAS简介</h2><p>Java 认证和授权服务（Java Authentication and Authorization Service，JAAS）是JDK3开始引入的，JDK4以后作为核心功能部分。我将首先对 Java 2 平台安全体系结构作一概述，重点放在这个体系结构如何利用两个基本概念 – 安全策略和保护域 – 来定义、组织和聚集静态和/或动态访问权限。</p><h2 id="以代码为中心的授权"><a href="#以代码为中心的授权" class="headerlink" title="以代码为中心的授权"></a>以代码为中心的授权</h2><p>JDK 1.x 模型和 Java 2 平台 SDK 版本 1.2 的新安全结构之间的最大区别是引入了新的、可配置的安全策略，这样就可以实现细化的和可管理的访问控制。所有代码（不管是本地还是下载的，不管是签名或者没有签名的）都可以受到定义良好的安全策略的约束，它为不同的代码授予（可能是重叠的）权限。同时，随着在 JVM 中引入了多进程能力（请参阅 参考资料），出现了对基于用户的访问控制的要求。这也就出现沙箱的概念。</p><p><b style="color:red">Java 2 平台安全体系结构背后的基本原理可以总结如下：一个系统级的 安全策略定义了按 保护域组织的执行代码的 访问权限(按照应用程序的需要）。安全策略用于访问控制检查，这是由 JVM 在运行时执行的。</b></p><h2 id="Permission类型化对象"><a href="#Permission类型化对象" class="headerlink" title="Permission类型化对象"></a>Permission类型化对象</h2><p>所有访问权限都是类型化的并且有层次结构（主要是指继承的结构），其根是抽象类java.security.Permission。通常一个 Permission 包含一个目标（“由这个权限控制的操作将对谁执行？”）和一个操作（“如果这个权限允许的话，对这个目标将执行什么操作？”）。</p><p>在允许一段运行的代码对特定的“目标”执行特定的“操作”这一上下文中，一个重要的概念是代码不一定被授予与所需要完全一样的 Permission 。相反，只要可以从实际授予这段代码的 Permission 中推断出或者隐含了所需要的 Permission 就可以。例如，如果一段运行代码授予了读目录 /x 中所有文件的权限，那么它就不需要对目标文件 /x/in.xtx 执行 读操作的显式权限，因为前一个权限隐含了后者。</p><p>显然，某个 Permission 是否隐含另一个 Permission 的定义将取决于这两个 Permission 是如何定义的。至少，这两个 Permission 必须为同一类型。不过，不能指望运行时进行进一步的判断，并且必须将这种隐含推断逻辑指派给所涉及的 Permission 类。<b style="color:red">运行时通过调用一个恰当地取名为 implies 的方法来查询 Permission 类的隐含推断逻辑。这就是Permission中抽象出来的implies的作用。</b></p><h3 id="聚集的权限-PermissionCollection"><a href="#聚集的权限-PermissionCollection" class="headerlink" title="聚集的权限 PermissionCollection"></a>聚集的权限 PermissionCollection</h3><p><b style="color:red">PermissionCollection 可以聚集同一类型的 Permission 对象的多个实例。</b> 例如，一个 PermissionCollection 可能包含两个 java.io.FilePermission 实例，表示读取两个不同文件的特权。</p><p>不用在每次要检查权限时对每一个对象分别调用 implies() 方法，Java 运行时只是调用由 PermissionCollection 对象提供的 implies() 方法并等待其响应。可以为所创建的每一个自定义 Permission 对象定义一种新的 PermissionCollection 类型。当然， PermissionCollection 中 implies() 方法的具体实现取决于给定 Permission 对象的特性。也可能是通过内部类的方式进行实现的。</p><h3 id="Permissions对象"><a href="#Permissions对象" class="headerlink" title="Permissions对象"></a>Permissions对象</h3><p>Permissions是PermissionCollection的实现类，其内部有多个PermissionCollection。除了对特定的 Permission 类型有多个实例，任何给定的一段运行代码都将得到不同类型的 Permission 。Permissions会通过Permission来找到相应的PermissionCollection对象。以 Permissions 对象的形式提供了一组 PermissionCollection 对象。Permissions 类还提供了一个 implies() 方法。不过，要记住为了让一个 Permission 隐含另一个，它们必须是同一类型的。因此，调用 Permissions 对象的 implies() 方法会使后者首先在其内部集合中定位正确的 PermissionCollection 实例（那个包含一组正确类型的 Permission 对象的实例），然后调用由此获得的 PermissionCollection 对象的 implies() 方法，并向它传递要检查的 Permission 。</p><h2 id="安全策略和保护域ProtectionDomain"><a href="#安全策略和保护域ProtectionDomain" class="headerlink" title="安全策略和保护域ProtectionDomain"></a>安全策略和保护域ProtectionDomain</h2><p>适用于一个系统的安全策略实质上是一个良好定义的“仓库”，它存储了授予这个系统中不同实体的访问权限的断言。根据 保护域（protection domain）的经典定义（请参阅 参考资料），域是由系统中当前获得授权的一个实体可以直接访问的一组对象所界定的（按照这个定义，实际上可以将 JDK 版本 1.1 中的 Java 沙箱想像为一个具有固定边界的保护域）。在此基础上构建的 Java 2 平台安全策略设计为根据 ProtectionDomain 授权访问权限，而不是向单个的一段运行代码授权这种权限。因此，每一个类或者对象“属于”一个 ProtectionDomain ，安全策略对这个保护域授予了某种访问权限。重申 ProtectionDomain 的观点，一个特定的 ProtectionDomain 封装了一组类（例如，所有从特定位置上装载、并用特定密钥签名的所有类），它们的实例将会授予同样的一组权限。</p><p>这种间接性（即，权限不是直接授予类和对象）背后的理由是可扩展性 – 它应当可以改变和/或细化构成 ProtectionDomain 的定义，而不会影响权限的授予。（确实，JAAS 之前的 ProtectionDomain 只由“属于”它的代码描述，而 JAAS 后的 ProtectionDomain 还由运行代码的、经过认证的用户描述。由于每一位用户都分配到了设置了他或者她的权限的特定 ProtectionDomain ，进行用户认证可以使给定的一段代码根据当前认证用户而用不同的一组权限运行。我将在讨论 JAAS 授权体系结构时，对所有这些内容给予更详细的描述。）</p><h3 id="保护域-ProtectionDomain-和代码源-CodeSource"><a href="#保护域-ProtectionDomain-和代码源-CodeSource" class="headerlink" title="保护域(ProtectionDomain)和代码源(CodeSource)"></a>保护域(ProtectionDomain)和代码源(CodeSource)</h3><p>显然，一定要能惟一地标识一段运行代码以保证它的访问权限没有冲突。运行代码的惟一标识属性共有两项：代码的来源CodeSource（代码装载到内存所用的 URL）和代码的 signer 实体CodeSigner（由对应于运行代码的数字签名的一组公共密钥指定）。这两种特性的组合在 Java 2 平台安全体系结构中编写为给定运行代码的 CodeSource 。现在可以提供 ProtectionDomain 的更严格定义了： ProtectionDomain 是一组 CodeSource 及其访问权限。换一种说法， ProtectionDomain 表示授予特定 CodeSource 的所有权限。</p><p>Java 运行时通过名为 java.security.Policy 的类（的具体扩展）设置 ProtectionDomain 与授予它的权限之间的映射。这个类的默认扩展是 sun.security.provider.PolicyFile 。正如其名字所表明的， sun.security.provider.PolicyFile 从一个文件中获得 CodeSource （由位置 URL 和 signer 标识别名）与授予它的权限之间的映射。可以通过环境变量 java.security.policy 将这个文件的位置作为输入提供给 JVM。 Policy 类提供了一个名为 getPermissions() 的方法，可以调用它以获得授予特定 CodeSource 的一组权限。</p><p>ProtectionDomain封装了codeSource、Permissions，classLoader和principals，具体看构造方法（其他的方法暂时忽略）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ProtectionDomain(CodeSource codesource,</span><br><span class="line">                        PermissionCollection permissions,</span><br><span class="line">                        ClassLoader classloader,</span><br><span class="line">                        Principal[] principals) &#123;</span><br><span class="line">    this.codesource = codesource;</span><br><span class="line">    if (permissions != null) &#123;</span><br><span class="line">        this.permissions = permissions;</span><br><span class="line">        this.permissions.setReadOnly();</span><br><span class="line">        if (permissions instanceof Permissions &amp;&amp;</span><br><span class="line">            ((Permissions)permissions).allPermission != null) &#123;</span><br><span class="line">            hasAllPerm = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.classloader = classloader;</span><br><span class="line">    this.principals = (principals != null ? principals.clone():</span><br><span class="line">                        new Principal[0]);</span><br><span class="line">    staticPermissions = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>关于CodeSource和CodeSigner的代码以后再来研究吧！我可能需要深入学习java的类加载机制才能明白这里面的知识，否则很难学习的。SecureClassLoader就是生成CodeSource和ProtectionDomain关系的类加载器。也对这个东西本来就是需要类加载器来实现，否则很多的事情是做不了的。的确用类加载器来实现沙箱的功能，的确很赞。</p><h3 id="SecureClassLoader"><a href="#SecureClassLoader" class="headerlink" title="SecureClassLoader"></a>SecureClassLoader</h3><p>一个类与 其 ProtectionDomain 之间的映射是在类第一次装载时设置的，并在类被垃圾收集之前不会改变。一个类通常是由一个名为 SecureClassLoader 的特殊类装载的。 SecureClassLoader 首先从相应 URL 处装载字节，如果需要还会验证包围文档文件的数字签名。然后它调用上述 getPermissions() 方法获得授予类的 CodeSource 的一个填充了静态绑定权限的异类 PermissionCollection 。然后 SecureClassLoader 创建新的 ProtectionDomain ，传递 CodeSource 及其相关的权限作为其构造函数的参数（当然，这假定对于给定 CodeSource 还不存在 ProtectionDomain 。如果用一个现有的 CodeSource 装载类，那么就会重复使用它已经建立的 ProtectionDomain ） 。 最后，用装载的类字节向 JVM 定义一个类，并在关联的 ProtectionDomain 中维护一个引用指针。</p><p>默认情况下，会创建一个 ProtectionDomain ，并作为“特殊”情况处理，即属于这个域的代码被认为是受信任的并可以获得特殊的权限。这称为 系统域并包括由 系统（应用程序）装载器、扩展装载器和 bootstrap 装载器装载的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected PermissionCollection getPermissions(CodeSource codesource)</span><br><span class="line">&#123;</span><br><span class="line">    check();</span><br><span class="line">    return new Permissions(); // ProtectionDomain defers the binding</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ProtectionDomain getProtectionDomain(CodeSource cs) &#123;</span><br><span class="line">    if (cs == null)</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    // 创建一个新的ProtectionDomain</span><br><span class="line">    ProtectionDomain pd = null;</span><br><span class="line">    synchronized (pdcache) &#123;</span><br><span class="line">        pd = pdcache.get(cs);</span><br><span class="line">        if (pd == null) &#123;</span><br><span class="line">            // 创建新的Permissions数组</span><br><span class="line">            PermissionCollection perms = getPermissions(cs);</span><br><span class="line">            // 进行环境装配打包</span><br><span class="line">            pd = new ProtectionDomain(cs, perms, this, null);</span><br><span class="line">            // 缓存数据</span><br><span class="line">            pdcache.put(cs, pd);</span><br><span class="line">            if (debug != null) &#123;</span><br><span class="line">                debug.println(&quot; getPermissions &quot;+ pd);</span><br><span class="line">                debug.println(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在查看ClassLoader的代码的时候也发现了，ClassLoader和ProtectionDomain，CodeSource有关系，等我认真查看ClassLoader源码的时候再来查看，现在就不用去考虑这么多了。</p><h3 id="动态权限"><a href="#动态权限" class="headerlink" title="动态权限"></a>动态权限</h3><p>直到 Java 平台 1.3，都只能用（上面描述的）以 CodeSource 和相关权限为参数的构造函数创建 ProtectionDomain 。这意味着授予特定 ProtectionDomain 的权限必须在构建时就已经知道，并且没有动态刷新所授予的一组权限的灵活性。然而在 Java 2 平台 SDK 1.4 中， ProtectionDomain 可以同时封装（通过其构造函数传递的）静态权限和动态权限。</p><p>动态权限是在权限检查时由生效的策略所授予的、并由 ProtectionDomain 隐式地处理。对 ProtectionDomain 调用 implies() 方法时（实质上是对权限进行检查时），它调用安装的 Policy 类的 getPolicyNoCheck() 方法。因而 Policy 类提供了刷新所授予的一组权限并向调用 ProtectionDomain 返回这个刷新的权限的可能。这保证了针对在构造时提供的 PermissionCollection 和在那一瞬间绑定的 Policy 的组合进行权限检查。</p><p>关于Policy的加载，我们可以通过Policy的静态方法来一探究竟：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">static Policy getPolicyNoCheck()</span><br><span class="line">&#123;</span><br><span class="line">    // 默认是没有Policy的</span><br><span class="line">    PolicyInfo pi = policy.get();</span><br><span class="line">    // Use double-check idiom to avoid locking if system-wide policy is</span><br><span class="line">    // already initialized</span><br><span class="line">    // policy是空的，或没有初始化</span><br><span class="line">    if (pi.initialized == false || pi.policy == null) &#123;</span><br><span class="line">        // 同步加锁，可以对类加锁</span><br><span class="line">        synchronized (Policy.class) &#123;</span><br><span class="line">            // 再取一遍，防止出错</span><br><span class="line">            PolicyInfo pinfo = policy.get();</span><br><span class="line">            if (pinfo.policy == null) &#123;</span><br><span class="line">                String policy_class = AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                    public String run() &#123;</span><br><span class="line">                        // 这里我们发现是从policy.provider属性中取得policy_class</span><br><span class="line">                        return Security.getProperty(&quot;policy.provider&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if (policy_class == null) &#123;</span><br><span class="line">                    // 如果policy.provider属性为空，那么默认使用sun.security.provider.PolicyFile</span><br><span class="line">                    policy_class = &quot;sun.security.provider.PolicyFile&quot;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    // 这里使用policyProvider来创建实例</span><br><span class="line">                    pinfo = new PolicyInfo(</span><br><span class="line">                        (Policy) Class.forName(policy_class).newInstance(),</span><br><span class="line">                        true);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                        * The policy_class seems to be an extension</span><br><span class="line">                        * so we have to bootstrap loading it via a policy</span><br><span class="line">                        * provider that is on the bootclasspath.</span><br><span class="line">                        * If it loads then shift gears to using the configured</span><br><span class="line">                        * provider.</span><br><span class="line">                        *</span><br><span class="line">                        * 如果policy_class是一个扩展类，那么我们不得不通过一个policy provider加载，在bootclasspath上。</span><br><span class="line">                        * 如果它加载了，那么需要换挡要使用配置</span><br><span class="line">                        */</span><br><span class="line"></span><br><span class="line">                    // install the bootstrap provider to avoid recursion</span><br><span class="line">                    // 如果创建失败了，还是使用PolicyFile这个类来创建</span><br><span class="line">                    Policy polFile = new sun.security.provider.PolicyFile();</span><br><span class="line">                    pinfo = new PolicyInfo(polFile, false);</span><br><span class="line">                    // 设置policyInfo</span><br><span class="line">                    policy.set(pinfo);</span><br><span class="line"></span><br><span class="line">                    final String pc = policy_class;</span><br><span class="line">                    Policy pol = AccessController.doPrivileged(</span><br><span class="line">                        new PrivilegedAction&lt;Policy&gt;() &#123;</span><br><span class="line">                        public Policy run() &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                ClassLoader cl =</span><br><span class="line">                                        ClassLoader.getSystemClassLoader();</span><br><span class="line">                                // we want the extension loader</span><br><span class="line">                                ClassLoader extcl = null;</span><br><span class="line">                                // 我们需要扩展类加载器</span><br><span class="line">                                while (cl != null) &#123;</span><br><span class="line">                                    extcl = cl;</span><br><span class="line">                                    cl = cl.getParent();</span><br><span class="line">                                &#125;</span><br><span class="line">                                // 加载policy_class类</span><br><span class="line">                                return (extcl != null ? (Policy)Class.forName(</span><br><span class="line">                                        pc, true, extcl).newInstance() : null);</span><br><span class="line">                            &#125; catch (Exception e) &#123;</span><br><span class="line">                                if (debug != null) &#123;</span><br><span class="line">                                    debug.println(&quot;policy provider &quot; +</span><br><span class="line">                                                pc +</span><br><span class="line">                                                &quot; not available&quot;);</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    /*</span><br><span class="line">                        * if it loaded install it as the policy provider. Otherwise</span><br><span class="line">                        * continue to use the system default implementation</span><br><span class="line">                        */</span><br><span class="line">                    if (pol != null) &#123;</span><br><span class="line">                        pinfo = new PolicyInfo(pol, true);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (debug != null) &#123;</span><br><span class="line">                            debug.println(&quot;using sun.security.provider.PolicyFile&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        pinfo = new PolicyInfo(polFile, true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                policy.set(pinfo);</span><br><span class="line">            &#125;</span><br><span class="line">            return pinfo.policy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pi.policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red">我们其实可以通过指定policy.provider属性来切换Policy的生成，可以从数据库中、二进制文件、ASCII文件等等获取，默认是PolicyFile实现。关于Policy文件的读取路径和解析，可以查看类PolicyFile的实现，由于里面代码量比较大，而且这个类很少使用，所以我决定不深入研究了，具体怎么用网上找找资料就能解决了。</b></p><p>关于policy文件如何进行编写处理的网站如下所示：<span class="exturl" data-url="aHR0cHM6Ly9qaXNodXN1aXNob3VqaS5naXRodWIuaW8vMjAxNy8wNS8wOS8lRTUlQTYlODIlRTQlQkQlOTUlRTklODUlOEQlRTclQkQlQUVQb2xpY3klRTYlOTYlODclRTQlQkIlQjYlRTglQkYlOUIlRTglQTElOENKYXZhJUU1JUFFJTg5JUU1JTg1JUE4JUU3JUFEJTk2JUU3JTk1JUE1JUU3JTlBJTg0JUU4JUFFJUJFJUU3JUJEJUFFLm1kLyVFNSVBNiU4MiVFNCVCRCU5NSVFOSU4NSU4RCVFNyVCRCVBRVBvbGljeSVFNiU5NiU4NyVFNCVCQiVCNiVFOCVCRiU5QiVFOCVBMSU4Q0phdmElRTUlQUUlODklRTUlODUlQTglRTclQUQlOTYlRTclOTUlQTUlRTclOUElODQlRTglQUUlQkUlRTclQkQlQUUv" title="https://jishusuishouji.github.io/2017/05/09/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE.md/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE/">如何配置Policy文件进行Java安全策略的设置<i class="fa fa-external-link"></i></span></p><h2 id="运行时访问检查"><a href="#运行时访问检查" class="headerlink" title="运行时访问检查"></a>运行时访问检查</h2><p>在默认情况下不安装安全管理器，必须通过一个在启动时传递给 JVM 的、名为 java.security.manager 的环境变量显式地指定。任何应用程序都可找到安装的 SecurityManager 并调用它相应的 check<xxx>方法。如果所要求的权限在给定运行时上下文中是授予的，那么调用将无声地返回（void）。如果权限没有授予，那么将抛出一个 java.security.AccessControlException 。</xxx></p><p>在 Java 1.1 的时代， SecurityManager 通过其内部逻辑负责管理所有权限本身。因此，任何需要自定义逻辑进行访问决定的应用程序都必须实现并安装一个自定义的 SecurityManager 。Java 2 平台安全体系结构通过引入一个名为 AccessController 的新类使这一切变得简单了，并更具有可扩展性。这个类的目的与 SecurityManager 是一样的，即它负责做出访问决定。当然， 为了向后兼容性保留了 SecurityManager 类，但是其更新的实现委派给了底层的 AccessController 。对 SecurityManager 类进行的所有 check<xxx>方法调用都解释为相应的 Permission 对象，并将它作为输入参数传递给 AccessController 类的 checkPermission() 方法。</xxx></p><h3 id="Java-程序中的执行线程"><a href="#Java-程序中的执行线程" class="headerlink" title="Java 程序中的执行线程"></a>Java 程序中的执行线程</h3><p>在 Java 程序的执行过程中，可能需要在不同的时间访问“受保护的”资源。当我谈到执行 Java 程序时，我的意思是在特定类 C 1 中（因而在特定的方法中，如 main() ）中启动、通过类 C 2 到 C n-1 、并“结束”于 C n 的执行线程。下面是一个 Java 程序执行的典型控制流程：</p><p>调用类 C 1 的 main() 方法 -&gt; C 1 的 main() 方法调用 C 2 的 m C2 方法 -&gt; C 2 的 m C2 方法调用 C 3 类的 m C3 方法 -&gt; … -&gt; 类 C n-1 的 m Cn-1 方法调用类 C n 的 m Cn 方法。</p><p>假定方法 m Cn 必须访问一个受保护的资源以完成其功能，它调用系统中生效的 AccessController 以确认是否可以继续请求的对特定“受保护的”资源的访问。如果 AccessController 同意放行，那么就执行所要求的操作，控制返回给调用者（ C n-1 类的 m Cn-1 方法），它又将控制返回给其调用者（ C n-2 类的 m Cn-2 方法），如此继续。</p><p>在 JVM 中，线程的控制流表示为 帧堆栈（stack of frame）。每个帧基本上维护有关特定 m Ck 方法、它的类 C k 以及这个方法调用的变量/参数的信息。图 1 显示了一个典型的调用堆栈。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/java/JAAS%E5%85%B8%E5%9E%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E7%9A%84%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7.gif?raw=true"></p><p>上面堆栈中的每个类属于一个 ProtectionDomain ，它由其 CodeSource 惟一地标识。一般来说，这样遍历的一组 ProtectionDomain 将包含 &lt;=n个元素。（您可能还记得，一组中的每一个 ProtectionDomain 都有相关的一组权限 – P i .）像图 1 显示的这样一个调用堆栈快照将编写为（codified）为一个 AccessControlContext 并由 AccessController 对象提供的本机方法调用返回。</p><h2 id="访问检查内幕"><a href="#访问检查内幕" class="headerlink" title="访问检查内幕"></a>访问检查内幕</h2><p>最后得到的一组适用权限的算法是要计算所有权限的交集。换句话说，某一权限，只有与这个特定瞬间、这个线程的执行堆栈上出现的所有类 C i 相应的 ProtectionDomain 相 关联时，这个权限才适用于给定的执行线程。</p><p>这种算法的正确性是很显然的。通过计算与调用堆栈上所有 ProtectionDomain s 相关联的权限集的交集，它保证了不会因为两个类中间的一个（系统/应用程序）调用另一个，而使系统类（通常与更大的 – 如果不是全部的 – 一组权限相关联）“泄露”权限给应用程序类（通常与更少的一组权限相关联）。基本上，属于能力更低的域的类不能通过调用属于能力更高的域的类而变得更强大，而属于能力更高的域中的类会在调用能力更低的类时损失其能力。</p><h3 id="访问控制方法"><a href="#访问控制方法" class="headerlink" title="访问控制方法"></a>访问控制方法</h3><p>确定权限集的交集的算法是在 AccessController 类的 checkPermission 方法中间接实现的。本质上，调用这个方法所发生的事情是对那一瞬间调用堆栈和一组相互交叠的权限进行快照。所请求的权限必须包含在交集结果中或者是它所隐含的。如果这种检查判断为 true，那么 checkPermission() 方法就安静地返回，如果不是，那么就抛出一个异常。（显然， 图 1中描述的调用堆栈中最后一帧实际上是对 AccessController 类的 checkPermission() 方法的调用。）</p><p>注意，直到现在我还没有提到图 1 中描述的调用堆栈的线程起源。这个线程 T 2 可能是由另一个线程 T 1 在其调用堆栈中的某一点上创建的，只要 JVM 为在系统中执行的每一个线程维护单独的调用堆栈。可以直观地假定， T 2 将继承 T 1 调用堆栈（不过只是 T 1 已经运行的那部分）以保证继承的 ProtectionDomain 的权限集也与 T 2 自己的调用堆栈的 ProtectionDomain 取交集。这将保证子线程（这里是 T 2 ）不会偷偷地得到它的父线程（在这里是 T 1 ）所拒绝的某个权限。</p><h3 id="跨域调用问题"><a href="#跨域调用问题" class="headerlink" title="跨域调用问题"></a>跨域调用问题</h3><p>如果属于能力更低的域的类调用属于能力更高的域中的类，就有可能出现奇怪的现象。能力更高的域（类），例如 C n 拥有可以访问所需要的“受保护的” 资源的权限，如果它是由没有相关权限的、能力更低的域（类） C n-1 所调用的，它就不能访问这些资源了。如果 C n 一定要访问受保护的资源才能工作怎么办？不应当有这样一种机制吗：在确定有效的权限集，让 C n 可以告诉安全系统忽略其调用者（及调用者的调用者，并上推到调用堆栈最上层的类）的权限？</p><p>现在，Java 2 平台安全体系结构提供了一种机制，提供的就是这种功能。 AccessController 类有一个名为 doPrivileged 的方法（实际上提供了这个方法的许多变种，但是基本思路是相同的），它用特殊的旗标标记调用堆栈中有关的帧。在这个执行线程中调用 checkPermission 方法时，只有在这个堆栈帧 中和它下面出现的类的权限集才会取交集。调用类和它的上级（即所有在它 上面的堆栈帧）的权限集都 不包括在交集计算中。</p><p>不难看出为什么要包括在调用堆栈以下发生的所有类的权限集：需要考虑属于能力更高的域的类调用属于更能力更低的域的类的情况。更明确地说，需要防止能力更高的域 ( C k ) 将其额外的能力传递给能力更低的域 ( C k+1 )。</p><p>doPrivileged 方法的所有变种都以一个类型为 PrivilegedAction 的对象作为输入。这个对象必须有一个名为 run() 的方法，在调用堆栈中的当前帧特别做了如上所述的标记时，由运行时执行这个方法。因此，任何时候如果有一些代码，希望在执行时让它的权限 临时性地授予给调用堆栈帧前面的代码时，必须将代码包装为 PrivilegedAction 的形式并用这个对象作为输入调用 AccessController 的 doPrivileged() 方法。</p><p>我在想这种机制我们是否可以做一些其他的处理。</p><h3 id="调用堆栈优化"><a href="#调用堆栈优化" class="headerlink" title="调用堆栈优化"></a>调用堆栈优化</h3><p>在 图 1中看到的调用堆栈快照（或者 AccessControlContext ）是在对 AccessController 进行 checkPermission 调用时获得的。在内部， AccessController 在确定这个调用堆栈时进行一些优化，以使访问检查循环尽可能地快。这些优化包括：</p><ul><li>返回的 ProtectionDomain 只到达（并包括）通过调用 AccessController 的 doPrivileged 特别标记的第一个堆栈帧。从前面对 doPrivileged 调用的讨论中显然可以看出这样做的原因。</li><li>返回的 ProtectionDomain s 不包括系统域。系统域定义为具有所有权限，所以不需要检查是否“隐含”了所需要的权限（它总是隐含的）。</li><li>返回的 ProtectionDomain 都是惟一的（即如果多个堆栈帧对应于同一个 ProtectionDomain ，那么只会返回一个 ProtectionDomain ）。</li></ul><p>如果搜索完当前 AccessControlContext 并且没有抛出 AccessControlException ，那么将对这个线程在创建时从其父线程“继承”的 AccessControlContext 进行同样的搜索（ AccessControlContext 被继承，即一个孙子线程将继承它的所有上级的调用堆栈）。</p><h3 id="doPrivileged-方法的变种"><a href="#doPrivileged-方法的变种" class="headerlink" title="doPrivileged() 方法的变种"></a>doPrivileged() 方法的变种</h3><p>在前面看到调用 AccessController 的 doPrivileged() 方法是用一个特殊旗标标识调用堆栈的当前帧，指明控制流中所有前面的帧都不进行访问检查。还看到调用堆栈快照（或者 AccessControlContext ）是在对 AccessController 进行 checkPermission 调用时获得的。不过，这个 AccessControlContext 不一定就是应当用来确定是否授予所请求的权限的那一个 。 例如，请求可能是由客户机发起并发送给服务器进行处理。服务器通常代表客户机执行请求实施代码。</p><p>因为服务器的一部分用于完成请求，如果它调用 AccessController ，那么返回的调用堆栈将是服务器的。显然，不希望（只） 使用服务器的 AccessControlContext 给客户机授权。（当然，希望保证服务器代码本身对试图访问的资源有相应的权限，不过更重要的是保证客户机对服务器代表它访问的资源有相应的权限）。服务器运行时通常是已经授予了权限，因此，真正希望使用的是在客户端向服务器发送请求时存在的客户端调用堆栈。</p><p>AccessController 类提供了 doPrivileged() 方法的另一个变种，它以 AccessControlContext 的实例作为输入。假定客户机设法获得了其 AccessControlContext 的一个副本（ AccessController 类提供了实现这个目的的方法）并将它传递给服务器，服务器可以通过调用以从客户端获得的上述 AccessControlContext 作为输入的 doPrivileged ，将请求的完成代码作为 PrivilegedAction 执行。</p><p>在这种情况下，权限检查的算法（假定在过程某处，在对 PrivilegedAction 的 run() 方法调用后，调用了 checkPermission 时）通过执行上述的循环推进，直到在堆栈中遇到了特别标记的帧，这时，调用作为输入传递的 AccessControlContext 对象的 checkPermission() 方法。这个调用实质上会执行同一个算法，但是是对于在这个 AccessControlContext 中封装的调用堆栈（属于客户机）执行。</p><h2 id="为何要使用以用户为中心的授权？"><a href="#为何要使用以用户为中心的授权？" class="headerlink" title="为何要使用以用户为中心的授权？"></a>为何要使用以用户为中心的授权？</h2><p>Java 2 平台安全体系结构的以代码为中心的授权基于这样的假设，即必须保护用户不受外界影响。为了保证恶意 Java 程序（由世界上恶意破坏者编写的）不会损坏用户的系统，所有移动代码都视为不受信任的，并且那怕进行最无害的操作也要求具有特殊的访问权限。</p><p>相反，JAAS 的以用户为中心的认证模型是以保护世界不受用户影响的思路开发的。随着越来越多的移动和企业网络的出现， 信任概念有了不同的定义。在现实生活中，如果我信任某人 X 多于信任任何某人 Y，我将允许 X 有比 Y 更多的自由度。与此类似，如果一个 Java 应用程序将由多位用户使用（其中一些人实际上可能是恶意破坏者），那么最好将访问权限扩展为以 每个用户为基础。在这种新模型下，根据每位用户受信任的程度，对他或者她授权使用应用程序的某一范围的功能。</p><p>在下面一节中，我将重点介绍 Java 认证和授权服务（Java Authentication and Authorization Service）的以用户为中心的授权模型。虽然 JAAS 代表了 Java 平台安全体系结构的价值的翻天覆地的变化（即它从基于代码的模型转移到以用户为基础的模型），但是您会看到它的许多组件是熟悉的，尽管它们已经更新过以满足新的要求。</p><h2 id="JAAS-授权体系结构"><a href="#JAAS-授权体系结构" class="headerlink" title="JAAS 授权体系结构"></a>JAAS 授权体系结构</h2><p>JAAS 最初是作为 JDK 的一个扩展引入的，在版本 1.4 时成为了核心 JDK 的一部分。既然 JAAS 的目的是为了以每位用户为基础控制任何一段代码所能做的事情，因此需要首先能够准确和惟一地标识用户，换句话说，必须能够对他们进行认证。虽然在这里我不会在 JAAS 的“认证”方面花很多时间，但是我将重点介绍它的一个核心组件： Subject 类。</p><p>就像以前一直说的，JAAS 是一种用以用户为中心进行授权的方式。在 JAAS 下，相关的问题不再是（像在 Java 2 平台安全体系结构中那样）“哪些是这段代码可以做的？”，而变为“这个认证用户的访问权限是什么？”因此，在本文的其余部分我将着重介绍 JAAS 中 Subject 类的作用，并深入讨论基于 subject 的访问控制。</p><h2 id="基于-subject-的访问控制"><a href="#基于-subject-的访问控制" class="headerlink" title="基于 subject 的访问控制"></a>基于 subject 的访问控制</h2><p>Subject 类用于表示在给定系统中认证的用户（即填充的 Subject 是 JAAS 认证过程的结果）。在内部， Subject 包含一组 Principal 对象（和其他有关用户的信息），其中每个 Principal 对象表示同一个用户的不同“身份”。例如，一个 Principal 可能是我在一个终端系统上的用户 ID，而另一个可能是我在同一系统上所属于的“组”。</p><p>在前面我介绍过 生效的 Policy 是如何在系统中设置 ProtectionDomain （以及由相关的 CodeSource 标识的、“属于”它的类）和授予它的权限之间的映射的。JAAS 通过要求用一组 Principal 进一步描述 ProtectionDomain （超越了 CodeSource ）而强化了这种概念。当系统 Policy 设置了这样的 ProtectionDomain （即除了 CodeSource ，还用一组 Principal s 描述）和授予它的权限之间的映射后，如果要用 ProtectionDomain 的权限检查是否应当授予用户某个请求的权限，那么在 Subject 中包含的、与运行这段代码的认证用户相对应的 Principal 对象必须匹配在这个 ProtectionDomain 中包含的 Principal 对象。</p><p>既然 Java 2 平台已经有了干净的、高效的、使用调用堆栈（通过 AccessControlContext ）的授权实现，那么保持它就容易得多了，只要提供一种机制将运行这段代码的用户的身份（如由用户的 Subject 所提供的）“注入”到在权限检查瞬间调用堆栈中的 ProtectionDomain 。</p><p>为此，JAAS Subject 类提供了两个静态方法，称为 doAs 和 doAsPrivileged 。 这些方法期待的输入是认证的用户的 Subject 实例和 PrivilegedAction 的一个实例（它的 run() 方法应当包含需要访问受保护的资源的业务逻辑）。基本思路是应用程序应当首先认证用户，对认证的用户建立了 Subject 后，这个用户可能希望执行的每一个操作都包装为 PrivilegedAction 、并由应用程序作为 Subject （就像方法自己的名字所表明的 – doAs() ！）执行。这两个方法之间有细微但是重要的区别，我们将在稍后介绍。</p><p>为了能够将操作作为 Subject 执行，必须在调用堆 栈中将 Subject引入（或者注入）ProtectionDomain 。这是在一个名为 DomainCombiner 的专用接口的帮助下实现的，我将在开始 doAs() 和 doAsPrivileged() 方法的内幕之前介绍这个接口。</p><h3 id="DomainCombiner"><a href="#DomainCombiner" class="headerlink" title="DomainCombiner"></a>DomainCombiner</h3><p>如前所述，对于一个 AccessControlContext (一个调用堆栈），在 JAAS 中将 Subject 注入堆栈中的 ProtectionDomain 是通过实现 DomainCombiner 接口（一个特定的实现是 SubjectDomainCombiner ）所处理的。</p><p>注入是在将 SubjectDomainCombiner 作为构造函数参数传递以构建 AccessControlContext 时执行的。（作为参数传递给 doAs 调用的 Subject 被封装到 SubjectDomainCombiner 对象中，这种封装是在创建后者时，将 Subject 作为构造函数参数传递而完成的。）不过，真正的工作是在 SubjectDomainCombiner 的 combine() 方法中完成的。您将在稍后看到在这个方法中所发生的过程。</p><h2 id="参考和引用"><a href="#参考和引用" class="headerlink" title="参考和引用"></a>参考和引用</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9qYXZhL2otamF2YWF1dGgv" title="https://www.ibm.com/developerworks/cn/java/j-javaauth/">Java 授权内幕<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qaXNodXN1aXNob3VqaS5naXRodWIuaW8vMjAxNy8wNS8wOS8lRTUlQTYlODIlRTQlQkQlOTUlRTklODUlOEQlRTclQkQlQUVQb2xpY3klRTYlOTYlODclRTQlQkIlQjYlRTglQkYlOUIlRTglQTElOENKYXZhJUU1JUFFJTg5JUU1JTg1JUE4JUU3JUFEJTk2JUU3JTk1JUE1JUU3JTlBJTg0JUU4JUFFJUJFJUU3JUJEJUFFLm1kLyVFNSVBNiU4MiVFNCVCRCU5NSVFOSU4NSU4RCVFNyVCRCVBRVBvbGljeSVFNiU5NiU4NyVFNCVCQiVCNiVFOCVCRiU5QiVFOCVBMSU4Q0phdmElRTUlQUUlODklRTUlODUlQTglRTclQUQlOTYlRTclOTUlQTUlRTclOUElODQlRTglQUUlQkUlRTclQkQlQUUv" title="https://jishusuishouji.github.io/2017/05/09/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE.md/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE/">如何配置Policy文件进行Java安全策略的设置<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veW91eGlhL3AvamF2YTAwNi5odG1s" title="https://www.cnblogs.com/youxia/p/java006.html">JAAS 是个什么梗<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS95b3V4aWEvcC9qYXZhMDA0Lmh0bWw=" title="http://www.cnblogs.com/youxia/p/java004.html">使用 SecurityManager 和 Policy File 管理 Java 程序的权限<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SecurityManager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的SPI机制</title>
      <link href="//java/Java%E7%9A%84SPI%E6%9C%BA%E5%88%B6.html"/>
      <url>//java/Java%E7%9A%84SPI%E6%9C%BA%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>之前在看Dubbo的源码的时候，也发现了一个ServiceLoader，当然现在我已经忘记了Dubbo的源码，但是无所谓基础的思想还是记得的。这次再看完System的源码的时候，一路研究发现了ServiceLoader这个类，瞬间想起了了SPI的机制，所以今天就专门写一下记录一下。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SPI的全名为Service Provider Interface.普通开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档里有比较详细的介绍。究其思想，其实是和”Callback”差不多。“Callback”的思想是在我们调用API的时候，我们可以自己写一段逻辑代码，传入到API里面，API内部在合适的时候会调用它，从而实现某种程度的“定制”。</p><p>典型的是Collections.sort（List<t>list,Comparator&lt;? super T&gt; c）这个方法，它的第二个参数是一个实现Comparator接口的实例。我们可以根据自己的排序规则写一个类，实现此接口，传入此方法，那么这个方法就会根据我们的规则对list进行排序。</t></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面来看看Java中SPI的实现机制。<b style="color:red">客户把自己的排序规则写成一个类，并且打包成Jar文件，这个Jar文件里面必须有META-INF目录，其下又有services目录，其下有一个文本文件，文件名即为接口的全名：java.util.Comparator。</b><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--META-INF</span><br><span class="line">  --services</span><br><span class="line">    --java.util.Comparator</span><br></pre></td></tr></table></figure><p></p><p>文件的内容只有一行即可，当然多行也行的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.company1.ComparatorProvider</span><br></pre></td></tr></table></figure><p></p><p>下面我们看一下，代码的实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.company1;  </span><br><span class="line">import java.util.Comparator;  </span><br><span class="line">import com.mycompany.myapp.MyItem;  </span><br><span class="line">public class ComparatorProvider implements Comparator&lt;MyItem&gt;&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(MyItem o1, MyItem o2) &#123;  </span><br><span class="line">                //依据name排序    </span><br><span class="line">        return o1.getName().compareTo(o2.getName());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">// 编译打包后，把它放到你的主程序的class path里。下面是你的主程序：  </span><br><span class="line">//从class path中所有Jar的META-INF目录中搜索，找到合适的类并加载。 </span><br><span class="line"></span><br><span class="line">private static ServiceLoader&lt;Comparator&gt; serviceLoader  </span><br><span class="line">    = ServiceLoader.load(Comparator.class);  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        List&lt;MyItem&gt; myList = new ArrayList&lt;MyItem&gt;();  </span><br><span class="line">        myList.add(new MyItem(2,&quot;c&quot;,&quot;hhh&quot;));  </span><br><span class="line">        myList.add(new MyItem(3,&quot;k&quot;,&quot;ooo&quot;));  </span><br><span class="line">        myList.add(new MyItem(4,&quot;d&quot;,&quot;ppp&quot;));  </span><br><span class="line">        myList.add(new MyItem(5,&quot;b&quot;,&quot;ggg&quot;));  </span><br><span class="line">          </span><br><span class="line">        showList(myList);  </span><br><span class="line">          </span><br><span class="line">        Collections.sort(myList, getCompartor());  </span><br><span class="line">          </span><br><span class="line">        showList(myList);      </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)  </span><br><span class="line">    private static Comparator&lt;MyItem&gt; getCompartor() &#123;  </span><br><span class="line">          </span><br><span class="line">        for(Comparator service : serviceLoader) &#123;  </span><br><span class="line">           return (Comparator&lt;MyItem&gt;)service;  </span><br><span class="line">        &#125;  </span><br><span class="line">                 </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。我们来看一下ServiceLoader的实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line">public final class ServiceLoader&lt;S&gt;</span><br><span class="line">    implements Iterable&lt;S&gt;</span><br><span class="line">&#123;</span><br><span class="line">    // Service的接口，前缀：META-INF/services/</span><br><span class="line">    private static final String PREFIX = &quot;META-INF/services/&quot;;</span><br><span class="line"></span><br><span class="line">    // The class or interface representing the service being loaded</span><br><span class="line">    // 类或者接口代表服务被加载</span><br><span class="line">    private Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    // The class loader used to locate, load, and instantiate providers</span><br><span class="line">    // 类加载器</span><br><span class="line">    private ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    // Cached providers, in instantiation order</span><br><span class="line">    // 缓存的提供者，按照实例化顺序</span><br><span class="line">    private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // The current lazy-lookup iterator</span><br><span class="line">    // 懒得迭代器</span><br><span class="line">    private LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line">    public void reload() &#123;</span><br><span class="line">        // 先清空提供队列</span><br><span class="line">        providers.clear();</span><br><span class="line">        // 迭代访问，后面再看</span><br><span class="line">        lookupIterator = new LazyIterator(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;</span><br><span class="line">        // 类名</span><br><span class="line">        service = svc;</span><br><span class="line">        // 类加载器</span><br><span class="line">        loader = cl;</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void fail(Class service, String msg, Throwable cause)</span><br><span class="line">        throws ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        // 出现服务配置问题</span><br><span class="line">        throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg,</span><br><span class="line">                                            cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void fail(Class service, String msg)</span><br><span class="line">        throws ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void fail(Class service, URL u, int line, String msg)</span><br><span class="line">        throws ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        fail(service, u + &quot;:&quot; + line + &quot;: &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从给的配置文件中解析单行，添加行上的名称到name列表里面去</span><br><span class="line">    private int parseLine(Class service, URL u, BufferedReader r, int lc,</span><br><span class="line">                          List&lt;String&gt; names)</span><br><span class="line">        throws IOException, ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        String ln = r.readLine();</span><br><span class="line">        if (ln == null) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // #号搜索，#号是注释</span><br><span class="line">        int ci = ln.indexOf(&apos;#&apos;);</span><br><span class="line">        if (ci &gt;= 0) ln = ln.substring(0, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        int n = ln.length();</span><br><span class="line">        if (n != 0) &#123;</span><br><span class="line">            if ((ln.indexOf(&apos; &apos;) &gt;= 0) || (ln.indexOf(&apos;\t&apos;) &gt;= 0))</span><br><span class="line">                fail(service, u, lc, &quot;Illegal configuration-file syntax&quot;);</span><br><span class="line">            int cp = ln.codePointAt(0);</span><br><span class="line">            if (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);</span><br><span class="line">            for (int i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != &apos;.&apos;))</span><br><span class="line">                    fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        &#125;</span><br><span class="line">        return lc + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Iterator&lt;String&gt; parse(Class service, URL u)</span><br><span class="line">        throws ServiceConfigurationError</span><br><span class="line">    &#123;</span><br><span class="line">        InputStream in = null;</span><br><span class="line">        BufferedReader r = null;</span><br><span class="line">        ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 从url中获取URL</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            // 包装一下输入流</span><br><span class="line">            r = new BufferedReader(new InputStreamReader(in, &quot;utf-8&quot;));</span><br><span class="line">            int lc = 1;</span><br><span class="line">            while ((lc = parseLine(service, u, r, lc, names)) &gt;= 0);// 逐行解析，这个语句很有趣</span><br><span class="line">        &#125; catch (IOException x) &#123;</span><br><span class="line">            fail(service, &quot;Error reading configuration file&quot;, x);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (r != null) r.close();</span><br><span class="line">                if (in != null) in.close();</span><br><span class="line">            &#125; catch (IOException y) &#123;</span><br><span class="line">                fail(service, &quot;Error closing configuration file&quot;, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return names.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class LazyIterator</span><br><span class="line">        implements Iterator&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;    // 服务类</span><br><span class="line">        ClassLoader loader;  // 类加载器</span><br><span class="line">        Enumeration&lt;URL&gt; configs = null; // URL配置迭代</span><br><span class="line">        Iterator&lt;String&gt; pending = null; // pending状态迭代</span><br><span class="line">        String nextName = null; // 下一个名字</span><br><span class="line"></span><br><span class="line">        private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123;</span><br><span class="line">            this.service = service;</span><br><span class="line">            this.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            if (nextName != null) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (configs == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 得到fullName</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    if (loader == null) // 加载文件</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    else // 当前类加载器加载文件</span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; catch (IOException x) &#123;</span><br><span class="line">                    fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while ((pending == null) || !pending.hasNext()) &#123;</span><br><span class="line">                if (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public S next() &#123;</span><br><span class="line">            if (!hasNext()) &#123;</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = null;</span><br><span class="line">            Class&lt;?&gt; c = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                c = Class.forName(cn, false, loader);</span><br><span class="line">            &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                return p;</span><br><span class="line">            &#125; catch (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn + &quot; could not be instantiated: &quot; + x,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new Error();          // This cannot happen</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;S&gt; iterator() &#123;</span><br><span class="line">        // 默认的实现类</span><br><span class="line">        return new Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            public boolean hasNext() &#123;</span><br><span class="line">                if (knownProviders.hasNext())</span><br><span class="line">                    return true;</span><br><span class="line">                return lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public S next() &#123;</span><br><span class="line">                if (knownProviders.hasNext())</span><br><span class="line">                    return knownProviders.next().getValue();</span><br><span class="line">                return lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void remove() &#123;</span><br><span class="line">                throw new UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,</span><br><span class="line">                                            ClassLoader loader)</span><br><span class="line">    &#123;</span><br><span class="line">        // 内部类的初始化，单例模式的instance方法</span><br><span class="line">        return new ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">        // 使用默认的类加载器</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        return ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;S&gt; ServiceLoader&lt;S&gt; loadInstalled(Class&lt;S&gt; service) &#123;</span><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        ClassLoader prev = null;</span><br><span class="line">        // 一直加载到系统类加载器</span><br><span class="line">        while (cl != null) &#123;</span><br><span class="line">            prev = cl;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        return ServiceLoader.load(service, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;java.util.ServiceLoader[&quot; + service.getName() + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:red"><br>调用的方式：load(单例)-&gt;构造方法-&gt;reload()-&gt;LazyIterator实例化构造函数</b><br><b style="color:red">当然到这里，ServiceLoader类就实例化完毕了。使用的时候是通过迭代器访问，实例化ServiceLoader并没有读取文件，LazyIterator是一种懒的加载机制，我们看一下里面的迭代方法。或者直接使用里面的iterator方法的默认构造器。<br>如果想知道ServiceLoader类是如何加载服务的，可以查看LazyIterator的hasNext方法就明白了。好了大致的原理就是这样的，活用了内部类机制和迭代器模式。LazyIterator中hasNext负责找文件，next方法负责加载类并进行实例化，很棒的处理方式。<br></b></p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h3 id="1-common-logging"><a href="#1-common-logging" class="headerlink" title="1.common-logging"></a>1.common-logging</h3><p>apache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现，发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提工商实现类。<b style="color:red">只要我们的日志实现里包含了这个文件，并在文件里制定 LogFactory工厂接口的实现类即可。</b></p><h3 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h3><p>jdbc4.0以前，开发人员还需要基于Class.forName(“xxx”)的方式来装载驱动，jdbc4也基于spi的机制来发现驱动提供商了，可以通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者。</p><h3 id="Nio中Selector查找"><a href="#Nio中Selector查找" class="headerlink" title="Nio中Selector查找"></a>Nio中Selector查找</h3><p>我们可以看到Selector类中open的实现，发现它是通过SelectorProvider去查找相应的实现的，这个SelectorProvider查找实现并实例化只有3种方式：</p><ul><li>属性传入实现类的名称</li><li>ServiceLoader进行加载</li><li>默认的实现类。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spi </tag>
            
            <tag> ServiceLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系统底层运行参数</title>
      <link href="//java/JVM%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0.html"/>
      <url>//java/JVM%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>今天在网上看到一个很有趣的例子，貌似大家一点也不关注，今天来学习一下，不过这个例子激起了我对JVM底层运行原理的兴趣，如果日后有兴趣，倒是可以花心思研究一下。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    String a = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); </span><br><span class="line">    String b = sun.misc.VM.getSavedProperty(&quot;high&quot;); </span><br><span class="line">    String c = System.getProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); </span><br><span class="line">    String d = System.getProperty(&quot;high&quot;); </span><br><span class="line"></span><br><span class="line">    System.err.println(a); </span><br><span class="line">    System.err.println(b); </span><br><span class="line">    System.err.println(c); </span><br><span class="line">    System.err.println(d); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入java命令执行时设置的值是这样的：<code>-Djava.lang.Integer.IntegerCache.high=250 -Dhigh=250</code>,输出的结果是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">250 </span><br><span class="line">250 </span><br><span class="line">null </span><br><span class="line">250</span><br></pre></td></tr></table></figure><p></p><p>那么问题来了，为何System.getProperty(“java.lang.Integer.IntegerCache.high”); 是null呢？</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>其实上面的<code>java.lang.Integer.IntegerCache.high</code>是用来设置HotSpot VM上Integer的autobox（自动装箱缓存大小配置）范围的。详细参考：<span class="exturl" data-url="aHR0cDovL3JlZG5heGVsYWZ4Lml0ZXllLmNvbS9ibG9nLzY4MDc0Ng==" title="http://rednaxelafx.iteye.com/blog/680746">http://rednaxelafx.iteye.com/blog/680746<i class="fa fa-external-link"></i></span></p><p>使用<code>sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</code>来获取这个参数值，而不是通过<code>System.getProperty()</code>.</p><p>通常，HotSpot VM所接收的特定的VM参数都是通过-XX:前缀的命令行参数指定的，而传给Java层的system property则是通过-D前缀的参数来指定。</p><p>在系统初始化的时候，JVM调用<code>java.lang.System.initializeSystemClass()</code>来初始化System类，而它进一步调用的<br><code>java.lang.System.initProperties()</code>会调用到JVM的<code>JVM_InitProperties()</code>函数，来从JVM那边把-D参数都拿到System.properties里。</p><p>紧接着，<code>initializeSystemClass()</code>又调用<code>sun.misc.VM.saveAndRemoveProperties()</code>来保存一份“干净”的system properties备份以便JDK内部使用，避免JDK的内部行为受到运行时用户代码对<code>System.properties</code>的修改所干扰。同时<code>saveAndRemoveProperties()</code>也会从System.properties移除一些只供JDK内部使用、用户代码不应该看到的系统属性，例如设置NIO direct memory大小限制的sun.nio.MaxDirectMemorySize属性。这些被移除的系统属性在sun.misc.VM.savedProps里都留有备份。</p><p>所以上面使用System.getProperty去获取系统预留的配置时，就获取不到任何信息。关于VM会从系统属性中删除哪些信息可以查看 <code>sun.misc.VM</code> 这个VM类中的saveAndRemoveProperties方法。这个调用过程，可以查看System类里面的initializeSystemClass方法。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中一些实用类</title>
      <link href="//java/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E7%B1%BB.html"/>
      <url>//java/Java%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E7%B1%BB.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>Java中有很多比较实用的类，大多使用过，但是也有很多未被大家所使用的类。</p><h2 id="BitSet类"><a href="#BitSet类" class="headerlink" title="BitSet类"></a>BitSet类</h2><p>BitSet就是一个位存储和操作而设计的一个类。里面使用Long数组进行存储，一个long64字节，所以一个bit地址对应的查找是先找long或者称为word的索引，然后进行位操作进行设置读取等操作。更多的知识参考源码即可。</p><p>应用场景也是有的，比如说你想删除一些元素，但是需要暂存一下，就可以使用这个类。元素的标记可以作为索引，是否删除取决于，索引对应标志位的值。</p><p>##</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java Set学习</title>
      <link href="//java/java-Set%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/java-Set%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>Set和list是很相似的，只是List可以存在相同元素，而Set却不可以，其他都是类似的。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>讲到这个当然先说说Set接口了，这个比较简单，就不过多去说了。几乎和List是一样的。</p><h2 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h2><p>我们来看一下这个类，继承自AbstractCollection，也没啥定义了一些通用方法，比如实现了equals、hashCode和removeAll方法。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>内部定义了一个hashMap作为实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure><p></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashSet的构造函数比较重要：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 默认的无参构造器，构造一个空的HashSet。</span><br><span class="line"> *</span><br><span class="line"> * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span><br><span class="line"> */</span><br><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;E,Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 构造一个包含指定collection中的元素的新set。</span><br><span class="line"> *</span><br><span class="line"> * 实际底层使用默认的加载因子0.75和足以包含指定collection中所有元素的初始容量来创建一个HashMap。</span><br><span class="line"> * @param c 其中的元素将存放在此set中的collection。</span><br><span class="line"> */</span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 以指定的initialCapacity和loadFactor构造一个空的HashSet。</span><br><span class="line"> *</span><br><span class="line"> * 实际底层以相应的参数构造一个空的HashMap。</span><br><span class="line"> * @param initialCapacity 初始容量。</span><br><span class="line"> * @param loadFactor 加载因子。</span><br><span class="line"> */</span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 以指定的initialCapacity构造一个空的HashSet。</span><br><span class="line"> *</span><br><span class="line"> * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span><br><span class="line"> * @param initialCapacity 初始容量。</span><br><span class="line"> */</span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。此构造函数为包访问权限，不对外公开，</span><br><span class="line"> * 实际只是是对LinkedHashSet的支持。</span><br><span class="line"> *</span><br><span class="line"> * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span><br><span class="line"> * @param initialCapacity 初始容量。</span><br><span class="line"> * @param loadFactor 加载因子。</span><br><span class="line"> * @param dummy 标记。</span><br><span class="line"> */</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意这里可以利用LinkedHashMap实现，这个作用比较大，因为HashSet中元素的遍历是通过map的迭代器，但是也不一定，如果数量比较少，利用hashMap的迭代器进行迭代，速度也不应该会慢，这要相对的看。</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用hash表实现的Set本身就不用考虑相同的值被插入进来。这里的PRESENT是一个Object常量。其他的还是阅读源码吧！</p><h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>继承Set的接口，定义和SortedMap类似，都会出现子树等形式的函数。</p><h2 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h2><p>看到JDK有这样的一个类，所以过来学习一下。这个类和HashSet差不多，不过只针对枚举，也有缓存。EnumSet是一个抽象类，有两个实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123;</span><br><span class="line">    Enum[] universe = getUniverse(elementType);</span><br><span class="line">    if (universe == null)</span><br><span class="line">        throw new ClassCastException(elementType + &quot; not an enum&quot;);</span><br><span class="line"></span><br><span class="line">    if (universe.length &lt;= 64)</span><br><span class="line">        return new RegularEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">    else</span><br><span class="line">        return new JumboEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>这个类是基于HashSet实现的，由于HashSet和HashMap不同，已经做了数组的缓存，所以LinkedHash几乎完全基于HashSet实现。看其中的一个构造方法即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>传入的第三个参数就是告诉HashSet使用LinkedHashMap实现，具体原因查看HashSet的构造函数就明白了。</p><h2 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a>NavigableSet</h2><p>对Set进行树形结构操作的规范接口。这个接口继承自SortedSet。</p><h2 id="TreeSet接口"><a href="#TreeSet接口" class="headerlink" title="TreeSet接口"></a>TreeSet接口</h2><p>这也是一个比较简单的类。基于红黑树实现的Set集。TreeSet 底层实际使用的存储容器就是 TreeMap。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><p>TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。</p><p>TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。<br>另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。</p><p>具体可以查看TreeSet的源码进行解读。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF3bWluZy9hcnRpY2xlL2RldGFpbHMvNTI0MzgzODc=" title="http://blog.csdn.net/mawming/article/details/52438387">Java 之EnumSet与EnumMap<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9qYXZhL2otbG8tdHJlZS9pbmRleC5odG1s" title="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">通过分析 JDK 源代码研究 TreeMap 红黑树算法实现<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树（RB-Tree）</title>
      <link href="//%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html"/>
      <url>//%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>红黑树在大学的数据结构没有涉及，他是AVL（平衡二叉树）的变种和升级，大学着重基本原理就只有AVL，而红黑树是为了满足企业级的开发捣鼓出来的为了节省成本的一种数据结构，本文讲解的RBTree只有插入部分，没有删除部分，因为只有插入比较易懂，而且诠释了红黑树的基本原理，而删除不论是在AVL还是在RBTree中都是最复杂的一步，此文只讲原理不讲代码。</p><p>RBTree的规则：</p><ol><li>每一个结点不是红色的就是黑色的。</li><li>根总是黑色的。</li><li>每个叶子节点必须是黑色的。</li><li>如果结点是红色的，那么他的子结点必须是黑色的（反之倒不一定必须为真）。</li><li>从根到叶结点或空子结点的每条路径，必须包含相同数目的黑色结点。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>一棵含有n个节点的红黑树的高度至多为2log(n+1).</p><p>高度为h的红黑树，它的包含的内节点个数至少为 2<sup>bh(x)</sup>-1个</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)  </span><br><span class="line">01  y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作</span><br><span class="line">02  right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span><br><span class="line">03  p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span><br><span class="line">04  p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”</span><br><span class="line">05  if p[x] = nil[T]       </span><br><span class="line">06  then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span><br><span class="line">07  else if x = left[p[x]]  </span><br><span class="line">08            then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span><br><span class="line">09            else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span><br><span class="line">10  left[y] ← x             // 将 “x” 设为 “y的左孩子”</span><br><span class="line">11  p[x] ← y                // 将 “x的父节点” 设为 “y”</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋和左旋相反而已。原理都是一样的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)  </span><br><span class="line">01  x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作</span><br><span class="line">02  left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span><br><span class="line">03  p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span><br><span class="line">04  p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”</span><br><span class="line">05  if p[y] = nil[T]       </span><br><span class="line">06  then root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span><br><span class="line">07  else if y = right[p[y]]  </span><br><span class="line">08            then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span><br><span class="line">09            else left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span><br><span class="line">10  right[x] ← y            // 将 “y” 设为 “x的右孩子”</span><br><span class="line">11  p[y] ← x                // 将 “y的父节点” 设为 “x”</span><br></pre></td></tr></table></figure><p></p><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>当我们要往树里边插入一个节点的的时候分下边3个步骤：</p><ul><li>在下行路途中的颜色变换。</li><li>在向下路途上的旋转。</li><li>插入结点之后的旋转。</li></ul><h3 id="在下行路途中的颜色变换。"><a href="#在下行路途中的颜色变换。" class="headerlink" title="在下行路途中的颜色变换。"></a>在下行路途中的颜色变换。</h3><p>从root根结点开始向下搜索，当碰到如下情况是要进行颜色的变换<br>发现一个黑色结点有2个红色子结点，把2个红色子结点颜色变为黑色，父结点颜色变为红色（如果父结点为根，那么父结点还是黑色，遵守规则一）。</p><h3 id="插入结点之后的旋转。"><a href="#插入结点之后的旋转。" class="headerlink" title="插入结点之后的旋转。"></a>插入结点之后的旋转。</h3><p>结点插入之后可能会造成树的规则的破坏，需要对树重新调整。</p><p>新插入的节点有3中可能的情况：</p><ul><li>父节点（P）是黑色的</li><li>P是红色的，X是G的外侧子孙节点。</li><li>P是红色的，X是G的内侧子孙节点。</li></ul><h4 id="父节点（P）是黑色的"><a href="#父节点（P）是黑色的" class="headerlink" title="父节点（P）是黑色的"></a>父节点（P）是黑色的</h4><p>如果P是黑色的什么事也不做，直接把节点插入即可。</p><h4 id="P是红色的，X是G的外侧子孙节点。"><a href="#P是红色的，X是G的外侧子孙节点。" class="headerlink" title="P是红色的，X是G的外侧子孙节点。"></a>P是红色的，X是G的外侧子孙节点。</h4><p>X是插入的节点，G是祖先节点，也就是P的父节点，调整方法如下：</p><ul><li>改变X的祖父节点G（本例中是25）的颜色。</li><li>改变X的父节点P（12）的颜色。</li><li>以X的祖父节点G（25）为顶旋转，向X（6）上升的方向，在本例中是右旋。</li></ul><h4 id="P是红色的，X是G的内侧子孙节点。"><a href="#P是红色的，X是G的内侧子孙节点。" class="headerlink" title="P是红色的，X是G的内侧子孙节点。"></a>P是红色的，X是G的内侧子孙节点。</h4><p>调整步骤：</p><ol><li>改变X的祖父节点（本例中为25）的颜色。</li><li>改变X（18）的颜色。</li><li>用X的父节点P（12）作为顶旋转，向X上升的方向旋转，本例是左旋。</li><li>再以X的祖父节点（25）为顶旋转，向X上升的方向旋转（本例为右旋）。</li></ol><h3 id="在向下路途上的旋转"><a href="#在向下路途上的旋转" class="headerlink" title="在向下路途上的旋转"></a>在向下路途上的旋转</h3><p>解释：在从根结点向下搜索遍历寻找插入位置的时候，会进行中途结点颜色的调整（即步骤一），以便于搜索继续向下进行，旋转之后可能会造成红-红冲突（规则三），出现冲突就需要进行树的旋转调整。<br>在向下的路径上有2中旋转的可能性：</p><ul><li>外侧子孙节点。</li><li>内侧子孙节点。</li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>红可以变黑，但是必须是双红变黑，否则的确解决了红红冲突，但是会出现每条链上黑色的果树就会不一致。另外上下层的黑色和红色可以互换。这样本层路径的黑色数量也不会改变。红红变换可能需要多次的红红冲突解决才能重新让整棵树维护成红黑树。详细还是查看引用。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9za3l3YW5nMTIzNDUvcC8zMjQ1Mzk5Lmh0bWw=" title="http://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNDQ5NDY3Mjk=" title="http://blog.csdn.net/wzq6578702/article/details/44946729">红黑树原理（RB-Tree Principle）<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9KVUxZX3YvYXJ0aWNsZS9kZXRhaWxzLzYxMDU2MzA=" title="http://blog.csdn.net/v_JULY_v/article/details/6105630">教你初步了解红黑树<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang的包组织方式</title>
      <link href="//golang/golang%E7%9A%84%E5%8C%85%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.html"/>
      <url>//golang/golang%E7%9A%84%E5%8C%85%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近在研究以太坊官网的源代码，经常发现包的导入，由于不了解机制所以不免给阅读带来不小的难度，所以这里我们来讨论一下golang的包导入策略。</p><h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>可以是相对路径，也可以是绝对路径。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import   &quot;./module&quot;   //当前文件同一目录的module目录， 此方式没什么用容易出错</span><br><span class="line">import “LearnGo/init”     //加载gopath/src/LearnGo/init模块</span><br></pre></td></tr></table></figure><p></p><h3 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h3><p>我们有时候会看到如下的方式导入包<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import( . “fmt” )</span><br></pre></td></tr></table></figure><p></p><p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”);</p><h3 id="别名操作"><a href="#别名操作" class="headerlink" title="别名操作"></a>别名操作</h3><p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    f &quot;fmt&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)。</p><h3 id="操作"><a href="#操作" class="headerlink" title="_操作"></a>_操作</h3><p>这个操作经常是让很多人费解的一个操作符，请看下面这个import<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (//revel框架的代码片段</span><br><span class="line">_ &quot;github.com/revel/modules/testrunner/app&quot;</span><br><span class="line">_ &quot;guild_website/app&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p></p><p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数，要理解这个问题，需要看下面这个图，理解包是怎么按照顺序加载的：</p><p>程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它 只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先 将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开 始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。此外需了解别名操作方式导入包也会执行init函数。</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/golang/golang%E5%8C%85%E6%9C%BA%E5%88%B6.jpeg?raw=true"></p><h2 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h2><p>程序的启动是从main包开始的，main包下面有一个main方法就是程序的入口点。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sun.misc.Unsafe的学习</title>
      <link href="//java/sun-misc-Unsafe%E7%9A%84%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/sun-misc-Unsafe%E7%9A%84%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下sun.misc.Unsafe源码和demo基于jdk1.7；JUC的包中很多都使用了这个类的实例，这里我们需要进一步深入的学习。</p><p>这个类的实现方法很多都是native的，所以研究起来并不容易，需要了解动态链接库做的一些事情，这里我就不深入研究了，源码是网上找的，不知道对不对，提供一种研究思路吧，所以这篇博文也就是简单地了解一下，日后可以根据具体的情况深入研究一下。</p><h2 id="Unsafe类的作用"><a href="#Unsafe类的作用" class="headerlink" title="Unsafe类的作用"></a>Unsafe类的作用</h2><p>可以用来在任意内存地址位置处读写数据，可见，对于普通用户来说，使用起来还是比较危险的；</p><p>另外，还支持一些CAS原子操作；</p><h2 id="获取Unsafe对象"><a href="#获取Unsafe对象" class="headerlink" title="获取Unsafe对象"></a>获取Unsafe对象</h2><p>遗憾的是，Unsafe对象不能直接通过new Unsafe()或调用Unsafe.getUnsafe()获取，原因如下：</p><ul><li><p>不能直接new Unsafe()，原因是Unsafe被设计成单例模式，构造方法是私有的；</p></li><li><p>不能通过调用Unsafe.getUnsafe()获取，因为getUnsafe被设计成只能从引导类加载器（bootstrap class loader）加载，从getUnsafe的源码中也可以看出来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">    //得到调用该方法的Class对象</span><br><span class="line">    Class cc = Reflection.getCallerClass();</span><br><span class="line">    //判断调用该方法的类是否是引导类加载器（bootstrap class loader）</span><br><span class="line">    //如果不是的话，比如由AppClassLoader调用该方法，则抛出SecurityException异常</span><br><span class="line">    if (cc.getClassLoader() != null)</span><br><span class="line">        throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">    //返回单例对象</span><br><span class="line">    return theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>虽然我们不能通过以上方法得到Unsafe对象，但得Unsafe类中有个私有的静态全局属性theUnsafe（Unsafe实例对象），通过反射，可以获取到该成员属性theUnsafe对应的Field对象，并将其设置为可访问，从而得到theUnsafe具体对象，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package concurrency;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import sun.reflect.Reflection;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException,</span><br><span class="line">            SecurityException, IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">        // 通过反射得到theUnsafe对应的Field对象</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        // 设置该Field为可访问</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 通过Field得到该Field对应的具体对象，传入null是因为该Field为static的</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unsafe类中的API"><a href="#Unsafe类中的API" class="headerlink" title="Unsafe类中的API"></a>Unsafe类中的API</h2><p>本地方法，功能是生成一个对象实例，但是不会运行该对象的构造方法；由于natUnsafe.cc版本较老，没找到对应的c++实现；<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/** Allocate an instance but do not run any constructor. Initializes the class if it has not yet been. */</span><br><span class="line">    public native Object allocateInstance(Class cls)</span><br><span class="line">        throws InstantiationException;</span><br></pre></td></tr></table></figure><p></p><p>例子，利用Unsafe的allocateInstance方法，在未调用构造方法的情况下生成了对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package concurrency;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import sun.reflect.Reflection;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private String name = &quot;&quot;;</span><br><span class="line">    private int age = 0;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">        this.name = &quot;test&quot;;</span><br><span class="line">        this.age = 22;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name + &quot;: &quot; + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException,</span><br><span class="line">            SecurityException, IllegalArgumentException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 通过反射得到theUnsafe对应的Field对象</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        // 设置该Field为可访问</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 通过Field得到该Field对应的具体对象，传入null是因为该Field为static的</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line"></span><br><span class="line">        User user = (User) unsafe.allocateInstance(User.class);</span><br><span class="line">        System.out.println(user); //dont invoke constructor, print null: 0</span><br><span class="line">        </span><br><span class="line">        User userFromNormal = new User();</span><br><span class="line">        System.out.println(userFromNormal); //print test: 22</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">objectFieldOffset方法，返回成员属性在内存中的地址相对于对象内存地址的偏移量</b><br>比较简单，就是返回成员属性内存地址相对于对象内存地址的偏移量，通过该方法可以计算一个对象在内存中的空间大小，方法是通过反射得到它的所有Field(包括父类继承得到的)，找出Field中偏移量最大值，然后对该最大偏移值填充字节数即为对象大小；</p><p>关于该方法的使用例子可以看下面的修改内存数据的例子；</p><p><b style="color:#00f">putLong，putInt，putDouble，putChar，putObject等方法，直接修改内存数据（可以越过访问权限）</b><br>这里，还有put对应的get方法，很简单就是直接读取内存地址处的数据，不做举例；</p><p>我们可以举个putLong(Object, long, long)方法详细看下其具体实现，其它的类似，先看Java的源码，没啥好看的，就声明了一个native本地方法：</p><p>三个参数说明下：</p><p>Object o//对象引用<br>long offset//对象内存地址的偏移量<br>long x//写入的数据<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native void    putLong(Object o, long offset, long x);</span><br></pre></td></tr></table></figure><p></p><p>还是看下natUnsafe.cc中的c++实现吧，很简单，就是计算要写入数据的内存地址，然后写入数据，如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void sun::misc::Unsafe::putLong (jobject obj, jlong offset, jlong value)</span><br><span class="line">&#123;</span><br><span class="line">  jlong *addr = (jlong *) ((char *) obj + offset);//计算要修改的数据的内存地址=对象地址+成员属性地址偏移量</span><br><span class="line">  spinlock lock;//自旋锁，通过循环来获取锁， i386处理器需要加锁访问64位数据，如果是int，则不需要改行代码</span><br><span class="line">  *addr = value;//往该内存地址位置直接写入数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如下例子，即使User类的成员属性是私有的且没有提供对外的public方法，我们还是可以直接在它们的内存地址位置处写入数据，并成功；<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package concurrency;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import sun.reflect.Reflection;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    private String name = &quot;test&quot;; </span><br><span class="line">    private long id = 1;</span><br><span class="line">    private int age = 2;</span><br><span class="line">    private double height = 1.72;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return name + &quot;,&quot; + id + &quot;,&quot; + age + &quot;,&quot; + height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException,</span><br><span class="line">            SecurityException, IllegalArgumentException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        // 通过反射得到theUnsafe对应的Field对象</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        // 设置该Field为可访问</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 通过Field得到该Field对应的具体对象，传入null是因为该Field为static的</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line"></span><br><span class="line">        User user = new User();</span><br><span class="line">        System.out.println(user); //打印test,1,2,1.72</span><br><span class="line">        </span><br><span class="line">        Class userClass = user.getClass();</span><br><span class="line">        Field name = userClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        Field id = userClass.getDeclaredField(&quot;id&quot;);</span><br><span class="line">        Field age = userClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">        Field height = userClass.getDeclaredField(&quot;height&quot;);</span><br><span class="line">        //直接往内存地址写数据</span><br><span class="line">        unsafe.putObject(user, unsafe.objectFieldOffset(name), &quot;midified-name&quot;);</span><br><span class="line">        unsafe.putLong(user, unsafe.objectFieldOffset(id),100l);</span><br><span class="line">        unsafe.putInt(user, unsafe.objectFieldOffset(age), 101);</span><br><span class="line">        unsafe.putDouble(user, unsafe.objectFieldOffset(height), 100.1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(user);//打印midified-name,100,101,100.1</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><b style="color:#00f">copyMemory、freeMemory</b><br>copyMemory：内存数据拷贝</p><p>freeMemory：用于释放allocateMemory和reallocateMemory申请的内存</p><p><b style="color:#00f">CAS操作的方法，compareAndSwapInt，compareAndSwapLong等</b><br>看下natUnsafe.cc中的c++实现吧，加深理解，其实就是将内存值与预期值作比较，判断是否相等，相等的话，写入数据，不相等不做操作，返回旧数据；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline bool</span><br><span class="line">compareAndSwap (volatile jint *addr, jint old, jint new_val)</span><br><span class="line">&#123;</span><br><span class="line">  jboolean result = false;</span><br><span class="line">  spinlock lock;</span><br><span class="line">  if ((result = (*addr == old)))</span><br><span class="line">    *addr = new_val;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* compareAndSwapObject(Object var1, long var2, Object var3, Object var4)</span><br><span class="line">* var1 操作的对象</span><br><span class="line">* var2 操作的对象属性偏移</span><br><span class="line">* var3 var2与var3比较，相等才更新</span><br><span class="line">* var4 更新值</span><br><span class="line">*/</span><br><span class="line">return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val)</span><br></pre></td></tr></table></figure><p>J.U.C里原子类就是基于以上CAS操作实现的；</p><p><b style="color:#00f">getLongVolatile/putLongVolatile等等方法</b><br>这类方法使用volatile语义去存取数据，我的理解就是各个线程不缓存数据，直接在内存中读取数据；</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQva2VybmVsX3N5bmNocm9uaXphdGlvbi9zcGlubG9jay5odG1s" title="http://www.wowotech.net/kernel_synchronization/spinlock.html">Linux内核同步机制之（四）：spin lock<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS9zdW4tbWlzYy11bnNhZmUv" title="http://ifeve.com/sun-misc-unsafe/">并发编程网Java Magic. Part 4: sun.misc.Unsafe<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbnBpL3AvNTM4OTI1NC5odG1s" title="https://www.cnblogs.com/chenpi/p/5389254.html">原文：sun.misc.Unsafe的理解<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中Map学习</title>
      <link href="//java/java%E4%B8%ADMap%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/java%E4%B8%ADMap%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>这里写的是基于Java7的版本，java8已经改了实现的方式，主要是红黑树的实现，Entry更名为Node。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>map是一个接口， 但是在这个接口的内部也定义了一个接口Entry，用于标识映射项（键-值对）。</p><p>java8中有默认的实现和加了一些方法。</p><h2 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h2><p>此类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。</p><p>要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet() 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add 或 remove 方法，其迭代器也不支持 remove 方法。</p><p>这个类的设计巧妙之处就是在这个entrySet()的抽象方法。典型的模板方法模式。</p><p>这个类的内部的Entry类是SimpleEntry。</p><p>这个的类基本实现都是靠着迭代器模式，遍历entrySet来实现基础的各个功能。</p><p>我们先看一个基础的实现，不涉及具体的操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    Entry&lt;K,V&gt; correctEntry = null;</span><br><span class="line">    if (key==null) &#123;</span><br><span class="line">        while (correctEntry==null &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            if (e.getKey()==null)</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (correctEntry==null &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            if (key.equals(e.getKey()))</span><br><span class="line">                correctEntry = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V oldValue = null;</span><br><span class="line">    if (correctEntry !=null) &#123;</span><br><span class="line">        oldValue = correctEntry.getValue();</span><br><span class="line">        i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>里面的put方法这个类没有实现，remove函数我们可以看到默认还是使用迭代器的模式实现的。感觉更像是在使用数组实现。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>默认的初始化大小为16. 最大容量为1&gt;&gt;30,就是2的30次方的大小吧！默认的加载因子是0.75（当然可以指定），也就是扩容的临界值等于容量的0.75。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">// 存放集合</span><br><span class="line">transient Entry&lt;K,V&gt;[] table;</span><br><span class="line">transient int size;</span><br><span class="line">// 下一个重新扩容的阈值（默认capacity * load factor）</span><br><span class="line">int threshold;</span><br><span class="line">final float loadFactor;</span><br><span class="line">transient int modCount;</span><br></pre></td></tr></table></figure><p></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>HashMap 包含如下几个构造器：</p><ul><li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li><li>ashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li><li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line"></span><br><span class="line">    // Find a power of 2 &gt;= initialCapacity</span><br><span class="line">    int capacity = 1;</span><br><span class="line">    while (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    // 决定下次访问的阈值</span><br><span class="line">    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    table = new Entry[capacity];</span><br><span class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下Entry的结构<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    final int hash;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="核心方法解读"><a href="#核心方法解读" class="headerlink" title="核心方法解读"></a>核心方法解读</h3><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //其允许存放null的key和null的value，当其key为null时，调用putForNullKey方法，放入到table[0]的这个位置</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    //通过调用hash方法对key进行哈希，得到哈希之后的数值。该方法实现可以通过看源码，其目的是为了尽可能的让键值对可以分不到不同的桶中</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    //根据上一步骤中求出的hash得到在数组中是索引i</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    //如果i处的Entry不为null，则通过其next指针不断遍历e元素的下一个元素。</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key相同，新的值会替换旧的值并返回旧的值，如果旧的值不存在就返回null。</p><p>从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的 hashCode 重新计算 hash 值，根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p><p>还有就是put一个为null的key，这个是放在table[0]这个位置的（很重要的一个点）。</p><p>注意addEntry(hash, key, value, i)方法根据计算出的 hash 值，将 key-value 对放在数组 table 的 i 索引处。addEntry 是 HashMap 提供的一个包访问权限的方法。这个就是职责分离的一个最基本的应用，代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        // 获取指定 bucketIndex 索引处的 Entry</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entr</span><br><span class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>hash(int h)方法根据 key 的 hashCode 重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的 hash 冲突。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    if (useAltHashing) &#123;</span><br><span class="line">        if (k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h = hashSeed;</span><br><span class="line">    &#125;</span><br><span class="line">    //得到k的hashcode值</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    //进行计算</span><br><span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>“模”运算的消耗还是比较大的，在 HashMap 中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;  </span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。在 HashMap 构造器中有如下代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int capacity = 1;</span><br><span class="line">    while (capacity &lt; initialCapacity)  </span><br><span class="line">        capacity &lt;&lt;= 1;</span><br></pre></td></tr></table></figure><p></p><p>这段代码保证初始化时 HashMap 的容量总是 2 的 n 次方，即底层数组的长度总是为 2 的 n 次方。</p><p>当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap基于红黑树实现的。查看“键”或“键值对”时，它们会被排序（次序由Comparable或Comparator决定）。TreeMap的特点在于，所得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Comparamtor接口"><a href="#Comparamtor接口" class="headerlink" title="Comparamtor接口"></a>Comparamtor接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    // 左孩子</span><br><span class="line">    Entry&lt;K,V&gt; left = null;</span><br><span class="line">    // 右孩子</span><br><span class="line">    Entry&lt;K,V&gt; right = null;</span><br><span class="line">    // 父节点</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    // 默认颜色是黑</span><br><span class="line">    boolean color = BLACK;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 根据给定的键、值、父节点构造一个节点，颜色为默认的黑色</span><br><span class="line">    */</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getKey() &#123;return key;&#125;</span><br><span class="line">    public V getValue() &#123;return value;&#125;</span><br><span class="line">    public V setValue(V value) &#123;</span><br><span class="line">        V oldValue = this.value;</span><br><span class="line">        this.value = value;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line">            return false;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        int keyHash = (key==null ? 0 : key.hashCode());</span><br><span class="line">        int valueHash = (value==null ? 0 : value.hashCode());</span><br><span class="line">        return keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;   return key + &quot;=&quot; + value;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt;</span><br><span class="line">    extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>NavigableMap接口扩展的SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法。方法lowerEntry、floorEntry、ceilingEntry和higherEntry分别返回与小于、小于等于、大于等于、大于给定键的键关联的Map.Entry对象，如果不存在这样的键，则返回null。类似地，方法lowerKey、floorKey、ceilingKey和higherKey只返回关联的键。所有这些方法是为查找条目而不是遍历条目而设计的（后面会逐个介绍这些方法）。其实就是以此为方法进行分树进行操作。</p><p>SortedMap就是可排序的鼻祖接口，里面有基本的分树的接口。</p><h3 id="TreeMap属性"><a href="#TreeMap属性" class="headerlink" title="TreeMap属性"></a>TreeMap属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 用于保持顺序的比较器，如果为空的话使用自然顺保持Key的顺序</span><br><span class="line">private final Comparator&lt;? super K&gt; comparator;</span><br><span class="line">// 根节点</span><br><span class="line">private transient Entry&lt;K,V&gt; root = null;</span><br><span class="line">// 树中的节点数量</span><br><span class="line">private transient int size = 0;</span><br><span class="line">// 多次在集合类中提到了，用于举了结构行的改变次数</span><br><span class="line">private transient int modCount = 0;</span><br></pre></td></tr></table></figure><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public TreeMap() &#123;</span><br><span class="line">    comparator = null;</span><br><span class="line">&#125;</span><br><span class="line">// 构造方法二，提供指定的比较器(这个功能很赞，有木有)</span><br><span class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line">public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    comparator = null;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line">// 构造方法四，接收SortedMap参数，根据SortedMap的比较器维持TreeMap中的节点顺序，* 同时通过</span><br><span class="line">// buildFromSorted(int size, Iterator it, java.io.ObjectInputStream str, V defaultVal)方* 法</span><br><span class="line">// 将SortedMap中的内容添加到TreeMap中(其实就是通过其他的SortedMap进行初始化)</span><br><span class="line">public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    try &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);</span><br><span class="line">    &#125; catch (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; catch (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h3><p>ok，了解了上面的基础知识之后，我们来看看put方法的内容，从而了解内部的结构。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        // 如果根节点为空，将传入的键值对构造成根节点（根节点没有父节点，所以传入的父节点为null）</span><br><span class="line">        compare(key, key); // type (and possibly null) check</span><br><span class="line"></span><br><span class="line">        root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">        size = 1;</span><br><span class="line">        modCount++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int cmp; // 用于记录比较结果</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    // split comparator and comparable paths</span><br><span class="line">    // 分割比较器和可比较接口的处理</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">    if (cpr != null) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 注意treeMap不支持null的操作</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        // Key本身是Comparable的接口，也就是说Comparable和Comparator的区别在这个地方</span><br><span class="line">        // 一个是类来实现，一个是外部实现而已</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有找到节点的话，新建节点，并放入到树中</span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    if (cmp &lt; 0)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    else</span><br><span class="line">        parent.right = e;</span><br><span class="line">    // 检查是否符合红黑树的规范，不符合进行调整。</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在put(K key,V value)方法的末尾调用了fixAfterInsertion(Entry&lt;K,V&gt; x)方法，这个方法负责在插入节点后调整树结构和着色，以满足红黑树的要求。</p><ul><li>每一个节点或者着成红色，或者着成黑色。</li><li>根是黑色的。</li><li>如果一个节点是红色的，那么它的子节点必须是黑色的。</li><li>一个节点到一个null引用的每一条路径必须包含相同数量的黑色节点。</li></ul><p>在看fixAfterInsertion(Entry&lt;K,V&gt; x)方法前先看一个红黑树的内容：红黑树不是严格的平衡二叉树，它并不严格的保证左右子树的高度差不超过1，但红黑树高度依然是平均log(n)，且最坏情况高度不会超过2log(n)，所以它算是平衡树。</p><p>下面的功能和这里类似，这里我们就不再深入分析了，更多的分析请查看引用</p><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>和 HashMap 一样，Hashtable 也是一个散列表，它存储的内容是键值对。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Hashtable&lt;K,V&gt;</span><br><span class="line">    extends Dictionary&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><p>Dictionary类是一个抽象类，用来存储键/值对，作用和Map类相似。</p><p>给出键和值，你就可以将值存储在Dictionary对象中。一旦该值被存储，就可以通过它的键来获取它。所以和Map一样， Dictionary 也可以作为一个键/值对列表。这个Dictionary应该是过时了。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。</p><ul><li>table是一个 Entry[] 数组类型，而 Entry（在 HashMap 中有讲解过）实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。</li><li>count 是 Hashtable 的大小，它是 Hashtable 保存的键值对的数量。</li><li>threshold 是 Hashtable 的阈值，用于判断是否需要调整 Hashtable 的容量。threshold 的值=”容量*加载因子”。</li><li>loadFactor 就是加载因子。</li><li>modCount 是用来实现 fail-fast 机制的。</li></ul><h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><ol><li>默认的初始容量是11，加载因子还是0.75，这意味着扩展的实现可能是不一样的。</li><li>put不支持key为null</li><li>方法synchronized同步。</li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？</p><p>LinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用 get 方法)的链表。<b style="color:red">默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</b></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对于 LinkedHashMap 而言，它继承与 HashMap(public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;)、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类 HashMap 相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析 LinkedHashMap 的源代码：</p><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><p>LinkedHashMap 采用的 hash 算法和 HashMap 相同，但是它重新定义了数组中保存的元素 Entry，该 Entry 除了保存当前对象的引用外，还保存了其上一个元素 before 和下一个元素 after 的引用，从而在哈希表的基础上又构成了双向链接列表。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line">* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line">* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。</span><br><span class="line">*/</span><br><span class="line">private final boolean accessOrder;</span><br><span class="line">/**</span><br><span class="line">* 双向链表的表头元素。</span><br><span class="line"> */</span><br><span class="line">private transient Entry&lt;K,V&gt; header;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* LinkedHashMap的Entry元素。</span><br><span class="line">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。</span><br><span class="line"> */</span><br><span class="line">private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过源代码可以看出，在 LinkedHashMap 的构造方法中，实际调用了父类 HashMap 的相关构造方法来构造一个底层存放的 table 数组，但额外可以增加 accessOrder 这个参数，如果不设置，默认为 false，代表按照插入顺序进行迭代；当然可以显式设置为 true，代表以访问顺序进行迭代。如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) &#123;</span><br><span class="line">    super(initialCapacity, loadFactor);</span><br><span class="line">    this.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>LinkedHashMap 并未重写父类 HashMap 的 put 方法，而是重写了父类 HashMap 的 put 方法调用的子方法void recordAccess(HashMap m) ，void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">    if (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        remove();</span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 调用create方法，将新元素以双向链表的的形式加入到映射中。</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line"></span><br><span class="line">    // 删除最近最少使用元素的策略定义</span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;</span><br><span class="line">    if (removeEldestEntry(eldest)) &#123;</span><br><span class="line">        removeEntryForKey(eldest.key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (size &gt;= threshold)</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    // 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。  </span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = this;</span><br><span class="line">    after.before = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>LinkedHashMap 重写了父类 HashMap 的 get 方法，实际在调用父类 getEntry() 方法取得查找的元素后，再判断当排序模式 accessOrder 为 true 时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    // 调用父类HashMap的getEntry()方法，取得要查找的元素。</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">    if (e == null)</span><br><span class="line">        return null;</span><br><span class="line">    // 记录访问顺序。</span><br><span class="line">    e.recordAccess(this);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;</span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">    // 如果定义了LinkedHashMap的迭代顺序为访问顺序，</span><br><span class="line">    // 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。  </span><br><span class="line">    if (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++;</span><br><span class="line">        remove();</span><br><span class="line">        addBefore(lm.header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Removes this entry from the linked list.</span><br><span class="line">*/</span><br><span class="line">private void remove() &#123;</span><br><span class="line">    before.after = after;</span><br><span class="line">    after.before = before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**clear链表，设置header为初始状态*/</span><br><span class="line">public void clear() &#123;</span><br><span class="line"> super.clear();</span><br><span class="line"> header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="排序模式"><a href="#排序模式" class="headerlink" title="排序模式"></a>排序模式</h4><p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p><p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个 LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造 LinkedHashMap：public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</p><p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建 LRU 缓存。LinkedHashMap 提供了 removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) 方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</p><p>我们其实可以利用 LinkedHashMap 构建 LRU 缓存。</p><h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a><b style="color:red">EnumMap</b></h2><p>EnumMap是处理Enum为key的优化，没有仔细看源码，但是看到put方法时，就大概明白优化的地方在哪了！没有hash函数，使用Enum.ordinal()作为散列函数确实妙，这样没有key冲突，直接访问即可，性能会有一定提升。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // 类型检查</span><br><span class="line">    typeCheck(key);</span><br><span class="line"></span><br><span class="line">    // 找到枚举的索引（注意这里是利用枚举的index作为hash值，的确很好使）</span><br><span class="line">    int index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    if (oldValue == null)</span><br><span class="line">        size++;</span><br><span class="line">    return unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里就是简单介绍一下，具体还是查看源码的具体实现</p><h2 id="关于fail-fast-和-fail-safe的区别"><a href="#关于fail-fast-和-fail-safe的区别" class="headerlink" title="关于fail-fast 和 fail-safe的区别"></a>关于fail-fast 和 fail-safe的区别</h2><p>这里为了解决并发的问题，一般采用这两种机制。一般来说容器都是线程不安全的，特别是迭代器进行访问的时候特别容易出现问题。下面我们来大概解释一下这个概念。</p><p>其实就是通过版本号防止并发的问题，但是呢？光通过版本号是解决不了问题的，所以这里的这种机制是带有欺骗性的，只是会减少并发的问题，但是真正并发量大的时候，问题是解决不了的。</p><p>fail-fast就是发现版本号不对的时候抛异常，fail-safe不会抛异常，会优雅地返回错误而已。另外fail-safe是通过clone来保证访问没有问题的。下面列个表看一下：</p><table><thead><tr><th style="text-align:center">item</th><th style="text-align:center">Fail Fast Iterator</th><th style="text-align:center">Fail Safe Iterator</th></tr></thead><tbody><tr><td style="text-align:center">Throw ConcurrentModification Exception</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">Clone object</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center">Memory Overhead</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center">Examples</td><td style="text-align:center">HashMap, Vector, ArrayList, HashSet</td><td style="text-align:center">CopyOnWriteArrayList, ConcurrentHashMap</td></tr></tbody></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2g3MTc4MjgvYXJ0aWNsZS9kZXRhaWxzLzQ2ODkyMDUx" title="http://blog.csdn.net/ch717828/article/details/46892051">java中fail-fast 和 fail-safe的区别<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbmNoYW9mdWNrMS9hcnRpY2xlL2RldGFpbHMvNTEyOTcwNzc=" title="http://blog.csdn.net/chenchaofuck1/article/details/51297077">JDK源码学习(2)-TreeMap源码分析<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1jb2xsZWN0aW9ucy5odG1s" title="http://www.runoob.com/java/java-collections.html">Java 集合框架<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2phdmEvamF2YS1kaWN0aW9uYXJ5LWNsYXNzLmh0bWw=" title="http://www.runoob.com/java/java-dictionary-class.html">Java Dictionary 类<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvamF2YS1jb2xsZWN0aW9uL2hhc2h0YWJsZS5odG1s" title="http://wiki.jikexueyuan.com/project/java-collection/hashtable.html">Hashtable 的实现原理<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly95aWt1bi5naXRodWIuaW8vMjAxNS8wNC8wMi9KYXZhLUxpbmtlZEhhc2hNYXAlRTUlQjclQTUlRTQlQkQlOUMlRTUlOEUlOUYlRTclOTAlODYlRTUlOEYlOEElRTUlQUUlOUUlRTclOEUlQjAv" title="https://yikun.github.io/2015/04/02/Java-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java LinkedHashMap工作原理及实现<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中list学习</title>
      <link href="//java/java%E4%B8%ADlist%E5%AD%A6%E4%B9%A0.html"/>
      <url>//java/java%E4%B8%ADlist%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>好久没有认真学习java了，可能是前阶段的事情比较多，现在觉得还是要认真学习才行。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先所有的集合类都是Collection这个接口的子类，它的默认实现是AbstractCollection实现类。这是一个抽象类，提供一些默认的实现啥的。其实就是一些基本的功能实现。</p><p>关于List结合，我们先看一下List即可，这是所有List的基类。接下是基础的实现类AbstractList，这个继承自AbstractCollection，实现了List接口。从源码的分析上我们可以看出AbstractList是支持null元素的操作的。</p><p>在AbstractList类中有迭代器的内部类的实现。在这个类中有两种迭代器，一种是Iterator的实现类，另一种是ListIterator的实现类。我觉得这种内部类的实现方式有助于，公用类实例的空间，这样我们迭代器的实现就比较简单，不用拷贝List数组了，因为在外部类中有自己的List实例可以直接调用，可为简单呀！</p><p>ListIterator是继承Iterator的，定义了一些自己针对List的扩展而已。</p><h2 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h2><p>我们来看看这个类里面的subList方法，这个方法我很少用，不过看起来很好玩：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">    // 如果是RandomAccess的实例，那么就创建RandomAccessSubList实例，否则就创建SubList实例</span><br><span class="line">    return (this instanceof RandomAccess ?</span><br><span class="line">            new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex) :</span><br><span class="line">            new SubList&lt;&gt;(this, fromIndex, toIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>RandomAccess其实就是一个接口。标记为一个可以随机访问的作用。这里的RandomAccessSubList和SubList都在这个类定义的文件中出现定义。有兴趣可以查看这些实现。</p><p>看一下hashCode()的实现吧，这个也挺有趣。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int hashCode = 1;</span><br><span class="line">    for (E e : this)</span><br><span class="line">        hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());</span><br><span class="line">    return hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h2><p>AbstractSequentialList意思是按照顺序的访问，也就是顺序访问。我们来看看这里类通过迭代器的实现，这就是迭代器的实现。也许这就是顺序访问的意思吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return listIterator(index).next();</span><br><span class="line">    &#125; catch (NoSuchElementException exc) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ListIterator&lt;E&gt; e = listIterator(index);</span><br><span class="line">        E oldVal = e.next();</span><br><span class="line">        // 设置index索引的值</span><br><span class="line">        e.set(element);</span><br><span class="line">        return oldVal;</span><br><span class="line">    &#125; catch (NoSuchElementException exc) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>迭代器中index就是要传入迭代器开始迭代的地方而已。其他的类也就是这些类似的实现。这些我们不再说明，只是这部分知识的大概叙述，具体还是要去查看源码的实现。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList 是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比 ArrayList 更加高效。但也是由于其为基于链表的，所以随机访问的效率要比ArrayList差。我们来看一下继承的结构。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>双向队列Deque，这是一个接口，继承自Queue。Queue是队列，继承自Collection。关于队列的数据结构，我们会在后面的一篇博文中进行分析。下面是Queue接口的方法解释：</p><table><thead><tr><th>方法名</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>add</td><td>增加一个元索</td><td>如果队列已满，则抛出一个IIIegaISlabEepeplian异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>element</td><td>返回队列头部的元素</td><td>如果队列为空，则抛出一个NoSuchElementException异常</td></tr><tr><td>offer</td><td>添加一个元素并返回true</td><td>如果队列已满，则返回false</td></tr><tr><td>poll</td><td>移除并返问队列头部的元素</td><td>如果队列为空，则返回null</td></tr><tr><td>peek</td><td>返回队列头部的元素</td><td>如果队列为空，则返回null</td></tr><tr><td>put</td><td>添加一个元素</td><td>如果队列满，则阻塞</td></tr><tr><td>take</td><td>移除并返回队列头部的元素</td><td>如果队列为空，则阻塞</td></tr></tbody></table><p>Deque接口列表如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>getFirst()</td><td>返回头部元素, 不删除该元素</td></tr><tr><td>getLast()</td><td>返回末尾元素,不删除该元素</td></tr><tr><td>peekFirst()</td><td>返回头部元素,不删除该元素</td></tr><tr><td>peekLast()</td><td>返回末尾元素,不删除该元素</td></tr><tr><td>pollFirst()</td><td>返回头部元素并且删除该元素</td></tr><tr><td>pollLast()</td><td>返回尾部元素并且删除该元素</td></tr><tr><td>removeFirst()</td><td>返回头部元素并且删除该元素</td></tr><tr><td>removeLast()</td><td>返回尾部元素并且删除该元素</td></tr><tr><td>removeFirstOccurrence(Object)</td><td>由头至尾删除第一次出现在列表中的元素</td></tr><tr><td>removeLastOccurrence(Object)</td><td>由尾至头删除第一次出现在列表中的元素</td></tr><tr><td>pop()</td><td>从末尾取出并且删除元素</td></tr></tbody></table><p>所以说LinkedList就是一个双端队列。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>LinkedList 是基于链表结构实现，所以在类中包含了 first 和 last 两个指针(Node)。Node 中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br><span class="line">transient Node&lt;E&gt; first; //链表的头指针</span><br><span class="line">transient Node&lt;E&gt; last; //尾指针</span><br><span class="line">//存储对象的结构 Node, LinkedList的内部类</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next; // 指向下一个节点</span><br><span class="line">    Node&lt;E&gt; prev; //指向上一个节点</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>直接看方法吧：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* Links e as last element.</span><br><span class="line">*/</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其他方法和这个类似，其实只是链表的操作而已。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList 可以理解为动态数组。每个 ArrayList 实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造 ArrayList 时指定其容量。在添加大量元素前，应用程序也可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量，这可以减少递增式再分配的数量。</p><p>我们看一下实现的接口吧！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p></p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>一般需要指明capcity的大小。ArrayList 提供了三种方式的构造器：</p><ul><li>public ArrayList()可以构造一个默认初始容量为10的空列表；</li><li>public ArrayList(int initialCapacity)构造一个指定初始容量的空列表；</li><li>public ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</li></ul><h3 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h3><p>我们来看看一些操作：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    // 需要gc去做一些操作</span><br><span class="line">    elementData[--size] = null; // Let gc do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>下面我们看看add方法，该方法是将指定的元素添加到列表的尾部。当容量不足时，会调用 grow 方法增长容量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    // 看一下扩容方式，是1.5倍进行扩容。</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="删除的方法"><a href="#删除的方法" class="headerlink" title="删除的方法"></a>删除的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = null; // Let gc do its work</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br><span class="line">// 删除函数</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h4><p>从上面介绍的向 ArrayList 中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容有两个方法，其中开发者可以通过一个 public 的方法ensureCapacity(int minCapacity)来增加 ArrayList 的容量，而在存储元素等操作过程中，如果遇到容量不足，会调用priavte方法private void ensureCapacityInternal(int minCapacity)实现。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">    if (minCapacity &gt; 0)</span><br><span class="line">        ensureCapacityInternal(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line">// growth方法上面是有的</span><br></pre></td></tr></table></figure><p></p><h4 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h4><p>ArrayList 也采用了快速失败的机制，通过记录 modCount 参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector也是一个List，但是这里面是线程安全的，而且没有实现迭代器模式。或者说Enumeration也是迭代器模式。另外没有扩容因子这个东西的存在，默认是以两倍的方式进行扩容，但是可以指定每次扩容的量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    // 扩容方式是翻倍或者用户指定的扩容参数即可</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        // 防止容量不够</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        // 不能超过上限，其实没有上限的</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // 进行扩容存放元素。</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized boolean removeElement(Object obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = indexOf(obj);</span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void removeElementAt(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (index &gt;= elementCount) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br><span class="line">                                                    elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (index &lt; 0) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    int j = elementCount - index - 1;</span><br><span class="line">    if (j &gt; 0) &#123;</span><br><span class="line">        System.arraycopy(elementData, index + 1, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = null; /* to let gc do its work */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>细节方面就不多写了。下面看一下Enumeration接口<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Enumeration&lt;E&gt; &#123;</span><br><span class="line">    boolean hasMoreElements();</span><br><span class="line">    E nextElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack是Vector的子类。实现的是后入先出的队列功能。里面基本上没有添加什么功能，就是新定义了几个函数。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>push</td><td>加入元素，调用的是Vector的addElement方法，返回压栈的元素</td></tr><tr><td>pop</td><td>弹出栈顶的元素，如果栈是空的抛出异常</td></tr><tr><td>peek</td><td>查看栈顶的元素，如果栈是空的，就抛出异常</td></tr><tr><td>empty</td><td>注意这个是判断栈是不是空的</td></tr><tr><td>search</td><td>在栈中找某个元素，返回索引，没有返回-1</td></tr></tbody></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9lbmQvYXJjaGl2ZS8yMDEyLzEwLzI1LzI3Mzg0OTMuaHRtbA==" title="http://www.cnblogs.com/end/archive/2012/10/25/2738493.html">java中queue的使用<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言如何实现继承和多态</title>
      <link href="//golang/Go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81.html"/>
      <url>//golang/Go%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实golang里是不提倡继承的，也不提倡重载的。但是有些场景下，我们还是想试验一下传统C++或Java语言里的继承和重载能否用在golang里。这里是利用了Go语言结构体和接口的特性实现的。</p><p>可以理解接口就是一种抽象，而结构体就是最终干活的，注意这种实现关系并没有java那样直接需要你去implements，所以这种继承和实现的关系，没有那么直观也没有那么富有语法约束能力。也就是我想实现就实现。缺点：</p><ol><li>阅读代码难，可能存在误解</li><li>没有检查机制（其实可以在Go语言的基础上自己写一些插件来进行约束，可以通过变更语法或者逻辑判断，比如说命名）</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">Id   int</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Tester interface &#123;</span><br><span class="line">Test()</span><br><span class="line">Eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *Person) Test() &#123;</span><br><span class="line">fmt.Println(&quot;\tthis =&quot;, &amp;this, &quot;Person.Test&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *Person) Eat() &#123;</span><br><span class="line">fmt.Println(&quot;\tthis =&quot;, &amp;this, &quot;Person.Eat&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Employee 从Person继承, 直接继承了 Eat 方法，并且将 Test 方法覆盖了。</span><br><span class="line">type Employee struct &#123;</span><br><span class="line">Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *Employee) Test() &#123;</span><br><span class="line">fmt.Println(&quot;\tthis =&quot;, &amp;this, &quot;Employee.Test&quot;)</span><br><span class="line">this.Person.Test() // 调用父类的方法，且该方法被子类覆盖了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;An Employee instance :&quot;)</span><br><span class="line">var nu Employee</span><br><span class="line">nu.Id = 2</span><br><span class="line">nu.Name = &quot;NTom&quot;</span><br><span class="line">nu.Test()</span><br><span class="line">nu.Eat()</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;A Tester interface to Employee instance :&quot;)</span><br><span class="line">var t Tester</span><br><span class="line">t = &amp;nu</span><br><span class="line">t.Test()</span><br><span class="line">t.Eat()</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;A Tester interface to Person instance :&quot;)</span><br><span class="line">t = &amp;nu.Person</span><br><span class="line">t.Test()</span><br><span class="line">t.Eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序执行输出"><a href="#程序执行输出" class="headerlink" title="程序执行输出"></a>程序执行输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">An Employee instance :</span><br><span class="line">this = 0xc082024020 Employee.Test</span><br><span class="line">this = 0xc082024028 Person.Test</span><br><span class="line">this = 0xc082024030 Person.Eat</span><br><span class="line"></span><br><span class="line">A Tester interface to Employee instance :</span><br><span class="line">this = 0xc082024038 Employee.Test</span><br><span class="line">this = 0xc082024040 Person.Test</span><br><span class="line">this = 0xc082024048 Person.Eat</span><br><span class="line"></span><br><span class="line">A Tester interface to Person instance :</span><br><span class="line">this = 0xc082024050 Person.Test</span><br><span class="line">this = 0xc082024058 Person.Eat</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多态的实现是通过地址实现，继承是通过结构体复用的逻辑实现的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL2dvL2dvLWludGVyZmFjZXMuaHRtbA==" title="http://www.runoob.com/go/go-interfaces.html">Go 语言接口<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY29kZWcuY24vMjAxNS8wMi8xMi9nb2xhbmctZGVyaXZlLW92ZXJyaWRlLw==" title="http://blog.codeg.cn/2015/02/12/golang-derive-override/">golang学习之继承和重载<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web3 Secret存储定义</title>
      <link href="//blockchain/Web3-Secret%E5%AD%98%E5%82%A8%E5%AE%9A%E4%B9%89.html"/>
      <url>//blockchain/Web3-Secret%E5%AD%98%E5%82%A8%E5%AE%9A%E4%B9%89.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>我最近在阅读以太坊官网的一些源代码，看到keystore的那篇源码之后发现官网关于以太坊生成的UTF8格式的json文件的定义标准，所以去官网看了一下，不是很明白，所以想边看看边记录一下这里面的知识。一开始的阅读确实比较难理解，这里我们先补充一点基础知识便于阅读。</p><p>这里主要写的是关于以太坊keystore的知识，以太坊的存储是一个内容经过加密的json文件，以太坊的密钥与比特币的密钥不同，除了记住私钥，你还要记住密码。其实就是这个json文件和这个json文件内容解密的密码，否则你就找不到你的账户了。下面的讲解就是这个文件是怎么生成的，加密的方式，json文件中内容以及意义等等。这个我们可以先给出一个这样的json文件，以便于后面正文的阅读。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ethereum/keystore/UTC--&lt;created_date_time&gt;--  008aeeda4d805471df9b2a5b0f38a0c3bcba786b</span><br><span class="line">&#123;</span><br><span class="line">    &quot;crypto&quot; : &#123;</span><br><span class="line">        &quot;cipher&quot; : &quot;aes-128-ctr&quot;,</span><br><span class="line">        &quot;cipherparams&quot; : &#123;</span><br><span class="line">            &quot;iv&quot; : &quot;83dbcc02d8ccb40e466191a123791e0e&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ciphertext&quot; : &quot;d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c&quot;,</span><br><span class="line">        &quot;kdf&quot; : &quot;scrypt&quot;,</span><br><span class="line">        &quot;kdfparams&quot; : &#123;</span><br><span class="line">            &quot;dklen&quot; : 32,</span><br><span class="line">            &quot;n&quot; : 262144,</span><br><span class="line">            &quot;r&quot; : 1,</span><br><span class="line">            &quot;p&quot; : 8,</span><br><span class="line">            &quot;salt&quot; : &quot;ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;mac&quot; : &quot;2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;id&quot; : &quot;3198bc9c-6672-5ab3-d995-4942343ae5b6&quot;,</span><br><span class="line">    &quot;version&quot; : 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在下文的讲解中有些定义没有将清除，这里先对文件中的几个字段做个说明好了，便于阅读：</p><ul><li>cipher：对称 AES 算法的名称;</li><li>cipherparams：上述 cipher 算法需要的参数;</li><li>ciphertext：你的以太坊私钥使用上述 cipher 算法进行加密;</li><li>kdf：密钥生成函数，用于让你用密码加密 keystore 文件;</li><li>kdfparams：上述 kdf 算法需要的参数;</li><li>Mac：用于验证密码的代码。</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了让您的应用程序能够在以太坊上运行，您可以使用web3.js库提供的web3对象。它通过RPC调用与本地节点通信。web3与任何暴露RPC层的以太坊节点一起工作。</p><p>web3包含eth对象 - web3.eth（专门用于以太坊区块链交互）和shh对象 - web3.shh（用于Whisper交互）。随着时间的推移，我们将为其他每个web3协议引入其他对象。下面是一个具体的例子。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var recognizer = require(&apos;ethereum-keyfile-recognizer&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;keyfile.json&apos;, (err, data) =&gt; &#123;</span><br><span class="line">var json = JSON.parse(data);</span><br><span class="line">var result = recognizer(json);</span><br><span class="line">/** result</span><br><span class="line">  *               [ &apos;web3&apos;, 3 ]   web3 (v3) keyfile</span><br><span class="line">  *  [ &apos;ethersale&apos;, undefined ]   Ethersale keyfile</span><br><span class="line">  *                        null     invalid keyfile</span><br><span class="line"> */</span><br><span class="line"> &#125;));</span><br></pre></td></tr></table></figure><p></p><p>这是Web3 secret存储定义的第三版。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>除了AES-128-CBC不再固定加密算法（AES-128-CTR现在是最低要求）之外，文件的实际编码和解码在版本1上基本保持不变。除了mac将衍生密钥的最后16个字节与完整字符串ciphertext联起来进行SHA3（keccak-256）之外，大部分meanings/algorithm与版本1类似。</p><p>密钥文件直接存储在~/.web3/keystore（对于类Unix系统）和~/AppData/Web3/keystore（对于Windows）。它们可以被随意命名，但是比较好的约定是<uuid>.json，这里<uuid>是给出私钥的128位的UUID（私钥地址的隐私保护代理）。</uuid></uuid></p><p>所有这些文件都有一个关联的密码。要导出给定.json文件的密钥，首先要导出文件的加密密钥;这是通过获取文件的密码并根据kdf参数所描述的，通过私钥派生函数传递密码。KDF决定KDF函数的静态和动态参数在kdfparams关键字中有说明。</p><p>PBKDF2必须得到所有最低限度兼容的实现的支持，表示为：</p><ul><li>kdf: pbkdf2</li></ul><p>对于PBKDF2， kdfparams包含以下的一些内容：</p><ul><li>prf：必须是hmac-sha256（可能会在将来扩展）</li><li>c：迭代次数</li><li>salt： 传给PBKDF的盐</li><li>dklen： 生成key的长度，必须&gt;=32</li></ul><p>一旦文件的key被生成出来，就应该通过Mac的派生器来验证。MAC应该计算为字节数组的SHA3（keccak-256）散列，形成为派生密钥的左二十六个字节与ciphertext密钥内容的连接，即：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KECCAK(DK[16..31] ++ &lt;ciphertext&gt;)  // （其中++是连接运算符）</span><br></pre></td></tr></table></figure><p></p><p>这个值应该与mac密钥的内容进行比较; 如果它们不同，则应请求替代密码（或取消操作）。</p><p>文件密钥验证完成后，密文（ciphertext文件中的密钥）可以使用密钥指定的对称加密算法进行解密，cipher并通过密钥进行参数化cipherparams。如果导出的密钥大小和算法的密钥大小不匹配，则应使用派生密钥的零填充最右边的字节作为算法的密钥。</p><p>所有最低限度兼容的实施必须支持AES-128-CTR算法，表示为：</p><ul><li>cipher： aes-128-ctr</li></ul><p>该密码采用以下参数，作为密钥的cipherparams键：</p><ul><li>iv：密码的128位初始化向量。</li></ul><p>密码的关键是派生密钥的最左边的16个字节，即 DK[0..15]</p><p>密钥的创建/加密应基本上与这些指令相反。确保uuid，salt并且iv实际上是随机的。</p><p>除了version应该作为版本的“硬”标识符的字段之外，实现还可以minorversion用于追踪对格式的更小的，不中断的更改。</p><h2 id="测试举例"><a href="#测试举例" class="headerlink" title="测试举例"></a>测试举例</h2><p>细节：</p><ul><li>Address: 008aeeda4d805471df9b2a5b0f38a0c3bcba786b</li><li>ICAP: XE542A5PZHH8PYIZUBEJEO0MFWRAPPIL67</li><li>UUID: 3198bc9c-6672-5ab3-d9954942343ae5b6</li><li>Password: testpassword</li><li>Secret: 7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d</li></ul><h3 id="PBKDF2-SHA-256"><a href="#PBKDF2-SHA-256" class="headerlink" title="PBKDF2-SHA-256"></a>PBKDF2-SHA-256</h3><p>使用AES-128-CTR和PBKDF2-SHA-256的测试向量：</p><p>文件内容~/.web3/keystore/3198bc9c-6672-5ab3-d9954942343ae5b6.json：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     “ crypto ”：&#123;</span><br><span class="line">         “ cipher ”：“ aes-128-ctr ”，</span><br><span class="line">         “ cipherparams ”：&#123;</span><br><span class="line">             “ iv ”：“ 6087dab2f9fdbbfaddc31a909735c1e6 ”</span><br><span class="line">        &#125;，</span><br><span class="line">        “ ciphertext ”： “ 5318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46 ”，</span><br><span class="line">         “ kdf ”： “ pbkdf2 ”，</span><br><span class="line">         “ kdfparams ”：&#123;</span><br><span class="line">             “ c ”： 262144，</span><br><span class="line">             “ dklen ”： 32，</span><br><span class="line">             “ prf ”： “ hmac-sha256 ”，</span><br><span class="line">             “ salt ”：“ae3cd4e7013836a3df6bd7241b12db061dbe2c6785853cce422d148a624ce0bd “</span><br><span class="line">        &#125;，</span><br><span class="line">        “ mac ”： “ 517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2 ”</span><br><span class="line">    &#125;，</span><br><span class="line">    “ id ”： “ 3198bc9c-6672-5ab3-d995-4942343ae5b6 ”，</span><br><span class="line">     “ version ”： 3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>中间结果：</p><ul><li>Derived key: f06d69cdc7da0faffb1008270bca38f5e31891a3a773950e6d0fea48a7188551</li><li>MAC Body: e31891a3a773950e6d0fea48a71885515318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46</li><li>MAC 517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2</li><li>Cipher key: f06d69cdc7da0faffb1008270bca38f5<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3>使用AES-128-CTR和Scrypt的测试矢量：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;crypto&quot; : &#123;</span><br><span class="line">        &quot;cipher&quot; : &quot;aes-128-ctr&quot;,</span><br><span class="line">        &quot;cipherparams&quot; : &#123;</span><br><span class="line">            &quot;iv&quot; : &quot;83dbcc02d8ccb40e466191a123791e0e&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ciphertext&quot; : &quot;d172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c&quot;,</span><br><span class="line">        &quot;kdf&quot; : &quot;scrypt&quot;,</span><br><span class="line">        &quot;kdfparams&quot; : &#123;</span><br><span class="line">            &quot;dklen&quot; : 32,</span><br><span class="line">            &quot;n&quot; : 262144,</span><br><span class="line">            &quot;r&quot; : 1,</span><br><span class="line">            &quot;p&quot; : 8,</span><br><span class="line">            &quot;salt&quot; : &quot;ab0c7876052600dd703518d6fc3fe8984592145b591fc8fb5c6d43190334ba19&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;mac&quot; : &quot;2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;id&quot; : &quot;3198bc9c-6672-5ab3-d995-4942343ae5b6&quot;,</span><br><span class="line">    &quot;version&quot; : 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>中间结果</p><ul><li>Derived key: fac192ceb5fd772906bea3e118a69e8bbb5cc24229e20d8766fd298291bba6bd</li><li>MAC Body bb5cc24229e20d8766fd298291bba6bdd172bf743a674da9cdad04534d56926ef8358534d458fffccd4e6ad2fbde479c</li><li>MAC: 2103ac29920d71da29f15d75b4a16dbe95cfd7ff8faea1056c33131d846e3097</li><li>Cipher key: fac192ceb5fd772906bea3e118a69e8b</li></ul><h2 id="版本1中的更改"><a href="#版本1中的更改" class="headerlink" title="版本1中的更改"></a>版本1中的更改</h2><p>该版本修复了此处发布的版本1的几个不一致之处。简而言之，这些是：</p><ul><li>大小写不合理且不一致（scrypt小写，Kdf混合大小写，MAC大写）。</li><li>Address 不必要和妥协的隐私。</li><li>Salt 本质上是密钥派生函数的一个参数，值得关联它，而不是一般的密码。</li><li>SaltLen不必要的（从中推导出来Salt）。</li><li>给出了密钥导出函数，但加密算法很难确定。</li><li>Version 本质上是数字，但是是一个字符串（可以使用字符串进行结构化版本控制，但可以认为超出了很少更改的配置文件格式）。</li><li>KDF和密码是概念上的兄弟概念，但组织方式不同。</li><li>MAC是通过一个空白不可知的数据块来计算的（！）</li></ul><p>已对格式进行了更改，以提供以下文件，功能上与前面链接页面上给出的示例相同：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     “ crypto ”：&#123;</span><br><span class="line">         “ cipher ”：“ aes-128-cbc ”，</span><br><span class="line">         “ ciphertext ”：“ 07533e172414bfa50e99dba4a0ce603f654ebfa1ff46277c3e0c577fdc87f6bb4e4fe16c5a94ce6ce14cfa069821ef9b ”，</span><br><span class="line">         “ cipherparams ”：&#123;</span><br><span class="line">             “ iv ”：“ 16d67ba0ce5a339ff2f07951253e6ba8 ”</span><br><span class="line">        &#125;，</span><br><span class="line">        “ kdf ”： “ scrypt ”，</span><br><span class="line">         “ kdfparams ”：&#123;</span><br><span class="line">             “ dklen ”： 32，</span><br><span class="line">             “ n ”： 262144，</span><br><span class="line">             “ p ”： 1，</span><br><span class="line">             “ r ”： 8，</span><br><span class="line">             “ salt ”： “ 06870e5e6a24e183a5c807bd1c43afd86d573f7db303ff4853d135cd0fd3fe91 ”</span><br><span class="line">        &#125;，</span><br><span class="line">        “ mac ”： “ 8ccded24da2e99a11d48cda146f9cc8213eb423e2ea0d8427f41c3be414424dd ”，</span><br><span class="line">         “版本”： 1</span><br><span class="line">    &#125;，</span><br><span class="line">    “ id ”： “ 0498f19a-59db-4d54-ac95-33901b4f1870 ”，</span><br><span class="line">     “ version ”： 2 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="版本2中的更改"><a href="#版本2中的更改" class="headerlink" title="版本2中的更改"></a>版本2中的更改</h2><p>版本2是一个早期的C++实现，带有许多错误。所有其中的东西保持不变。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9XZWIzLVNlY3JldC1TdG9yYWdlLURlZmluaXRpb24=" title="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret Storage Definition<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2V0aGZhbnMub3JnL3Bvc3RzL3doYXQtaXMtYW4tZXRoZXJldW0ta2V5c3RvcmUtZmlsZQ==" title="http://ethfans.org/posts/what-is-an-ethereum-keystore-file">科普 | 什么是以太坊私钥储存（Keystore）文件？<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 私钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mmap</title>
      <link href="//syslib/mmap.html"/>
      <url>//syslib/mmap.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>在计算机中，mmap(2)是符合POSIX标准的Unix 系统调用，可将文件或设备映射到内存中。它是内存映射文件 I/O的一种方法。它自然地实现了需求分页，因为文件内容最初不是从磁盘读取的，根本不使用物理RAM。在访问特定位置后，实际从磁盘读取数据的操作将以“懒惰”方式执行。在不再需要存储器之后，munmap(2)指向它的指针很重要。保护信息可以使用管理mprotect(2)，特殊处理可以使用强制执行madvise(2)。</p><p>个人的理解就是，直接跳过操作系统的内核空间，直接在你的进程内存空间映射到文件系统，这样就可已省去用户空间到内核空间的拷贝操作，可以多进程共同访问文件，但是会出现一些并发同步修改等问题。</p><p>详细的说明见引文，里面已经有很好的说明了。</p><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHV4aWFvLXRlZS9wLzQ2NjAzNTIuaHRtbCNfbGFiZWww" title="https://www.cnblogs.com/huxiao-tee/p/4660352.html#_label0">认真分析mmap：是什么 为什么 怎么用<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL21tYXAuMi5odG1s" title="http://man7.org/linux/man-pages/man2/mmap.2.html">Linux &gt; man-pages<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cDovL2FrYWVkdS5naXRodWIuaW8vYm9vay9jaDI4czA4Lmh0bWw=" title="http://akaedu.github.io/book/ch28s08.html">mmap<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 操作系统扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mmap </tag>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mycat简介</title>
      <link href="//database/Mycat%E7%AE%80%E4%BB%8B.html"/>
      <url>//database/Mycat%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>前几天因为要处理类似交易所的设计，发现大量的数据问题，于是想通过Mycat进行分表分库，读了Mycat的官方文档，真的学习了好多的东西，于是画了一张脑图。以后有时间再来整理里面的知识吧！</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/Database/Mycat%E7%AE%80%E4%BB%8B.png?raw=true"></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat </tag>
            
            <tag> 分表分库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊ERC20与ERC233的区别</title>
      <link href="//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20%E4%B8%8EERC233%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20%E4%B8%8EERC233%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ERC: 223<br>Title: Token standard<br>Author: Dexaran, <span class="exturl" data-url="bWFpbHRvOmRleGFyYW44MjBAZ21haWwuY29t" title="mailto:dexaran820@gmail.com">dexaran820@gmail.com<i class="fa fa-external-link"></i></span><br>Status: Draft<br>Type: ERC<br>Created: 5-03.2017<br>Resolution: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RleGFyYW4vRVJDMjIzLXRva2VuLXN0YW5kYXJk" title="https://github.com/Dexaran/ERC223-token-standard">https://github.com/Dexaran/ERC223-token-standard<i class="fa fa-external-link"></i></span><br>Recommended implementation: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RleGFyYW4vRVJDMjIzLXRva2VuLXN0YW5kYXJkL3RyZWUvUmVjb21tZW5kZWQ=" title="https://github.com/Dexaran/ERC223-token-standard/tree/Recommended">https://github.com/Dexaran/ERC223-token-standard/tree/Recommended<i class="fa fa-external-link"></i></span></p><p>以下描述标准功能，令牌合同和使用指定令牌的合同可以实施，以防止意外发送令牌到合同，并使令牌交易的行为像ether交易。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>ERC223解决了ERC20的一些问题:</p><p>ERC20令牌标准导致最终用户的资金损失。主要问题是缺乏处理通过ERC20代币transfer方法执行的传入ERC20事务的可能性。</p><p>如果您发送100个ETH到一个不打算与Ether协同工作的合同，那么它将拒绝一个交易，并且不会发生任何错误。如果您将100个ERC20令牌发送到不打算与ERC20令牌一起使用的合同，则它不会拒绝令牌，因为它无法识别传入的事务。结果，您的代币将卡住合约余额。</p><p>目前丢失了多少ERC20令牌（2017年12月27日）：</p><ol><li>QTUM，1,204,273美元流失。看着Etherscan</li><li>EOS 损失1,015,131美元。看着Etherscan</li><li>GNT，亏损249,627美元。看着Etherscan</li><li>STORJ，亏损217,477美元。看着Etherscan</li><li>Tronix，损失201,232美元。看着Etherscan</li><li>DGD，损失151,826美元。看着Etherscan</li><li>OMG，亏损149,941美元。看着Etherscan</li><li>STORJ，输掉102,560 美元。看着Etherscan</li></ol><p>注意：这些只是我知道的8个令牌合约。每个以太坊合约都是ERC20令牌的潜在令牌陷阱，因此，比我在此例中显示的损失要多得多。</p><p>ERC223解决了ERC20的一些问题:</p><p>1.无法处理接收合同中的进账交易。<br>2.令牌可以发送到合同中没有设计不处理与标记工作，并可能会丢失。目前至少有四十万美元的损失。<br>3.令牌交易应与Ethereum意识形态一致。当一个用户转账的时候，必须自己执行transfer.用户存入合同或发送到外部拥有的账户无关紧要。</p><p>这些将允许合同处理传入令牌交易并防止意外发送的令牌被合同接受。<br>例如，分散式交换将不再需要强制用户通过令牌合约来呼叫批准，然后通过从允许的令牌获取正在调用transfer的呼叫存款。 令牌交易将在交易所合约内自动处理。</p><p>这里最重要的是在执行合同交易时调用tokenFallback。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>与令牌一起使用的令牌合同</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>注意: 一个重要的一点是，如果合同开发人员希望他们的合同使用指定的令牌，那么合同开发人员必须实现tokenFallback。</p><p>如果接收方未实现tokenFallback函数，则认为合同不是设计为使用令牌，那么事务必须失败，并且不会传输令牌。 在尝试将Ether发送到没有实现function（）payable的合同时，与Ether事务的类比是失败的。</p><h3 id="totalSupply"><a href="#totalSupply" class="headerlink" title="totalSupply"></a>totalSupply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function totalSupply() constant returns (uint256 totalSupply)</span><br></pre></td></tr></table></figure><p>获取代币的发币总量</p><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function name() constant returns (string _name)</span><br></pre></td></tr></table></figure><p>获取代币的名称</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function symbol() constant returns (bytes32 _symbol)</span><br></pre></td></tr></table></figure><p>代币的标识符</p><h3 id="decimals"><a href="#decimals" class="headerlink" title="decimals"></a>decimals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function decimals() constant returns (uint8 _decimals)</span><br></pre></td></tr></table></figure><p>得到token的小数点后几位</p><h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a>balanceOf</h3><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint _value) returns (bool)</span><br></pre></td></tr></table></figure><p>由于向后兼容性原因，因为ERC20传输函数没有字节参数。如果_to是合约，则此函数必须传输令牌并调_to中的函数tokenFallback(address,uint256,bytes)。如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。</p><p>重要:将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address,uint256，bytes。 此函数必须具有0xc0ee0b8a签名。</p><h3 id="transfer-address-uint-bytes"><a href="#transfer-address-uint-bytes" class="headerlink" title="transfer(address, uint, bytes)"></a>transfer(address, uint, bytes)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint _value, bytes _data) returns (bool)</span><br></pre></td></tr></table></figure><p>当某人想要转移令牌时总是调用这个函数。<br>如果_to是合约，则此函数必须传输令牌并调用_to中的函数tokenFallback (address, uint256, bytes)。 如果_to（接收方合同）中没有实现tokenFallback函数，则事务必须失败，并且不会发生令牌的传输。<br>如果_to是外部拥有的地址，则必须发送事务，而不尝试在_to中执行tokenFallback。</p><p>_data可以附加到这个令牌交易中，它将永远保持在块状（需要更多的gas）。 _data可以是空的。</p><p>注意: 检查_to是合约还是地址的推荐方法是组装_to的代码。 如果_to中没有代码，那么这是一个外部拥有的地址，否则就是一个合约。</p><p>重要: 将在接收方合约中调用的令牌备用功能必须命名为tokenFallback，并使用参数address, uint256,bytes。 此函数必须具有0xc0ee0b8a签名。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="Transfer"><a href="#Transfer" class="headerlink" title="Transfer"></a>Transfer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data)</span><br></pre></td></tr></table></figure><p>当token转移的时候触发。</p><h3 id="合约和token一起工作"><a href="#合约和token一起工作" class="headerlink" title="合约和token一起工作"></a>合约和token一起工作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function tokenFallback(address _from, uint _value, bytes _data)</span><br></pre></td></tr></table></figure><p>令牌持有者发送令牌时处理从令牌合同所调用的令牌传输的功能。 _from是令牌发送者，_value是传入令牌的数量，_data是附加的数据，类似于Ether事务中的数据。 适用于以太交易的回退功能，并且不返回任何内容。</p><p>注意: msg.sender将是tokenFallback函数内的令牌合同。 过滤哪些令牌（通过令牌契约地址）发送可能很重要。 令牌发送者（谁发起了代币交易的人）将_from thetokenFallback函数内。</p><p>重要: 这个函数必须命名为tokenFallback，并使用参数地址uint256，字节来匹配函数签名0xc0ee0b8a。</p><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGlhbmRpYW54aXl1X2dlZWsvYXJ0aWNsZS9kZXRhaWxzLzc4MDkzMjI5" title="http://blog.csdn.net/diandianxiyu_geek/article/details/78093229">以太坊ERC20与ERC233的区别<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvaXNzdWVzLzIyMw==" title="https://github.com/ethereum/EIPs/issues/223">ERC223 token standard #223<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 代币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊ERC20 token标准</title>
      <link href="//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20-token%E6%A0%87%E5%87%86.html"/>
      <url>//blockchain/%E4%BB%A5%E5%A4%AA%E5%9D%8AERC20-token%E6%A0%87%E5%87%86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>关于原文请参考以太坊官网的wiki进行学习，这里只是列出一些基础知识供大家学习。</p><h2 id="ERC20令牌标准接口"><a href="#ERC20令牌标准接口" class="headerlink" title="ERC20令牌标准接口"></a>ERC20令牌标准接口</h2><p>以下是一个接口合同，声明所需的功能和事件以符合ERC20标准：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ----------------------------------------------------------------------------</span><br><span class="line">// ERC Token Standard #20 Interface</span><br><span class="line">// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md</span><br><span class="line">// ----------------------------------------------------------------------------</span><br><span class="line">contract ERC20Interface &#123;</span><br><span class="line">    function totalSupply() public constant returns (uint);</span><br><span class="line">    function balanceOf(address tokenOwner) public constant returns (uint balance);</span><br><span class="line">    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);</span><br><span class="line">    function transfer(address to, uint tokens) public returns (bool success);</span><br><span class="line">    function approve(address spender, uint tokens) public returns (bool success);</span><br><span class="line">    function transferFrom(address from, address to, uint tokens) public returns (bool success);</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed from, address indexed to, uint tokens);</span><br><span class="line">    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以太坊区块链上的大部分主要代币均符合ERC20标准。GNT Golem Network Token是唯一部分兼容erc20的代币，因为它不执行approve、allowance以及transferFrom功能和Approval事件。</p><p>一些令牌包括描述令牌合同的更多信息：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string public constant name = &quot;Token Name&quot;;</span><br><span class="line">string public constant symbol = &quot;SYM&quot;;</span><br><span class="line">uint8 public constant decimals = 18;  // 18 is the most common number of decimal places</span><br></pre></td></tr></table></figure><p></p><p>在这个标准中我们要指明我们的代币信息，和一些通用的调用接口信息。</p><h2 id="代用合同如何工作？"><a href="#代用合同如何工作？" class="headerlink" title="代用合同如何工作？"></a>代用合同如何工作？</h2><p>以下是令牌合同的一个片段，用于演示令牌合约如何维护以太坊帐户的令牌余额：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">contract TokenContractFragment &#123;</span><br><span class="line"> </span><br><span class="line">    // Balances for each account</span><br><span class="line">    mapping(address =&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">    // Owner of account approves the transfer of an amount to another account</span><br><span class="line">    mapping(address =&gt; mapping (address =&gt; uint256)) allowed;</span><br><span class="line"> </span><br><span class="line">    // Get the token balance for account `tokenOwner`</span><br><span class="line">    function balanceOf(address tokenOwner) public constant returns (uint balance) &#123;</span><br><span class="line">        return balances[tokenOwner];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Transfer the balance from owner&apos;s account to another account</span><br><span class="line">    function transfer(address to, uint tokens) public returns (bool success) &#123;</span><br><span class="line">        balances[msg.sender] = balances[msg.sender].sub(tokens);</span><br><span class="line">        balances[to] = balances[to].add(tokens);</span><br><span class="line">        Transfer(msg.sender, to, tokens);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Send `tokens` amount of tokens from address `from` to address `to`</span><br><span class="line">    // The transferFrom method is used for a withdraw workflow, allowing contracts to send</span><br><span class="line">    // tokens on your behalf, for example to &quot;deposit&quot; to a contract address and/or to charge</span><br><span class="line">    // fees in sub-currencies; the command should fail unless the _from account has</span><br><span class="line">    // deliberately authorized the sender of the message via some mechanism; we propose</span><br><span class="line">    // these standardized APIs for approval:</span><br><span class="line">    function transferFrom(address from, address to, uint tokens) public returns (bool success) &#123;</span><br><span class="line">        balances[from] = balances[from].sub(tokens);</span><br><span class="line">        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);</span><br><span class="line">        balances[to] = balances[to].add(tokens);</span><br><span class="line">        Transfer(from, to, tokens);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Allow `spender` to withdraw from your account, multiple times, up to the `tokens` amount.</span><br><span class="line">    // If this function is called again it overwrites the current allowance with _value.</span><br><span class="line">    function approve(address spender, uint tokens) public returns (bool success) &#123;</span><br><span class="line">        allowed[msg.sender][spender] = tokens;</span><br><span class="line">        Approval(msg.sender, spender, tokens);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>基于ERC20的货币更容易互换，并且能够在Dapps上相同的工作。</p><p>新的标准可以让token更兼容，允许其他功能，包括投票标记化。操作更像一个投票操作</p><p>Token的持有人可以完全控制资产，遵守ERC20的token可以跟踪任何人在任何时间拥有多少token.基于eth合约的子货币，所以容易实施。只能自己去转让。</p><p>标准化非常有利，也就意味着这些资产可以用于不同的平台和项目，否则只能用在特定的场合。</p><h2 id="接口文档说明"><a href="#接口文档说明" class="headerlink" title="接口文档说明"></a>接口文档说明</h2><h3 id="代币账户查询-balanceOf"><a href="#代币账户查询-balanceOf" class="headerlink" title="代币账户查询 balanceOf"></a>代币账户查询 balanceOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tokenContract.balanceOf(0x1111111111111111111111111111111111111111) will return 100</span><br><span class="line">tokenContract.balanceOf(0x2222222222222222222222222222222222222222) will return 200</span><br></pre></td></tr></table></figure><h3 id="转移Token余额transfer"><a href="#转移Token余额transfer" class="headerlink" title="转移Token余额transfer"></a>转移Token余额transfer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokenContract.transfer(0x2222222222222222222222222222222222222222, 10)</span><br></pre></td></tr></table></figure><h3 id="从token余额批准和转移-approve"><a href="#从token余额批准和转移-approve" class="headerlink" title="从token余额批准和转移 approve"></a>从token余额批准和转移 approve</h3><p>其实就是中转一下，类似于淘宝先付款再确认收货。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGlhbmRpYW54aXl1X2dlZWsvYXJ0aWNsZS9kZXRhaWxzLzc4MDgyNTUx" title="http://blog.csdn.net/diandianxiyu_geek/article/details/78082551">【Ethereum】以太坊ERC20 Token标准完整说明<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly90aGVldGhlcmV1bS53aWtpL3cvaW5kZXgucGhwL0VSQzIwX1Rva2VuX1N0YW5kYXJk" title="https://theethereum.wiki/w/index.php/ERC20_Token_Standard">ERC20 Token Standard<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2hhY2tvaW4tdGFpd2FuL2V0aGVyZXVtLWVyYzIwLXRva2VuLXN0YW5kYXJkLSVFNCVCQiVBNSVFNSVBNCVBQSVFNSU5RCU4QSVFNCVCQiVBMyVFNSVCOSVBMyVFNiVBOCU5OSVFNiVCQSU5NiVFNCVCQiU4QiVFNyVCNCVCOS1iN2JjNTgxNzEwMjE=" title="https://medium.com/hackoin-taiwan/ethereum-erc20-token-standard-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%A3%E5%B9%A3%E6%A8%99%E6%BA%96%E4%BB%8B%E7%B4%B9-b7bc58171021">Ethereum ERC20 Token Standard 以太坊代幣標準介紹<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ethereum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
            <tag> 代币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL网络协议分析</title>
      <link href="//database/MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.html"/>
      <url>//database/MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:24 GMT+0800 (CST) --><p>最近在开发类似交易所功能的应用，由于可能会用到分表分库之类的事情，所以接触到了MySQL协议的一些东西，之前也想过MySQL底层走的应该是相关的协议只是这些协议具体指什么，从来没有进行深入了解。MyCat就是模拟MySQL的协议做了一层中间件，从而隔离了分表分库对应用开发的侵入性，我觉得这个是一个很好的处理方式，对开发运维堪称完美，太棒了。但是这种中间件也有问题，这里提一下，但是不做深入讨论：</p><ol><li>中间件的维护成本高</li><li>开发运维不能实时沟通，不利于查找问题</li><li>聚合了很多查询，容易使得MyCat的访问量变大，从而带来很多的问题。</li></ol><p>下面我们进入正题。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>理解网络协议，可以实现很多功能，我们往往在上层站的太久，忘记了下来坐坐。通过网络协议我们可以抓包分析，可以做中间件（中继器）或者一些其他功能（Proxy、实时监控）。有的时候第三方中间件不太好改，也可通过熟知协议，拦截修改，可谓妙笔生花。</p><h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><p>到MySQL5.7为止，链接方式总共有五种，分别是TCP/IP，TLS/SSL，Unix Sockets，Shared Memory，Named pipes，下面我们就来看看这五种的区别：</p><table><thead><tr><th>方式</th><th>默认开启</th><th>支持系统</th><th>只支持本机</th><th>如何开启</th><th>参数配置</th></tr></thead><tbody><tr><td>TCP/IP</td><td>是</td><td>所有系统</td><td>否</td><td>–skip-networking=yes/no.</td><td>–port –bind-address</td></tr><tr><td>TLS/SSL</td><td>是</td><td>所有系统（基于TCP/IP)之上</td><td>否</td><td>–ssl=yes/no.</td><td>–ssl-* options</td></tr><tr><td>Unix Sockets</td><td>是</td><td>类Unix系统</td><td>是</td><td>设置–socket=<empty>来关闭.</empty></td><td>–socket=socket path</td></tr><tr><td>Shared Memory</td><td>否</td><td>Windows系统</td><td>是</td><td>–shared-memory=on/off.</td><td>–shared-memory-base-name=<name></name></td></tr><tr><td>Named pipes</td><td>否</td><td>Windows系统</td><td>否</td><td>–enable-named-pipe=on/off.</td><td>–socket=<name></name></td></tr></tbody></table><p>这里我只介绍TLS/SSL的连接方式：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql --protocol=tcp -uroot --ssl=on</span><br><span class="line">mysql -P3306 -h127.0.0.1 -uroot --ssl=on</span><br></pre></td></tr></table></figure><p></p><p>我们可以通过以下语句来查询目前数据库的连接情况：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> connection_type <span class="keyword">from</span> performance_schema.threads <span class="keyword">where</span> connection_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p></p><h2 id="MySQL数据包"><a href="#MySQL数据包" class="headerlink" title="MySQL数据包"></a>MySQL数据包</h2><p>现在我们来看一下链接的过程：</p><p><img alt="" data-src="https://github.com/gavin-account/blog-pics/blob/master/Database/MySQL%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90-process.png?raw=true"></p><p>其实主要就是两步，Client将执行命令编码成Server要求的格式传输给Server端执行，Server端将执行结果传输给Client端，Client端再根据相应的数据包格式解析获得所需的数据。然后通过数据格式的协定，开始交互。</p><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h3><p>虽然网络中的数据是用字节传输的，但它背后的数据源都是有类型的数据，MySQL协议也有基本的数据类型（可以看出协议也可认为是一种语言），好比Java中的8种基本数据类型，但MySQL协议中简单的多，它只有两种基本数据类型，分别为Integer(整型)，String(字符串)，下面我们就来看看这两种类型。</p><h4 id="Integer整形"><a href="#Integer整形" class="headerlink" title="Integer整形"></a>Integer整形</h4><p>首先Integer在MySQL协议中有两种编码方式，分别为FixedLengthInteger和LengthEncodedInteger ,其中前者用于存储无符号定长整数，实际中使用的不多。详细的情况还是参考原文比较好。</p><h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h4><p>就是正常的字符串在协议中的编码方式，这里也是参考博客原文进行解释。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本文是想通过解析协议来学习协议的指定规范，由于时间有限，就先到这里，原文的内容知识比较多，请参考文献。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><span class="exturl" data-url="aHR0cDovL3d3dy5nb2RwYW4ubWUvMjAxNy8xMS8xMC9teXNxbC1wcm90b2NvbC5odG1s" title="http://www.godpan.me/2017/11/10/mysql-protocol.html">MySQL网络协议分析<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用攻略</title>
      <link href="//hello-world.html"/>
      <url>//hello-world.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 22 2019 01:01:23 GMT+0800 (CST) --><p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>机器先安装好node即可。运行下面的安装命令。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="初始化目录"><a href="#初始化目录" class="headerlink" title="初始化目录"></a>初始化目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 相应目录</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/deployment.html">Deployment<i class="fa fa-external-link"></i></span></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>下载相应主题到theme目录，然后更改_config.js文件中的主题配置即可，名称theme的文件夹名即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: hexo-theme-next</span><br></pre></td></tr></table></figure><p></p><h2 id="更改网站的信息"><a href="#更改网站的信息" class="headerlink" title="更改网站的信息"></a>更改网站的信息</h2><p>在_config.js中更改：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 柳絮纷飞</span><br><span class="line">subtitle: Gavin的个人博客</span><br><span class="line">description: 一个孤独的开发者，正在互联网公司踩坑</span><br><span class="line">author: Gavin Zhang</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><p></p><h2 id="添加新的菜单页"><a href="#添加新的菜单页" class="headerlink" title="添加新的菜单页"></a>添加新的菜单页</h2><p><span class="exturl" data-url="aHR0cHM6Ly9saW5saWYuZ2l0aHViLmlvLzIwMTcvMDUvMjcvSGV4byVFNCVCRCVCRiVFNyU5NCVBOCVFNiU5NCVCQiVFNyU5NSVBNS0lRTYlQjclQkIlRTUlOEElQTAlRTUlODglODYlRTclQjElQkIlRTUlOEYlOEElRTYlQTAlODclRTclQUQlQkUv" title="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9kdXJhbnQzNS5naXRodWIuaW8vMjAxNi8wMS8yNi9oZXhvXyVFNiVCNyVCQiVFNSU4QSVBMGFib3V0JUU1JUFGJUJDJUU4JTg4JUFBJUU2JUEwJThGLw==" title="https://durant35.github.io/2016/01/26/hexo_%E6%B7%BB%E5%8A%A0about%E5%AF%BC%E8%88%AA%E6%A0%8F/">https://durant35.github.io/2016/01/26/hexo_%E6%B7%BB%E5%8A%A0about%E5%AF%BC%E8%88%AA%E6%A0%8F/<i class="fa fa-external-link"></i></span></p><h2 id="安装三方的插件（hexo已集成）"><a href="#安装三方的插件（hexo已集成）" class="headerlink" title="安装三方的插件（hexo已集成）"></a>安装三方的插件（hexo已集成）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM0NTM4NC9hcnRpY2xlL2RldGFpbHMvODA1NDQ2NjA=" title="https://blog.csdn.net/weixin_39345384/article/details/80544660">https://blog.csdn.net/weixin_39345384/article/details/80544660<i class="fa fa-external-link"></i></span></p><h2 id="hexo使用说明"><a href="#hexo使用说明" class="headerlink" title="hexo使用说明"></a>hexo使用说明</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84NTE5MjYyNmZhZjM=" title="https://www.jianshu.com/p/85192626faf3">Github+Hexo一站式部署个人博客(原创)<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OGViMmZkMmEwYmI5ZjAwNjkyOGY4YzcjaGVhZGluZy0yMQ==" title="https://juejin.im/post/58eb2fd2a0bb9f006928f8c7#heading-21">hexo高阶教程：next主题优化之加入网易云音乐、网易云跟帖、炫酷动态背景、自定义样式，打造属于你自己的定制化博客<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OTBiNDUxYTBjZTQ2MzAwNTg4YzQzYTAjaGVhZGluZy0w" title="https://juejin.im/post/590b451a0ce46300588c43a0#heading-0">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mMDY4YjhhMzZkODQ=" title="https://www.jianshu.com/p/f068b8a36d84">Hexo 博客 之 简要美化<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTcxYWI5ZjUxODgyNTczNTMwMGVlNmM=" title="https://juejin.im/post/5a71ab9f518825735300ee6c">（Ⅱ）NexT主题的优化定制修改指南<i class="fa fa-external-link"></i></span></p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
